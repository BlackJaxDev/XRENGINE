using System.Numerics;

namespace XREngine.Audio.Steam;

/// <summary>
/// Managed wrapper around an <see cref="IPLProbeBatch"/>, providing probe generation,
/// serialization, and lifecycle management for use with Steam Audio's baking and
/// pathing simulation workflows.
/// <para>
/// A probe batch holds a set of probe positions (each a sphere with center + radius) and
/// associated baked data layers (reflections, pathing). Probe data is generated by placing
/// probes within a committed <see cref="SteamAudioScene"/>, committed into the batch, and
/// then either baked offline or used at runtime for pathing simulation.
/// </para>
/// </summary>
public sealed class SteamAudioProbeBatch : IDisposable
{
    private readonly IPLContext _context;
    private IPLProbeBatch _batch;
    private IPLProbeArray _probeArray;
    private bool _committed;
    private bool _disposed;

    /// <summary>The underlying Phonon probe batch handle.</summary>
    public IPLProbeBatch Handle
    {
        get
        {
            ObjectDisposedException.ThrowIf(_disposed, this);
            return _batch;
        }
    }

    /// <summary>Whether <see cref="Commit"/> has been called after the last modification.</summary>
    public bool IsCommitted => _committed;

    /// <summary>
    /// Number of probes in the committed batch.
    /// Returns 0 if not yet committed.
    /// </summary>
    public int ProbeCount
    {
        get
        {
            if (_disposed || _batch.Handle == IntPtr.Zero)
                return 0;
            return Phonon.iplProbeBatchGetNumProbes(_batch);
        }
    }

    internal SteamAudioProbeBatch(IPLContext context)
    {
        _context = context;

        var error = Phonon.iplProbeBatchCreate(context, ref _batch);
        if (error != IPLerror.IPL_STATUS_SUCCESS)
            throw new InvalidOperationException($"iplProbeBatchCreate failed: {error}");
    }

    /// <summary>
    /// Generates probes within the scene using a uniform floor placement strategy.
    /// Previous probes in this batch are replaced.
    /// </summary>
    /// <param name="scene">A committed <see cref="SteamAudioScene"/>.</param>
    /// <param name="spacing">Distance in meters between probes.</param>
    /// <param name="height">Height above floor surfaces for probe placement.</param>
    /// <param name="volumeTransform">
    /// A 4×4 matrix mapping the unit cube [(0,0,0)→(1,1,1)] to the scene volume in which
    /// probes are generated. Use <see cref="CreateVolumeTransform"/> for AABB convenience.
    /// </param>
    public void GenerateProbes(
        SteamAudioScene scene,
        float spacing,
        float height,
        IPLMatrix4x4 volumeTransform)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);
        ArgumentNullException.ThrowIfNull(scene);

        if (!scene.IsCommitted)
            throw new InvalidOperationException("Scene must be committed before generating probes.");

        if (spacing <= 0)
            throw new ArgumentOutOfRangeException(nameof(spacing), "Spacing must be positive.");

        // Release old probe array if any
        if (_probeArray.Handle != IntPtr.Zero)
            Phonon.iplProbeArrayRelease(ref _probeArray);

        var error = Phonon.iplProbeArrayCreate(_context, ref _probeArray);
        if (error != IPLerror.IPL_STATUS_SUCCESS)
            throw new InvalidOperationException($"iplProbeArrayCreate failed: {error}");

        var genParams = new IPLProbeGenerationParams
        {
            type = IPLProbeGenerationType.IPL_PROBEGENERATIONTYPE_UNIFORMFLOOR,
            spacing = spacing,
            height = height,
            transform = volumeTransform,
        };

        Phonon.iplProbeArrayGenerateProbes(_probeArray, scene.Handle, ref genParams);

        // Add generated probes into the batch
        Phonon.iplProbeBatchAddProbeArray(_batch, _probeArray);
        _committed = false;
    }

    /// <summary>
    /// Adds a single manually-placed probe to the batch.
    /// </summary>
    /// <param name="center">World-space center of the probe.</param>
    /// <param name="radius">Influence radius of the probe.</param>
    public void AddProbe(Vector3 center, float radius)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        var sphere = new IPLSphere
        {
            center = center,
            radius = radius,
        };

        Phonon.iplProbeBatchAddProbe(_batch, sphere);
        _committed = false;
    }

    /// <summary>
    /// Removes a probe by index (0-based).
    /// </summary>
    public void RemoveProbe(int index)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        if (index < 0 || index >= ProbeCount)
            throw new ArgumentOutOfRangeException(nameof(index));

        Phonon.iplProbeBatchRemoveProbe(_batch, index);
        _committed = false;
    }

    /// <summary>
    /// Commits the probe batch, making it ready for baking or simulation attachment.
    /// </summary>
    public void Commit()
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        Phonon.iplProbeBatchCommit(_batch);
        _committed = true;
    }

    /// <summary>
    /// Removes baked data of the specified type from this batch.
    /// </summary>
    public void RemoveData(IPLBakedDataIdentifier identifier)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);
        Phonon.iplProbeBatchRemoveData(_batch, ref identifier);
    }

    /// <summary>
    /// Retrieves the probe at the given index (from the generated probe array).
    /// </summary>
    public IPLSphere GetProbe(int index)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        if (_probeArray.Handle == IntPtr.Zero)
            throw new InvalidOperationException("No probes have been generated yet.");

        int count = Phonon.iplProbeArrayGetNumProbes(_probeArray);
        if (index < 0 || index >= count)
            throw new ArgumentOutOfRangeException(nameof(index));

        return Phonon.iplProbeArrayGetProbe(_probeArray, index);
    }

    /// <summary>
    /// Number of probes in the generated array (before commit).
    /// </summary>
    public int GeneratedProbeCount
    {
        get
        {
            if (_probeArray.Handle == IntPtr.Zero)
                return 0;
            return Phonon.iplProbeArrayGetNumProbes(_probeArray);
        }
    }

    /// <summary>
    /// Creates a volume transform matrix from an axis-aligned bounding box.
    /// The resulting matrix maps the unit cube to the specified world-space AABB.
    /// </summary>
    public static IPLMatrix4x4 CreateVolumeTransform(Vector3 min, Vector3 max)
    {
        var size = max - min;
        // IPLMatrix4x4 is column-major: elements[row, col]
        var m = new IPLMatrix4x4
        {
            elements = new float[4, 4]
        };

        // Scale + translation: maps (0,0,0)→min, (1,1,1)→max
        m.elements[0, 0] = size.X; m.elements[0, 1] = 0;      m.elements[0, 2] = 0;      m.elements[0, 3] = min.X;
        m.elements[1, 0] = 0;      m.elements[1, 1] = size.Y;  m.elements[1, 2] = 0;      m.elements[1, 3] = min.Y;
        m.elements[2, 0] = 0;      m.elements[2, 1] = 0;       m.elements[2, 2] = size.Z;  m.elements[2, 3] = min.Z;
        m.elements[3, 0] = 0;      m.elements[3, 1] = 0;       m.elements[3, 2] = 0;       m.elements[3, 3] = 1;

        return m;
    }

    public void Dispose()
    {
        if (_disposed)
            return;
        _disposed = true;

        if (_probeArray.Handle != IntPtr.Zero)
            Phonon.iplProbeArrayRelease(ref _probeArray);
        if (_batch.Handle != IntPtr.Zero)
            Phonon.iplProbeBatchRelease(ref _batch);
    }
}
