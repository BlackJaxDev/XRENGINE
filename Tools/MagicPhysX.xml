<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MagicPhysX</name>
    </assembly>
    <members>
        <member name="M:MagicPhysX.NativeMethods.create_raycast_filter_callback(MagicPhysX.PxRigidActor*)">
            <summary>Destroy the returned callback object using PxQueryFilterCallback_delete.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.create_raycast_filter_callback_func(,System.Void*)">
            <summary>Destroy the returned callback object using PxQueryFilterCallback_delete.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.create_simulation_event_callbacks(MagicPhysX.SimulationEventCallbackInfo*)">
            <summary>New interface to handle simulation events, replacing create_contact_callback.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.enable_custom_filter_shader(MagicPhysX.PxSceneDesc*,,System.UInt32)">
            <summary>Override the default filter shader in the scene with a custom function. If call_default_filter_shader_first is set to true, this will first call the built-in PhysX filter (that matches Physx 2.8 behavior) before your callback.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxAssertHandler_opCall_mut(MagicPhysX.PxAssertHandler*,System.SByte*,System.SByte*,System.Int32,System.Boolean*)">
            <summary>(hidden) Should only be used in testing etc! This isn't generated as we don't generate op functions.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxAllocatorCallback_allocate_mut(MagicPhysX.PxAllocatorCallback*,System.UIntPtr,System.Byte*,System.Byte*,System.Int32)">
            <summary>Allocates size bytes of memory, which must be 16-byte aligned.  This method should never return NULL.  If you run out of memory, then you should terminate the app or take some other appropriate action.  Threading: This function should be thread safe as it can be called in the context of the user thread and physics processing thread(s).  The allocated block of memory.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxAllocatorCallback_deallocate_mut(MagicPhysX.PxAllocatorCallback*,System.Void*)">
            <summary>Frees memory previously allocated by allocate().  Threading: This function should be thread safe as it can be called in the context of the user thread and physics processing thread(s).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxFoundation_release_mut(MagicPhysX.PxFoundation*)">
            <summary>Destroys the instance it is called on.  The operation will fail, if there are still modules referencing the foundation object. Release all dependent modules prior to calling this method.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxFoundation_getErrorCallback_mut(MagicPhysX.PxFoundation*)">
            <summary>retrieves error callback</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxFoundation_setErrorLevel_mut(MagicPhysX.PxFoundation*,System.UInt32)">
            <summary>Sets mask of errors to report.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxFoundation_getErrorLevel(MagicPhysX.PxFoundation*)">
            <summary>Retrieves mask of errors to be reported.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxFoundation_getAllocatorCallback_mut(MagicPhysX.PxFoundation*)">
            <summary>Retrieves the allocator this object was created with.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxFoundation_getReportAllocationNames(MagicPhysX.PxFoundation*)">
            <summary>Retrieves if allocation names are being passed to allocator callback.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxFoundation_setReportAllocationNames_mut(MagicPhysX.PxFoundation*,System.Boolean)">
            <summary>Set if allocation names are being passed to allocator callback.  Enabled by default in debug and checked build, disabled by default in profile and release build.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCreateFoundation(System.UInt32,MagicPhysX.PxAllocatorCallback*,MagicPhysX.PxErrorCallback*)">
            <summary>Creates an instance of the foundation class  The foundation class is needed to initialize higher level SDKs. There may be only one instance per process. Calling this method after an instance has been created already will result in an error message and NULL will be returned.  Foundation instance on success, NULL if operation failed</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxGetProfilerCallback">
            <summary>Get the callback that will be used for all profiling.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxSetProfilerCallback(MagicPhysX.PxProfilerCallback*)">
            <summary>Set the callback that will be used for all profiling.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxGetAllocatorCallback">
            <summary>Get the allocator callback</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxGetBroadcastAllocator">
            <summary>Get the broadcasting allocator callback</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxGetErrorCallback">
            <summary>Get the error callback</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxGetBroadcastError">
            <summary>Get the broadcasting error callback</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxGetWarnOnceTimeStamp">
            <summary>Get the warn once timestamp</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxDecFoundationRefCount">
            <summary>Decrement the ref count of PxFoundation</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxIncFoundationRefCount">
            <summary>Increment the ref count of PxFoundation</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxMemZero(System.Void*,System.UInt32)">
            <summary>Sets the bytes of the provided buffer to zero.  Pointer to memory block (same as input)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxMemSet(System.Void*,System.Int32,System.UInt32)">
            <summary>Sets the bytes of the provided buffer to the specified value.  Pointer to memory block (same as input)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxMemCopy(System.Void*,System.Void*,System.UInt32)">
            <summary>Copies the bytes of one memory block to another. The memory blocks must not overlap.  Use [`PxMemMove`] if memory blocks overlap.  Pointer to destination memory block</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxMemMove(System.Void*,System.Void*,System.UInt32)">
            <summary>Copies the bytes of one memory block to another. The memory blocks can overlap.  Use [`PxMemCopy`] if memory blocks do not overlap.  Pointer to destination memory block</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxMarkSerializedMemory(System.Void*,System.UInt32)">
            <summary>Mark a specified amount of memory with 0xcd pattern. This is used to check that the meta data definition for serialized classes is complete in checked builds.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxHighestSetBitUnsafe(System.UInt32)">
            <summary>Return the index of the highest set bit. Undefined for zero arg.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxLowestSetBitUnsafe(System.UInt32)">
            <summary>Return the index of the highest set bit. Undefined for zero arg.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCountLeadingZeros(System.UInt32)">
            <summary>Returns the index of the highest set bit. Returns 32 for v=0.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxPrefetchLine(System.Void*,System.UInt32)">
            <summary>Prefetch aligned 64B x86, 32b ARM around</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxPrefetch(System.Void*,System.UInt32)">
            <summary>Prefetch bytes starting at</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxLowestSetBit(System.UInt32)">
            <summary>Return the index of the highest set bit. Not valid for zero arg.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxHighestSetBit(System.UInt32)">
            <summary>Return the index of the highest set bit. Not valid for zero arg.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec3_new">
            <summary>default constructor leaves data uninitialized.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec3_new_1(MagicPhysX.PxZERO)">
            <summary>zero constructor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec3_new_2(System.Single)">
            <summary>Assigns scalar parameter to all elements.  Useful to initialize to zero or one.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec3_new_3(System.Single,System.Single,System.Single)">
            <summary>Initializes from 3 scalar parameters.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec3_isZero(MagicPhysX.PxVec3*)">
            <summary>tests for exact zero vector</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec3_isFinite(MagicPhysX.PxVec3*)">
            <summary>returns true if all 3 elems of the vector are finite (not NAN or INF, etc.)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec3_isNormalized(MagicPhysX.PxVec3*)">
            <summary>is normalized - used by API parameter validation</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec3_magnitudeSquared(MagicPhysX.PxVec3*)">
            <summary>returns the squared magnitude  Avoids calling PxSqrt()!</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec3_magnitude(MagicPhysX.PxVec3*)">
            <summary>returns the magnitude</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec3_dot(MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>returns the scalar product of this and other.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec3_cross(MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>cross product</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec3_getNormalized(MagicPhysX.PxVec3*)">
            <summary>returns a unit vector</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec3_normalize_mut(MagicPhysX.PxVec3*)">
            <summary>normalizes the vector in place</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec3_normalizeSafe_mut(MagicPhysX.PxVec3*)">
            <summary>normalizes the vector in place. Does nothing if vector magnitude is under PX_NORMALIZATION_EPSILON. Returns vector magnitude if &gt;= PX_NORMALIZATION_EPSILON and 0.0f otherwise.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec3_normalizeFast_mut(MagicPhysX.PxVec3*)">
            <summary>normalizes the vector in place. Asserts if vector magnitude is under PX_NORMALIZATION_EPSILON. returns vector magnitude.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec3_multiply(MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>a[i] * b[i], for all i.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec3_minimum(MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>element-wise minimum</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec3_minElement(MagicPhysX.PxVec3*)">
            <summary>returns MIN(x, y, z);</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec3_maximum(MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>element-wise maximum</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec3_maxElement(MagicPhysX.PxVec3*)">
            <summary>returns MAX(x, y, z);</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec3_abs(MagicPhysX.PxVec3*)">
            <summary>returns absolute values of components;</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxQuat_new">
            <summary>Default constructor, does not do any initialization.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxQuat_new_1(MagicPhysX.PxIDENTITY)">
            <summary>identity constructor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxQuat_new_2(System.Single)">
            <summary>Constructor from a scalar: sets the real part w to the scalar value, and the imaginary parts (x,y,z) to zero</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxQuat_new_3(System.Single,System.Single,System.Single,System.Single)">
            <summary>Constructor. Take note of the order of the elements!</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxQuat_new_4(System.Single,MagicPhysX.PxVec3*)">
            <summary>Creates from angle-axis representation.  Axis must be normalized!  Angle is in radians!  Unit: Radians</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxQuat_new_5(MagicPhysX.PxMat33*)">
            <summary>Creates from orientation matrix.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxQuat_isIdentity(MagicPhysX.PxQuat*)">
            <summary>returns true if quat is identity</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxQuat_isFinite(MagicPhysX.PxQuat*)">
            <summary>returns true if all elements are finite (not NAN or INF, etc.)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxQuat_isUnit(MagicPhysX.PxQuat*)">
            <summary>returns true if finite and magnitude is close to unit</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxQuat_isSane(MagicPhysX.PxQuat*)">
            <summary>returns true if finite and magnitude is reasonably close to unit to allow for some accumulation of error vs isValid</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxQuat_toRadiansAndUnitAxis(MagicPhysX.PxQuat*,System.Single*,MagicPhysX.PxVec3*)">
            <summary>converts this quaternion to angle-axis representation</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxQuat_getAngle(MagicPhysX.PxQuat*)">
            <summary>Gets the angle between this quat and the identity quaternion.  Unit: Radians</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxQuat_getAngle_1(MagicPhysX.PxQuat*,MagicPhysX.PxQuat*)">
            <summary>Gets the angle between this quat and the argument  Unit: Radians</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxQuat_magnitudeSquared(MagicPhysX.PxQuat*)">
            <summary>This is the squared 4D vector length, should be 1 for unit quaternions.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxQuat_dot(MagicPhysX.PxQuat*,MagicPhysX.PxQuat*)">
            <summary>returns the scalar product of this and other.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxQuat_normalize_mut(MagicPhysX.PxQuat*)">
            <summary>maps to the closest unit quaternion.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxQuat_getBasisVector0(MagicPhysX.PxQuat*)">
            <summary>brief computes rotation of x-axis</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxQuat_getBasisVector1(MagicPhysX.PxQuat*)">
            <summary>brief computes rotation of y-axis</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxQuat_getBasisVector2(MagicPhysX.PxQuat*)">
            <summary>brief computes rotation of z-axis</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxQuat_rotate(MagicPhysX.PxQuat*,MagicPhysX.PxVec3*)">
            <summary>rotates passed vec by this (assumed unitary)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxQuat_rotateInv(MagicPhysX.PxQuat*,MagicPhysX.PxVec3*)">
            <summary>inverse rotates passed vec by this (assumed unitary)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTransform_transform_1(MagicPhysX.PxTransform*,MagicPhysX.PxTransform*)">
            <summary>Transform transform to parent (returns compound transform: first src, then *this)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTransform_isValid(MagicPhysX.PxTransform*)">
            <summary>returns true if finite and q is a unit quaternion</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTransform_isSane(MagicPhysX.PxTransform*)">
            <summary>returns true if finite and quat magnitude is reasonably close to unit to allow for some accumulation of error vs isValid</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTransform_isFinite(MagicPhysX.PxTransform*)">
            <summary>returns true if all elems are finite (not NAN or INF, etc.)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTransform_transformInv_1(MagicPhysX.PxTransform*,MagicPhysX.PxTransform*)">
            <summary>Transform transform from parent (returns compound transform: first src, then this-&gt;inverse)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTransform_getNormalized(MagicPhysX.PxTransform*)">
            <summary>return a normalized transform (i.e. one in which the quaternion has unit magnitude)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMat33_new">
            <summary>Default constructor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMat33_new_1(MagicPhysX.PxIDENTITY)">
            <summary>identity constructor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMat33_new_2(MagicPhysX.PxZERO)">
            <summary>zero constructor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMat33_new_3(MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>Construct from three base vectors</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMat33_new_4(System.Single)">
            <summary>constructor from a scalar, which generates a multiple of the identity matrix</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMat33_new_5(System.Single*)">
            <summary>Construct from float[9]</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMat33_new_6(MagicPhysX.PxQuat*)">
            <summary>Construct from a quaternion</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMat33_createDiagonal(MagicPhysX.PxVec3*)">
            <summary>Construct from diagonal, off-diagonals are zero.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMat33_outer(MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>Computes the outer product of two vectors</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMat33_getTranspose(MagicPhysX.PxMat33*)">
            <summary>Get transposed matrix</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMat33_getInverse(MagicPhysX.PxMat33*)">
            <summary>Get the real inverse</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMat33_getDeterminant(MagicPhysX.PxMat33*)">
            <summary>Get determinant</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMat33_transform(MagicPhysX.PxMat33*,MagicPhysX.PxVec3*)">
            <summary>Transform vector by matrix, equal to v' = M*v</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMat33_transformTranspose(MagicPhysX.PxMat33*,MagicPhysX.PxVec3*)">
            <summary>Transform vector by matrix transpose, v' = M^t*v</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBounds3_new">
            <summary>Default constructor, not performing any initialization for performance reason.  Use empty() function below to construct empty bounds.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBounds3_new_1(MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>Construct from two bounding points</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBounds3_empty">
            <summary>Return empty bounds.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBounds3_boundsOfPoints(MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>returns the AABB containing v0 and v1.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBounds3_centerExtents(MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>returns the AABB from center and extents vectors.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBounds3_basisExtent(MagicPhysX.PxVec3*,MagicPhysX.PxMat33*,MagicPhysX.PxVec3*)">
            <summary>Construct from center, extent, and (not necessarily orthogonal) basis</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBounds3_poseExtent(MagicPhysX.PxTransform*,MagicPhysX.PxVec3*)">
            <summary>Construct from pose and extent</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBounds3_transformSafe(MagicPhysX.PxMat33*,MagicPhysX.PxBounds3*)">
            <summary>gets the transformed bounds of the passed AABB (resulting in a bigger AABB).  This version is safe to call for empty bounds.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBounds3_transformFast(MagicPhysX.PxMat33*,MagicPhysX.PxBounds3*)">
            <summary>gets the transformed bounds of the passed AABB (resulting in a bigger AABB).  Calling this method for empty bounds leads to undefined behavior. Use [`transformSafe`]() instead.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBounds3_transformSafe_1(MagicPhysX.PxTransform*,MagicPhysX.PxBounds3*)">
            <summary>gets the transformed bounds of the passed AABB (resulting in a bigger AABB).  This version is safe to call for empty bounds.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBounds3_transformFast_1(MagicPhysX.PxTransform*,MagicPhysX.PxBounds3*)">
            <summary>gets the transformed bounds of the passed AABB (resulting in a bigger AABB).  Calling this method for empty bounds leads to undefined behavior. Use [`transformSafe`]() instead.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBounds3_setEmpty_mut(MagicPhysX.PxBounds3*)">
            <summary>Sets empty to true</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBounds3_setMaximal_mut(MagicPhysX.PxBounds3*)">
            <summary>Sets the bounds to maximum size [-PX_MAX_BOUNDS_EXTENTS, PX_MAX_BOUNDS_EXTENTS].</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBounds3_include_mut(MagicPhysX.PxBounds3*,MagicPhysX.PxVec3*)">
            <summary>expands the volume to include v</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBounds3_include_mut_1(MagicPhysX.PxBounds3*,MagicPhysX.PxBounds3*)">
            <summary>expands the volume to include b.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBounds3_intersects(MagicPhysX.PxBounds3*,MagicPhysX.PxBounds3*)">
            <summary>indicates whether the intersection of this and b is empty or not.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBounds3_intersects1D(MagicPhysX.PxBounds3*,MagicPhysX.PxBounds3*,System.UInt32)">
            <summary>computes the 1D-intersection between two AABBs, on a given axis.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBounds3_contains(MagicPhysX.PxBounds3*,MagicPhysX.PxVec3*)">
            <summary>indicates if these bounds contain v.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBounds3_isInside(MagicPhysX.PxBounds3*,MagicPhysX.PxBounds3*)">
            <summary>checks a box is inside another box.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBounds3_getCenter(MagicPhysX.PxBounds3*)">
            <summary>returns the center of this axis aligned box.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBounds3_getCenter_1(MagicPhysX.PxBounds3*,System.UInt32)">
            <summary>get component of the box's center along a given axis</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBounds3_getExtents(MagicPhysX.PxBounds3*,System.UInt32)">
            <summary>get component of the box's extents along a given axis</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBounds3_getDimensions(MagicPhysX.PxBounds3*)">
            <summary>returns the dimensions (width/height/depth) of this axis aligned box.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBounds3_getExtents_1(MagicPhysX.PxBounds3*)">
            <summary>returns the extents, which are half of the width/height/depth.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBounds3_scaleSafe_mut(MagicPhysX.PxBounds3*,System.Single)">
            <summary>scales the AABB.  This version is safe to call for empty bounds.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBounds3_scaleFast_mut(MagicPhysX.PxBounds3*,System.Single)">
            <summary>scales the AABB.  Calling this method for empty bounds leads to undefined behavior. Use [`scaleSafe`]() instead.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBounds3_fattenSafe_mut(MagicPhysX.PxBounds3*,System.Single)">
            <summary>fattens the AABB in all 3 dimensions by the given distance.  This version is safe to call for empty bounds.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBounds3_fattenFast_mut(MagicPhysX.PxBounds3*,System.Single)">
            <summary>fattens the AABB in all 3 dimensions by the given distance.  Calling this method for empty bounds leads to undefined behavior. Use [`fattenSafe`]() instead.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBounds3_isFinite(MagicPhysX.PxBounds3*)">
            <summary>checks that the AABB values are not NaN</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBounds3_isValid(MagicPhysX.PxBounds3*)">
            <summary>checks that the AABB values describe a valid configuration.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBounds3_closestPoint(MagicPhysX.PxBounds3*,MagicPhysX.PxVec3*)">
            <summary>Finds the closest point in the box to the point p. If p is contained, this will be p, otherwise it will be the closest point on the surface of the box.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxErrorCallback_reportError_mut(MagicPhysX.PxErrorCallback*,MagicPhysX.PxErrorCode,System.Byte*,System.Byte*,System.Int32)">
            <summary>Reports an error code.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxAllocationListener_onAllocation_mut(MagicPhysX.PxAllocationListener*,System.UIntPtr,System.Byte*,System.Byte*,System.Int32,System.Void*)">
            <summary>callback when memory is allocated.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxAllocationListener_onDeallocation_mut(MagicPhysX.PxAllocationListener*,System.Void*)">
            <summary>callback when memory is deallocated.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBroadcastingAllocator_new_alloc(MagicPhysX.PxAllocatorCallback*,MagicPhysX.PxErrorCallback*)">
            <summary>The default constructor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBroadcastingAllocator_delete(MagicPhysX.PxBroadcastingAllocator*)">
            <summary>The default constructor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBroadcastingAllocator_allocate_mut(MagicPhysX.PxBroadcastingAllocator*,System.UIntPtr,System.Byte*,System.Byte*,System.Int32)">
            <summary>Allocates size bytes of memory, which must be 16-byte aligned.  This method should never return NULL.  If you run out of memory, then you should terminate the app or take some other appropriate action.  Threading: This function should be thread safe as it can be called in the context of the user thread and physics processing thread(s).  The allocated block of memory.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBroadcastingAllocator_deallocate_mut(MagicPhysX.PxBroadcastingAllocator*,System.Void*)">
            <summary>Frees memory previously allocated by allocate().  Threading: This function should be thread safe as it can be called in the context of the user thread and physics processing thread(s).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBroadcastingErrorCallback_new_alloc(MagicPhysX.PxErrorCallback*)">
            <summary>The default constructor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBroadcastingErrorCallback_delete(MagicPhysX.PxBroadcastingErrorCallback*)">
            <summary>The default destructor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBroadcastingErrorCallback_reportError_mut(MagicPhysX.PxBroadcastingErrorCallback*,MagicPhysX.PxErrorCode,System.Byte*,System.Byte*,System.Int32)">
            <summary>Reports an error code.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxEnableFPExceptions">
            <summary>Enables floating point exceptions for the scalar and SIMD unit</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxDisableFPExceptions">
            <summary>Disables floating point exceptions for the scalar and SIMD unit</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxInputStream_read_mut(MagicPhysX.PxInputStream*,System.Void*,System.UInt32)">
            <summary>read from the stream. The number of bytes read may be less than the number requested.  the number of bytes read from the stream.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxInputData_getLength(MagicPhysX.PxInputData*)">
            <summary>return the length of the input data  size in bytes of the input data</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxInputData_seek_mut(MagicPhysX.PxInputData*,System.UInt32)">
            <summary>seek to the given offset from the start of the data.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxInputData_tell(MagicPhysX.PxInputData*)">
            <summary>return the current offset from the start of the data  the offset to seek to.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxOutputStream_write_mut(MagicPhysX.PxOutputStream*,System.Void*,System.UInt32)">
            <summary>write to the stream. The number of bytes written may be less than the number sent.  the number of bytes written to the stream by this call.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec4_new">
            <summary>default constructor leaves data uninitialized.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec4_new_1(MagicPhysX.PxZERO)">
            <summary>zero constructor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec4_new_2(System.Single)">
            <summary>Assigns scalar parameter to all elements.  Useful to initialize to zero or one.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec4_new_3(System.Single,System.Single,System.Single,System.Single)">
            <summary>Initializes from 3 scalar parameters.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec4_new_4(MagicPhysX.PxVec3*,System.Single)">
            <summary>Initializes from 3 scalar parameters.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec4_new_5(System.Single*)">
            <summary>Initializes from an array of scalar parameters.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec4_isZero(MagicPhysX.PxVec4*)">
            <summary>tests for exact zero vector</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec4_isFinite(MagicPhysX.PxVec4*)">
            <summary>returns true if all 3 elems of the vector are finite (not NAN or INF, etc.)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec4_isNormalized(MagicPhysX.PxVec4*)">
            <summary>is normalized - used by API parameter validation</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec4_magnitudeSquared(MagicPhysX.PxVec4*)">
            <summary>returns the squared magnitude  Avoids calling PxSqrt()!</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec4_magnitude(MagicPhysX.PxVec4*)">
            <summary>returns the magnitude</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec4_dot(MagicPhysX.PxVec4*,MagicPhysX.PxVec4*)">
            <summary>returns the scalar product of this and other.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec4_getNormalized(MagicPhysX.PxVec4*)">
            <summary>returns a unit vector</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec4_normalize_mut(MagicPhysX.PxVec4*)">
            <summary>normalizes the vector in place</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec4_multiply(MagicPhysX.PxVec4*,MagicPhysX.PxVec4*)">
            <summary>a[i] * b[i], for all i.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec4_minimum(MagicPhysX.PxVec4*,MagicPhysX.PxVec4*)">
            <summary>element-wise minimum</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec4_maximum(MagicPhysX.PxVec4*,MagicPhysX.PxVec4*)">
            <summary>element-wise maximum</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMat44_new">
            <summary>Default constructor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMat44_new_1(MagicPhysX.PxIDENTITY)">
            <summary>identity constructor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMat44_new_2(MagicPhysX.PxZERO)">
            <summary>zero constructor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMat44_new_3(MagicPhysX.PxVec4*,MagicPhysX.PxVec4*,MagicPhysX.PxVec4*,MagicPhysX.PxVec4*)">
            <summary>Construct from four 4-vectors</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMat44_new_4(System.Single)">
            <summary>constructor that generates a multiple of the identity matrix</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMat44_new_5(MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>Construct from three base vectors and a translation</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMat44_new_6(System.Single*)">
            <summary>Construct from float[16]</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMat44_new_7(MagicPhysX.PxQuat*)">
            <summary>Construct from a quaternion</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMat44_new_8(MagicPhysX.PxVec4*)">
            <summary>Construct from a diagonal vector</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMat44_new_9(MagicPhysX.PxMat33*,MagicPhysX.PxVec3*)">
            <summary>Construct from Mat33 and a translation</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMat44_getTranspose(MagicPhysX.PxMat44*)">
            <summary>Get transposed matrix</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMat44_transform(MagicPhysX.PxMat44*,MagicPhysX.PxVec4*)">
            <summary>Transform vector by matrix, equal to v' = M*v</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMat44_transform_1(MagicPhysX.PxMat44*,MagicPhysX.PxVec3*)">
            <summary>Transform vector by matrix, equal to v' = M*v</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMat44_rotate(MagicPhysX.PxMat44*,MagicPhysX.PxVec4*)">
            <summary>Rotate vector by matrix, equal to v' = M*v</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMat44_rotate_1(MagicPhysX.PxMat44*,MagicPhysX.PxVec3*)">
            <summary>Rotate vector by matrix, equal to v' = M*v</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPlane_new">
            <summary>Constructor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPlane_new_1(System.Single,System.Single,System.Single,System.Single)">
            <summary>Constructor from a normal and a distance</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPlane_new_2(MagicPhysX.PxVec3*,System.Single)">
            <summary>Constructor from a normal and a distance</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPlane_new_3(MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>Constructor from a point on the plane and a normal</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPlane_new_4(MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>Constructor from three points</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPlane_project(MagicPhysX.PxPlane*,MagicPhysX.PxVec3*)">
            <summary>projects p into the plane</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPlane_pointInPlane(MagicPhysX.PxPlane*)">
            <summary>find an arbitrary point in the plane</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPlane_normalize_mut(MagicPhysX.PxPlane*)">
            <summary>equivalent plane with unit normal</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPlane_transform(MagicPhysX.PxPlane*,MagicPhysX.PxTransform*)">
            <summary>transform plane</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPlane_inverseTransform(MagicPhysX.PxPlane*,MagicPhysX.PxTransform*)">
            <summary>inverse-transform plane</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxShortestRotation(MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>finds the shortest rotation between two vectors.  a rotation about an axis normal to the two vectors which takes one to the other via the shortest path</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxTransformFromSegment(MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,System.Single*)">
            <summary>creates a transform from the endpoints of a segment, suitable for an actor transform for a PxCapsuleGeometry  A PxTransform which will transform the vector (1,0,0) to the capsule axis shrunk by the halfHeight</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxTransformFromPlaneEquation(MagicPhysX.PxPlane*)">
            <summary>creates a transform from a plane equation, suitable for an actor transform for a PxPlaneGeometry  a PxTransform which will transform the plane PxPlane(1,0,0,0) to the specified plane</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxPlaneEquationFromTransform(MagicPhysX.PxTransform*)">
            <summary>creates a plane equation from a transform, such as the actor transform for a PxPlaneGeometry  the plane</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxSlerp(System.Single,MagicPhysX.PxQuat*,MagicPhysX.PxQuat*)">
            <summary>Spherical linear interpolation of two quaternions.  Returns left when t=0, right when t=1 and a linear interpolation of left and right when 0 &lt; t &lt; 1. Returns angle between -PI and PI in radians</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxIntegrateTransform(MagicPhysX.PxTransform*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxTransform*)">
            <summary>integrate transform.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxExp(MagicPhysX.PxVec3*)">
            <summary>Compute the exponent of a PxVec3</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxOptimizeBoundingBox(MagicPhysX.PxMat33*)">
            <summary>computes a oriented bounding box around the scaled basis.  Bounding box extent.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxLog(MagicPhysX.PxQuat*)">
            <summary>return Returns the log of a PxQuat</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxLargestAxis(MagicPhysX.PxVec3*)">
            <summary>return Returns 0 if v.x is largest element of v, 1 if v.y is largest element, 2 if v.z is largest element.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxTanHalf(System.Single,System.Single)">
            <summary>Compute tan(theta/2) given sin(theta) and cos(theta) as inputs.  Returns tan(theta/2)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxEllipseClamp(MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>Compute the closest point on an 2d ellipse to a given 2d point.  Returns the 2d position on the surface of the ellipse that is closest to point.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxSeparateSwingTwist(MagicPhysX.PxQuat*,MagicPhysX.PxQuat*,MagicPhysX.PxQuat*)">
            <summary>Compute from an input quaternion q a pair of quaternions (swing, twist) such that q = swing * twist with the caveats that swing.x = twist.y = twist.z = 0.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxComputeAngle(MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>Compute the angle between two non-unit vectors  Returns the angle (in radians) between the two vector v0 and v1.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxComputeBasisVectors(MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>Compute two normalized vectors (right and up) that are perpendicular to an input normalized vector (dir).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxComputeBasisVectors_1(MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>Compute three normalized vectors (dir, right and up) that are parallel to (dir) and perpendicular to (right, up) the normalized direction vector (p1 - p0)/||p1 - p0||.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxGetNextIndex3(System.UInt32)">
            <summary>Compute (i+1)%3</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMutexImpl_new_alloc">
            <summary>The constructor for Mutex creates a mutex. It is initially unlocked.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMutexImpl_delete(MagicPhysX.PxMutexImpl*)">
            <summary>The destructor for Mutex deletes the mutex.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMutexImpl_lock_mut(MagicPhysX.PxMutexImpl*)">
            <summary>Acquire (lock) the mutex. If the mutex is already locked by another thread, this method blocks until the mutex is unlocked.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMutexImpl_trylock_mut(MagicPhysX.PxMutexImpl*)">
            <summary>Acquire (lock) the mutex. If the mutex is already locked by another thread, this method returns false without blocking.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMutexImpl_unlock_mut(MagicPhysX.PxMutexImpl*)">
            <summary>Release (unlock) the mutex.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMutexImpl_getSize">
            <summary>Size of this class.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxProfilerCallback_zoneStart_mut(MagicPhysX.PxProfilerCallback*,System.Byte*,System.Boolean,System.UInt64)">
            <summary>Mark the beginning of a nested profile block  Returns implementation-specific profiler data for this event</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxProfilerCallback_zoneEnd_mut(MagicPhysX.PxProfilerCallback*,System.Void*,System.Byte*,System.Boolean,System.UInt64)">
            <summary>Mark the end of a nested profile block  eventName plus contextId can be used to uniquely match up start and end of a zone.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSyncImpl_wait_mut(MagicPhysX.PxSyncImpl*,System.UInt32)">
            <summary>Wait on the object for at most the given number of ms. Returns true if the object is signaled. Sync::waitForever will block forever or until the object is signaled.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSyncImpl_set_mut(MagicPhysX.PxSyncImpl*)">
            <summary>Signal the synchronization object, waking all threads waiting on it</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSyncImpl_reset_mut(MagicPhysX.PxSyncImpl*)">
            <summary>Reset the synchronization object</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSyncImpl_getSize">
            <summary>Size of this class.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec2_new">
            <summary>default constructor leaves data uninitialized.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec2_new_1(MagicPhysX.PxZERO)">
            <summary>zero constructor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec2_new_2(System.Single)">
            <summary>Assigns scalar parameter to all elements.  Useful to initialize to zero or one.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec2_new_3(System.Single,System.Single)">
            <summary>Initializes from 2 scalar parameters.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec2_isZero(MagicPhysX.PxVec2*)">
            <summary>tests for exact zero vector</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec2_isFinite(MagicPhysX.PxVec2*)">
            <summary>returns true if all 2 elems of the vector are finite (not NAN or INF, etc.)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec2_isNormalized(MagicPhysX.PxVec2*)">
            <summary>is normalized - used by API parameter validation</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec2_magnitudeSquared(MagicPhysX.PxVec2*)">
            <summary>returns the squared magnitude  Avoids calling PxSqrt()!</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec2_magnitude(MagicPhysX.PxVec2*)">
            <summary>returns the magnitude</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec2_dot(MagicPhysX.PxVec2*,MagicPhysX.PxVec2*)">
            <summary>returns the scalar product of this and other.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec2_getNormalized(MagicPhysX.PxVec2*)">
            <summary>returns a unit vector</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec2_normalize_mut(MagicPhysX.PxVec2*)">
            <summary>normalizes the vector in place</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec2_multiply(MagicPhysX.PxVec2*,MagicPhysX.PxVec2*)">
            <summary>a[i] * b[i], for all i.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec2_minimum(MagicPhysX.PxVec2*,MagicPhysX.PxVec2*)">
            <summary>element-wise minimum</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec2_minElement(MagicPhysX.PxVec2*)">
            <summary>returns MIN(x, y);</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec2_maximum(MagicPhysX.PxVec2*,MagicPhysX.PxVec2*)">
            <summary>element-wise maximum</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxVec2_maxElement(MagicPhysX.PxVec2*)">
            <summary>returns MAX(x, y);</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSerializationContext_registerReference_mut(MagicPhysX.PxSerializationContext*,MagicPhysX.PxBase*,System.UInt32,System.UIntPtr)">
            <summary>Registers a reference value corresponding to a PxBase object.  This method is assumed to be called in the implementation of PxSerializer::registerReferences for serialized references that need to be resolved on deserialization.  A reference needs to be associated with exactly one PxBase object in either the collection or the external references collection.  Different kinds of references are supported and need to be specified. In the most common case (PX_SERIAL_REF_KIND_PXBASE) the PxBase object matches the reference value (which is the pointer to the PxBase object). Integer references maybe registered as well (used for internal material indices with PX_SERIAL_REF_KIND_MATERIAL_IDX). Other kinds could be added with the restriction that for pointer types the kind value needs to be marked with the PX_SERIAL_REF_KIND_PTR_TYPE_BIT.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSerializationContext_getCollection(MagicPhysX.PxSerializationContext*)">
            <summary>Returns the collection that is being serialized.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSerializationContext_writeData_mut(MagicPhysX.PxSerializationContext*,System.Void*,System.UInt32)">
            <summary>Serializes object data and object extra data.  This function is assumed to be called within the implementation of PxSerializer::exportData and PxSerializer::exportExtraData.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSerializationContext_alignData_mut(MagicPhysX.PxSerializationContext*,System.UInt32)">
            <summary>Aligns the serialized data.  This function is assumed to be called within the implementation of PxSerializer::exportData and PxSerializer::exportExtraData.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSerializationContext_writeName_mut(MagicPhysX.PxSerializationContext*,System.Byte*)">
            <summary>Helper function to write a name to the extraData if serialization is configured to save names.  This function is assumed to be called within the implementation of PxSerializer::exportExtraData.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxDeserializationContext_resolveReference(MagicPhysX.PxDeserializationContext*,System.UInt32,System.UIntPtr)">
            <summary>Retrieves a pointer to a deserialized PxBase object given a corresponding deserialized reference value  This method is assumed to be called in the implementation of PxSerializer::createObject in order to update reference values on deserialization.  To update a PxBase reference the corresponding deserialized pointer value needs to be provided in order to retrieve the location of the corresponding deserialized PxBase object. (PxDeserializationContext::translatePxBase simplifies this common case).  For other kinds of references the reverence values need to be updated by deduction given the corresponding PxBase instance.  PxBase object associated with the reference value</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxDeserializationContext_readName_mut(MagicPhysX.PxDeserializationContext*,System.Byte**)">
            <summary>Helper function to read a name from the extra data during deserialization.  This function is assumed to be called within the implementation of PxSerializer::createObject.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxDeserializationContext_alignExtraData_mut(MagicPhysX.PxDeserializationContext*,System.UInt32)">
            <summary>Function to align the extra data stream to a power of 2 alignment  This function is assumed to be called within the implementation of PxSerializer::createObject.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSerializationRegistry_registerSerializer_mut(MagicPhysX.PxSerializationRegistry*,System.UInt16,MagicPhysX.PxSerializer*)">
            <summary>Register a serializer for a concrete type</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSerializationRegistry_unregisterSerializer_mut(MagicPhysX.PxSerializationRegistry*,System.UInt16)">
            <summary>Unregister a serializer for a concrete type, and retrieves the corresponding serializer object.  Unregistered serializer corresponding to type, NULL for types for which no serializer has been registered.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSerializationRegistry_getSerializer(MagicPhysX.PxSerializationRegistry*,System.UInt16)">
            <summary>Returns PxSerializer corresponding to type  Registered PxSerializer object corresponding to type</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSerializationRegistry_registerRepXSerializer_mut(MagicPhysX.PxSerializationRegistry*,System.UInt16,MagicPhysX.PxRepXSerializer*)">
            <summary>Register a RepX serializer for a concrete type</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSerializationRegistry_unregisterRepXSerializer_mut(MagicPhysX.PxSerializationRegistry*,System.UInt16)">
            <summary>Unregister a RepX serializer for a concrete type, and retrieves the corresponding serializer object.  Unregistered PxRepxSerializer corresponding to type, NULL for types for which no RepX serializer has been registered.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSerializationRegistry_getRepXSerializer(MagicPhysX.PxSerializationRegistry*,System.Byte*)">
            <summary>Returns RepX serializer given the corresponding type name  Registered PxRepXSerializer object corresponding to type name</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSerializationRegistry_release_mut(MagicPhysX.PxSerializationRegistry*)">
            <summary>Releases PxSerializationRegistry instance.  This unregisters all PhysX and PhysXExtension serializers. Make sure to unregister all custom type serializers before releasing the PxSerializationRegistry.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCollection_add_mut(MagicPhysX.PxCollection*,MagicPhysX.PxBase*,System.UInt64)">
            <summary>Adds a PxBase object to the collection.  Adds a PxBase object to the collection. Optionally a PxSerialObjectId can be provided in order to resolve dependencies between collections. A PxSerialObjectId value of PX_SERIAL_OBJECT_ID_INVALID means the object remains without id. Objects can be added regardless of other objects they require. If the object is already in the collection, the ID will be set if it was PX_SERIAL_OBJECT_ID_INVALID previously, otherwise the operation fails.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCollection_remove_mut(MagicPhysX.PxCollection*,MagicPhysX.PxBase*)">
            <summary>Removes a PxBase member object from the collection.  Object needs to be contained by the collection.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCollection_contains(MagicPhysX.PxCollection*,MagicPhysX.PxBase*)">
            <summary>Returns whether the collection contains a certain PxBase object.  Whether object is contained.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCollection_addId_mut(MagicPhysX.PxCollection*,MagicPhysX.PxBase*,System.UInt64)">
            <summary>Adds an id to a member PxBase object.  If the object is already associated with an id within the collection, the id is replaced. May only be called for objects that are members of the collection. The id needs to be unique within the collection.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCollection_removeId_mut(MagicPhysX.PxCollection*,System.UInt64)">
            <summary>Removes id from a contained PxBase object.  May only be called for ids that are associated with an object in the collection.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCollection_add_mut_1(MagicPhysX.PxCollection*,MagicPhysX.PxCollection*)">
            <summary>Adds all PxBase objects and their ids of collection to this collection.  PxBase objects already in this collection are ignored. Object ids need to be conflict free, i.e. the same object may not have two different ids within the two collections.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCollection_remove_mut_1(MagicPhysX.PxCollection*,MagicPhysX.PxCollection*)">
            <summary>Removes all PxBase objects of collection from this collection.  PxBase objects not present in this collection are ignored. Ids of objects which are removed are also removed.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCollection_getNbObjects(MagicPhysX.PxCollection*)">
            <summary>Gets number of PxBase objects in this collection.  Number of objects in this collection</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCollection_getObject(MagicPhysX.PxCollection*,System.UInt32)">
            <summary>Gets the PxBase object of this collection given its index.  PxBase object at index index</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCollection_getObjects(MagicPhysX.PxCollection*,MagicPhysX.PxBase**,System.UInt32,System.UInt32)">
            <summary>Copies member PxBase pointers to a user specified buffer.  number of members PxBase objects that have been written to the userBuffer</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCollection_find(MagicPhysX.PxCollection*,System.UInt64)">
            <summary>Looks for a PxBase object given a PxSerialObjectId value.  If there is no PxBase object in the collection with the given id, NULL is returned.  PxBase object with the given id value or NULL</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCollection_getNbIds(MagicPhysX.PxCollection*)">
            <summary>Gets number of PxSerialObjectId names in this collection.  Number of PxSerialObjectId names in this collection</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCollection_getIds(MagicPhysX.PxCollection*,System.UInt64*,System.UInt32,System.UInt32)">
            <summary>Copies member PxSerialObjectId values to a user specified buffer.  number of members PxSerialObjectId values that have been written to the userBuffer</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCollection_getId(MagicPhysX.PxCollection*,MagicPhysX.PxBase*)">
            <summary>Gets the PxSerialObjectId name of a PxBase object within the collection.  The PxBase object needs to be a member of the collection.  PxSerialObjectId name of the object or PX_SERIAL_OBJECT_ID_INVALID if the object is unnamed</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCollection_release_mut(MagicPhysX.PxCollection*)">
            <summary>Deletes a collection object.  This function only deletes the collection object, i.e. the container class. It doesn't delete objects that are part of the collection.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCreateCollection">
            <summary>Creates a collection object.  Objects can only be serialized or deserialized through a collection. For serialization, users must add objects to the collection and serialize the collection as a whole. For deserialization, the system gives back a collection of deserialized objects to users.  The new collection object.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBase_release_mut(MagicPhysX.PxBase*)">
            <summary>Releases the PxBase instance, please check documentation of release in derived class.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBase_getConcreteTypeName(MagicPhysX.PxBase*)">
            <summary>Returns string name of dynamic type.  Class name of most derived type of this object.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBase_getConcreteType(MagicPhysX.PxBase*)">
            <summary>Returns concrete type of object.  PxConcreteType::Enum of serialized object</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBase_setBaseFlag_mut(MagicPhysX.PxBase*,MagicPhysX.PxBaseFlag,System.Boolean)">
            <summary>Set PxBaseFlag</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBase_setBaseFlags_mut(MagicPhysX.PxBase*,MagicPhysX.PxBaseFlags)">
            <summary>Set PxBaseFlags</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBase_getBaseFlags(MagicPhysX.PxBase*)">
            <summary>Returns PxBaseFlags  PxBaseFlags</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBase_isReleasable(MagicPhysX.PxBase*)">
            <summary>Whether the object is subordinate.  A class is subordinate, if it can only be instantiated in the context of another class.  Whether the class is subordinate</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRefCounted_release_mut(MagicPhysX.PxRefCounted*)">
            <summary>Decrements the reference count of the object and releases it if the new reference count is zero.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRefCounted_getReferenceCount(MagicPhysX.PxRefCounted*)">
            <summary>Returns the reference count of the object.  At creation, the reference count of the object is 1. Every other object referencing this object increments the count by 1. When the reference count reaches 0, and only then, the object gets destroyed automatically.  the current reference count.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRefCounted_acquireReference_mut(MagicPhysX.PxRefCounted*)">
            <summary>Acquires a counted reference to this object.  This method increases the reference count of the object by 1. Decrement the reference count by calling release()</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTolerancesScale_new(System.Single,System.Single)">
            <summary>constructor sets to default</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTolerancesScale_isValid(MagicPhysX.PxTolerancesScale*)">
            <summary>Returns true if the descriptor is valid.  true if the current settings are valid (returns always true).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxStringTable_allocateStr_mut(MagicPhysX.PxStringTable*,System.Byte*)">
            <summary>Allocate a new string.  *Always* a valid null terminated string.  \"\" is returned if \"\" or null is passed in.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxStringTable_release_mut(MagicPhysX.PxStringTable*)">
            <summary>Release the string table and all the strings associated with it.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSerializer_getConcreteTypeName(MagicPhysX.PxSerializer*)">
            <summary>Returns string name of dynamic type.  Class name of most derived type of this object.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSerializer_requiresObjects(MagicPhysX.PxSerializer*,MagicPhysX.PxBase*,MagicPhysX.PxProcessPxBaseCallback*)">
            <summary>Adds required objects to the collection.  This method does not add the required objects recursively, e.g. objects required by required objects.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSerializer_isSubordinate(MagicPhysX.PxSerializer*)">
            <summary>Whether the object is subordinate.  A class is subordinate, if it can only be instantiated in the context of another class.  Whether the class is subordinate</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSerializer_exportExtraData(MagicPhysX.PxSerializer*,MagicPhysX.PxBase*,MagicPhysX.PxSerializationContext*)">
            <summary>Exports object's extra data to stream.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSerializer_exportData(MagicPhysX.PxSerializer*,MagicPhysX.PxBase*,MagicPhysX.PxSerializationContext*)">
            <summary>Exports object's data to stream.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSerializer_registerReferences(MagicPhysX.PxSerializer*,MagicPhysX.PxBase*,MagicPhysX.PxSerializationContext*)">
            <summary>Register references that the object maintains to other objects.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSerializer_getClassSize(MagicPhysX.PxSerializer*)">
            <summary>Returns size needed to create the class instance.  sizeof class instance.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSerializer_createObject(MagicPhysX.PxSerializer*,System.Byte**,MagicPhysX.PxDeserializationContext*)">
            <summary>Create object at a given address, resolve references and import extra data.  Created PxBase pointer (needs to be identical to address before increment).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSerializer_delete(MagicPhysX.PxSerializer*)">
            <summary>*******************************************************************************************************************</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxInsertionCallback_buildObjectFromData_mut(MagicPhysX.PxInsertionCallback*,MagicPhysX.PxConcreteType,System.Void*)">
            <summary>Builds object (TriangleMesh, Heightfield, ConvexMesh or BVH) from given data in PxPhysics.  PxBase Created object in PxPhysics.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTaskManager_setCpuDispatcher_mut(MagicPhysX.PxTaskManager*,MagicPhysX.PxCpuDispatcher*)">
            <summary>Set the user-provided dispatcher object for CPU tasks</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTaskManager_getCpuDispatcher(MagicPhysX.PxTaskManager*)">
            <summary>Get the user-provided dispatcher object for CPU tasks  The CPU dispatcher object.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTaskManager_resetDependencies_mut(MagicPhysX.PxTaskManager*)">
            <summary>Reset any dependencies between Tasks  Will be called at the start of every frame before tasks are submitted.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTaskManager_startSimulation_mut(MagicPhysX.PxTaskManager*)">
            <summary>Called by the owning scene to start the task graph.  All tasks with ref count of 1 will be dispatched.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTaskManager_stopSimulation_mut(MagicPhysX.PxTaskManager*)">
            <summary>Called by the owning scene at the end of a simulation step.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTaskManager_taskCompleted_mut(MagicPhysX.PxTaskManager*,MagicPhysX.PxTask*)">
            <summary>Called by the worker threads to inform the PxTaskManager that a task has completed processing.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTaskManager_getNamedTask_mut(MagicPhysX.PxTaskManager*,System.Byte*)">
            <summary>Retrieve a task by name  The ID of the task with that name, or eNOT_PRESENT if not found</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTaskManager_submitNamedTask_mut(MagicPhysX.PxTaskManager*,MagicPhysX.PxTask*,System.Byte*,MagicPhysX.PxTaskType)">
            <summary>Submit a task with a unique name.  The ID of the task with that name, or eNOT_PRESENT if not found</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTaskManager_submitUnnamedTask_mut(MagicPhysX.PxTaskManager*,MagicPhysX.PxTask*,MagicPhysX.PxTaskType)">
            <summary>Submit an unnamed task.  The ID of the task with that name, or eNOT_PRESENT if not found</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTaskManager_getTaskFromID_mut(MagicPhysX.PxTaskManager*,System.UInt32)">
            <summary>Retrieve a task given a task ID  The task associated with the ID</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTaskManager_release_mut(MagicPhysX.PxTaskManager*)">
            <summary>Release the PxTaskManager object, referenced dispatchers will not be released</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTaskManager_createTaskManager(MagicPhysX.PxErrorCallback*,MagicPhysX.PxCpuDispatcher*)">
            <summary>Construct a new PxTaskManager instance with the given [optional] dispatchers</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCpuDispatcher_submitTask_mut(MagicPhysX.PxCpuDispatcher*,MagicPhysX.PxBaseTask*)">
            <summary>Called by the TaskManager when a task is to be queued for execution.  Upon receiving a task, the dispatcher should schedule the task to run. After the task has been run, it should call the release() method and discard its pointer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCpuDispatcher_getWorkerCount(MagicPhysX.PxCpuDispatcher*)">
            <summary>Returns the number of available worker threads for this dispatcher.  The SDK will use this count to control how many tasks are submitted. By matching the number of tasks with the number of execution units task overhead can be reduced.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBaseTask_run_mut(MagicPhysX.PxBaseTask*)">
            <summary>The user-implemented run method where the task's work should be performed  run() methods must be thread safe, stack friendly (no alloca, etc), and must never block.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBaseTask_getName(MagicPhysX.PxBaseTask*)">
            <summary>Return a user-provided task name for profiling purposes.  It does not have to be unique, but unique names are helpful.  The name of this task</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBaseTask_addReference_mut(MagicPhysX.PxBaseTask*)">
            <summary>Implemented by derived implementation classes</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBaseTask_removeReference_mut(MagicPhysX.PxBaseTask*)">
            <summary>Implemented by derived implementation classes</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBaseTask_getReference(MagicPhysX.PxBaseTask*)">
            <summary>Implemented by derived implementation classes</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBaseTask_release_mut(MagicPhysX.PxBaseTask*)">
            <summary>Implemented by derived implementation classes  A task may assume in its release() method that the task system no longer holds references to it - so it may safely run its destructor, recycle itself, etc. provided no additional user references to the task exist</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBaseTask_getTaskManager(MagicPhysX.PxBaseTask*)">
            <summary>Return PxTaskManager to which this task was submitted  Note, can return NULL if task was not submitted, or has been completed.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTask_release_mut(MagicPhysX.PxTask*)">
            <summary>Release method implementation</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTask_finishBefore_mut(MagicPhysX.PxTask*,System.UInt32)">
            <summary>Inform the PxTaskManager this task must finish before the given</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTask_startAfter_mut(MagicPhysX.PxTask*,System.UInt32)">
            <summary>Inform the PxTaskManager this task cannot start until the given</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTask_addReference_mut(MagicPhysX.PxTask*)">
            <summary>Manually increment this task's reference count. The task will not be allowed to run until removeReference() is called.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTask_removeReference_mut(MagicPhysX.PxTask*)">
            <summary>Manually decrement this task's reference count. If the reference count reaches zero, the task will be dispatched.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTask_getReference(MagicPhysX.PxTask*)">
            <summary>Return the ref-count for this task</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTask_getTaskID(MagicPhysX.PxTask*)">
            <summary>Return the unique ID for this task</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTask_submitted_mut(MagicPhysX.PxTask*)">
            <summary>Called by PxTaskManager at submission time for initialization  Perform simulation step initialization here.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxLightCpuTask_setContinuation_mut(MagicPhysX.PxLightCpuTask*,MagicPhysX.PxTaskManager*,MagicPhysX.PxBaseTask*)">
            <summary>Initialize this task and specify the task that will have its ref count decremented on completion.  Submission is deferred until the task's mRefCount is decremented to zero. Note that we only use the PxTaskManager to query the appropriate dispatcher.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxLightCpuTask_setContinuation_mut_1(MagicPhysX.PxLightCpuTask*,MagicPhysX.PxBaseTask*)">
            <summary>Initialize this task and specify the task that will have its ref count decremented on completion.  This overload of setContinuation() queries the PxTaskManager from the continuation task, which cannot be NULL.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxLightCpuTask_getContinuation(MagicPhysX.PxLightCpuTask*)">
            <summary>Retrieves continuation task</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxLightCpuTask_removeReference_mut(MagicPhysX.PxLightCpuTask*)">
            <summary>Manually decrement this task's reference count. If the reference count reaches zero, the task will be dispatched.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxLightCpuTask_getReference(MagicPhysX.PxLightCpuTask*)">
            <summary>Return the ref-count for this task</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxLightCpuTask_addReference_mut(MagicPhysX.PxLightCpuTask*)">
            <summary>Manually increment this task's reference count. The task will not be allowed to run until removeReference() is called.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxLightCpuTask_release_mut(MagicPhysX.PxLightCpuTask*)">
            <summary>called by CpuDispatcher after run method has completed  Decrements the continuation task's reference count, if specified.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxGeometry_getType(MagicPhysX.PxGeometry*)">
            <summary>Returns the type of the geometry.  The type of the object.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBoxGeometry_new(System.Single,System.Single,System.Single)">
            <summary>Constructor to initialize half extents from scalar parameters.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBoxGeometry_new_1(MagicPhysX.PxVec3)">
            <summary>Constructor to initialize half extents from vector parameter.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBoxGeometry_isValid(MagicPhysX.PxBoxGeometry*)">
            <summary>Returns true if the geometry is valid.  True if the current settings are valid  A valid box has a positive extent in each direction (halfExtents.x &gt; 0, halfExtents.y &gt; 0, halfExtents.z &gt; 0). It is illegal to call PxRigidActor::createShape and PxPhysics::createShape with a box that has zero extent in any direction.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBVH_raycast(MagicPhysX.PxBVH*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxBVHRaycastCallback*,MagicPhysX.PxGeometryQueryFlags)">
            <summary>Raycast test against a BVH.  false if query has been aborted</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBVH_sweep(MagicPhysX.PxBVH*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxBVHRaycastCallback*,MagicPhysX.PxGeometryQueryFlags)">
            <summary>Sweep test against a BVH.  false if query has been aborted</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBVH_overlap(MagicPhysX.PxBVH*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxBVHOverlapCallback*,MagicPhysX.PxGeometryQueryFlags)">
            <summary>Overlap test against a BVH.  false if query has been aborted</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBVH_cull(MagicPhysX.PxBVH*,System.UInt32,MagicPhysX.PxPlane*,MagicPhysX.PxBVHOverlapCallback*,MagicPhysX.PxGeometryQueryFlags)">
            <summary>Frustum culling test against a BVH.  This is similar in spirit to an overlap query using a convex object around the frustum. However this specialized query has better performance, and can support more than the 6 planes of a frustum, which can be useful in portal-based engines.  On the other hand this test only returns a conservative number of bounds, i.e. some of the returned bounds may actually be outside the frustum volume, close to it but not touching it. This is usually an ok performance trade-off when the function is used for view-frustum culling.  false if query has been aborted</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBVH_getNbBounds(MagicPhysX.PxBVH*)">
            <summary>Returns the number of bounds in the BVH.  You can use [`getBounds`]() to retrieve the bounds.  These are the user-defined bounds passed to the BVH builder, not the internal bounds around each BVH node.  Number of bounds in the BVH.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBVH_getBounds(MagicPhysX.PxBVH*)">
            <summary>Retrieve the read-only bounds in the BVH.  These are the user-defined bounds passed to the BVH builder, not the internal bounds around each BVH node.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBVH_getBoundsForModification_mut(MagicPhysX.PxBVH*)">
            <summary>Retrieve the bounds in the BVH.  These bounds can be modified. Call refit() after modifications are done.  These are the user-defined bounds passed to the BVH builder, not the internal bounds around each BVH node.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBVH_refit_mut(MagicPhysX.PxBVH*)">
            <summary>Refit the BVH.  This function \"refits\" the tree, i.e. takes the new (leaf) bounding boxes into account and recomputes all the BVH bounds accordingly. This is an O(n) operation with n = number of bounds in the BVH.  This works best with minor bounds modifications, i.e. when the bounds remain close to their initial values. With large modifications the tree quality degrades more and more, and subsequent query performance suffers. It might be a better strategy to create a brand new BVH if bounds change drastically.  This function refits the whole tree after an arbitrary number of bounds have potentially been modified by users (via getBoundsForModification()). If you only have a small number of bounds to update, it might be more efficient to use setBounds() and partialRefit() instead.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBVH_updateBounds_mut(MagicPhysX.PxBVH*,System.UInt32,MagicPhysX.PxBounds3*)">
            <summary>Update single bounds.  This is an alternative to getBoundsForModification() / refit(). If you only have a small set of bounds to update, it can be inefficient to call the refit() function, because it refits the whole BVH.  Instead, one can update individual bounds with this updateBounds() function. It sets the new bounds and marks the corresponding BVH nodes for partial refit. Once all the individual bounds have been updated, call partialRefit() to only refit the subset of marked nodes.  true if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBVH_partialRefit_mut(MagicPhysX.PxBVH*)">
            <summary>Refits subset of marked nodes.  This is an alternative to the refit() function, to be called after updateBounds() calls. See updateBounds() for details.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBVH_traverse(MagicPhysX.PxBVH*,MagicPhysX.PxBVHTraversalCallback*)">
            <summary>Generic BVH traversal function.  This can be used to implement custom BVH traversal functions if provided ones are not enough. In particular this can be used to visualize the tree's bounds.  false if query has been aborted</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCapsuleGeometry_new(System.Single,System.Single)">
            <summary>Constructor, initializes to a capsule with passed radius and half height.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCapsuleGeometry_isValid(MagicPhysX.PxCapsuleGeometry*)">
            <summary>Returns true if the geometry is valid.  True if the current settings are valid.  A valid capsule has radius &gt; 0, halfHeight &gt;= 0. It is illegal to call PxRigidActor::createShape and PxPhysics::createShape with a capsule that has zero radius or height.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConvexMesh_getNbVertices(MagicPhysX.PxConvexMesh*)">
            <summary>Returns the number of vertices.  Number of vertices.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConvexMesh_getVertices(MagicPhysX.PxConvexMesh*)">
            <summary>Returns the vertices.  Array of vertices.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConvexMesh_getIndexBuffer(MagicPhysX.PxConvexMesh*)">
            <summary>Returns the index buffer.  Index buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConvexMesh_getNbPolygons(MagicPhysX.PxConvexMesh*)">
            <summary>Returns the number of polygons.  Number of polygons.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConvexMesh_getPolygonData(MagicPhysX.PxConvexMesh*,System.UInt32,MagicPhysX.PxHullPolygon*)">
            <summary>Returns the polygon data.  True if success.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConvexMesh_release_mut(MagicPhysX.PxConvexMesh*)">
            <summary>Decrements the reference count of a convex mesh and releases it if the new reference count is zero.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConvexMesh_getMassInformation(MagicPhysX.PxConvexMesh*,System.Single*,MagicPhysX.PxMat33*,MagicPhysX.PxVec3*)">
            <summary>Returns the mass properties of the mesh assuming unit density.  The following relationship holds between mass and volume:  mass = volume * density  The mass of a unit density mesh is equal to its volume, so this function returns the volume of the mesh.  Similarly, to obtain the localInertia of an identically shaped object with a uniform density of d, simply multiply the localInertia of the unit density mesh by d.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConvexMesh_getLocalBounds(MagicPhysX.PxConvexMesh*)">
            <summary>Returns the local-space (vertex space) AABB from the convex mesh.  local-space bounds</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConvexMesh_getSDF(MagicPhysX.PxConvexMesh*)">
            <summary>Returns the local-space Signed Distance Field for this mesh if it has one.  local-space SDF.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConvexMesh_isGpuCompatible(MagicPhysX.PxConvexMesh*)">
            <summary>This method decides whether a convex mesh is gpu compatible. If the total number of vertices are more than 64 or any number of vertices in a polygon is more than 32, or convex hull data was not cooked with GPU data enabled during cooking or was loaded from a serialized collection, the convex hull is incompatible with GPU collision detection. Otherwise it is compatible.  True if the convex hull is gpu compatible</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMeshScale_new">
            <summary>Constructor initializes to identity scale.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMeshScale_new_1(System.Single)">
            <summary>Constructor from scalar.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMeshScale_new_2(MagicPhysX.PxVec3*)">
            <summary>Constructor to initialize to arbitrary scale and identity scale rotation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMeshScale_new_3(MagicPhysX.PxVec3*,MagicPhysX.PxQuat*)">
            <summary>Constructor to initialize to arbitrary scaling.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMeshScale_isIdentity(MagicPhysX.PxMeshScale*)">
            <summary>Returns true if the scaling is an identity transformation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMeshScale_getInverse(MagicPhysX.PxMeshScale*)">
            <summary>Returns the inverse of this scaling transformation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMeshScale_toMat33(MagicPhysX.PxMeshScale*)">
            <summary>Converts this transformation to a 3x3 matrix representation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMeshScale_hasNegativeDeterminant(MagicPhysX.PxMeshScale*)">
            <summary>Returns true if combination of negative scale components will cause the triangle normal to flip. The SDK will flip the normals internally.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConvexMeshGeometry_new(MagicPhysX.PxConvexMesh*,MagicPhysX.PxMeshScale*,MagicPhysX.PxConvexMeshGeometryFlags)">
            <summary>Constructor. By default creates an empty object with a NULL mesh and identity scale.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConvexMeshGeometry_isValid(MagicPhysX.PxConvexMeshGeometry*)">
            <summary>Returns true if the geometry is valid.  True if the current settings are valid for shape creation.  A valid convex mesh has a positive scale value in each direction (scale.x &gt; 0, scale.y &gt; 0, scale.z &gt; 0). It is illegal to call PxRigidActor::createShape and PxPhysics::createShape with a convex that has zero extent in any direction.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSphereGeometry_new(System.Single)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSphereGeometry_isValid(MagicPhysX.PxSphereGeometry*)">
            <summary>Returns true if the geometry is valid.  True if the current settings are valid  A valid sphere has radius &gt; 0. It is illegal to call PxRigidActor::createShape and PxPhysics::createShape with a sphere that has zero radius.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPlaneGeometry_new">
            <summary>Constructor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPlaneGeometry_isValid(MagicPhysX.PxPlaneGeometry*)">
            <summary>Returns true if the geometry is valid.  True if the current settings are valid</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTriangleMeshGeometry_new(MagicPhysX.PxTriangleMesh*,MagicPhysX.PxMeshScale*,MagicPhysX.PxMeshGeometryFlags)">
            <summary>Constructor. By default creates an empty object with a NULL mesh and identity scale.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTriangleMeshGeometry_isValid(MagicPhysX.PxTriangleMeshGeometry*)">
            <summary>Returns true if the geometry is valid.  True if the current settings are valid for shape creation.  A valid triangle mesh has a positive scale value in each direction (scale.scale.x &gt; 0, scale.scale.y &gt; 0, scale.scale.z &gt; 0). It is illegal to call PxRigidActor::createShape and PxPhysics::createShape with a triangle mesh that has zero extents in any direction.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxHeightFieldGeometry_new(MagicPhysX.PxHeightField*,MagicPhysX.PxMeshGeometryFlags,System.Single,System.Single,System.Single)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxHeightFieldGeometry_isValid(MagicPhysX.PxHeightFieldGeometry*)">
            <summary>Returns true if the geometry is valid.  True if the current settings are valid  A valid height field has a positive scale value in each direction (heightScale &gt; 0, rowScale &gt; 0, columnScale &gt; 0). It is illegal to call PxRigidActor::createShape and PxPhysics::createShape with a height field that has zero extents in any direction.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxParticleSystemGeometry_new">
            <summary>Default constructor.  Creates an empty object with no particles.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxParticleSystemGeometry_isValid(MagicPhysX.PxParticleSystemGeometry*)">
            <summary>Returns true if the geometry is valid.  True if the current settings are valid for shape creation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxHairSystemGeometry_new">
            <summary>Default constructor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxHairSystemGeometry_isValid(MagicPhysX.PxHairSystemGeometry*)">
            <summary>Returns true if the geometry is valid.  True if the current settings are valid for shape creation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTetrahedronMeshGeometry_new(MagicPhysX.PxTetrahedronMesh*)">
            <summary>Constructor. By default creates an empty object with a NULL mesh and identity scale.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTetrahedronMeshGeometry_isValid(MagicPhysX.PxTetrahedronMeshGeometry*)">
            <summary>Returns true if the geometry is valid.  True if the current settings are valid for shape creation.  A valid tetrahedron mesh has a positive scale value in each direction (scale.scale.x &gt; 0, scale.scale.y &gt; 0, scale.scale.z &gt; 0). It is illegal to call PxRigidActor::createShape and PxPhysics::createShape with a tetrahedron mesh that has zero extents in any direction.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxLocationHit_hadInitialOverlap(MagicPhysX.PxLocationHit*)">
            <summary>For raycast hits: true for shapes overlapping with raycast origin.  For sweep hits: true for shapes overlapping at zero sweep distance.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCustomGeometry_getUniqueID">
            <summary>For internal use</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCustomGeometryType_new">
            <summary>Default constructor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCustomGeometryType_INVALID">
            <summary>Invalid type</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCustomGeometryCallbacks_getCustomType(MagicPhysX.PxCustomGeometryCallbacks*)">
            <summary>Return custom type. The type purpose is for user to differentiate custom geometries. Not used by PhysX.  Unique ID of a custom geometry type.  User should use DECLARE_CUSTOM_GEOMETRY_TYPE and IMPLEMENT_CUSTOM_GEOMETRY_TYPE intead of overwriting this function.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCustomGeometryCallbacks_getLocalBounds(MagicPhysX.PxCustomGeometryCallbacks*,MagicPhysX.PxGeometry*)">
            <summary>Return local bounds.  Bounding box in the geometry local space.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCustomGeometryCallbacks_raycast(MagicPhysX.PxCustomGeometryCallbacks*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,System.Single,MagicPhysX.PxHitFlags,System.UInt32,MagicPhysX.PxGeomRaycastHit*,System.UInt32,MagicPhysX.PxQueryThreadContext*)">
            <summary>Raycast. Cast a ray against the geometry in given pose.  Number of hits.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCustomGeometryCallbacks_overlap(MagicPhysX.PxCustomGeometryCallbacks*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxQueryThreadContext*)">
            <summary>Overlap. Test if geometries overlap.  True if there is overlap. False otherwise.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCustomGeometryCallbacks_sweep(MagicPhysX.PxCustomGeometryCallbacks*,MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxGeomSweepHit*,MagicPhysX.PxHitFlags,System.Single,MagicPhysX.PxQueryThreadContext*)">
            <summary>Sweep. Sweep one geometry against the other.  True if there is hit. False otherwise.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCustomGeometryCallbacks_computeMassProperties(MagicPhysX.PxCustomGeometryCallbacks*,MagicPhysX.PxGeometry*,MagicPhysX.PxMassProperties*)">
            <summary>Compute custom geometry mass properties. For geometries usable with dynamic rigidbodies.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCustomGeometryCallbacks_usePersistentContactManifold(MagicPhysX.PxCustomGeometryCallbacks*,MagicPhysX.PxGeometry*,System.Single*)">
            <summary>Compatible with PhysX's PCM feature. Allows to optimize contact generation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCustomGeometry_new">
            <summary>Default constructor.  Creates an empty object with a NULL callbacks pointer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCustomGeometry_new_1(MagicPhysX.PxCustomGeometryCallbacks*)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCustomGeometry_isValid(MagicPhysX.PxCustomGeometry*)">
            <summary>Returns true if the geometry is valid.  True if the current settings are valid for shape creation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCustomGeometry_getCustomType(MagicPhysX.PxCustomGeometry*)">
            <summary>Returns the custom type of the custom geometry.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxGeometryQuery_raycast(MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,System.Single,MagicPhysX.PxHitFlags,System.UInt32,MagicPhysX.PxGeomRaycastHit*,System.UInt32,MagicPhysX.PxGeometryQueryFlags,MagicPhysX.PxQueryThreadContext*)">
            <summary>Raycast test against a geometry object.  All geometry types are supported except PxParticleSystemGeometry, PxTetrahedronMeshGeometry and PxHairSystemGeometry.  Number of hits between the ray and the geometry object</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxGeometryQuery_overlap(MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxGeometryQueryFlags,MagicPhysX.PxQueryThreadContext*)">
            <summary>Overlap test for two geometry objects.  All combinations are supported except:  PxPlaneGeometry vs. {PxPlaneGeometry, PxTriangleMeshGeometry, PxHeightFieldGeometry}  PxTriangleMeshGeometry vs. PxHeightFieldGeometry  PxHeightFieldGeometry vs. PxHeightFieldGeometry  Anything involving PxParticleSystemGeometry, PxTetrahedronMeshGeometry or PxHairSystemGeometry.  True if the two geometry objects overlap</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxGeometryQuery_sweep(MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxGeomSweepHit*,MagicPhysX.PxHitFlags,System.Single,MagicPhysX.PxGeometryQueryFlags,MagicPhysX.PxQueryThreadContext*)">
            <summary>Sweep a specified geometry object in space and test for collision with a given object.  The following combinations are supported.  PxSphereGeometry vs. {PxSphereGeometry, PxPlaneGeometry, PxCapsuleGeometry, PxBoxGeometry, PxConvexMeshGeometry, PxTriangleMeshGeometry, PxHeightFieldGeometry}  PxCapsuleGeometry vs. {PxSphereGeometry, PxPlaneGeometry, PxCapsuleGeometry, PxBoxGeometry, PxConvexMeshGeometry, PxTriangleMeshGeometry, PxHeightFieldGeometry}  PxBoxGeometry vs. {PxSphereGeometry, PxPlaneGeometry, PxCapsuleGeometry, PxBoxGeometry, PxConvexMeshGeometry, PxTriangleMeshGeometry, PxHeightFieldGeometry}  PxConvexMeshGeometry vs. {PxSphereGeometry, PxPlaneGeometry, PxCapsuleGeometry, PxBoxGeometry, PxConvexMeshGeometry, PxTriangleMeshGeometry, PxHeightFieldGeometry}  True if the swept geometry object geom0 hits the object geom1</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxGeometryQuery_computePenetration(MagicPhysX.PxVec3*,System.Single*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxGeometryQueryFlags)">
            <summary>Compute minimum translational distance (MTD) between two geometry objects.  All combinations of geom objects are supported except: - plane/plane - plane/mesh - plane/heightfield - mesh/mesh - mesh/heightfield - heightfield/heightfield - anything involving PxParticleSystemGeometry, PxTetrahedronMeshGeometry or PxHairSystemGeometry  The function returns a unit vector ('direction') and a penetration depth ('depth').  The depenetration vector D = direction * depth should be applied to the first object, to get out of the second object.  Returned depth should always be positive or null.  If objects do not overlap, the function can not compute the MTD and returns false.  True if the MTD has successfully been computed, i.e. if objects do overlap.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxGeometryQuery_pointDistance(MagicPhysX.PxVec3*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxVec3*,System.UInt32*,MagicPhysX.PxGeometryQueryFlags)">
            <summary>Computes distance between a point and a geometry object.  Currently supported geometry objects: box, sphere, capsule, convex, mesh.  For meshes, only the BVH34 midphase data-structure is supported.  Square distance between the point and the geom object, or 0.0 if the point is inside the object, or -1.0 if an error occured (geometry type is not supported, or invalid pose)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxGeometryQuery_computeGeomBounds(MagicPhysX.PxBounds3*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,System.Single,System.Single,MagicPhysX.PxGeometryQueryFlags)">
            <summary>computes the bounds for a geometry object</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxGeometryQuery_isValid(MagicPhysX.PxGeometry*)">
            <summary>Checks if provided geometry is valid.  True if geometry is valid.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxHeightField_release_mut(MagicPhysX.PxHeightField*)">
            <summary>Decrements the reference count of a height field and releases it if the new reference count is zero.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxHeightField_saveCells(MagicPhysX.PxHeightField*,System.Void*,System.UInt32)">
            <summary>Writes out the sample data array.  The user provides destBufferSize bytes storage at destBuffer. The data is formatted and arranged as PxHeightFieldDesc.samples.  The number of bytes written.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxHeightField_modifySamples_mut(MagicPhysX.PxHeightField*,System.Int32,System.Int32,MagicPhysX.PxHeightFieldDesc*,System.Boolean)">
            <summary>Replaces a rectangular subfield in the sample data array.  The user provides the description of a rectangular subfield in subfieldDesc. The data is formatted and arranged as PxHeightFieldDesc.samples.  True on success, false on failure. Failure can occur due to format mismatch.  Modified samples are constrained to the same height quantization range as the original heightfield. Source samples that are out of range of target heightfield will be clipped with no error. PhysX does not keep a mapping from the heightfield to heightfield shapes that reference it. Call PxShape::setGeometry on each shape which references the height field, to ensure that internal data structures are updated to reflect the new geometry. Please note that PxShape::setGeometry does not guarantee correct/continuous behavior when objects are resting on top of old or new geometry.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxHeightField_getNbRows(MagicPhysX.PxHeightField*)">
            <summary>Retrieves the number of sample rows in the samples array.  The number of sample rows in the samples array.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxHeightField_getNbColumns(MagicPhysX.PxHeightField*)">
            <summary>Retrieves the number of sample columns in the samples array.  The number of sample columns in the samples array.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxHeightField_getFormat(MagicPhysX.PxHeightField*)">
            <summary>Retrieves the format of the sample data.  The format of the sample data.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxHeightField_getSampleStride(MagicPhysX.PxHeightField*)">
            <summary>Retrieves the offset in bytes between consecutive samples in the array.  The offset in bytes between consecutive samples in the array.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxHeightField_getConvexEdgeThreshold(MagicPhysX.PxHeightField*)">
            <summary>Retrieves the convex edge threshold.  The convex edge threshold.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxHeightField_getFlags(MagicPhysX.PxHeightField*)">
            <summary>Retrieves the flags bits, combined from values of the enum ::PxHeightFieldFlag.  The flags bits, combined from values of the enum ::PxHeightFieldFlag.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxHeightField_getHeight(MagicPhysX.PxHeightField*,System.Single,System.Single)">
            <summary>Retrieves the height at the given coordinates in grid space.  The height at the given coordinates or 0 if the coordinates are out of range.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxHeightField_getTriangleMaterialIndex(MagicPhysX.PxHeightField*,System.UInt32)">
            <summary>Returns material table index of given triangle  This function takes a post cooking triangle index.  Material table index, or 0xffff if no per-triangle materials are used</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxHeightField_getTriangleNormal(MagicPhysX.PxHeightField*,System.UInt32)">
            <summary>Returns a triangle face normal for a given triangle index  This function takes a post cooking triangle index.  Triangle normal for a given triangle index</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxHeightField_getSample(MagicPhysX.PxHeightField*,System.UInt32,System.UInt32)">
            <summary>Returns heightfield sample of given row and column  Heightfield sample</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxHeightField_getTimestamp(MagicPhysX.PxHeightField*)">
            <summary>Returns the number of times the heightfield data has been modified  This method returns the number of times modifySamples has been called on this heightfield, so that code that has retained state that depends on the heightfield can efficiently determine whether it has been modified.  the number of times the heightfield sample data has been modified.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxHeightFieldDesc_new">
            <summary>Constructor sets to default.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxHeightFieldDesc_setToDefault_mut(MagicPhysX.PxHeightFieldDesc*)">
            <summary>(re)sets the structure to the default.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxHeightFieldDesc_isValid(MagicPhysX.PxHeightFieldDesc*)">
            <summary>Returns true if the descriptor is valid.  True if the current settings are valid.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMeshQuery_getTriangle(MagicPhysX.PxTriangleMeshGeometry*,MagicPhysX.PxTransform*,System.UInt32,MagicPhysX.PxTriangle*,System.UInt32*,System.UInt32*)">
            <summary>Retrieves triangle data from a triangle ID.  This function can be used together with [`findOverlapTriangleMesh`]() to retrieve triangle properties.  This function will flip the triangle normal whenever triGeom.scale.hasNegativeDeterminant() is true.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMeshQuery_getTriangle_1(MagicPhysX.PxHeightFieldGeometry*,MagicPhysX.PxTransform*,System.UInt32,MagicPhysX.PxTriangle*,System.UInt32*,System.UInt32*)">
            <summary>Retrieves triangle data from a triangle ID.  This function can be used together with [`findOverlapHeightField`]() to retrieve triangle properties.  This function will flip the triangle normal whenever triGeom.scale.hasNegativeDeterminant() is true.  TriangleIndex is an index used in internal format, which does have an index out of the bounds in last row. To traverse all tri indices in the HF, the following code can be applied: for (PxU32 row = 0; row &lt; (nbRows - 1); row++) { for (PxU32 col = 0; col &lt; (nbCols - 1); col++) { for (PxU32 k = 0; k &lt; 2; k++) { const PxU32 triIndex = 2 * (row*nbCols + col) + k; .... } } }</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMeshQuery_findOverlapTriangleMesh(MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxTriangleMeshGeometry*,MagicPhysX.PxTransform*,System.UInt32*,System.UInt32,System.UInt32,System.Boolean*,MagicPhysX.PxGeometryQueryFlags)">
            <summary>Find the mesh triangles which touch the specified geometry object.  For mesh-vs-mesh overlap tests, please use the specialized function below.  Returned triangle indices can be used with [`getTriangle`]() to retrieve the triangle properties.  Number of overlaps found, i.e. number of elements written to the results buffer</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMeshQuery_findOverlapHeightField(MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxHeightFieldGeometry*,MagicPhysX.PxTransform*,System.UInt32*,System.UInt32,System.UInt32,System.Boolean*,MagicPhysX.PxGeometryQueryFlags)">
            <summary>Find the height field triangles which touch the specified geometry object.  Returned triangle indices can be used with [`getTriangle`]() to retrieve the triangle properties.  Number of overlaps found, i.e. number of elements written to the results buffer</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMeshQuery_sweep(MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,System.UInt32,MagicPhysX.PxTriangle*,MagicPhysX.PxGeomSweepHit*,MagicPhysX.PxHitFlags,System.UInt32*,System.Single,System.Boolean,MagicPhysX.PxGeometryQueryFlags)">
            <summary>Sweep a specified geometry object in space and test for collision with a set of given triangles.  This function simply sweeps input geometry against each input triangle, in the order they are given. This is an O(N) operation with N = number of input triangles. It does not use any particular acceleration structure.  True if the swept geometry object hits the specified triangles  Only the following geometry types are currently supported: PxSphereGeometry, PxCapsuleGeometry, PxBoxGeometry  If a shape from the scene is already overlapping with the query shape in its starting position, the hit is returned unless eASSUME_NO_INITIAL_OVERLAP was specified.  This function returns a single closest hit across all the input triangles. Multiple hits are not supported.  Supported hitFlags are PxHitFlag::eDEFAULT, PxHitFlag::eASSUME_NO_INITIAL_OVERLAP, PxHitFlag::ePRECISE_SWEEP, PxHitFlag::eMESH_BOTH_SIDES, PxHitFlag::eMESH_ANY.  ePOSITION is only defined when there is no initial overlap (sweepHit.hadInitialOverlap() == false)  The returned normal for initially overlapping sweeps is set to -unitDir.  Otherwise the returned normal is the front normal of the triangle even if PxHitFlag::eMESH_BOTH_SIDES is set.  The returned PxGeomSweepHit::faceIndex parameter will hold the index of the hit triangle in input array, i.e. the range is [0; triangleCount). For initially overlapping sweeps, this is the index of overlapping triangle.  The inflation parameter is not compatible with PxHitFlag::ePRECISE_SWEEP.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSimpleTriangleMesh_new">
            <summary>constructor sets to default.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSimpleTriangleMesh_setToDefault_mut(MagicPhysX.PxSimpleTriangleMesh*)">
            <summary>(re)sets the structure to the default.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSimpleTriangleMesh_isValid(MagicPhysX.PxSimpleTriangleMesh*)">
            <summary>returns true if the current settings are valid</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTriangle_new_alloc">
            <summary>Constructor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTriangle_new_alloc_1(MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>Constructor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTriangle_delete(MagicPhysX.PxTriangle*)">
            <summary>Destructor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTriangle_normal(MagicPhysX.PxTriangle*,MagicPhysX.PxVec3*)">
            <summary>Compute the normal of the Triangle.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTriangle_denormalizedNormal(MagicPhysX.PxTriangle*,MagicPhysX.PxVec3*)">
            <summary>Compute the unnormalized normal of the triangle.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTriangle_area(MagicPhysX.PxTriangle*)">
            <summary>Compute the area of the triangle.  Area of the triangle.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTriangle_pointFromUV(MagicPhysX.PxTriangle*,System.Single,System.Single)">
            <summary>Computes a point on the triangle from u and v barycentric coordinates.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTriangleMesh_getNbVertices(MagicPhysX.PxTriangleMesh*)">
            <summary>Returns the number of vertices.  number of vertices</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTriangleMesh_getVertices(MagicPhysX.PxTriangleMesh*)">
            <summary>Returns the vertices.  array of vertices</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTriangleMesh_getVerticesForModification_mut(MagicPhysX.PxTriangleMesh*)">
            <summary>Returns all mesh vertices for modification.  This function will return the vertices of the mesh so that their positions can be changed in place. After modifying the vertices you must call refitBVH for the refitting to actually take place. This function maintains the old mesh topology (triangle indices).  inplace vertex coordinates for each existing mesh vertex.  It is recommended to use this feature for scene queries only.  Size of array returned is equal to the number returned by getNbVertices().  This function operates on cooked vertex indices.  This means the index mapping and vertex count can be different from what was provided as an input to the cooking routine.  To achieve unchanged 1-to-1 index mapping with orignal mesh data (before cooking) please use the following cooking flags:  eWELD_VERTICES = 0, eDISABLE_CLEAN_MESH = 1.  It is also recommended to make sure that a call to validateTriangleMesh returns true if mesh cleaning is disabled.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTriangleMesh_refitBVH_mut(MagicPhysX.PxTriangleMesh*)">
            <summary>Refits BVH for mesh vertices.  This function will refit the mesh BVH to correctly enclose the new positions updated by getVerticesForModification. Mesh BVH will not be reoptimized by this function so significantly different new positions will cause significantly reduced performance.  New bounds for the entire mesh.  For PxMeshMidPhase::eBVH34 trees the refit operation is only available on non-quantized trees (see PxBVH34MidphaseDesc::quantized)  PhysX does not keep a mapping from the mesh to mesh shapes that reference it.  Call PxShape::setGeometry on each shape which references the mesh, to ensure that internal data structures are updated to reflect the new geometry.  PxShape::setGeometry does not guarantee correct/continuous behavior when objects are resting on top of old or new geometry.  It is also recommended to make sure that a call to validateTriangleMesh returns true if mesh cleaning is disabled.  Active edges information will be lost during refit, the rigid body mesh contact generation might not perform as expected.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTriangleMesh_getNbTriangles(MagicPhysX.PxTriangleMesh*)">
            <summary>Returns the number of triangles.  number of triangles</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTriangleMesh_getTriangles(MagicPhysX.PxTriangleMesh*)">
            <summary>Returns the triangle indices.  The indices can be 16 or 32bit depending on the number of triangles in the mesh. Call getTriangleMeshFlags() to know if the indices are 16 or 32 bits.  The number of indices is the number of triangles * 3.  array of triangles</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTriangleMesh_getTriangleMeshFlags(MagicPhysX.PxTriangleMesh*)">
            <summary>Reads the PxTriangleMesh flags.  See the list of flags [`PxTriangleMeshFlag`]  The values of the PxTriangleMesh flags.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTriangleMesh_getTrianglesRemap(MagicPhysX.PxTriangleMesh*)">
            <summary>Returns the triangle remapping table.  The triangles are internally sorted according to various criteria. Hence the internal triangle order does not always match the original (user-defined) order. The remapping table helps finding the old indices knowing the new ones:  remapTable[ internalTriangleIndex ] = originalTriangleIndex  the remapping table (or NULL if 'PxCookingParams::suppressTriangleMeshRemapTable' has been used)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTriangleMesh_release_mut(MagicPhysX.PxTriangleMesh*)">
            <summary>Decrements the reference count of a triangle mesh and releases it if the new reference count is zero.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTriangleMesh_getTriangleMaterialIndex(MagicPhysX.PxTriangleMesh*,System.UInt32)">
            <summary>Returns material table index of given triangle  This function takes a post cooking triangle index.  Material table index, or 0xffff if no per-triangle materials are used</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTriangleMesh_getLocalBounds(MagicPhysX.PxTriangleMesh*)">
            <summary>Returns the local-space (vertex space) AABB from the triangle mesh.  local-space bounds</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTriangleMesh_getSDF(MagicPhysX.PxTriangleMesh*)">
            <summary>Returns the local-space Signed Distance Field for this mesh if it has one.  local-space SDF.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTriangleMesh_getSDFDimensions(MagicPhysX.PxTriangleMesh*,System.UInt32*,System.UInt32*,System.UInt32*)">
            <summary>Returns the resolution of the local-space dense SDF.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTriangleMesh_setPreferSDFProjection_mut(MagicPhysX.PxTriangleMesh*,System.Boolean)">
            <summary>Sets whether this mesh should be preferred for SDF projection.  By default, meshes are flagged as preferring projection and the decisions on which mesh to project is based on the triangle and vertex count. The model with the fewer triangles is projected onto the SDF of the more detailed mesh. If one of the meshes is set to prefer SDF projection (default) and the other is set to not prefer SDF projection, model flagged as preferring SDF projection will be projected onto the model flagged as not preferring, regardless of the detail of the respective meshes. Where both models are flagged as preferring no projection, the less detailed model will be projected as before.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTriangleMesh_getPreferSDFProjection(MagicPhysX.PxTriangleMesh*)">
            <summary>Returns whether this mesh prefers SDF projection.  whether this mesh prefers SDF projection.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTriangleMesh_getMassInformation(MagicPhysX.PxTriangleMesh*,System.Single*,MagicPhysX.PxMat33*,MagicPhysX.PxVec3*)">
            <summary>Returns the mass properties of the mesh assuming unit density.  The following relationship holds between mass and volume:  mass = volume * density  The mass of a unit density mesh is equal to its volume, so this function returns the volume of the mesh.  Similarly, to obtain the localInertia of an identically shaped object with a uniform density of d, simply multiply the localInertia of the unit density mesh by d.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTetrahedron_new_alloc">
            <summary>Constructor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTetrahedron_new_alloc_1(MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>Constructor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTetrahedron_delete(MagicPhysX.PxTetrahedron*)">
            <summary>Destructor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSoftBodyAuxData_release_mut(MagicPhysX.PxSoftBodyAuxData*)">
            <summary>Decrements the reference count of a tetrahedron mesh and releases it if the new reference count is zero.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTetrahedronMesh_getNbVertices(MagicPhysX.PxTetrahedronMesh*)">
            <summary>Returns the number of vertices.  number of vertices</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTetrahedronMesh_getVertices(MagicPhysX.PxTetrahedronMesh*)">
            <summary>Returns the vertices  array of vertices</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTetrahedronMesh_getNbTetrahedrons(MagicPhysX.PxTetrahedronMesh*)">
            <summary>Returns the number of tetrahedrons.  number of tetrahedrons</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTetrahedronMesh_getTetrahedrons(MagicPhysX.PxTetrahedronMesh*)">
            <summary>Returns the tetrahedron indices.  The indices can be 16 or 32bit depending on the number of tetrahedrons in the mesh. Call getTetrahedronMeshFlags() to know if the indices are 16 or 32 bits.  The number of indices is the number of tetrahedrons * 4.  array of tetrahedrons</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTetrahedronMesh_getTetrahedronMeshFlags(MagicPhysX.PxTetrahedronMesh*)">
            <summary>Reads the PxTetrahedronMesh flags.  See the list of flags [`PxTetrahedronMeshFlags`]  The values of the PxTetrahedronMesh flags.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTetrahedronMesh_getTetrahedraRemap(MagicPhysX.PxTetrahedronMesh*)">
            <summary>Returns the tetrahedra remapping table.  The tetrahedra are internally sorted according to various criteria. Hence the internal tetrahedron order does not always match the original (user-defined) order. The remapping table helps finding the old indices knowing the new ones:  remapTable[ internalTetrahedronIndex ] = originalTetrahedronIndex  the remapping table (or NULL if 'PxCookingParams::suppressTriangleMeshRemapTable' has been used)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTetrahedronMesh_getLocalBounds(MagicPhysX.PxTetrahedronMesh*)">
            <summary>Returns the local-space (vertex space) AABB from the tetrahedron mesh.  local-space bounds</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTetrahedronMesh_release_mut(MagicPhysX.PxTetrahedronMesh*)">
            <summary>Decrements the reference count of a tetrahedron mesh and releases it if the new reference count is zero.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSoftBodyMesh_getCollisionMesh(MagicPhysX.PxSoftBodyMesh*)">
            <summary>Const accecssor to the softbody's collision mesh.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSoftBodyMesh_getCollisionMesh_mut(MagicPhysX.PxSoftBodyMesh*)">
            <summary>Accecssor to the softbody's collision mesh.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSoftBodyMesh_getSimulationMesh(MagicPhysX.PxSoftBodyMesh*)">
            <summary>Const accessor to the softbody's simulation mesh.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSoftBodyMesh_getSimulationMesh_mut(MagicPhysX.PxSoftBodyMesh*)">
            <summary>Accecssor to the softbody's simulation mesh.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSoftBodyMesh_getSoftBodyAuxData(MagicPhysX.PxSoftBodyMesh*)">
            <summary>Const accessor to the softbodies simulation state.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSoftBodyMesh_getSoftBodyAuxData_mut(MagicPhysX.PxSoftBodyMesh*)">
            <summary>Accessor to the softbody's auxilary data like mass and rest pose information</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSoftBodyMesh_release_mut(MagicPhysX.PxSoftBodyMesh*)">
            <summary>Decrements the reference count of a tetrahedron mesh and releases it if the new reference count is zero.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxActor_release_mut(MagicPhysX.PxActor*)">
            <summary>Deletes the actor.  Do not keep a reference to the deleted instance.  If the actor belongs to a [`PxAggregate`] object, it is automatically removed from the aggregate.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxActor_getType(MagicPhysX.PxActor*)">
            <summary>Retrieves the type of actor.  The actor type of the actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxActor_getScene(MagicPhysX.PxActor*)">
            <summary>Retrieves the scene which this actor belongs to.  Owner Scene. NULL if not part of a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxActor_setName_mut(MagicPhysX.PxActor*,System.Byte*)">
            <summary>Sets a name string for the object that can be retrieved with getName().  This is for debugging and is not used by the SDK. The string is not copied by the SDK, only the pointer is stored.  Default: NULL</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxActor_getName(MagicPhysX.PxActor*)">
            <summary>Retrieves the name string set with setName().  Name string associated with object.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxActor_getWorldBounds(MagicPhysX.PxActor*,System.Single)">
            <summary>Retrieves the axis aligned bounding box enclosing the actor.  It is not allowed to use this method while the simulation is running (except during PxScene::collide(), in PxContactModifyCallback or in contact report callbacks).  The actor's bounding box.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxActor_setActorFlag_mut(MagicPhysX.PxActor*,MagicPhysX.PxActorFlag,System.Boolean)">
            <summary>Raises or clears a particular actor flag.  See the list of flags [`PxActorFlag`]  Sleeping: Does NOT wake the actor up automatically.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxActor_setActorFlags_mut(MagicPhysX.PxActor*,MagicPhysX.PxActorFlags)">
            <summary>Sets the actor flags.  See the list of flags [`PxActorFlag`]</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxActor_getActorFlags(MagicPhysX.PxActor*)">
            <summary>Reads the PxActor flags.  See the list of flags [`PxActorFlag`]  The values of the PxActor flags.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxActor_setDominanceGroup_mut(MagicPhysX.PxActor*,System.Byte)">
            <summary>Assigns dynamic actors a dominance group identifier.  PxDominanceGroup is a 5 bit group identifier (legal range from 0 to 31).  The PxScene::setDominanceGroupPair() lets you set certain behaviors for pairs of dominance groups. By default every dynamic actor is created in group 0.  Default: 0  Sleeping: Changing the dominance group does NOT wake the actor up automatically.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxActor_getDominanceGroup(MagicPhysX.PxActor*)">
            <summary>Retrieves the value set with setDominanceGroup().  The dominance group of this actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxActor_setOwnerClient_mut(MagicPhysX.PxActor*,System.Byte)">
            <summary>Sets the owner client of an actor.  This cannot be done once the actor has been placed into a scene.  Default: PX_DEFAULT_CLIENT</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxActor_getOwnerClient(MagicPhysX.PxActor*)">
            <summary>Returns the owner client that was specified at creation time.  This value cannot be changed once the object is placed into the scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxActor_getAggregate(MagicPhysX.PxActor*)">
            <summary>Retrieves the aggregate the actor might be a part of.  The aggregate the actor is a part of, or NULL if the actor does not belong to an aggregate.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxAggregate_release_mut(MagicPhysX.PxAggregate*)">
            <summary>Deletes the aggregate object.  Deleting the PxAggregate object does not delete the aggregated actors. If the PxAggregate object belongs to a scene, the aggregated actors are automatically re-inserted in that scene. If you intend to delete both the PxAggregate and its actors, it is best to release the actors first, then release the PxAggregate when it is empty.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxAggregate_addActor_mut(MagicPhysX.PxAggregate*,MagicPhysX.PxActor*,MagicPhysX.PxBVH*)">
            <summary>Adds an actor to the aggregate object.  A warning is output if the total number of actors is reached, or if the incoming actor already belongs to an aggregate.  If the aggregate belongs to a scene, adding an actor to the aggregate also adds the actor to that scene.  If the actor already belongs to a scene, a warning is output and the call is ignored. You need to remove the actor from the scene first, before adding it to the aggregate.  When a BVH is provided the actor shapes are grouped together. The scene query pruning structure inside PhysX SDK will store/update one bound per actor. The scene queries against such an actor will query actor bounds and then make a local space query against the provided BVH, which is in actor's local space.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxAggregate_removeActor_mut(MagicPhysX.PxAggregate*,MagicPhysX.PxActor*)">
            <summary>Removes an actor from the aggregate object.  A warning is output if the incoming actor does not belong to the aggregate. Otherwise the actor is removed from the aggregate. If the aggregate belongs to a scene, the actor is reinserted in that scene. If you intend to delete the actor, it is best to call [`PxActor::release`]() directly. That way the actor will be automatically removed from its aggregate (if any) and not reinserted in a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxAggregate_addArticulation_mut(MagicPhysX.PxAggregate*,MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Adds an articulation to the aggregate object.  A warning is output if the total number of actors is reached (every articulation link counts as an actor), or if the incoming articulation already belongs to an aggregate.  If the aggregate belongs to a scene, adding an articulation to the aggregate also adds the articulation to that scene.  If the articulation already belongs to a scene, a warning is output and the call is ignored. You need to remove the articulation from the scene first, before adding it to the aggregate.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxAggregate_removeArticulation_mut(MagicPhysX.PxAggregate*,MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Removes an articulation from the aggregate object.  A warning is output if the incoming articulation does not belong to the aggregate. Otherwise the articulation is removed from the aggregate. If the aggregate belongs to a scene, the articulation is reinserted in that scene. If you intend to delete the articulation, it is best to call [`PxArticulationReducedCoordinate::release`]() directly. That way the articulation will be automatically removed from its aggregate (if any) and not reinserted in a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxAggregate_getNbActors(MagicPhysX.PxAggregate*)">
            <summary>Returns the number of actors contained in the aggregate.  You can use [`getActors`]() to retrieve the actor pointers.  Number of actors contained in the aggregate.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxAggregate_getMaxNbShapes(MagicPhysX.PxAggregate*)">
            <summary>Retrieves max amount of shapes that can be contained in the aggregate.  Max shape size.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxAggregate_getActors(MagicPhysX.PxAggregate*,MagicPhysX.PxActor**,System.UInt32,System.UInt32)">
            <summary>Retrieve all actors contained in the aggregate.  You can retrieve the number of actor pointers by calling [`getNbActors`]()  Number of actor pointers written to the buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxAggregate_getScene_mut(MagicPhysX.PxAggregate*)">
            <summary>Retrieves the scene which this aggregate belongs to.  Owner Scene. NULL if not part of a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxAggregate_getSelfCollision(MagicPhysX.PxAggregate*)">
            <summary>Retrieves aggregate's self-collision flag.  self-collision flag</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConstraintVisualizer_visualizeJointFrames_mut(MagicPhysX.PxConstraintVisualizer*,MagicPhysX.PxTransform*,MagicPhysX.PxTransform*)">
            <summary>Visualize joint frames</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConstraintVisualizer_visualizeLinearLimit_mut(MagicPhysX.PxConstraintVisualizer*,MagicPhysX.PxTransform*,MagicPhysX.PxTransform*,System.Single,System.Boolean)">
            <summary>Visualize joint linear limit</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConstraintVisualizer_visualizeAngularLimit_mut(MagicPhysX.PxConstraintVisualizer*,MagicPhysX.PxTransform*,System.Single,System.Single,System.Boolean)">
            <summary>Visualize joint angular limit</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConstraintVisualizer_visualizeLimitCone_mut(MagicPhysX.PxConstraintVisualizer*,MagicPhysX.PxTransform*,System.Single,System.Single,System.Boolean)">
            <summary>Visualize limit cone</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConstraintVisualizer_visualizeDoubleCone_mut(MagicPhysX.PxConstraintVisualizer*,MagicPhysX.PxTransform*,System.Single,System.Boolean)">
            <summary>Visualize joint double cone</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConstraintVisualizer_visualizeLine_mut(MagicPhysX.PxConstraintVisualizer*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,System.UInt32)">
            <summary>Visualize line</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConstraintConnector_prepareData_mut(MagicPhysX.PxConstraintConnector*)">
            <summary>Pre-simulation data preparation when the constraint is marked dirty, this function is called at the start of the simulation step for the SDK to copy the constraint data block.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConstraintConnector_onConstraintRelease_mut(MagicPhysX.PxConstraintConnector*)">
            <summary>Constraint release callback  When the SDK deletes a PxConstraint object this function is called by the SDK. In general custom constraints should not be deleted directly by applications: rather, the constraint should respond to a release() request by calling PxConstraint::release(), then wait for this call to release its own resources.  This function is also called when a PxConstraint object is deleted on cleanup due to destruction of the PxPhysics object.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConstraintConnector_onComShift_mut(MagicPhysX.PxConstraintConnector*,System.UInt32)">
            <summary>Center-of-mass shift callback  This function is called by the SDK when the CoM of one of the actors is moved. Since the API specifies constraint positions relative to actors, and the constraint shader functions are supplied with coordinates relative to bodies, some synchronization is usually required when the application moves an object's center of mass.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConstraintConnector_onOriginShift_mut(MagicPhysX.PxConstraintConnector*,MagicPhysX.PxVec3*)">
            <summary>Origin shift callback  This function is called by the SDK when the scene origin gets shifted and allows to adjust custom data which contains world space transforms.  If the adjustments affect constraint shader data, it is necessary to call PxConstraint::markDirty() to make sure that the data gets synced at the beginning of the next simulation step.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConstraintConnector_getSerializable_mut(MagicPhysX.PxConstraintConnector*)">
            <summary>Obtain a reference to a PxBase interface if the constraint has one.  If the constraint does not implement the PxBase interface, it should return NULL.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConstraintConnector_getConstantBlock(MagicPhysX.PxConstraintConnector*)">
            <summary>Obtain the pointer to the constraint's constant data</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConstraintConnector_connectToConstraint_mut(MagicPhysX.PxConstraintConnector*,MagicPhysX.PxConstraint*)">
            <summary>Let the connector know it has been connected to a constraint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConstraintConnector_delete(MagicPhysX.PxConstraintConnector*)">
            <summary>virtual destructor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConstraintAllocator_reserveConstraintData_mut(MagicPhysX.PxConstraintAllocator*,System.UInt32)">
            <summary>Allocates constraint data. It is the application's responsibility to release this memory after PxSolveConstraints has completed.  The allocated memory. This address must be 16-byte aligned.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConstraintAllocator_reserveFrictionData_mut(MagicPhysX.PxConstraintAllocator*,System.UInt32)">
            <summary>Allocates friction data. Friction data can be retained by the application for a given pair and provided as an input to PxSolverContactDesc to improve simulation stability. It is the application's responsibility to release this memory. If this memory is released, the application should ensure it does not pass pointers to this memory to PxSolverContactDesc.  The allocated memory. This address must be 4-byte aligned.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationAttachment_setRestLength_mut(MagicPhysX.PxArticulationAttachment*,System.Single)">
            <summary>Sets the spring rest length for the sub-tendon from the root to this leaf attachment.  Setting this on non-leaf attachments has no effect.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationAttachment_getRestLength(MagicPhysX.PxArticulationAttachment*)">
            <summary>Gets the spring rest length for the sub-tendon from the root to this leaf attachment.  The rest length.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationAttachment_setLimitParameters_mut(MagicPhysX.PxArticulationAttachment*,MagicPhysX.PxArticulationTendonLimit*)">
            <summary>Sets the low and high limit on the length of the sub-tendon from the root to this leaf attachment.  Setting this on non-leaf attachments has no effect.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationAttachment_getLimitParameters(MagicPhysX.PxArticulationAttachment*)">
            <summary>Gets the low and high limit on the length of the sub-tendon from the root to this leaf attachment.  Struct with the low and high limit.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationAttachment_setRelativeOffset_mut(MagicPhysX.PxArticulationAttachment*,MagicPhysX.PxVec3*)">
            <summary>Sets the attachment's relative offset in the link actor frame.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationAttachment_getRelativeOffset(MagicPhysX.PxArticulationAttachment*)">
            <summary>Gets the attachment's relative offset in the link actor frame.  The relative offset in the link actor frame.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationAttachment_setCoefficient_mut(MagicPhysX.PxArticulationAttachment*,System.Single)">
            <summary>Sets the attachment coefficient.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationAttachment_getCoefficient(MagicPhysX.PxArticulationAttachment*)">
            <summary>Gets the attachment coefficient.  The scale that the distance between this attachment and its parent is multiplied by when summing up the spatial tendon's length.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationAttachment_getLink(MagicPhysX.PxArticulationAttachment*)">
            <summary>Gets the articulation link.  The articulation link that this attachment is attached to.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationAttachment_getParent(MagicPhysX.PxArticulationAttachment*)">
            <summary>Gets the parent attachment.  The parent attachment.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationAttachment_isLeaf(MagicPhysX.PxArticulationAttachment*)">
            <summary>Indicates that this attachment is a leaf, and thus defines a sub-tendon from the root to this attachment.  True: This attachment is a leaf and has zero children; False: Not a leaf.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationAttachment_getTendon(MagicPhysX.PxArticulationAttachment*)">
            <summary>Gets the spatial tendon that the attachment is a part of.  The tendon.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationAttachment_release_mut(MagicPhysX.PxArticulationAttachment*)">
            <summary>Releases the attachment.  Releasing the attachment is not allowed while the articulation is in a scene. In order to release the attachment, remove and then re-add the articulation to the scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationAttachment_getConcreteTypeName(MagicPhysX.PxArticulationAttachment*)">
            <summary>Returns the string name of the dynamic type.  The string name.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationTendonJoint_setCoefficient_mut(MagicPhysX.PxArticulationTendonJoint*,MagicPhysX.PxArticulationAxis,System.Single,System.Single)">
            <summary>Sets the tendon joint coefficient.  RecipCoefficient is commonly expected to be 1/coefficient, but it can be set to different values to tune behavior; for example, zero can be used to have a joint axis only participate in the length computation of the tendon, but not have any tendon force applied to it.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationTendonJoint_getCoefficient(MagicPhysX.PxArticulationTendonJoint*,MagicPhysX.PxArticulationAxis*,System.Single*,System.Single*)">
            <summary>Gets the tendon joint coefficient.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationTendonJoint_getLink(MagicPhysX.PxArticulationTendonJoint*)">
            <summary>Gets the articulation link.  The articulation link (and its incoming joint in particular) that this tendon joint is associated with.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationTendonJoint_getParent(MagicPhysX.PxArticulationTendonJoint*)">
            <summary>Gets the parent tendon joint.  The parent tendon joint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationTendonJoint_getTendon(MagicPhysX.PxArticulationTendonJoint*)">
            <summary>Gets the tendon that the joint is a part of.  The tendon.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationTendonJoint_release_mut(MagicPhysX.PxArticulationTendonJoint*)">
            <summary>Releases a tendon joint.  Releasing a tendon joint is not allowed while the articulation is in a scene. In order to release the joint, remove and then re-add the articulation to the scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationTendonJoint_getConcreteTypeName(MagicPhysX.PxArticulationTendonJoint*)">
            <summary>Returns the string name of the dynamic type.  The string name.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationTendon_setStiffness_mut(MagicPhysX.PxArticulationTendon*,System.Single)">
            <summary>Sets the spring stiffness term acting on the tendon length.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationTendon_getStiffness(MagicPhysX.PxArticulationTendon*)">
            <summary>Gets the spring stiffness of the tendon.  The spring stiffness.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationTendon_setDamping_mut(MagicPhysX.PxArticulationTendon*,System.Single)">
            <summary>Sets the damping term acting both on the tendon length and tendon-length limits.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationTendon_getDamping(MagicPhysX.PxArticulationTendon*)">
            <summary>Gets the damping term acting both on the tendon length and tendon-length limits.  The damping term.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationTendon_setLimitStiffness_mut(MagicPhysX.PxArticulationTendon*,System.Single)">
            <summary>Sets the limit stiffness term acting on the tendon's length limits.  For spatial tendons, this parameter applies to all its leaf attachments / sub-tendons.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationTendon_getLimitStiffness(MagicPhysX.PxArticulationTendon*)">
            <summary>Gets the limit stiffness term acting on the tendon's length limits.  For spatial tendons, this parameter applies to all its leaf attachments / sub-tendons.  The limit stiffness term.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationTendon_setOffset_mut(MagicPhysX.PxArticulationTendon*,System.Single,System.Boolean)">
            <summary>Sets the length offset term for the tendon.  An offset defines an amount to be added to the accumulated length computed for the tendon. It allows the application to actuate the tendon by shortening or lengthening it.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationTendon_getOffset(MagicPhysX.PxArticulationTendon*)">
            <summary>Gets the length offset term for the tendon.  The offset term.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationTendon_getArticulation(MagicPhysX.PxArticulationTendon*)">
            <summary>Gets the articulation that the tendon is a part of.  The articulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationTendon_release_mut(MagicPhysX.PxArticulationTendon*)">
            <summary>Releases a tendon to remove it from the articulation and free its associated memory.  When an articulation is released, its attached tendons are automatically released.  Releasing a tendon is not allowed while the articulation is in a scene. In order to release the tendon, remove and then re-add the articulation to the scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationSpatialTendon_createAttachment_mut(MagicPhysX.PxArticulationSpatialTendon*,MagicPhysX.PxArticulationAttachment*,System.Single,MagicPhysX.PxVec3,MagicPhysX.PxArticulationLink*)">
            <summary>Creates an articulation attachment and adds it to the list of children in the parent attachment.  Creating an attachment is not allowed while the articulation is in a scene. In order to add the attachment, remove and then re-add the articulation to the scene.  The newly-created attachment if creation was successful, otherwise a null pointer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationSpatialTendon_getAttachments(MagicPhysX.PxArticulationSpatialTendon*,MagicPhysX.PxArticulationAttachment**,System.UInt32,System.UInt32)">
            <summary>Fills a user-provided buffer of attachment pointers with the set of attachments.  The number of attachments that were filled into the user buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationSpatialTendon_getNbAttachments(MagicPhysX.PxArticulationSpatialTendon*)">
            <summary>Returns the number of attachments in the tendon.  The number of attachments.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationSpatialTendon_getConcreteTypeName(MagicPhysX.PxArticulationSpatialTendon*)">
            <summary>Returns the string name of the dynamic type.  The string name.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationFixedTendon_createTendonJoint_mut(MagicPhysX.PxArticulationFixedTendon*,MagicPhysX.PxArticulationTendonJoint*,MagicPhysX.PxArticulationAxis,System.Single,System.Single,MagicPhysX.PxArticulationLink*)">
            <summary>Creates an articulation tendon joint and adds it to the list of children in the parent tendon joint.  Creating a tendon joint is not allowed while the articulation is in a scene. In order to add the joint, remove and then re-add the articulation to the scene.  The newly-created tendon joint if creation was successful, otherwise a null pointer.  - The axis motion must not be configured as PxArticulationMotion::eLOCKED. - The axis cannot be part of a fixed joint, i.e. joint configured as PxArticulationJointType::eFIX.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationFixedTendon_getTendonJoints(MagicPhysX.PxArticulationFixedTendon*,MagicPhysX.PxArticulationTendonJoint**,System.UInt32,System.UInt32)">
            <summary>Fills a user-provided buffer of tendon-joint pointers with the set of tendon joints.  The number of tendon joints filled into the user buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationFixedTendon_getNbTendonJoints(MagicPhysX.PxArticulationFixedTendon*)">
            <summary>Returns the number of tendon joints in the tendon.  The number of tendon joints.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationFixedTendon_setRestLength_mut(MagicPhysX.PxArticulationFixedTendon*,System.Single)">
            <summary>Sets the spring rest length of the tendon.  The accumulated \"length\" of a fixed tendon is a linear combination of the joint axis positions that the tendon is associated with, scaled by the respective tendon joints' coefficients. As such, when the joint positions of all joints are zero, the accumulated length of a fixed tendon is zero.  The spring of the tendon is not exerting any force on the articulation when the rest length is equal to the tendon's accumulated length plus the tendon offset.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationFixedTendon_getRestLength(MagicPhysX.PxArticulationFixedTendon*)">
            <summary>Gets the spring rest length of the tendon.  The spring rest length of the tendon.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationFixedTendon_setLimitParameters_mut(MagicPhysX.PxArticulationFixedTendon*,MagicPhysX.PxArticulationTendonLimit*)">
            <summary>Sets the low and high limit on the length of the tendon.  The limits, together with the damping and limit stiffness parameters, act on the accumulated length of the tendon.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationFixedTendon_getLimitParameters(MagicPhysX.PxArticulationFixedTendon*)">
            <summary>Gets the low and high limit on the length of the tendon.  Struct with the low and high limit.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationFixedTendon_getConcreteTypeName(MagicPhysX.PxArticulationFixedTendon*)">
            <summary>Returns the string name of the dynamic type.  The string name.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationCache_release_mut(MagicPhysX.PxArticulationCache*)">
            <summary>Releases an articulation cache.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationSensor_release_mut(MagicPhysX.PxArticulationSensor*)">
            <summary>Releases the sensor.  Releasing a sensor is not allowed while the articulation is in a scene. In order to release a sensor, remove and then re-add the articulation to the scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationSensor_getForces(MagicPhysX.PxArticulationSensor*)">
            <summary>Returns the spatial force in the local frame of the sensor.  The spatial force.  This call is not allowed while the simulation is running except in a split simulation during [`PxScene::collide`]() and up to #PxScene::advance(), and in PxContactModifyCallback or in contact report callbacks.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationSensor_getRelativePose(MagicPhysX.PxArticulationSensor*)">
            <summary>Returns the relative pose between this sensor and the body frame of the link that the sensor is attached to.  The link body frame is at the center of mass and aligned with the principal axes of inertia, see PxRigidBody::getCMassLocalPose.  The transform link body frame -&gt; sensor frame.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationSensor_setRelativePose_mut(MagicPhysX.PxArticulationSensor*,MagicPhysX.PxTransform*)">
            <summary>Sets the relative pose between this sensor and the body frame of the link that the sensor is attached to.  The link body frame is at the center of mass and aligned with the principal axes of inertia, see PxRigidBody::getCMassLocalPose.  Setting the sensor relative pose is not allowed while the articulation is in a scene. In order to set the pose, remove and then re-add the articulation to the scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationSensor_getLink(MagicPhysX.PxArticulationSensor*)">
            <summary>Returns the link that this sensor is attached to.  A pointer to the link.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationSensor_getIndex(MagicPhysX.PxArticulationSensor*)">
            <summary>Returns the index of this sensor inside the articulation.  The return value is only valid for sensors attached to articulations that are in a scene.  The low-level index, or 0xFFFFFFFF if the articulation is not in a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationSensor_getArticulation(MagicPhysX.PxArticulationSensor*)">
            <summary>Returns the articulation that this sensor is part of.  A pointer to the articulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationSensor_getFlags(MagicPhysX.PxArticulationSensor*)">
            <summary>Returns the sensor's flags.  The current set of flags of the sensor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationSensor_setFlag_mut(MagicPhysX.PxArticulationSensor*,MagicPhysX.PxArticulationSensorFlag,System.Boolean)">
            <summary>Sets a flag of the sensor.  Setting the sensor flags is not allowed while the articulation is in a scene. In order to set the flags, remove and then re-add the articulation to the scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationSensor_getConcreteTypeName(MagicPhysX.PxArticulationSensor*)">
            <summary>Returns the string name of the dynamic type.  The string name.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_getScene(MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Returns the scene which this articulation belongs to.  Owner Scene. NULL if not part of a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_setSolverIterationCounts_mut(MagicPhysX.PxArticulationReducedCoordinate*,System.UInt32,System.UInt32)">
            <summary>Sets the solver iteration counts for the articulation.  The solver iteration count determines how accurately contacts, drives, and limits are resolved. Setting a higher position iteration count may therefore help in scenarios where the articulation is subject to many constraints; for example, a manipulator articulation with drives and joint limits that is grasping objects, or several such articulations interacting through contacts. Other situations where higher position iterations may improve simulation fidelity are: large mass ratios within the articulation or between the articulation and an object in contact with it; or strong drives in the articulation being used to manipulate a light object.  If intersecting bodies are being depenetrated too violently, increase the number of velocity iterations. More velocity iterations will drive the relative exit velocity of the intersecting objects closer to the correct value given the restitution.  This call may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_getSolverIterationCounts(MagicPhysX.PxArticulationReducedCoordinate*,System.UInt32*,System.UInt32*)">
            <summary>Returns the solver iteration counts.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_isSleeping(MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Returns true if this articulation is sleeping.  When an actor does not move for a period of time, it is no longer simulated in order to save time. This state is called sleeping. However, because the object automatically wakes up when it is either touched by an awake object, or a sleep-affecting property is changed by the user, the entire sleep mechanism should be transparent to the user.  An articulation can only go to sleep if all links are ready for sleeping. An articulation is guaranteed to be awake if at least one of the following holds:  The wake counter is positive (see [`setWakeCounter`]()).  The linear or angular velocity of any link is non-zero.  A non-zero force or torque has been applied to the articulation or any of its links.  If an articulation is sleeping, the following state is guaranteed:  The wake counter is zero.  The linear and angular velocity of all links is zero.  There is no force update pending.  When an articulation gets inserted into a scene, it will be considered asleep if all the points above hold, else it will be treated as awake.  If an articulation is asleep after the call to [`PxScene::fetchResults`]() returns, it is guaranteed that the poses of the links were not changed. You can use this information to avoid updating the transforms of associated objects.  True if the articulation is sleeping.  This call may only be made on articulations that are in a scene, and may not be made during simulation, except in a split simulation in-between [`PxScene::fetchCollision`] and #PxScene::advance.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_setSleepThreshold_mut(MagicPhysX.PxArticulationReducedCoordinate*,System.Single)">
            <summary>Sets the mass-normalized energy threshold below which the articulation may go to sleep.  The articulation will sleep if the energy of each link is below this threshold.  This call may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_getSleepThreshold(MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Returns the mass-normalized energy below which the articulation may go to sleep.  The energy threshold for sleeping.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_setStabilizationThreshold_mut(MagicPhysX.PxArticulationReducedCoordinate*,System.Single)">
            <summary>Sets the mass-normalized kinetic energy threshold below which the articulation may participate in stabilization.  Articulations whose kinetic energy divided by their mass is above this threshold will not participate in stabilization.  This value has no effect if PxSceneFlag::eENABLE_STABILIZATION was not enabled on the PxSceneDesc.  Default: 0.01 * PxTolerancesScale::speed * PxTolerancesScale::speed  This call may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_getStabilizationThreshold(MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Returns the mass-normalized kinetic energy below which the articulation may participate in stabilization.  Articulations whose kinetic energy divided by their mass is above this threshold will not participate in stabilization.  The energy threshold for participating in stabilization.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_setWakeCounter_mut(MagicPhysX.PxArticulationReducedCoordinate*,System.Single)">
            <summary>Sets the wake counter for the articulation in seconds.  - The wake counter value determines the minimum amount of time until the articulation can be put to sleep. - An articulation will not be put to sleep if the energy is above the specified threshold (see [`setSleepThreshold`]()) or if other awake objects are touching it. - Passing in a positive value will wake up the articulation automatically.  Default: 0.4s (which corresponds to 20 frames for a time step of 0.02s)  This call may not be made during simulation, except in a split simulation in-between [`PxScene::fetchCollision`] and #PxScene::advance.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_getWakeCounter(MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Returns the wake counter of the articulation in seconds.  The wake counter of the articulation in seconds.  This call may not be made during simulation, except in a split simulation in-between [`PxScene::fetchCollision`] and #PxScene::advance.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_wakeUp_mut(MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Wakes up the articulation if it is sleeping.  - The articulation will get woken up and might cause other touching objects to wake up as well during the next simulation step. - This will set the wake counter of the articulation to the value specified in [`PxSceneDesc::wakeCounterResetValue`].  This call may only be made on articulations that are in a scene, and may not be made during simulation, except in a split simulation in-between [`PxScene::fetchCollision`] and #PxScene::advance.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_putToSleep_mut(MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Forces the articulation to sleep.  - The articulation will stay asleep during the next simulation step if not touched by another non-sleeping actor. - This will set any applied force, the velocity, and the wake counter of all bodies in the articulation to zero.  This call may not be made during simulation, and may only be made on articulations that are in a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_setMaxCOMLinearVelocity_mut(MagicPhysX.PxArticulationReducedCoordinate*,System.Single)">
            <summary>Sets the limit on the magnitude of the linear velocity of the articulation's center of mass.  - The limit acts on the linear velocity of the entire articulation. The velocity is calculated from the total momentum and the spatial inertia of the articulation. - The limit only applies to floating-base articulations. - A benefit of the COM velocity limit is that it is evenly applied to the whole articulation, which results in fewer visual artifacts compared to link rigid-body damping or joint-velocity limits. However, these per-link or per-degree-of-freedom limits may still help avoid numerical issues.  This call may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_getMaxCOMLinearVelocity(MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Gets the limit on the magnitude of the linear velocity of the articulation's center of mass.  The maximal linear velocity magnitude.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_setMaxCOMAngularVelocity_mut(MagicPhysX.PxArticulationReducedCoordinate*,System.Single)">
            <summary>Sets the limit on the magnitude of the angular velocity at the articulation's center of mass.  - The limit acts on the angular velocity of the entire articulation. The velocity is calculated from the total momentum and the spatial inertia of the articulation. - The limit only applies to floating-base articulations. - A benefit of the COM velocity limit is that it is evenly applied to the whole articulation, which results in fewer visual artifacts compared to link rigid-body damping or joint-velocity limits. However, these per-link or per-degree-of-freedom limits may still help avoid numerical issues.  This call may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_getMaxCOMAngularVelocity(MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Gets the limit on the magnitude of the angular velocity at the articulation's center of mass.  The maximal angular velocity magnitude.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_createLink_mut(MagicPhysX.PxArticulationReducedCoordinate*,MagicPhysX.PxArticulationLink*,MagicPhysX.PxTransform*)">
            <summary>Adds a link to the articulation with default attribute values.  The new link, or NULL if the link cannot be created.  Creating a link is not allowed while the articulation is in a scene. In order to add a link, remove and then re-add the articulation to the scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_release_mut(MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Releases the articulation, and all its links and corresponding joints.  Attached sensors and tendons are released automatically when the articulation is released.  This call may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_getNbLinks(MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Returns the number of links in the articulation.  The number of links.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_getLinks(MagicPhysX.PxArticulationReducedCoordinate*,MagicPhysX.PxArticulationLink**,System.UInt32,System.UInt32)">
            <summary>Returns the set of links in the articulation in the order that they were added to the articulation using createLink.  The number of links written into the buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_getNbShapes(MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Returns the number of shapes in the articulation.  The number of shapes.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_setName_mut(MagicPhysX.PxArticulationReducedCoordinate*,System.Byte*)">
            <summary>Sets a name string for the articulation that can be retrieved with getName().  This is for debugging and is not used by the SDK. The string is not copied by the SDK, only the pointer is stored.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_getName(MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Returns the name string set with setName().  Name string associated with the articulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_getWorldBounds(MagicPhysX.PxArticulationReducedCoordinate*,System.Single)">
            <summary>Returns the axis-aligned bounding box enclosing the articulation.  The articulation's bounding box.  It is not allowed to use this method while the simulation is running, except in a split simulation during [`PxScene::collide`]() and up to #PxScene::advance(), and in PxContactModifyCallback or in contact report callbacks.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_getAggregate(MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Returns the aggregate the articulation might be a part of.  The aggregate the articulation is a part of, or NULL if the articulation does not belong to an aggregate.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_setArticulationFlags_mut(MagicPhysX.PxArticulationReducedCoordinate*,MagicPhysX.PxArticulationFlags)">
            <summary>Sets flags on the articulation.  This call may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_setArticulationFlag_mut(MagicPhysX.PxArticulationReducedCoordinate*,MagicPhysX.PxArticulationFlag,System.Boolean)">
            <summary>Raises or clears a flag on the articulation.  This call may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_getArticulationFlags(MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Returns the articulation's flags.  The flags.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_getDofs(MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Returns the total number of joint degrees-of-freedom (DOFs) of the articulation.  - The six DOFs of the base of a floating-base articulation are not included in this count. - Example: Both a fixed-base and a floating-base double-pendulum with two revolute joints will have getDofs() == 2. - The return value is only valid for articulations that are in a scene.  The number of joint DOFs, or 0xFFFFFFFF if the articulation is not in a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_createCache(MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Creates an articulation cache that can be used to read and write internal articulation data.  - When the structure of the articulation changes (e.g. adding a link or sensor) after the cache was created, the cache needs to be released and recreated. - Free the memory allocated for the cache by calling the release() method on the cache. - Caches can only be created by articulations that are in a scene.  The cache, or NULL if the articulation is not in a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_getCacheDataSize(MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Returns the size of the articulation cache in bytes.  - The size does not include: the user-allocated memory for the coefficient matrix or lambda values; the scratch-related memory/members; and the cache version. See comment in [`PxArticulationCache`]. - The return value is only valid for articulations that are in a scene.  The byte size of the cache, or 0xFFFFFFFF if the articulation is not in a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_zeroCache(MagicPhysX.PxArticulationReducedCoordinate*,MagicPhysX.PxArticulationCache*)">
            <summary>Zeroes all data in the articulation cache, except user-provided and scratch memory, and cache version.  This call may only be made on articulations that are in a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_applyCache_mut(MagicPhysX.PxArticulationReducedCoordinate*,MagicPhysX.PxArticulationCache*,MagicPhysX.PxArticulationCacheFlags,System.Boolean)">
            <summary>Applies the data in the cache to the articulation.  This call wakes the articulation if it is sleeping, and the autowake parameter is true (default) or: - a nonzero joint velocity is applied or - a nonzero joint force is applied or - a nonzero root velocity is applied  This call may only be made on articulations that are in a scene, and may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_copyInternalStateToCache(MagicPhysX.PxArticulationReducedCoordinate*,MagicPhysX.PxArticulationCache*,MagicPhysX.PxArticulationCacheFlags)">
            <summary>Copies internal data of the articulation to the cache.  This call may only be made on articulations that are in a scene, and may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_packJointData(MagicPhysX.PxArticulationReducedCoordinate*,System.Single*,System.Single*)">
            <summary>Converts maximal-coordinate joint DOF data to reduced coordinates.  - Indexing into the maximal joint DOF data is via the link's low-level index minus 1 (the root link is not included). - The reduced-coordinate data follows the cache indexing convention, see PxArticulationCache::jointVelocity.  The articulation must be in a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_unpackJointData(MagicPhysX.PxArticulationReducedCoordinate*,System.Single*,System.Single*)">
            <summary>Converts reduced-coordinate joint DOF data to maximal coordinates.  - Indexing into the maximal joint DOF data is via the link's low-level index minus 1 (the root link is not included). - The reduced-coordinate data follows the cache indexing convention, see PxArticulationCache::jointVelocity.  The articulation must be in a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_commonInit(MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Prepares common articulation data based on articulation pose for inverse dynamics calculations.  Usage: 1. Set articulation pose (joint positions and base transform) via articulation cache and applyCache(). 1. Call commonInit. 1. Call inverse dynamics computation method.  This call may only be made on articulations that are in a scene, and may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_computeGeneralizedGravityForce(MagicPhysX.PxArticulationReducedCoordinate*,MagicPhysX.PxArticulationCache*)">
            <summary>Computes the joint DOF forces required to counteract gravitational forces for the given articulation pose.  - Inputs - Articulation pose (joint positions + base transform). - Outputs - Joint forces to counteract gravity (in cache).  - The joint forces returned are determined purely by gravity for the articulation in the current joint and base pose, and joints at rest; i.e. external forces, joint velocities, and joint accelerations are set to zero. Joint drives are also not considered in the computation. - commonInit() must be called before the computation, and after setting the articulation pose via applyCache().  This call may only be made on articulations that are in a scene, and may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_computeCoriolisAndCentrifugalForce(MagicPhysX.PxArticulationReducedCoordinate*,MagicPhysX.PxArticulationCache*)">
            <summary>Computes the joint DOF forces required to counteract Coriolis and centrifugal forces for the given articulation state.  - Inputs - Articulation state (joint positions and velocities (in cache), and base transform and spatial velocity). - Outputs - Joint forces to counteract Coriolis and centrifugal forces (in cache).  - The joint forces returned are determined purely by the articulation's state; i.e. external forces, gravity, and joint accelerations are set to zero. Joint drives and potential damping terms, such as link angular or linear damping, or joint friction, are also not considered in the computation. - Prior to the computation, update/set the base spatial velocity with PxArticulationCache::rootLinkData and applyCache(). - commonInit() must be called before the computation, and after setting the articulation pose via applyCache().  This call may only be made on articulations that are in a scene, and may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_computeGeneralizedExternalForce(MagicPhysX.PxArticulationReducedCoordinate*,MagicPhysX.PxArticulationCache*)">
            <summary>Computes the joint DOF forces required to counteract external spatial forces applied to articulation links.  - Inputs - External forces on links (in cache), articulation pose (joint positions + base transform). - Outputs - Joint forces to counteract the external forces (in cache).  - Only the external spatial forces provided in the cache and the articulation pose are considered in the computation. - The external spatial forces are with respect to the links' centers of mass, and not the actor's origin. - commonInit() must be called before the computation, and after setting the articulation pose via applyCache().  This call may only be made on articulations that are in a scene, and may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_computeJointAcceleration(MagicPhysX.PxArticulationReducedCoordinate*,MagicPhysX.PxArticulationCache*)">
            <summary>Computes the joint accelerations for the given articulation state and joint forces.  - Inputs - Joint forces (in cache) and articulation state (joint positions and velocities (in cache), and base transform and spatial velocity). - Outputs - Joint accelerations (in cache).  - The computation includes Coriolis terms and gravity. However, joint drives and potential damping terms are not considered in the computation (for example, linear link damping or joint friction). - Prior to the computation, update/set the base spatial velocity with PxArticulationCache::rootLinkData and applyCache(). - commonInit() must be called before the computation, and after setting the articulation pose via applyCache().  This call may only be made on articulations that are in a scene, and may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_computeJointForce(MagicPhysX.PxArticulationReducedCoordinate*,MagicPhysX.PxArticulationCache*)">
            <summary>Computes the joint forces for the given articulation state and joint accelerations, not considering gravity.  - Inputs - Joint accelerations (in cache) and articulation state (joint positions and velocities (in cache), and base transform and spatial velocity). - Outputs - Joint forces (in cache).  - The computation includes Coriolis terms. However, joint drives and potential damping terms are not considered in the computation (for example, linear link damping or joint friction). - Prior to the computation, update/set the base spatial velocity with PxArticulationCache::rootLinkData and applyCache(). - commonInit() must be called before the computation, and after setting the articulation pose via applyCache().  This call may only be made on articulations that are in a scene, and may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_computeDenseJacobian(MagicPhysX.PxArticulationReducedCoordinate*,MagicPhysX.PxArticulationCache*,System.UInt32*,System.UInt32*)">
            <summary>Compute the dense Jacobian for the articulation in world space, including the DOFs of a potentially floating base.  This computes the dense representation of an inherently sparse matrix. Multiplication with this matrix maps joint space velocities to world-space linear and angular (i.e. spatial) velocities of the centers of mass of the links.  This call may only be made on articulations that are in a scene, and may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_computeCoefficientMatrix(MagicPhysX.PxArticulationReducedCoordinate*,MagicPhysX.PxArticulationCache*)">
            <summary>Computes the coefficient matrix for contact forces.  - The matrix dimension is getCoefficientMatrixSize() = getDofs() * getNbLoopJoints(), and the DOF (column) indexing follows the internal DOF order, see PxArticulationCache::jointVelocity. - Each column in the matrix is the joint forces effected by a contact based on impulse strength 1. - The user must allocate memory for PxArticulationCache::coefficientMatrix where the required size of the PxReal array is equal to getCoefficientMatrixSize(). - commonInit() must be called before the computation, and after setting the articulation pose via applyCache().  This call may only be made on articulations that are in a scene, and may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_computeLambda(MagicPhysX.PxArticulationReducedCoordinate*,MagicPhysX.PxArticulationCache*,MagicPhysX.PxArticulationCache*,System.Single*,System.UInt32)">
            <summary>Computes the lambda values when the test impulse is 1.  - The user must allocate memory for PxArticulationCache::lambda where the required size of the PxReal array is equal to getNbLoopJoints(). - commonInit() must be called before the computation, and after setting the articulation pose via applyCache().  True if convergence was achieved within maxIter; False if convergence was not achieved or the operation failed otherwise.  This call may only be made on articulations that are in a scene, and may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_computeGeneralizedMassMatrix(MagicPhysX.PxArticulationReducedCoordinate*,MagicPhysX.PxArticulationCache*)">
            <summary>Compute the joint-space inertia matrix that maps joint accelerations to joint forces: forces = M * accelerations.  - Inputs - Articulation pose (joint positions and base transform). - Outputs - Mass matrix (in cache).  commonInit() must be called before the computation, and after setting the articulation pose via applyCache().  This call may only be made on articulations that are in a scene, and may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_addLoopJoint_mut(MagicPhysX.PxArticulationReducedCoordinate*,MagicPhysX.PxConstraint*)">
            <summary>Adds a loop joint to the articulation system for inverse dynamics.  This call may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_removeLoopJoint_mut(MagicPhysX.PxArticulationReducedCoordinate*,MagicPhysX.PxConstraint*)">
            <summary>Removes a loop joint from the articulation for inverse dynamics.  This call may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_getNbLoopJoints(MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Returns the number of loop joints in the articulation for inverse dynamics.  The number of loop joints.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_getLoopJoints(MagicPhysX.PxArticulationReducedCoordinate*,MagicPhysX.PxConstraint**,System.UInt32,System.UInt32)">
            <summary>Returns the set of loop constraints (i.e. joints) in the articulation.  The number of constraints written into the buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_getCoefficientMatrixSize(MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Returns the required size of the coefficient matrix in the articulation.  Size of the coefficient matrix (equal to getDofs() * getNbLoopJoints()).  This call may only be made on articulations that are in a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_setRootGlobalPose_mut(MagicPhysX.PxArticulationReducedCoordinate*,MagicPhysX.PxTransform*,System.Boolean)">
            <summary>Sets the root link transform (world to actor frame).  - For performance, prefer PxArticulationCache::rootLinkData to set the root link transform in a batch articulation state update. - Use updateKinematic() after all state updates to the articulation via non-cache API such as this method, in order to update link states for the next simulation frame or querying.  This call may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_getRootGlobalPose(MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Returns the root link transform (world to actor frame).  For performance, prefer PxArticulationCache::rootLinkData to get the root link transform in a batch query.  The root link transform.  This call is not allowed while the simulation is running except in a split simulation during [`PxScene::collide`]() and up to #PxScene::advance(), and in PxContactModifyCallback or in contact report callbacks.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_setRootLinearVelocity_mut(MagicPhysX.PxArticulationReducedCoordinate*,MagicPhysX.PxVec3*,System.Boolean)">
            <summary>Sets the root link linear center-of-mass velocity.  - The linear velocity is with respect to the link's center of mass and not the actor frame origin. - For performance, prefer PxArticulationCache::rootLinkData to set the root link velocity in a batch articulation state update. - The articulation is woken up if the input velocity is nonzero (ignoring autowake) and the articulation is in a scene. - Use updateKinematic() after all state updates to the articulation via non-cache API such as this method, in order to update link states for the next simulation frame or querying.  This call may not be made during simulation, except in a split simulation in-between [`PxScene::fetchCollision`] and #PxScene::advance.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_getRootLinearVelocity(MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Gets the root link center-of-mass linear velocity.  - The linear velocity is with respect to the link's center of mass and not the actor frame origin. - For performance, prefer PxArticulationCache::rootLinkData to get the root link velocity in a batch query.  The root link center-of-mass linear velocity.  This call is not allowed while the simulation is running except in a split simulation during [`PxScene::collide`]() and up to #PxScene::advance(), and in PxContactModifyCallback or in contact report callbacks.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_setRootAngularVelocity_mut(MagicPhysX.PxArticulationReducedCoordinate*,MagicPhysX.PxVec3*,System.Boolean)">
            <summary>Sets the root link angular velocity.  - For performance, prefer PxArticulationCache::rootLinkData to set the root link velocity in a batch articulation state update. - The articulation is woken up if the input velocity is nonzero (ignoring autowake) and the articulation is in a scene. - Use updateKinematic() after all state updates to the articulation via non-cache API such as this method, in order to update link states for the next simulation frame or querying.  This call may not be made during simulation, except in a split simulation in-between [`PxScene::fetchCollision`] and #PxScene::advance.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_getRootAngularVelocity(MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Gets the root link angular velocity.  For performance, prefer PxArticulationCache::rootLinkData to get the root link velocity in a batch query.  The root link angular velocity.  This call is not allowed while the simulation is running except in a split simulation during [`PxScene::collide`]() and up to #PxScene::advance(), and in PxContactModifyCallback or in contact report callbacks.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_getLinkAcceleration_mut(MagicPhysX.PxArticulationReducedCoordinate*,System.UInt32)">
            <summary>Returns the (classical) link acceleration in world space for the given low-level link index.  - The returned acceleration is not a spatial, but a classical, i.e. body-fixed acceleration (https://en.wikipedia.org/wiki/Spatial_acceleration). - The (linear) acceleration is with respect to the link's center of mass and not the actor frame origin.  The link's center-of-mass classical acceleration, or 0 if the call is made before the articulation participated in a first simulation step.  This call may only be made on articulations that are in a scene, and it is not allowed to use this method while the simulation is running except in a split simulation during [`PxScene::collide`]() and up to #PxScene::advance(), and in PxContactModifyCallback or in contact report callbacks.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_getGpuArticulationIndex_mut(MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Returns the GPU articulation index.  The GPU index, or 0xFFFFFFFF if the articulation is not in a scene or PxSceneFlag::eSUPPRESS_READBACK is not set.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_createSpatialTendon_mut(MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Creates a spatial tendon to attach to the articulation with default attribute values.  The new spatial tendon.  Creating a spatial tendon is not allowed while the articulation is in a scene. In order to add the tendon, remove and then re-add the articulation to the scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_createFixedTendon_mut(MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Creates a fixed tendon to attach to the articulation with default attribute values.  The new fixed tendon.  Creating a fixed tendon is not allowed while the articulation is in a scene. In order to add the tendon, remove and then re-add the articulation to the scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_createSensor_mut(MagicPhysX.PxArticulationReducedCoordinate*,MagicPhysX.PxArticulationLink*,MagicPhysX.PxTransform*)">
            <summary>Creates a force sensor attached to a link of the articulation.  The new sensor.  Creating a sensor is not allowed while the articulation is in a scene. In order to add the sensor, remove and then re-add the articulation to the scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_getSpatialTendons(MagicPhysX.PxArticulationReducedCoordinate*,MagicPhysX.PxArticulationSpatialTendon**,System.UInt32,System.UInt32)">
            <summary>Returns the spatial tendons attached to the articulation.  The order of the tendons in the buffer is not necessarily identical to the order in which the tendons were added to the articulation.  The number of tendons written into the buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_getNbSpatialTendons_mut(MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Returns the number of spatial tendons in the articulation.  The number of tendons.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_getFixedTendons(MagicPhysX.PxArticulationReducedCoordinate*,MagicPhysX.PxArticulationFixedTendon**,System.UInt32,System.UInt32)">
            <summary>Returns the fixed tendons attached to the articulation.  The order of the tendons in the buffer is not necessarily identical to the order in which the tendons were added to the articulation.  The number of tendons written into the buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_getNbFixedTendons_mut(MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Returns the number of fixed tendons in the articulation.  The number of tendons.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_getSensors(MagicPhysX.PxArticulationReducedCoordinate*,MagicPhysX.PxArticulationSensor**,System.UInt32,System.UInt32)">
            <summary>Returns the sensors attached to the articulation.  The order of the sensors in the buffer is not necessarily identical to the order in which the sensors were added to the articulation.  The number of sensors written into the buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_getNbSensors_mut(MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Returns the number of sensors in the articulation.  The number of sensors.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationReducedCoordinate_updateKinematic_mut(MagicPhysX.PxArticulationReducedCoordinate*,MagicPhysX.PxArticulationKinematicFlags)">
            <summary>Update link velocities and/or positions in the articulation.  For performance, prefer the PxArticulationCache API that performs batch articulation state updates.  If the application updates the root state (position and velocity) or joint state via any combination of the non-cache API calls  - setRootGlobalPose(), setRootLinearVelocity(), setRootAngularVelocity() - PxArticulationJointReducedCoordinate::setJointPosition(), PxArticulationJointReducedCoordinate::setJointVelocity()  the application needs to call this method after the state setting in order to update the link states for the next simulation frame or querying.  Use - PxArticulationKinematicFlag::ePOSITION after any changes to the articulation root or joint positions using non-cache API calls. Updates links' positions and velocities. - PxArticulationKinematicFlag::eVELOCITY after velocity-only changes to the articulation root or joints using non-cache API calls. Updates links' velocities only.  This call may only be made on articulations that are in a scene, and may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationJointReducedCoordinate_getParentArticulationLink(MagicPhysX.PxArticulationJointReducedCoordinate*)">
            <summary>Gets the parent articulation link of this joint.  The parent link.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationJointReducedCoordinate_setParentPose_mut(MagicPhysX.PxArticulationJointReducedCoordinate*,MagicPhysX.PxTransform*)">
            <summary>Sets the joint pose in the parent link actor frame.  This call is not allowed while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationJointReducedCoordinate_getParentPose(MagicPhysX.PxArticulationJointReducedCoordinate*)">
            <summary>Gets the joint pose in the parent link actor frame.  The joint pose.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationJointReducedCoordinate_getChildArticulationLink(MagicPhysX.PxArticulationJointReducedCoordinate*)">
            <summary>Gets the child articulation link of this joint.  The child link.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationJointReducedCoordinate_setChildPose_mut(MagicPhysX.PxArticulationJointReducedCoordinate*,MagicPhysX.PxTransform*)">
            <summary>Sets the joint pose in the child link actor frame.  This call is not allowed while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationJointReducedCoordinate_getChildPose(MagicPhysX.PxArticulationJointReducedCoordinate*)">
            <summary>Gets the joint pose in the child link actor frame.  The joint pose.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationJointReducedCoordinate_setJointType_mut(MagicPhysX.PxArticulationJointReducedCoordinate*,MagicPhysX.PxArticulationJointType)">
            <summary>Sets the joint type (e.g. revolute).  Setting the joint type is not allowed while the articulation is in a scene. In order to set the joint type, remove and then re-add the articulation to the scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationJointReducedCoordinate_getJointType(MagicPhysX.PxArticulationJointReducedCoordinate*)">
            <summary>Gets the joint type.  The joint type.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationJointReducedCoordinate_setMotion_mut(MagicPhysX.PxArticulationJointReducedCoordinate*,MagicPhysX.PxArticulationAxis,MagicPhysX.PxArticulationMotion)">
            <summary>Sets the joint motion for a given axis.  Setting the motion of joint axes is not allowed while the articulation is in a scene. In order to set the motion, remove and then re-add the articulation to the scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationJointReducedCoordinate_getMotion(MagicPhysX.PxArticulationJointReducedCoordinate*,MagicPhysX.PxArticulationAxis)">
            <summary>Returns the joint motion for the given axis.  The joint motion of the given axis.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationJointReducedCoordinate_setLimitParams_mut(MagicPhysX.PxArticulationJointReducedCoordinate*,MagicPhysX.PxArticulationAxis,MagicPhysX.PxArticulationLimit*)">
            <summary>Sets the joint limits for a given axis.  - The motion of the corresponding axis should be set to PxArticulationMotion::eLIMITED in order for the limits to be enforced. - The lower limit should be strictly smaller than the higher limit. If the limits should be equal, use PxArticulationMotion::eLOCKED and an appropriate offset in the parent/child joint frames.  This call is not allowed while the simulation is running.  For spherical joints, limit.min and limit.max must both be in range [-Pi, Pi].</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationJointReducedCoordinate_getLimitParams(MagicPhysX.PxArticulationJointReducedCoordinate*,MagicPhysX.PxArticulationAxis)">
            <summary>Returns the joint limits for a given axis.  The joint limits.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationJointReducedCoordinate_setDriveParams_mut(MagicPhysX.PxArticulationJointReducedCoordinate*,MagicPhysX.PxArticulationAxis,MagicPhysX.PxArticulationDrive*)">
            <summary>Configures a joint drive for the given axis.  See PxArticulationDrive for parameter details; and the manual for further information, and the drives' implicit spring-damper (i.e. PD control) implementation in particular.  This call is not allowed while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationJointReducedCoordinate_getDriveParams(MagicPhysX.PxArticulationJointReducedCoordinate*,MagicPhysX.PxArticulationAxis)">
            <summary>Gets the joint drive configuration for the given axis.  The drive parameters.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationJointReducedCoordinate_setDriveTarget_mut(MagicPhysX.PxArticulationJointReducedCoordinate*,MagicPhysX.PxArticulationAxis,System.Single,System.Boolean)">
            <summary>Sets the joint drive position target for the given axis.  The target units are linear units (equivalent to scene units) for a translational axis, or rad for a rotational axis.  This call is not allowed while the simulation is running.  For spherical joints, target must be in range [-Pi, Pi].  The target is specified in the parent frame of the joint. If Gp, Gc are the parent and child actor poses in the world frame and Lp, Lc are the parent and child joint frames expressed in the parent and child actor frames then the joint will drive the parent and child links to poses that obey Gp * Lp * J = Gc * Lc. For joints restricted to angular motion, J has the form PxTranfsorm(PxVec3(PxZero), PxExp(PxVec3(twistTarget, swing1Target, swing2Target))).  For joints restricted to linear motion, J has the form PxTransform(PxVec3(XTarget, YTarget, ZTarget), PxQuat(PxIdentity)).  For spherical joints with more than 1 degree of freedom, the joint target angles taken together can collectively represent a rotation of greater than Pi around a vector. When this happens the rotation that matches the joint drive target is not the shortest path rotation.  The joint pose J that is the outcome after driving to the target pose will always be the equivalent of the shortest path rotation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationJointReducedCoordinate_getDriveTarget(MagicPhysX.PxArticulationJointReducedCoordinate*,MagicPhysX.PxArticulationAxis)">
            <summary>Returns the joint drive position target for the given axis.  The target position.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationJointReducedCoordinate_setDriveVelocity_mut(MagicPhysX.PxArticulationJointReducedCoordinate*,MagicPhysX.PxArticulationAxis,System.Single,System.Boolean)">
            <summary>Sets the joint drive velocity target for the given axis.  The target units are linear units (equivalent to scene units) per second for a translational axis, or radians per second for a rotational axis.  This call is not allowed while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationJointReducedCoordinate_getDriveVelocity(MagicPhysX.PxArticulationJointReducedCoordinate*,MagicPhysX.PxArticulationAxis)">
            <summary>Returns the joint drive velocity target for the given axis.  The target velocity.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationJointReducedCoordinate_setArmature_mut(MagicPhysX.PxArticulationJointReducedCoordinate*,MagicPhysX.PxArticulationAxis,System.Single)">
            <summary>Sets the joint armature for the given axis.  - The armature is directly added to the joint-space spatial inertia of the corresponding axis. - The armature is in mass units for a prismatic (i.e. linear) joint, and in mass units * (scene linear units)^2 for a rotational joint.  This call is not allowed while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationJointReducedCoordinate_getArmature(MagicPhysX.PxArticulationJointReducedCoordinate*,MagicPhysX.PxArticulationAxis)">
            <summary>Gets the joint armature for the given axis.  The armature set on the given axis.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationJointReducedCoordinate_setFrictionCoefficient_mut(MagicPhysX.PxArticulationJointReducedCoordinate*,System.Single)">
            <summary>Sets the joint friction coefficient, which applies to all joint axes.  - The joint friction is unitless and relates the magnitude of the spatial force [F_trans, T_trans] transmitted from parent to child link to the maximal friction force F_resist that may be applied by the solver to resist joint motion, per axis; i.e. |F_resist| &lt; coefficient * (|F_trans| + |T_trans|), where F_resist may refer to a linear force or torque depending on the joint axis. - The simulated friction effect is therefore similar to static and Coulomb friction. In order to simulate dynamic joint friction, use a joint drive with zero stiffness and zero velocity target, and an appropriately dimensioned damping parameter.  This call is not allowed while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationJointReducedCoordinate_getFrictionCoefficient(MagicPhysX.PxArticulationJointReducedCoordinate*)">
            <summary>Gets the joint friction coefficient.  The joint friction coefficient.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationJointReducedCoordinate_setMaxJointVelocity_mut(MagicPhysX.PxArticulationJointReducedCoordinate*,System.Single)">
            <summary>Sets the maximal joint velocity enforced for all axes.  - The solver will apply appropriate joint-space impulses in order to enforce the per-axis joint-velocity limit. - The velocity units are linear units (equivalent to scene units) per second for a translational axis, or radians per second for a rotational axis.  This call is not allowed while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationJointReducedCoordinate_getMaxJointVelocity(MagicPhysX.PxArticulationJointReducedCoordinate*)">
            <summary>Gets the maximal joint velocity enforced for all axes.  The maximal per-axis joint velocity.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationJointReducedCoordinate_setJointPosition_mut(MagicPhysX.PxArticulationJointReducedCoordinate*,MagicPhysX.PxArticulationAxis,System.Single)">
            <summary>Sets the joint position for the given axis.  - For performance, prefer PxArticulationCache::jointPosition to set joint positions in a batch articulation state update. - Use PxArticulationReducedCoordinate::updateKinematic after all state updates to the articulation via non-cache API such as this method, in order to update link states for the next simulation frame or querying.  This call is not allowed while the simulation is running.  For spherical joints, jointPos must be in range [-Pi, Pi].  Joint position is specified in the parent frame of the joint. If Gp, Gc are the parent and child actor poses in the world frame and Lp, Lc are the parent and child joint frames expressed in the parent and child actor frames then the parent and child links will be given poses that obey Gp * Lp * J = Gc * Lc with J denoting the joint pose. For joints restricted to angular motion, J has the form PxTranfsorm(PxVec3(PxZero), PxExp(PxVec3(twistPos, swing1Pos, swing2Pos))).  For joints restricted to linear motion, J has the form PxTransform(PxVec3(xPos, yPos, zPos), PxQuat(PxIdentity)).  For spherical joints with more than 1 degree of freedom, the input joint positions taken together can collectively represent a rotation of greater than Pi around a vector. When this happens the rotation that matches the joint positions is not the shortest path rotation.  The joint pose J that is the outcome of setting and applying the joint positions will always be the equivalent of the shortest path rotation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationJointReducedCoordinate_getJointPosition(MagicPhysX.PxArticulationJointReducedCoordinate*,MagicPhysX.PxArticulationAxis)">
            <summary>Gets the joint position for the given axis, i.e. joint degree of freedom (DOF).  For performance, prefer PxArticulationCache::jointPosition to get joint positions in a batch query.  The joint position in linear units (equivalent to scene units) for a translational axis, or radians for a rotational axis.  This call is not allowed while the simulation is running except in a split simulation during [`PxScene::collide`]() and up to #PxScene::advance(), and in PxContactModifyCallback or in contact report callbacks.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationJointReducedCoordinate_setJointVelocity_mut(MagicPhysX.PxArticulationJointReducedCoordinate*,MagicPhysX.PxArticulationAxis,System.Single)">
            <summary>Sets the joint velocity for the given axis.  - For performance, prefer PxArticulationCache::jointVelocity to set joint velocities in a batch articulation state update. - Use PxArticulationReducedCoordinate::updateKinematic after all state updates to the articulation via non-cache API such as this method, in order to update link states for the next simulation frame or querying.  This call is not allowed while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationJointReducedCoordinate_getJointVelocity(MagicPhysX.PxArticulationJointReducedCoordinate*,MagicPhysX.PxArticulationAxis)">
            <summary>Gets the joint velocity for the given axis.  For performance, prefer PxArticulationCache::jointVelocity to get joint velocities in a batch query.  The joint velocity in linear units (equivalent to scene units) per second for a translational axis, or radians per second for a rotational axis.  This call is not allowed while the simulation is running except in a split simulation during [`PxScene::collide`]() and up to #PxScene::advance(), and in PxContactModifyCallback or in contact report callbacks.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationJointReducedCoordinate_getConcreteTypeName(MagicPhysX.PxArticulationJointReducedCoordinate*)">
            <summary>Returns the string name of the dynamic type.  The string name.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShape_release_mut(MagicPhysX.PxShape*)">
            <summary>Decrements the reference count of a shape and releases it if the new reference count is zero.  Note that in releases prior to PhysX 3.3 this method did not have reference counting semantics and was used to destroy a shape created with PxActor::createShape(). In PhysX 3.3 and above, this usage is deprecated, instead, use PxRigidActor::detachShape() to detach a shape from an actor. If the shape to be detached was created with PxActor::createShape(), the actor holds the only counted reference, and so when the shape is detached it will also be destroyed.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShape_setGeometry_mut(MagicPhysX.PxShape*,MagicPhysX.PxGeometry*)">
            <summary>Adjust the geometry of the shape.  The type of the passed in geometry must match the geometry type of the shape.  It is not allowed to change the geometry type of a shape.  This function does not guarantee correct/continuous behavior when objects are resting on top of old or new geometry.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShape_getGeometry(MagicPhysX.PxShape*)">
            <summary>Retrieve a reference to the shape's geometry.  The returned reference has the same lifetime as the PxShape it comes from.  Reference to internal PxGeometry object.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShape_getActor(MagicPhysX.PxShape*)">
            <summary>Retrieves the actor which this shape is associated with.  The actor this shape is associated with, if it is an exclusive shape, else NULL</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShape_setLocalPose_mut(MagicPhysX.PxShape*,MagicPhysX.PxTransform*)">
            <summary>Sets the pose of the shape in actor space, i.e. relative to the actors to which they are attached.  This transformation is identity by default.  The local pose is an attribute of the shape, and so will apply to all actors to which the shape is attached.  Sleeping: Does NOT wake the associated actor up automatically.  Note: Does not automatically update the inertia properties of the owning actor (if applicable); use the PhysX extensions method [`PxRigidBodyExt::updateMassAndInertia`]() to do this.  Default: the identity transform</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShape_getLocalPose(MagicPhysX.PxShape*)">
            <summary>Retrieves the pose of the shape in actor space, i.e. relative to the actor they are owned by.  This transformation is identity by default.  Pose of shape relative to the actor's frame.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShape_setSimulationFilterData_mut(MagicPhysX.PxShape*,MagicPhysX.PxFilterData*)">
            <summary>Sets the user definable collision filter data.  Sleeping: Does wake up the actor if the filter data change causes a formerly suppressed collision pair to be enabled.  Default: (0,0,0,0)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShape_getSimulationFilterData(MagicPhysX.PxShape*)">
            <summary>Retrieves the shape's collision filter data.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShape_setQueryFilterData_mut(MagicPhysX.PxShape*,MagicPhysX.PxFilterData*)">
            <summary>Sets the user definable query filter data.  Default: (0,0,0,0)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShape_getQueryFilterData(MagicPhysX.PxShape*)">
            <summary>Retrieves the shape's Query filter data.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShape_setMaterials_mut(MagicPhysX.PxShape*,MagicPhysX.PxMaterial**,System.UInt16)">
            <summary>Assigns material(s) to the shape. Will remove existing materials from the shape.  Sleeping: Does NOT wake the associated actor up automatically.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShape_getNbMaterials(MagicPhysX.PxShape*)">
            <summary>Returns the number of materials assigned to the shape.  You can use [`getMaterials`]() to retrieve the material pointers.  Number of materials associated with this shape.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShape_getMaterials(MagicPhysX.PxShape*,MagicPhysX.PxMaterial**,System.UInt32,System.UInt32)">
            <summary>Retrieve all the material pointers associated with the shape.  You can retrieve the number of material pointers by calling [`getNbMaterials`]()  Note: The returned data may contain invalid pointers if you release materials using [`PxMaterial::release`]().  Number of material pointers written to the buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShape_getMaterialFromInternalFaceIndex(MagicPhysX.PxShape*,System.UInt32)">
            <summary>Retrieve material from given triangle index.  The input index is the internal triangle index as used inside the SDK. This is the index returned to users by various SDK functions such as raycasts.  This function is only useful for triangle meshes or heightfields, which have per-triangle materials. For other shapes or SDF triangle meshes, the function returns the single material associated with the shape, regardless of the index.  Material from input triangle  If faceIndex value of 0xFFFFffff is passed as an input for mesh and heightfield shapes, this function will issue a warning and return NULL.  Scene queries set the value of PxQueryHit::faceIndex to 0xFFFFffff whenever it is undefined or does not apply.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShape_setContactOffset_mut(MagicPhysX.PxShape*,System.Single)">
            <summary>Sets the contact offset.  Shapes whose distance is less than the sum of their contactOffset values will generate contacts. The contact offset must be positive and greater than the rest offset. Having a contactOffset greater than than the restOffset allows the collision detection system to predictively enforce the contact constraint even when the objects are slightly separated. This prevents jitter that would occur if the constraint were enforced only when shapes were within the rest distance.  Default: 0.02f * PxTolerancesScale::length  Sleeping: Does NOT wake the associated actor up automatically.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShape_getContactOffset(MagicPhysX.PxShape*)">
            <summary>Retrieves the contact offset.  The contact offset of the shape.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShape_setRestOffset_mut(MagicPhysX.PxShape*,System.Single)">
            <summary>Sets the rest offset.  Two shapes will come to rest at a distance equal to the sum of their restOffset values. If the restOffset is 0, they should converge to touching exactly.  Having a restOffset greater than zero is useful to have objects slide smoothly, so that they do not get hung up on irregularities of each others' surfaces.  Default: 0.0f  Sleeping: Does NOT wake the associated actor up automatically.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShape_getRestOffset(MagicPhysX.PxShape*)">
            <summary>Retrieves the rest offset.  The rest offset of the shape.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShape_setDensityForFluid_mut(MagicPhysX.PxShape*,System.Single)">
            <summary>Sets the density used to interact with fluids.  To be physically accurate, the density of a rigid body should be computed as its mass divided by its volume. To simplify tuning the interaction of fluid and rigid bodies, the density for fluid can differ from the real density. This allows to create floating bodies, even if they are supposed to sink with their mass and volume.  Default: 800.0f</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShape_getDensityForFluid(MagicPhysX.PxShape*)">
            <summary>Retrieves the density used to interact with fluids.  The density of the body when interacting with fluid.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShape_setTorsionalPatchRadius_mut(MagicPhysX.PxShape*,System.Single)">
            <summary>Sets torsional patch radius.  This defines the radius of the contact patch used to apply torsional friction. If the radius is 0, no torsional friction will be applied. If the radius is &gt; 0, some torsional friction will be applied. This is proportional to the penetration depth so, if the shapes are separated or penetration is zero, no torsional friction will be applied. It is used to approximate rotational friction introduced by the compression of contacting surfaces.  Default: 0.0</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShape_getTorsionalPatchRadius(MagicPhysX.PxShape*)">
            <summary>Gets torsional patch radius.  This defines the radius of the contact patch used to apply torsional friction. If the radius is 0, no torsional friction will be applied. If the radius is &gt; 0, some torsional friction will be applied. This is proportional to the penetration depth so, if the shapes are separated or penetration is zero, no torsional friction will be applied. It is used to approximate rotational friction introduced by the compression of contacting surfaces.  The torsional patch radius of the shape.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShape_setMinTorsionalPatchRadius_mut(MagicPhysX.PxShape*,System.Single)">
            <summary>Sets minimum torsional patch radius.  This defines the minimum radius of the contact patch used to apply torsional friction. If the radius is 0, the amount of torsional friction that will be applied will be entirely dependent on the value of torsionalPatchRadius.  If the radius is &gt; 0, some torsional friction will be applied regardless of the value of torsionalPatchRadius or the amount of penetration.  Default: 0.0</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShape_getMinTorsionalPatchRadius(MagicPhysX.PxShape*)">
            <summary>Gets minimum torsional patch radius.  This defines the minimum radius of the contact patch used to apply torsional friction. If the radius is 0, the amount of torsional friction that will be applied will be entirely dependent on the value of torsionalPatchRadius.  If the radius is &gt; 0, some torsional friction will be applied regardless of the value of torsionalPatchRadius or the amount of penetration.  The minimum torsional patch radius of the shape.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShape_setFlag_mut(MagicPhysX.PxShape*,MagicPhysX.PxShapeFlag,System.Boolean)">
            <summary>Sets shape flags  Sleeping: Does NOT wake the associated actor up automatically.  Default: PxShapeFlag::eVISUALIZATION | PxShapeFlag::eSIMULATION_SHAPE | PxShapeFlag::eSCENE_QUERY_SHAPE</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShape_setFlags_mut(MagicPhysX.PxShape*,MagicPhysX.PxShapeFlags)">
            <summary>Sets shape flags</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShape_getFlags(MagicPhysX.PxShape*)">
            <summary>Retrieves shape flags.  The values of the shape flags.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShape_isExclusive(MagicPhysX.PxShape*)">
            <summary>Returns true if the shape is exclusive to an actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShape_setName_mut(MagicPhysX.PxShape*,System.Byte*)">
            <summary>Sets a name string for the object that can be retrieved with [`getName`]().  This is for debugging and is not used by the SDK. The string is not copied by the SDK, only the pointer is stored.  Default: NULL</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShape_getName(MagicPhysX.PxShape*)">
            <summary>retrieves the name string set with setName().  The name associated with the shape.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidActor_release_mut(MagicPhysX.PxRigidActor*)">
            <summary>Deletes the rigid actor object.  Also releases any shapes associated with the actor.  Releasing an actor will affect any objects that are connected to the actor (constraint shaders like joints etc.). Such connected objects will be deleted upon scene deletion, or explicitly by the user by calling release() on these objects. It is recommended to always remove all objects that reference actors before the actors themselves are removed. It is not possible to retrieve list of dead connected objects.  Sleeping: This call will awaken any sleeping actors contacting the deleted actor (directly or indirectly).  Calls [`PxActor::release`]() so you might want to check the documentation of that method as well.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidActor_getInternalActorIndex(MagicPhysX.PxRigidActor*)">
            <summary>Returns the internal actor index.  This is only defined for actors that have been added to a scene.  The internal actor index, or 0xffffffff if the actor is not part of a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidActor_getGlobalPose(MagicPhysX.PxRigidActor*)">
            <summary>Retrieves the actors world space transform.  The getGlobalPose() method retrieves the actor's current actor space to world space transformation.  It is not allowed to use this method while the simulation is running (except during PxScene::collide(), in PxContactModifyCallback or in contact report callbacks).  Global pose of object.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidActor_setGlobalPose_mut(MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*,System.Boolean)">
            <summary>Method for setting an actor's pose in the world.  This method instantaneously changes the actor space to world space transformation.  This method is mainly for dynamic rigid bodies (see [`PxRigidDynamic`]). Calling this method on static actors is likely to result in a performance penalty, since internal optimization structures for static actors may need to be recomputed. In addition, moving static actors will not interact correctly with dynamic actors or joints.  To directly control an actor's position and have it correctly interact with dynamic bodies and joints, create a dynamic body with the PxRigidBodyFlag::eKINEMATIC flag, then use the setKinematicTarget() commands to define its path.  Even when moving dynamic actors, exercise restraint in making use of this method. Where possible, avoid:  moving actors into other actors, thus causing overlap (an invalid physical state)  moving an actor that is connected by a joint to another away from the other (thus causing joint error)  Sleeping: This call wakes dynamic actors if they are sleeping and the autowake parameter is true (default).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidActor_attachShape_mut(MagicPhysX.PxRigidActor*,MagicPhysX.PxShape*)">
            <summary>Attach a shape to an actor  This call will increment the reference count of the shape.  Mass properties of dynamic rigid actors will not automatically be recomputed to reflect the new mass distribution implied by the shape. Follow this call with a call to the PhysX extensions method [`PxRigidBodyExt::updateMassAndInertia`]() to do that.  Attaching a triangle mesh, heightfield or plane geometry shape configured as eSIMULATION_SHAPE is not supported for non-kinematic PxRigidDynamic instances.  Sleeping: Does NOT wake the actor up automatically.  True if success.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidActor_detachShape_mut(MagicPhysX.PxRigidActor*,MagicPhysX.PxShape*,System.Boolean)">
            <summary>Detach a shape from an actor.  This will also decrement the reference count of the PxShape, and if the reference count is zero, will cause it to be deleted.  Sleeping: Does NOT wake the actor up automatically.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidActor_getNbShapes(MagicPhysX.PxRigidActor*)">
            <summary>Returns the number of shapes assigned to the actor.  You can use [`getShapes`]() to retrieve the shape pointers.  Number of shapes associated with this actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidActor_getShapes(MagicPhysX.PxRigidActor*,MagicPhysX.PxShape**,System.UInt32,System.UInt32)">
            <summary>Retrieve all the shape pointers belonging to the actor.  These are the shapes used by the actor for collision detection.  You can retrieve the number of shape pointers by calling [`getNbShapes`]()  Note: Removing shapes with [`PxShape::release`]() will invalidate the pointer of the released shape.  Number of shape pointers written to the buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidActor_getNbConstraints(MagicPhysX.PxRigidActor*)">
            <summary>Returns the number of constraint shaders attached to the actor.  You can use [`getConstraints`]() to retrieve the constraint shader pointers.  Number of constraint shaders attached to this actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidActor_getConstraints(MagicPhysX.PxRigidActor*,MagicPhysX.PxConstraint**,System.UInt32,System.UInt32)">
            <summary>Retrieve all the constraint shader pointers belonging to the actor.  You can retrieve the number of constraint shader pointers by calling [`getNbConstraints`]()  Note: Removing constraint shaders with [`PxConstraint::release`]() will invalidate the pointer of the released constraint.  Number of constraint shader pointers written to the buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_setCMassLocalPose_mut(MagicPhysX.PxRigidBody*,MagicPhysX.PxTransform*)">
            <summary>Sets the pose of the center of mass relative to the actor.  Changing this transform will not move the actor in the world!  Setting an unrealistic center of mass which is a long way from the body can make it difficult for the SDK to solve constraints. Perhaps leading to instability and jittering bodies.  Default: the identity transform</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_getCMassLocalPose(MagicPhysX.PxRigidBody*)">
            <summary>Retrieves the center of mass pose relative to the actor frame.  The center of mass pose relative to the actor frame.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_setMass_mut(MagicPhysX.PxRigidBody*,System.Single)">
            <summary>Sets the mass of a dynamic actor.  The mass must be non-negative.  setMass() does not update the inertial properties of the body, to change the inertia tensor use setMassSpaceInertiaTensor() or the PhysX extensions method [`PxRigidBodyExt::updateMassAndInertia`]().  A value of 0 is interpreted as infinite mass.  Values of 0 are not permitted for instances of PxArticulationLink but are permitted for instances of PxRigidDynamic.  Default: 1.0  Sleeping: Does NOT wake the actor up automatically.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_getMass(MagicPhysX.PxRigidBody*)">
            <summary>Retrieves the mass of the actor.  A value of 0 is interpreted as infinite mass.  The mass of this actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_getInvMass(MagicPhysX.PxRigidBody*)">
            <summary>Retrieves the inverse mass of the actor.  The inverse mass of this actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_setMassSpaceInertiaTensor_mut(MagicPhysX.PxRigidBody*,MagicPhysX.PxVec3*)">
            <summary>Sets the inertia tensor, using a parameter specified in mass space coordinates.  Note that such matrices are diagonal -- the passed vector is the diagonal.  If you have a non diagonal world/actor space inertia tensor(3x3 matrix). Then you need to diagonalize it and set an appropriate mass space transform. See [`setCMassLocalPose`]().  The inertia tensor elements must be non-negative.  A value of 0 in an element is interpreted as infinite inertia along that axis.  Values of 0 are not permitted for instances of PxArticulationLink but are permitted for instances of PxRigidDynamic.  Default: (1.0, 1.0, 1.0)  Sleeping: Does NOT wake the actor up automatically.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_getMassSpaceInertiaTensor(MagicPhysX.PxRigidBody*)">
            <summary>Retrieves the diagonal inertia tensor of the actor relative to the mass coordinate frame.  This method retrieves a mass frame inertia vector.  The mass space inertia tensor of this actor.  A value of 0 in an element is interpreted as infinite inertia along that axis.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_getMassSpaceInvInertiaTensor(MagicPhysX.PxRigidBody*)">
            <summary>Retrieves the diagonal inverse inertia tensor of the actor relative to the mass coordinate frame.  This method retrieves a mass frame inverse inertia vector.  A value of 0 in an element is interpreted as infinite inertia along that axis.  The mass space inverse inertia tensor of this actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_setLinearDamping_mut(MagicPhysX.PxRigidBody*,System.Single)">
            <summary>Sets the linear damping coefficient.  Zero represents no damping. The damping coefficient must be nonnegative.  Default: 0.0</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_getLinearDamping(MagicPhysX.PxRigidBody*)">
            <summary>Retrieves the linear damping coefficient.  The linear damping coefficient associated with this actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_setAngularDamping_mut(MagicPhysX.PxRigidBody*,System.Single)">
            <summary>Sets the angular damping coefficient.  Zero represents no damping.  The angular damping coefficient must be nonnegative.  Default: 0.05</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_getAngularDamping(MagicPhysX.PxRigidBody*)">
            <summary>Retrieves the angular damping coefficient.  The angular damping coefficient associated with this actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_getLinearVelocity(MagicPhysX.PxRigidBody*)">
            <summary>Retrieves the linear velocity of an actor.  It is not allowed to use this method while the simulation is running (except during PxScene::collide(), in PxContactModifyCallback or in contact report callbacks).  The linear velocity of the actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_getAngularVelocity(MagicPhysX.PxRigidBody*)">
            <summary>Retrieves the angular velocity of the actor.  It is not allowed to use this method while the simulation is running (except during PxScene::collide(), in PxContactModifyCallback or in contact report callbacks).  The angular velocity of the actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_setMaxLinearVelocity_mut(MagicPhysX.PxRigidBody*,System.Single)">
            <summary>Lets you set the maximum linear velocity permitted for this actor.  With this function, you can set the  maximum linear velocity permitted for this rigid body. Higher angular velocities are clamped to this value.  Note: The angular velocity is clamped to the set value before the solver, which means that the limit may still be momentarily exceeded.  Default: PX_MAX_F32</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_getMaxLinearVelocity(MagicPhysX.PxRigidBody*)">
            <summary>Retrieves the maximum angular velocity permitted for this actor.  The maximum allowed angular velocity for this actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_setMaxAngularVelocity_mut(MagicPhysX.PxRigidBody*,System.Single)">
            <summary>Lets you set the maximum angular velocity permitted for this actor.  For various internal computations, very quickly rotating actors introduce error into the simulation, which leads to undesired results.  With this function, you can set the  maximum angular velocity permitted for this rigid body. Higher angular velocities are clamped to this value.  Note: The angular velocity is clamped to the set value before the solver, which means that the limit may still be momentarily exceeded.  Default: 100.0</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_getMaxAngularVelocity(MagicPhysX.PxRigidBody*)">
            <summary>Retrieves the maximum angular velocity permitted for this actor.  The maximum allowed angular velocity for this actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_addForce_mut(MagicPhysX.PxRigidBody*,MagicPhysX.PxVec3*,MagicPhysX.PxForceMode,System.Boolean)">
            <summary>Applies a force (or impulse) defined in the global coordinate frame to the actor at its center of mass.  This will not induce a torque .  ::PxForceMode determines if the force is to be conventional or impulsive.  Each actor has an acceleration and a velocity change accumulator which are directly modified using the modes PxForceMode::eACCELERATION and PxForceMode::eVELOCITY_CHANGE respectively.  The modes PxForceMode::eFORCE and PxForceMode::eIMPULSE also modify these same accumulators and are just short hand for multiplying the vector parameter by inverse mass and then using PxForceMode::eACCELERATION and PxForceMode::eVELOCITY_CHANGE respectively.  It is invalid to use this method if the actor has not been added to a scene already or if PxActorFlag::eDISABLE_SIMULATION is set.  The force modes PxForceMode::eIMPULSE and PxForceMode::eVELOCITY_CHANGE can not be applied to articulation links.  if this is called on an articulation link, only the link is updated, not the entire articulation.  see [`PxRigidBodyExt::computeVelocityDeltaFromImpulse`] for details of how to compute the change in linear velocity that will arise from the application of an impulsive force, where an impulsive force is applied force multiplied by a timestep.  Sleeping: This call wakes the actor if it is sleeping, and the autowake parameter is true (default) or the force is non-zero.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_addTorque_mut(MagicPhysX.PxRigidBody*,MagicPhysX.PxVec3*,MagicPhysX.PxForceMode,System.Boolean)">
            <summary>Applies an impulsive torque defined in the global coordinate frame to the actor.  ::PxForceMode determines if the torque is to be conventional or impulsive.  Each actor has an angular acceleration and an angular velocity change accumulator which are directly modified using the modes PxForceMode::eACCELERATION and PxForceMode::eVELOCITY_CHANGE respectively.  The modes PxForceMode::eFORCE and PxForceMode::eIMPULSE also modify these same accumulators and are just short hand for multiplying the vector parameter by inverse inertia and then using PxForceMode::eACCELERATION and PxForceMode::eVELOCITY_CHANGE respectively.  It is invalid to use this method if the actor has not been added to a scene already or if PxActorFlag::eDISABLE_SIMULATION is set.  The force modes PxForceMode::eIMPULSE and PxForceMode::eVELOCITY_CHANGE can not be applied to articulation links.  if this called on an articulation link, only the link is updated, not the entire articulation.  see [`PxRigidBodyExt::computeVelocityDeltaFromImpulse`] for details of how to compute the change in angular velocity that will arise from the application of an impulsive torque, where an impulsive torque is an applied torque multiplied by a timestep.  Sleeping: This call wakes the actor if it is sleeping, and the autowake parameter is true (default) or the torque is non-zero.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_clearForce_mut(MagicPhysX.PxRigidBody*,MagicPhysX.PxForceMode)">
            <summary>Clears the accumulated forces (sets the accumulated force back to zero).  Each actor has an acceleration and a velocity change accumulator which are directly modified using the modes PxForceMode::eACCELERATION and PxForceMode::eVELOCITY_CHANGE respectively.  The modes PxForceMode::eFORCE and PxForceMode::eIMPULSE also modify these same accumulators (see PxRigidBody::addForce() for details); therefore the effect of calling clearForce(PxForceMode::eFORCE) is equivalent to calling clearForce(PxForceMode::eACCELERATION), and the effect of calling clearForce(PxForceMode::eIMPULSE) is equivalent to calling clearForce(PxForceMode::eVELOCITY_CHANGE).  ::PxForceMode determines if the cleared force is to be conventional or impulsive.  The force modes PxForceMode::eIMPULSE and PxForceMode::eVELOCITY_CHANGE can not be applied to articulation links.  It is invalid to use this method if the actor has not been added to a scene already or if PxActorFlag::eDISABLE_SIMULATION is set.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_clearTorque_mut(MagicPhysX.PxRigidBody*,MagicPhysX.PxForceMode)">
            <summary>Clears the impulsive torque defined in the global coordinate frame to the actor.  ::PxForceMode determines if the cleared torque is to be conventional or impulsive.  Each actor has an angular acceleration and a velocity change accumulator which are directly modified using the modes PxForceMode::eACCELERATION and PxForceMode::eVELOCITY_CHANGE respectively.  The modes PxForceMode::eFORCE and PxForceMode::eIMPULSE also modify these same accumulators (see PxRigidBody::addTorque() for details); therefore the effect of calling clearTorque(PxForceMode::eFORCE) is equivalent to calling clearTorque(PxForceMode::eACCELERATION), and the effect of calling clearTorque(PxForceMode::eIMPULSE) is equivalent to calling clearTorque(PxForceMode::eVELOCITY_CHANGE).  The force modes PxForceMode::eIMPULSE and PxForceMode::eVELOCITY_CHANGE can not be applied to articulation links.  It is invalid to use this method if the actor has not been added to a scene already or if PxActorFlag::eDISABLE_SIMULATION is set.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_setForceAndTorque_mut(MagicPhysX.PxRigidBody*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxForceMode)">
            <summary>Sets the impulsive force and torque defined in the global coordinate frame to the actor.  ::PxForceMode determines if the cleared torque is to be conventional or impulsive.  The force modes PxForceMode::eIMPULSE and PxForceMode::eVELOCITY_CHANGE can not be applied to articulation links.  It is invalid to use this method if the actor has not been added to a scene already or if PxActorFlag::eDISABLE_SIMULATION is set.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_setRigidBodyFlag_mut(MagicPhysX.PxRigidBody*,MagicPhysX.PxRigidBodyFlag,System.Boolean)">
            <summary>Raises or clears a particular rigid body flag.  See the list of flags [`PxRigidBodyFlag`]  Default: no flags are set  Sleeping: Does NOT wake the actor up automatically.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_getRigidBodyFlags(MagicPhysX.PxRigidBody*)">
            <summary>Reads the PxRigidBody flags.  See the list of flags [`PxRigidBodyFlag`]  The values of the PxRigidBody flags.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_setMinCCDAdvanceCoefficient_mut(MagicPhysX.PxRigidBody*,System.Single)">
            <summary>Sets the CCD minimum advance coefficient.  The CCD minimum advance coefficient is a value in the range [0, 1] that is used to control the minimum amount of time a body is integrated when it has a CCD contact. The actual minimum amount of time that is integrated depends on various properties, including the relative speed and collision shapes of the bodies involved in the contact. From these properties, a numeric value is calculated that determines the maximum distance (and therefore maximum time) which these bodies could be integrated forwards that would ensure that these bodies did not pass through each-other. This value is then scaled by CCD minimum advance coefficient to determine the amount of time that will be consumed in the CCD pass.  Things to consider: A large value (approaching 1) ensures that the objects will always advance some time. However, larger values increase the chances of objects gently drifting through each-other in scenes which the constraint solver can't converge, e.g. scenes where an object is being dragged through a wall with a constraint. A value of 0 ensures that the pair of objects stop at the exact time-of-impact and will not gently drift through each-other. However, with very small/thin objects initially in contact, this can lead to a large amount of time being dropped and increases the chances of jamming. Jamming occurs when the an object is persistently in contact with an object such that the time-of-impact is 0, which results in no time being advanced for those objects in that CCD pass.  The chances of jamming can be reduced by increasing the number of CCD mass</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_getMinCCDAdvanceCoefficient(MagicPhysX.PxRigidBody*)">
            <summary>Gets the CCD minimum advance coefficient.  The value of the CCD min advance coefficient.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_setMaxDepenetrationVelocity_mut(MagicPhysX.PxRigidBody*,System.Single)">
            <summary>Sets the maximum depenetration velocity permitted to be introduced by the solver. This value controls how much velocity the solver can introduce to correct for penetrations in contacts.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_getMaxDepenetrationVelocity(MagicPhysX.PxRigidBody*)">
            <summary>Returns the maximum depenetration velocity the solver is permitted to introduced. This value controls how much velocity the solver can introduce to correct for penetrations in contacts.  The maximum penetration bias applied by the solver.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_setMaxContactImpulse_mut(MagicPhysX.PxRigidBody*,System.Single)">
            <summary>Sets a limit on the impulse that may be applied at a contact. The maximum impulse at a contact between two dynamic or kinematic bodies will be the minimum of the two limit values. For a collision between a static and a dynamic body, the impulse is limited by the value for the dynamic body.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_getMaxContactImpulse(MagicPhysX.PxRigidBody*)">
            <summary>Returns the maximum impulse that may be applied at a contact.  The maximum impulse that may be applied at a contact</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_setContactSlopCoefficient_mut(MagicPhysX.PxRigidBody*,System.Single)">
            <summary>Sets a distance scale whereby the angular influence of a contact on the normal constraint in a contact is zeroed if normal.cross(offset) falls below this tolerance. Rather than acting as an absolute value, this tolerance is scaled by the ratio rXn.dot(angVel)/normal.dot(linVel) such that contacts that have relatively larger angular velocity than linear normal velocity (e.g. rolling wheels) achieve larger slop values as the angular velocity increases.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_getContactSlopCoefficient(MagicPhysX.PxRigidBody*)">
            <summary>Returns the contact slop coefficient.  The contact slop coefficient.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBody_getInternalIslandNodeIndex(MagicPhysX.PxRigidBody*)">
            <summary>Returns the island node index  The island node index.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationLink_release_mut(MagicPhysX.PxArticulationLink*)">
            <summary>Releases the link from the articulation.  Only a leaf articulation link can be released.  Releasing a link is not allowed while the articulation link is in a scene. In order to release a link, remove and then re-add the corresponding articulation to the scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationLink_getArticulation(MagicPhysX.PxArticulationLink*)">
            <summary>Gets the articulation that the link is a part of.  The articulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationLink_getInboundJoint(MagicPhysX.PxArticulationLink*)">
            <summary>Gets the joint which connects this link to its parent.  The joint connecting the link to the parent. NULL for the root link.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationLink_getInboundJointDof(MagicPhysX.PxArticulationLink*)">
            <summary>Gets the number of degrees of freedom of the joint which connects this link to its parent.  - The root link DOF-count is defined to be 0 regardless of PxArticulationFlag::eFIX_BASE. - The return value is only valid for articulations that are in a scene.  The number of degrees of freedom, or 0xFFFFFFFF if the articulation is not in a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationLink_getNbChildren(MagicPhysX.PxArticulationLink*)">
            <summary>Gets the number of child links.  The number of child links.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationLink_getLinkIndex(MagicPhysX.PxArticulationLink*)">
            <summary>Gets the low-level link index that may be used to index into members of PxArticulationCache.  The return value is only valid for articulations that are in a scene.  The low-level index, or 0xFFFFFFFF if the articulation is not in a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationLink_getChildren(MagicPhysX.PxArticulationLink*,MagicPhysX.PxArticulationLink**,System.UInt32,System.UInt32)">
            <summary>Retrieves the child links.  The number of articulation links written to the buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationLink_setCfmScale_mut(MagicPhysX.PxArticulationLink*,System.Single)">
            <summary>Set the constraint-force-mixing scale term.  The cfm scale term is a stabilization term that helps avoid instabilities with over-constrained configurations. It should be a small value that is multiplied by 1/mass internally to produce an additional bias added to the unit response term in the solver.  Default: 0.025 Range: [0, 1]  This call is not allowed while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationLink_getCfmScale(MagicPhysX.PxArticulationLink*)">
            <summary>Get the constraint-force-mixing scale term.  The constraint-force-mixing scale term.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationLink_getLinearVelocity(MagicPhysX.PxArticulationLink*)">
            <summary>Get the linear velocity of the link.  - The linear velocity is with respect to the link's center of mass and not the actor frame origin. - For performance, prefer PxArticulationCache::linkVelocity to get link spatial velocities in a batch query. - When the articulation state is updated via non-cache API, use PxArticulationReducedCoordinate::updateKinematic before querying velocity.  The linear velocity of the link.  This call is not allowed while the simulation is running except in a split simulation during [`PxScene::collide`]() and up to #PxScene::advance(), and in PxContactModifyCallback or in contact report callbacks.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationLink_getAngularVelocity(MagicPhysX.PxArticulationLink*)">
            <summary>Get the angular velocity of the link.  - For performance, prefer PxArticulationCache::linkVelocity to get link spatial velocities in a batch query. - When the articulation state is updated via non-cache API, use PxArticulationReducedCoordinate::updateKinematic before querying velocity.  The angular velocity of the link.  This call is not allowed while the simulation is running except in a split simulation during [`PxScene::collide`]() and up to #PxScene::advance(), and in PxContactModifyCallback or in contact report callbacks.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxArticulationLink_getConcreteTypeName(MagicPhysX.PxArticulationLink*)">
            <summary>Returns the string name of the dynamic type.  The string name.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConstraint_release_mut(MagicPhysX.PxConstraint*)">
            <summary>Releases a PxConstraint instance.  This call does not wake up the connected rigid bodies.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConstraint_getScene(MagicPhysX.PxConstraint*)">
            <summary>Retrieves the scene which this constraint belongs to.  Owner Scene. NULL if not part of a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConstraint_getActors(MagicPhysX.PxConstraint*,MagicPhysX.PxRigidActor**,MagicPhysX.PxRigidActor**)">
            <summary>Retrieves the actors for this constraint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConstraint_setActors_mut(MagicPhysX.PxConstraint*,MagicPhysX.PxRigidActor*,MagicPhysX.PxRigidActor*)">
            <summary>Sets the actors for this constraint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConstraint_markDirty_mut(MagicPhysX.PxConstraint*)">
            <summary>Notify the scene that the constraint shader data has been updated by the application</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConstraint_getFlags(MagicPhysX.PxConstraint*)">
            <summary>Retrieve the flags for this constraint  the constraint flags</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConstraint_setFlags_mut(MagicPhysX.PxConstraint*,MagicPhysX.PxConstraintFlags)">
            <summary>Set the flags for this constraint  default: PxConstraintFlag::eDRIVE_LIMITS_ARE_FORCES</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConstraint_setFlag_mut(MagicPhysX.PxConstraint*,MagicPhysX.PxConstraintFlag,System.Boolean)">
            <summary>Set a flag for this constraint</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConstraint_getForce(MagicPhysX.PxConstraint*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>Retrieve the constraint force most recently applied to maintain this constraint.  It is not allowed to use this method while the simulation is running (except during PxScene::collide(), in PxContactModifyCallback or in contact report callbacks).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConstraint_isValid(MagicPhysX.PxConstraint*)">
            <summary>whether the constraint is valid.  A constraint is valid if it has at least one dynamic rigid body or articulation link. A constraint that is not valid may not be inserted into a scene, and therefore a static actor to which an invalid constraint is attached may not be inserted into a scene.  Invalid constraints arise only when an actor to which the constraint is attached has been deleted.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConstraint_setBreakForce_mut(MagicPhysX.PxConstraint*,System.Single,System.Single)">
            <summary>Set the break force and torque thresholds for this constraint.  If either the force or torque measured at the constraint exceed these thresholds the constraint will break.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConstraint_getBreakForce(MagicPhysX.PxConstraint*,System.Single*,System.Single*)">
            <summary>Retrieve the constraint break force and torque thresholds</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConstraint_setMinResponseThreshold_mut(MagicPhysX.PxConstraint*,System.Single)">
            <summary>Set the minimum response threshold for a constraint row  When using mass modification for a joint or infinite inertia for a jointed body, very stiff solver constraints can be generated which can destabilize simulation. Setting this value to a small positive value (e.g. 1e-8) will cause constraint rows to be ignored if very large changes in impulses will generate only small changes in velocity. When setting this value, also set PxConstraintFlag::eDISABLE_PREPROCESSING. The solver accuracy for this joint may be reduced.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConstraint_getMinResponseThreshold(MagicPhysX.PxConstraint*)">
            <summary>Retrieve the constraint break force and torque thresholds  the minimum response threshold for a constraint row</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConstraint_getExternalReference_mut(MagicPhysX.PxConstraint*,System.UInt32*)">
            <summary>Fetch external owner of the constraint.  Provides a reference to the external owner of a constraint and a unique owner type ID.  Reference to the external object which owns the constraint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConstraint_setConstraintFunctions_mut(MagicPhysX.PxConstraint*,MagicPhysX.PxConstraintConnector*,MagicPhysX.PxConstraintShaderTable*)">
            <summary>Set the constraint functions for this constraint</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactStreamIterator_new(System.Byte*,System.Byte*,System.UInt32*,System.UInt32,System.UInt32)">
            <summary>Constructor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactStreamIterator_hasNextPatch(MagicPhysX.PxContactStreamIterator*)">
            <summary>Returns whether there are more patches in this stream.  Whether there are more patches in this stream.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactStreamIterator_getTotalContactCount(MagicPhysX.PxContactStreamIterator*)">
            <summary>Returns the total contact count.  Total contact count.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactStreamIterator_getTotalPatchCount(MagicPhysX.PxContactStreamIterator*)">
            <summary>Returns the total patch count.  Total patch count.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactStreamIterator_nextPatch_mut(MagicPhysX.PxContactStreamIterator*)">
            <summary>Advances iterator to next contact patch.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactStreamIterator_hasNextContact(MagicPhysX.PxContactStreamIterator*)">
            <summary>Returns if the current patch has more contacts.  If there are more contacts in the current patch.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactStreamIterator_nextContact_mut(MagicPhysX.PxContactStreamIterator*)">
            <summary>Advances to the next contact in the patch.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactStreamIterator_getContactNormal(MagicPhysX.PxContactStreamIterator*)">
            <summary>Gets the current contact's normal  The current contact's normal.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactStreamIterator_getInvMassScale0(MagicPhysX.PxContactStreamIterator*)">
            <summary>Gets the inverse mass scale for body 0.  The inverse mass scale for body 0.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactStreamIterator_getInvMassScale1(MagicPhysX.PxContactStreamIterator*)">
            <summary>Gets the inverse mass scale for body 1.  The inverse mass scale for body 1.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactStreamIterator_getInvInertiaScale0(MagicPhysX.PxContactStreamIterator*)">
            <summary>Gets the inverse inertia scale for body 0.  The inverse inertia scale for body 0.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactStreamIterator_getInvInertiaScale1(MagicPhysX.PxContactStreamIterator*)">
            <summary>Gets the inverse inertia scale for body 1.  The inverse inertia scale for body 1.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactStreamIterator_getMaxImpulse(MagicPhysX.PxContactStreamIterator*)">
            <summary>Gets the contact's max impulse.  The contact's max impulse.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactStreamIterator_getTargetVel(MagicPhysX.PxContactStreamIterator*)">
            <summary>Gets the contact's target velocity.  The contact's target velocity.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactStreamIterator_getContactPoint(MagicPhysX.PxContactStreamIterator*)">
            <summary>Gets the contact's contact point.  The contact's contact point.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactStreamIterator_getSeparation(MagicPhysX.PxContactStreamIterator*)">
            <summary>Gets the contact's separation.  The contact's separation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactStreamIterator_getFaceIndex0(MagicPhysX.PxContactStreamIterator*)">
            <summary>Gets the contact's face index for shape 0.  The contact's face index for shape 0.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactStreamIterator_getFaceIndex1(MagicPhysX.PxContactStreamIterator*)">
            <summary>Gets the contact's face index for shape 1.  The contact's face index for shape 1.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactStreamIterator_getStaticFriction(MagicPhysX.PxContactStreamIterator*)">
            <summary>Gets the contact's static friction coefficient.  The contact's static friction coefficient.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactStreamIterator_getDynamicFriction(MagicPhysX.PxContactStreamIterator*)">
            <summary>Gets the contact's dynamic friction coefficient.  The contact's dynamic friction coefficient.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactStreamIterator_getRestitution(MagicPhysX.PxContactStreamIterator*)">
            <summary>Gets the contact's restitution coefficient.  The contact's restitution coefficient.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactStreamIterator_getDamping(MagicPhysX.PxContactStreamIterator*)">
            <summary>Gets the contact's damping value.  The contact's damping value.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactStreamIterator_getMaterialFlags(MagicPhysX.PxContactStreamIterator*)">
            <summary>Gets the contact's material flags.  The contact's material flags.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactStreamIterator_getMaterialIndex0(MagicPhysX.PxContactStreamIterator*)">
            <summary>Gets the contact's material index for shape 0.  The contact's material index for shape 0.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactStreamIterator_getMaterialIndex1(MagicPhysX.PxContactStreamIterator*)">
            <summary>Gets the contact's material index for shape 1.  The contact's material index for shape 1.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactStreamIterator_advanceToIndex_mut(MagicPhysX.PxContactStreamIterator*,System.UInt32)">
            <summary>Advances the contact stream iterator to a specific contact index.  True if advancing was possible</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactSet_getPoint(MagicPhysX.PxContactSet*,System.UInt32)">
            <summary>Get the position of a specific contact point in the set.  Position to the requested point in world space</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactSet_setPoint_mut(MagicPhysX.PxContactSet*,System.UInt32,MagicPhysX.PxVec3*)">
            <summary>Alter the position of a specific contact point in the set.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactSet_getNormal(MagicPhysX.PxContactSet*,System.UInt32)">
            <summary>Get the contact normal of a specific contact point in the set.  The requested normal in world space</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactSet_setNormal_mut(MagicPhysX.PxContactSet*,System.UInt32,MagicPhysX.PxVec3*)">
            <summary>Alter the contact normal of a specific contact point in the set.  Changing the normal can cause contact points to be ignored.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactSet_getSeparation(MagicPhysX.PxContactSet*,System.UInt32)">
            <summary>Get the separation distance of a specific contact point in the set.  The separation. Negative implies penetration.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactSet_setSeparation_mut(MagicPhysX.PxContactSet*,System.UInt32,System.Single)">
            <summary>Alter the separation of a specific contact point in the set.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactSet_getTargetVelocity(MagicPhysX.PxContactSet*,System.UInt32)">
            <summary>Get the target velocity of a specific contact point in the set.  The target velocity in world frame</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactSet_setTargetVelocity_mut(MagicPhysX.PxContactSet*,System.UInt32,MagicPhysX.PxVec3*)">
            <summary>Alter the target velocity of a specific contact point in the set.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactSet_getInternalFaceIndex0(MagicPhysX.PxContactSet*,System.UInt32)">
            <summary>Get the face index with respect to the first shape of the pair for a specific contact point in the set.  The face index of the first shape  At the moment, the first shape is never a tri-mesh, therefore this function always returns PXC_CONTACT_NO_FACE_INDEX</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactSet_getInternalFaceIndex1(MagicPhysX.PxContactSet*,System.UInt32)">
            <summary>Get the face index with respect to the second shape of the pair for a specific contact point in the set.  The face index of the second shape</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactSet_getMaxImpulse(MagicPhysX.PxContactSet*,System.UInt32)">
            <summary>Get the maximum impulse for a specific contact point in the set.  The maximum impulse</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactSet_setMaxImpulse_mut(MagicPhysX.PxContactSet*,System.UInt32,System.Single)">
            <summary>Alter the maximum impulse for a specific contact point in the set.  Must be nonnegative. If set to zero, the contact point will be ignored</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactSet_getRestitution(MagicPhysX.PxContactSet*,System.UInt32)">
            <summary>Get the restitution coefficient for a specific contact point in the set.  The restitution coefficient</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactSet_setRestitution_mut(MagicPhysX.PxContactSet*,System.UInt32,System.Single)">
            <summary>Alter the restitution coefficient for a specific contact point in the set.  Valid ranges [0,1]</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactSet_getStaticFriction(MagicPhysX.PxContactSet*,System.UInt32)">
            <summary>Get the static friction coefficient for a specific contact point in the set.  The friction coefficient (dimensionless)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactSet_setStaticFriction_mut(MagicPhysX.PxContactSet*,System.UInt32,System.Single)">
            <summary>Alter the static friction coefficient for a specific contact point in the set.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactSet_getDynamicFriction(MagicPhysX.PxContactSet*,System.UInt32)">
            <summary>Get the static friction coefficient for a specific contact point in the set.  The friction coefficient</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactSet_setDynamicFriction_mut(MagicPhysX.PxContactSet*,System.UInt32,System.Single)">
            <summary>Alter the static dynamic coefficient for a specific contact point in the set.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactSet_ignore_mut(MagicPhysX.PxContactSet*,System.UInt32)">
            <summary>Ignore the contact point.  If a contact point is ignored then no force will get applied at this point. This can be used to disable collision in certain areas of a shape, for example.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactSet_size(MagicPhysX.PxContactSet*)">
            <summary>The number of contact points in the set.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactSet_getInvMassScale0(MagicPhysX.PxContactSet*)">
            <summary>Returns the invMassScale of body 0  A value &lt; 1.0 makes this contact treat the body as if it had larger mass. A value of 0.f makes this contact treat the body as if it had infinite mass. Any value &gt; 1.f makes this contact treat the body as if it had smaller mass.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactSet_getInvMassScale1(MagicPhysX.PxContactSet*)">
            <summary>Returns the invMassScale of body 1  A value &lt; 1.0 makes this contact treat the body as if it had larger mass. A value of 0.f makes this contact treat the body as if it had infinite mass. Any value &gt; 1.f makes this contact treat the body as if it had smaller mass.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactSet_getInvInertiaScale0(MagicPhysX.PxContactSet*)">
            <summary>Returns the invInertiaScale of body 0  A value &lt; 1.0 makes this contact treat the body as if it had larger inertia. A value of 0.f makes this contact treat the body as if it had infinite inertia. Any value &gt; 1.f makes this contact treat the body as if it had smaller inertia.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactSet_getInvInertiaScale1(MagicPhysX.PxContactSet*)">
            <summary>Returns the invInertiaScale of body 1  A value &lt; 1.0 makes this contact treat the body as if it had larger inertia. A value of 0.f makes this contact treat the body as if it had infinite inertia. Any value &gt; 1.f makes this contact treat the body as if it had smaller inertia.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactSet_setInvMassScale0_mut(MagicPhysX.PxContactSet*,System.Single)">
            <summary>Sets the invMassScale of body 0  This can be set to any value in the range [0, PX_MAX_F32). A value &lt; 1.0 makes this contact treat the body as if it had larger mass. A value of 0.f makes this contact treat the body as if it had infinite mass. Any value &gt; 1.f makes this contact treat the body as if it had smaller mass.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactSet_setInvMassScale1_mut(MagicPhysX.PxContactSet*,System.Single)">
            <summary>Sets the invMassScale of body 1  This can be set to any value in the range [0, PX_MAX_F32). A value &lt; 1.0 makes this contact treat the body as if it had larger mass. A value of 0.f makes this contact treat the body as if it had infinite mass. Any value &gt; 1.f makes this contact treat the body as if it had smaller mass.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactSet_setInvInertiaScale0_mut(MagicPhysX.PxContactSet*,System.Single)">
            <summary>Sets the invInertiaScale of body 0  This can be set to any value in the range [0, PX_MAX_F32). A value &lt; 1.0 makes this contact treat the body as if it had larger inertia. A value of 0.f makes this contact treat the body as if it had infinite inertia. Any value &gt; 1.f makes this contact treat the body as if it had smaller inertia.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactSet_setInvInertiaScale1_mut(MagicPhysX.PxContactSet*,System.Single)">
            <summary>Sets the invInertiaScale of body 1  This can be set to any value in the range [0, PX_MAX_F32). A value &lt; 1.0 makes this contact treat the body as if it had larger inertia. A value of 0.f makes this contact treat the body as if it had infinite inertia. Any value &gt; 1.f makes this contact treat the body as if it had smaller inertia.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactModifyCallback_onContactModify_mut(MagicPhysX.PxContactModifyCallback*,MagicPhysX.PxContactModifyPair*,System.UInt32)">
            <summary>Passes modifiable arrays of contacts to the application.  The initial contacts are regenerated from scratch each frame by collision detection.  The number of contacts can not be changed, so you cannot add your own contacts.  You may however disable contacts using PxContactSet::ignore().</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCCDContactModifyCallback_onCCDContactModify_mut(MagicPhysX.PxCCDContactModifyCallback*,MagicPhysX.PxContactModifyPair*,System.UInt32)">
            <summary>Passes modifiable arrays of contacts to the application.  The initial contacts are regenerated from scratch each frame by collision detection.  The number of contacts can not be changed, so you cannot add your own contacts.  You may however disable contacts using PxContactSet::ignore().</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxDeletionListener_onRelease_mut(MagicPhysX.PxDeletionListener*,MagicPhysX.PxBase*,System.Void*,MagicPhysX.PxDeletionEventFlag)">
            <summary>Notification if an object or its memory gets released  If release() gets called on a PxBase object, an eUSER_RELEASE event will get fired immediately. The object state can be queried in the callback but it is not allowed to change the state. Furthermore, when reading from the object it is the user's responsibility to make sure that no other thread is writing at the same time to the object (this includes the simulation itself, i.e., [`PxScene::fetchResults`]() must not get called at the same time).  Calling release() on a PxBase object does not necessarily trigger its destructor immediately. For example, the object can be shared and might still be referenced by other objects or the simulation might still be running and accessing the object state. In such cases the destructor will be called as soon as it is safe to do so. After the destruction of the object and its memory, an eMEMORY_RELEASE event will get fired. In this case it is not allowed to dereference the object pointer in the callback.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxFEMMaterial_setYoungsModulus_mut(MagicPhysX.PxFEMMaterial*,System.Single)">
            <summary>Sets young's modulus which defines the body's stiffness</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxFEMMaterial_getYoungsModulus(MagicPhysX.PxFEMMaterial*)">
            <summary>Retrieves the young's modulus value.  The young's modulus value.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxFEMMaterial_setPoissons_mut(MagicPhysX.PxFEMMaterial*,System.Single)">
            <summary>Sets the Poisson's ratio which defines the body's volume preservation. Completely incompressible materials have a poisson ratio of 0.5. Its value should not be set to exactly 0.5 because this leads to numerical problems.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxFEMMaterial_getPoissons(MagicPhysX.PxFEMMaterial*)">
            <summary>Retrieves the Poisson's ratio.  The Poisson's ratio.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxFEMMaterial_setDynamicFriction_mut(MagicPhysX.PxFEMMaterial*,System.Single)">
            <summary>Sets the dynamic friction value which defines the strength of resistance when two objects slide relative to each other while in contact.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxFEMMaterial_getDynamicFriction(MagicPhysX.PxFEMMaterial*)">
            <summary>Retrieves the dynamic friction value  The dynamic friction value</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxFilterData_new_1">
            <summary>Default constructor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxFilterData_new_2(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>Constructor to set filter data initially.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxFilterData_setToDefault_mut(MagicPhysX.PxFilterData*)">
            <summary>(re)sets the structure to the default.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxGetFilterObjectType(System.UInt32)">
            <summary>Extract filter object type from the filter attributes of a collision pair object  The type of the collision pair object.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxFilterObjectIsKinematic(System.UInt32)">
            <summary>Specifies whether the collision object belongs to a kinematic rigid body  True if the object belongs to a kinematic rigid body, else false</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxFilterObjectIsTrigger(System.UInt32)">
            <summary>Specifies whether the collision object is a trigger shape  True if the object is a trigger shape, else false</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSimulationFilterCallback_pairFound_mut(MagicPhysX.PxSimulationFilterCallback*,System.UInt32,System.UInt32,MagicPhysX.PxFilterData,MagicPhysX.PxActor*,MagicPhysX.PxShape*,System.UInt32,MagicPhysX.PxFilterData,MagicPhysX.PxActor*,MagicPhysX.PxShape*,MagicPhysX.PxPairFlags*)">
            <summary>Filter method to specify how a pair of potentially colliding objects should be processed.  This method gets called when the filter flags returned by the filter shader (see [`PxSimulationFilterShader`]) indicate that the filter callback should be invoked ([`PxFilterFlag::eCALLBACK`] or #PxFilterFlag::eNOTIFY set). Return the PxFilterFlag flags and set the PxPairFlag flags to define what the simulation should do with the given collision pair.  Filter flags defining whether the pair should be discarded, temporarily ignored or processed and whether the pair should be tracked and send a report on pair deletion through the filter callback</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSimulationFilterCallback_pairLost_mut(MagicPhysX.PxSimulationFilterCallback*,System.UInt32,System.UInt32,MagicPhysX.PxFilterData,System.UInt32,MagicPhysX.PxFilterData,System.Boolean)">
            <summary>Callback to inform that a tracked collision pair is gone.  This method gets called when a collision pair disappears or gets re-filtered. Only applies to collision pairs which have been marked as filter callback pairs ([`PxFilterFlag::eNOTIFY`] set in #pairFound()).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSimulationFilterCallback_statusChange_mut(MagicPhysX.PxSimulationFilterCallback*,System.UInt32*,MagicPhysX.PxPairFlags*,MagicPhysX.PxFilterFlags*)">
            <summary>Callback to give the opportunity to change the filter state of a tracked collision pair.  This method gets called once per simulation step to let the application change the filter and pair flags of a collision pair that has been reported in [`pairFound`]() and requested callbacks by setting [`PxFilterFlag::eNOTIFY`]. To request a change of filter status, the target pair has to be specified by its ID, the new filter and pair flags have to be provided and the method should return true.  If this method changes the filter status of a collision pair and the pair should keep being tracked by the filter callbacks then [`PxFilterFlag::eNOTIFY`] has to be set.  The application is responsible to ensure that this method does not get called for pairs that have been reported as lost, see [`pairLost`]().  True if the changes should be applied. In this case the method will get called again. False if no more status changes should be done in the current simulation step. In that case the provided flags will be discarded.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxLockedData_getDataAccessFlags_mut(MagicPhysX.PxLockedData*)">
            <summary>Any combination of PxDataAccessFlag::eREADABLE and PxDataAccessFlag::eWRITABLE</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxLockedData_unlock_mut(MagicPhysX.PxLockedData*)">
            <summary>Unlocks the bulk data.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxLockedData_delete(MagicPhysX.PxLockedData*)">
            <summary>virtual destructor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMaterial_setDynamicFriction_mut(MagicPhysX.PxMaterial*,System.Single)">
            <summary>Sets the coefficient of dynamic friction.  The coefficient of dynamic friction should be in [0, PX_MAX_F32). If set to greater than staticFriction, the effective value of staticFriction will be increased to match.  Sleeping: Does NOT wake any actors which may be affected.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMaterial_getDynamicFriction(MagicPhysX.PxMaterial*)">
            <summary>Retrieves the DynamicFriction value.  The coefficient of dynamic friction.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMaterial_setStaticFriction_mut(MagicPhysX.PxMaterial*,System.Single)">
            <summary>Sets the coefficient of static friction  The coefficient of static friction should be in the range [0, PX_MAX_F32)  Sleeping: Does NOT wake any actors which may be affected.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMaterial_getStaticFriction(MagicPhysX.PxMaterial*)">
            <summary>Retrieves the coefficient of static friction.  The coefficient of static friction.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMaterial_setRestitution_mut(MagicPhysX.PxMaterial*,System.Single)">
            <summary>Sets the coefficient of restitution  A coefficient of 0 makes the object bounce as little as possible, higher values up to 1.0 result in more bounce.  This property is overloaded when PxMaterialFlag::eCOMPLIANT_CONTACT flag is enabled. This permits negative values for restitution to be provided. The negative values are converted into spring stiffness terms for an implicit spring simulated at the contact site, with the spring positional error defined by the contact separation value. Higher stiffness terms produce stiffer springs that behave more like a rigid contact.  Sleeping: Does NOT wake any actors which may be affected.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMaterial_getRestitution(MagicPhysX.PxMaterial*)">
            <summary>Retrieves the coefficient of restitution.  See [`setRestitution`].  The coefficient of restitution.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMaterial_setDamping_mut(MagicPhysX.PxMaterial*,System.Single)">
            <summary>Sets the coefficient of damping  This property only affects the simulation if PxMaterialFlag::eCOMPLIANT_CONTACT is raised. Damping works together with spring stiffness (set through a negative restitution value). Spring stiffness corrects positional error while damping resists relative velocity. Setting a high damping coefficient can produce spongy contacts.  Sleeping: Does NOT wake any actors which may be affected.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMaterial_getDamping(MagicPhysX.PxMaterial*)">
            <summary>Retrieves the coefficient of damping.  See [`setDamping`].  The coefficient of damping.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMaterial_setFlag_mut(MagicPhysX.PxMaterial*,MagicPhysX.PxMaterialFlag,System.Boolean)">
            <summary>Raises or clears a particular material flag.  See the list of flags [`PxMaterialFlag`]  Default: eIMPROVED_PATCH_FRICTION  Sleeping: Does NOT wake any actors which may be affected.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMaterial_setFlags_mut(MagicPhysX.PxMaterial*,MagicPhysX.PxMaterialFlags)">
            <summary>sets all the material flags.  See the list of flags [`PxMaterialFlag`]  Default: eIMPROVED_PATCH_FRICTION  Sleeping: Does NOT wake any actors which may be affected.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMaterial_getFlags(MagicPhysX.PxMaterial*)">
            <summary>Retrieves the flags. See [`PxMaterialFlag`].  The material flags.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMaterial_setFrictionCombineMode_mut(MagicPhysX.PxMaterial*,MagicPhysX.PxCombineMode)">
            <summary>Sets the friction combine mode.  See the enum ::PxCombineMode .  Default: PxCombineMode::eAVERAGE  Sleeping: Does NOT wake any actors which may be affected.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMaterial_getFrictionCombineMode(MagicPhysX.PxMaterial*)">
            <summary>Retrieves the friction combine mode.  See [`setFrictionCombineMode`].  The friction combine mode for this material.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMaterial_setRestitutionCombineMode_mut(MagicPhysX.PxMaterial*,MagicPhysX.PxCombineMode)">
            <summary>Sets the restitution combine mode.  See the enum ::PxCombineMode .  Default: PxCombineMode::eAVERAGE  Sleeping: Does NOT wake any actors which may be affected.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMaterial_getRestitutionCombineMode(MagicPhysX.PxMaterial*)">
            <summary>Retrieves the restitution combine mode.  See [`setRestitutionCombineMode`].  The coefficient of restitution combine mode for this material.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxDiffuseParticleParams_new">
            <summary>Construct parameters with default values.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxDiffuseParticleParams_setToDefault_mut(MagicPhysX.PxDiffuseParticleParams*)">
            <summary>(re)sets the structure to the default.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxParticleMaterial_setFriction_mut(MagicPhysX.PxParticleMaterial*,System.Single)">
            <summary>Sets friction</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxParticleMaterial_getFriction(MagicPhysX.PxParticleMaterial*)">
            <summary>Retrieves the friction value.  The friction value.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxParticleMaterial_setDamping_mut(MagicPhysX.PxParticleMaterial*,System.Single)">
            <summary>Sets velocity damping term</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxParticleMaterial_getDamping(MagicPhysX.PxParticleMaterial*)">
            <summary>Retrieves the velocity damping term  The velocity damping term.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxParticleMaterial_setAdhesion_mut(MagicPhysX.PxParticleMaterial*,System.Single)">
            <summary>Sets adhesion term</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxParticleMaterial_getAdhesion(MagicPhysX.PxParticleMaterial*)">
            <summary>Retrieves the adhesion term  The adhesion term.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxParticleMaterial_setGravityScale_mut(MagicPhysX.PxParticleMaterial*,System.Single)">
            <summary>Sets gravity scale term</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxParticleMaterial_getGravityScale(MagicPhysX.PxParticleMaterial*)">
            <summary>Retrieves the gravity scale term  The gravity scale term.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxParticleMaterial_setAdhesionRadiusScale_mut(MagicPhysX.PxParticleMaterial*,System.Single)">
            <summary>Sets material adhesion radius scale. This is multiplied by the particle rest offset to compute the fall-off distance at which point adhesion ceases to operate.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxParticleMaterial_getAdhesionRadiusScale(MagicPhysX.PxParticleMaterial*)">
            <summary>Retrieves the adhesion radius scale.  The adhesion radius scale.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_release_mut(MagicPhysX.PxPhysics*)">
            <summary>Destroys the instance it is called on.  Use this release method to destroy an instance of this class. Be sure to not keep a reference to this object after calling release. Avoid release calls while a scene is simulating (in between simulate() and fetchResults() calls).  Note that this must be called once for each prior call to PxCreatePhysics, as there is a reference counter. Also note that you mustn't destroy the PxFoundation instance (holding the allocator, error callback etc.) until after the reference count reaches 0 and the SDK is actually removed.  Releasing an SDK will also release any objects created through it (scenes, triangle meshes, convex meshes, heightfields, shapes etc.), provided the user hasn't already done so.  Releasing the PxPhysics instance is a prerequisite to releasing the PxFoundation instance.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_getFoundation_mut(MagicPhysX.PxPhysics*)">
            <summary>Retrieves the Foundation instance.  A reference to the Foundation object.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_createAggregate_mut(MagicPhysX.PxPhysics*,System.UInt32,System.UInt32,System.UInt32)">
            <summary>Creates an aggregate with the specified maximum size and filtering hint.  The previous API used \"bool enableSelfCollision\" which should now silently evaluates to a PxAggregateType::eGENERIC aggregate with its self-collision bit.  Use PxAggregateType::eSTATIC or PxAggregateType::eKINEMATIC for aggregates that will only contain static or kinematic actors. This provides faster filtering when used in combination with PxPairFilteringMode.  The new aggregate.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_getTolerancesScale(MagicPhysX.PxPhysics*)">
            <summary>Returns the simulation tolerance parameters.  The current simulation tolerance parameters.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_createTriangleMesh_mut(MagicPhysX.PxPhysics*,MagicPhysX.PxInputStream*)">
            <summary>Creates a triangle mesh object.  This can then be instanced into [`PxShape`] objects.  The new triangle mesh.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_getNbTriangleMeshes(MagicPhysX.PxPhysics*)">
            <summary>Return the number of triangle meshes that currently exist.  Number of triangle meshes.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_getTriangleMeshes(MagicPhysX.PxPhysics*,MagicPhysX.PxTriangleMesh**,System.UInt32,System.UInt32)">
            <summary>Writes the array of triangle mesh pointers to a user buffer.  Returns the number of pointers written.  The ordering of the triangle meshes in the array is not specified.  The number of triangle mesh pointers written to userBuffer, this should be less or equal to bufferSize.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_createTetrahedronMesh_mut(MagicPhysX.PxPhysics*,MagicPhysX.PxInputStream*)">
            <summary>Creates a tetrahedron mesh object.  This can then be instanced into [`PxShape`] objects.  The new tetrahedron mesh.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_createSoftBodyMesh_mut(MagicPhysX.PxPhysics*,MagicPhysX.PxInputStream*)">
            <summary>Creates a softbody mesh object.  The new softbody mesh.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_getNbTetrahedronMeshes(MagicPhysX.PxPhysics*)">
            <summary>Return the number of tetrahedron meshes that currently exist.  Number of tetrahedron meshes.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_getTetrahedronMeshes(MagicPhysX.PxPhysics*,MagicPhysX.PxTetrahedronMesh**,System.UInt32,System.UInt32)">
            <summary>Writes the array of tetrahedron mesh pointers to a user buffer.  Returns the number of pointers written.  The ordering of the tetrahedron meshes in the array is not specified.  The number of tetrahedron mesh pointers written to userBuffer, this should be less or equal to bufferSize.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_createHeightField_mut(MagicPhysX.PxPhysics*,MagicPhysX.PxInputStream*)">
            <summary>Creates a heightfield object from previously cooked stream.  This can then be instanced into [`PxShape`] objects.  The new heightfield.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_getNbHeightFields(MagicPhysX.PxPhysics*)">
            <summary>Return the number of heightfields that currently exist.  Number of heightfields.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_getHeightFields(MagicPhysX.PxPhysics*,MagicPhysX.PxHeightField**,System.UInt32,System.UInt32)">
            <summary>Writes the array of heightfield pointers to a user buffer.  Returns the number of pointers written.  The ordering of the heightfields in the array is not specified.  The number of heightfield pointers written to userBuffer, this should be less or equal to bufferSize.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_createConvexMesh_mut(MagicPhysX.PxPhysics*,MagicPhysX.PxInputStream*)">
            <summary>Creates a convex mesh object.  This can then be instanced into [`PxShape`] objects.  The new convex mesh.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_getNbConvexMeshes(MagicPhysX.PxPhysics*)">
            <summary>Return the number of convex meshes that currently exist.  Number of convex meshes.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_getConvexMeshes(MagicPhysX.PxPhysics*,MagicPhysX.PxConvexMesh**,System.UInt32,System.UInt32)">
            <summary>Writes the array of convex mesh pointers to a user buffer.  Returns the number of pointers written.  The ordering of the convex meshes in the array is not specified.  The number of convex mesh pointers written to userBuffer, this should be less or equal to bufferSize.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_createBVH_mut(MagicPhysX.PxPhysics*,MagicPhysX.PxInputStream*)">
            <summary>Creates a bounding volume hierarchy.  The new BVH.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_getNbBVHs(MagicPhysX.PxPhysics*)">
            <summary>Return the number of bounding volume hierarchies that currently exist.  Number of bounding volume hierarchies.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_getBVHs(MagicPhysX.PxPhysics*,MagicPhysX.PxBVH**,System.UInt32,System.UInt32)">
            <summary>Writes the array of bounding volume hierarchy pointers to a user buffer.  Returns the number of pointers written.  The ordering of the BVHs in the array is not specified.  The number of BVH pointers written to userBuffer, this should be less or equal to bufferSize.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_createScene_mut(MagicPhysX.PxPhysics*,MagicPhysX.PxSceneDesc*)">
            <summary>Creates a scene.  Every scene uses a Thread Local Storage slot. This imposes a platform specific limit on the number of scenes that can be created.  The new scene object.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_getNbScenes(MagicPhysX.PxPhysics*)">
            <summary>Gets number of created scenes.  The number of scenes created.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_getScenes(MagicPhysX.PxPhysics*,MagicPhysX.PxScene**,System.UInt32,System.UInt32)">
            <summary>Writes the array of scene pointers to a user buffer.  Returns the number of pointers written.  The ordering of the scene pointers in the array is not specified.  The number of scene pointers written to userBuffer, this should be less or equal to bufferSize.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_createRigidStatic_mut(MagicPhysX.PxPhysics*,MagicPhysX.PxTransform*)">
            <summary>Creates a static rigid actor with the specified pose and all other fields initialized to their default values.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_createRigidDynamic_mut(MagicPhysX.PxPhysics*,MagicPhysX.PxTransform*)">
            <summary>Creates a dynamic rigid actor with the specified pose and all other fields initialized to their default values.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_createPruningStructure_mut(MagicPhysX.PxPhysics*,MagicPhysX.PxRigidActor**,System.UInt32)">
            <summary>Creates a pruning structure from actors.  Every provided actor needs at least one shape with the eSCENE_QUERY_SHAPE flag set.  Both static and dynamic actors can be provided.  It is not allowed to pass in actors which are already part of a scene.  Articulation links cannot be provided.  Pruning structure created from given actors, or NULL if any of the actors did not comply with the above requirements.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_createShape_mut(MagicPhysX.PxPhysics*,MagicPhysX.PxGeometry*,MagicPhysX.PxMaterial*,System.Boolean,MagicPhysX.PxShapeFlags)">
            <summary>Creates a shape which may be attached to multiple actors  The shape will be created with a reference count of 1.  The shape  Shared shapes are not mutable when they are attached to an actor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_createShape_mut_1(MagicPhysX.PxPhysics*,MagicPhysX.PxGeometry*,MagicPhysX.PxMaterial**,System.UInt16,System.Boolean,MagicPhysX.PxShapeFlags)">
            <summary>Creates a shape which may be attached to multiple actors  The shape will be created with a reference count of 1.  The shape  Shared shapes are not mutable when they are attached to an actor  Shapes created from *SDF* triangle-mesh geometries do not support more than one material.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_getNbShapes(MagicPhysX.PxPhysics*)">
            <summary>Return the number of shapes that currently exist.  Number of shapes.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_getShapes(MagicPhysX.PxPhysics*,MagicPhysX.PxShape**,System.UInt32,System.UInt32)">
            <summary>Writes the array of shape pointers to a user buffer.  Returns the number of pointers written.  The ordering of the shapes in the array is not specified.  The number of shape pointers written to userBuffer, this should be less or equal to bufferSize.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_createConstraint_mut(MagicPhysX.PxPhysics*,MagicPhysX.PxRigidActor*,MagicPhysX.PxRigidActor*,MagicPhysX.PxConstraintConnector*,MagicPhysX.PxConstraintShaderTable*,System.UInt32)">
            <summary>Creates a constraint shader.  A constraint shader will get added automatically to the scene the two linked actors belong to. Either, but not both, of actor0 and actor1 may be NULL to denote attachment to the world.  The new constraint shader.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_createArticulationReducedCoordinate_mut(MagicPhysX.PxPhysics*)">
            <summary>Creates a reduced-coordinate articulation with all fields initialized to their default values.  the new articulation</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_createMaterial_mut(MagicPhysX.PxPhysics*,System.Single,System.Single,System.Single)">
            <summary>Creates a new rigid body material with certain default properties.  The new rigid body material.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_getNbMaterials(MagicPhysX.PxPhysics*)">
            <summary>Return the number of rigid body materials that currently exist.  Number of rigid body materials.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_getMaterials(MagicPhysX.PxPhysics*,MagicPhysX.PxMaterial**,System.UInt32,System.UInt32)">
            <summary>Writes the array of rigid body material pointers to a user buffer.  Returns the number of pointers written.  The ordering of the materials in the array is not specified.  The number of material pointers written to userBuffer, this should be less or equal to bufferSize.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_registerDeletionListener_mut(MagicPhysX.PxPhysics*,MagicPhysX.PxDeletionListener*,MagicPhysX.PxDeletionEventFlags*,System.Boolean)">
            <summary>Register a deletion listener. Listeners will be called whenever an object is deleted.  It is illegal to register or unregister a deletion listener while deletions are being processed.  By default a registered listener will receive events from all objects. Set the restrictedObjectSet parameter to true on registration and use [`registerDeletionListenerObjects`] to restrict the received events to specific objects.  The deletion events are only supported on core PhysX objects. In general, objects in extension modules do not provide this functionality, however, in the case of PxJoint objects, the underlying PxConstraint will send the events.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_unregisterDeletionListener_mut(MagicPhysX.PxPhysics*,MagicPhysX.PxDeletionListener*)">
            <summary>Unregister a deletion listener.  It is illegal to register or unregister a deletion listener while deletions are being processed.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_registerDeletionListenerObjects_mut(MagicPhysX.PxPhysics*,MagicPhysX.PxDeletionListener*,MagicPhysX.PxBase**,System.UInt32)">
            <summary>Register specific objects for deletion events.  This method allows for a deletion listener to limit deletion events to specific objects only.  It is illegal to register or unregister objects while deletions are being processed.  The deletion listener has to be registered through [`registerDeletionListener`]() and configured to support restricted object sets prior to this method being used.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_unregisterDeletionListenerObjects_mut(MagicPhysX.PxPhysics*,MagicPhysX.PxDeletionListener*,MagicPhysX.PxBase**,System.UInt32)">
            <summary>Unregister specific objects for deletion events.  This method allows to clear previously registered objects for a deletion listener (see [`registerDeletionListenerObjects`]()).  It is illegal to register or unregister objects while deletions are being processed.  The deletion listener has to be registered through [`registerDeletionListener`]() and configured to support restricted object sets prior to this method being used.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPhysics_getPhysicsInsertionCallback_mut(MagicPhysX.PxPhysics*)">
            <summary>Gets PxPhysics object insertion interface.  The insertion interface is needed for PxCreateTriangleMesh, PxCooking::createTriangleMesh etc., this allows runtime mesh creation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCreatePhysics(System.UInt32,MagicPhysX.PxFoundation*,MagicPhysX.PxTolerancesScale*,System.Boolean,MagicPhysX.PxPvd*,MagicPhysX.PxOmniPvd*)">
            <summary>Creates an instance of the physics SDK.  Creates an instance of this class. May not be a class member to avoid name mangling. Pass the constant [`PX_PHYSICS_VERSION`] as the argument. There may be only one instance of this class per process. Calling this method after an instance has been created already will result in an error message and NULL will be returned.  Calling this will register all optional code modules (Articulations and HeightFields), preparing them for use. If you do not need some of these modules, consider calling PxCreateBasePhysics() instead and registering needed modules manually.  PxPhysics instance on success, NULL if operation failed</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxQueryCache_new">
            <summary>constructor sets to default</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxQueryCache_new_1(MagicPhysX.PxShape*,System.UInt32)">
            <summary>constructor to set properties</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxQueryFilterData_new">
            <summary>default constructor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxQueryFilterData_new_1(MagicPhysX.PxFilterData*,MagicPhysX.PxQueryFlags)">
            <summary>constructor to set both filter data and filter flags</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxQueryFilterData_new_2(MagicPhysX.PxQueryFlags)">
            <summary>constructor to set filter flags only</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxQueryFilterCallback_preFilter_mut(MagicPhysX.PxQueryFilterCallback*,MagicPhysX.PxFilterData*,MagicPhysX.PxShape*,MagicPhysX.PxRigidActor*,MagicPhysX.PxHitFlags*)">
            <summary>This filter callback is executed before the exact intersection test if PxQueryFlag::ePREFILTER flag was set.  the updated type for this hit  (see [`PxQueryHitType`])</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxQueryFilterCallback_postFilter_mut(MagicPhysX.PxQueryFilterCallback*,MagicPhysX.PxFilterData*,MagicPhysX.PxQueryHit*,MagicPhysX.PxShape*,MagicPhysX.PxRigidActor*)">
            <summary>This filter callback is executed if the exact intersection test returned true and PxQueryFlag::ePOSTFILTER flag was set.  the updated hit type for this hit  (see [`PxQueryHitType`])</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxQueryFilterCallback_delete(MagicPhysX.PxQueryFilterCallback*)">
            <summary>virtual destructor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidDynamic_setKinematicTarget_mut(MagicPhysX.PxRigidDynamic*,MagicPhysX.PxTransform*)">
            <summary>Moves kinematically controlled dynamic actors through the game world.  You set a dynamic actor to be kinematic using the PxRigidBodyFlag::eKINEMATIC flag with setRigidBodyFlag().  The move command will result in a velocity that will move the body into the desired pose. After the move is carried out during a single time step, the velocity is returned to zero. Thus, you must continuously call this in every time step for kinematic actors so that they move along a path.  This function simply stores the move destination until the next simulation step is processed, so consecutive calls will simply overwrite the stored target variable.  The motion is always fully carried out.  It is invalid to use this method if the actor has not been added to a scene already or if PxActorFlag::eDISABLE_SIMULATION is set.  Sleeping: This call wakes the actor if it is sleeping and will set the wake counter to [`PxSceneDesc::wakeCounterResetValue`].</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidDynamic_getKinematicTarget(MagicPhysX.PxRigidDynamic*,MagicPhysX.PxTransform*)">
            <summary>Get target pose of a kinematically controlled dynamic actor.  True if the actor is a kinematically controlled dynamic and the target has been set, else False.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidDynamic_isSleeping(MagicPhysX.PxRigidDynamic*)">
            <summary>Returns true if this body is sleeping.  When an actor does not move for a period of time, it is no longer simulated in order to save time. This state is called sleeping. However, because the object automatically wakes up when it is either touched by an awake object, or one of its properties is changed by the user, the entire sleep mechanism should be transparent to the user.  In general, a dynamic rigid actor is guaranteed to be awake if at least one of the following holds:  The wake counter is positive (see [`setWakeCounter`]()).  The linear or angular velocity is non-zero.  A non-zero force or torque has been applied.  If a dynamic rigid actor is sleeping, the following state is guaranteed:  The wake counter is zero.  The linear and angular velocity is zero.  There is no force update pending.  When an actor gets inserted into a scene, it will be considered asleep if all the points above hold, else it will be treated as awake.  If an actor is asleep after the call to PxScene::fetchResults() returns, it is guaranteed that the pose of the actor was not changed. You can use this information to avoid updating the transforms of associated objects.  A kinematic actor is asleep unless a target pose has been set (in which case it will stay awake until two consecutive simulation steps without a target pose being set have passed). The wake counter will get set to zero or to the reset value [`PxSceneDesc::wakeCounterResetValue`] in the case where a target pose has been set to be consistent with the definitions above.  It is invalid to use this method if the actor has not been added to a scene already.  It is not allowed to use this method while the simulation is running.  True if the actor is sleeping.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidDynamic_setSleepThreshold_mut(MagicPhysX.PxRigidDynamic*,System.Single)">
            <summary>Sets the mass-normalized kinetic energy threshold below which an actor may go to sleep.  Actors whose kinetic energy divided by their mass is below this threshold will be candidates for sleeping.  Default: 5e-5f * PxTolerancesScale::speed * PxTolerancesScale::speed</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidDynamic_getSleepThreshold(MagicPhysX.PxRigidDynamic*)">
            <summary>Returns the mass-normalized kinetic energy below which an actor may go to sleep.  The energy threshold for sleeping.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidDynamic_setStabilizationThreshold_mut(MagicPhysX.PxRigidDynamic*,System.Single)">
            <summary>Sets the mass-normalized kinetic energy threshold below which an actor may participate in stabilization.  Actors whose kinetic energy divided by their mass is above this threshold will not participate in stabilization.  This value has no effect if PxSceneFlag::eENABLE_STABILIZATION was not enabled on the PxSceneDesc.  Default: 1e-5f * PxTolerancesScale::speed * PxTolerancesScale::speed</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidDynamic_getStabilizationThreshold(MagicPhysX.PxRigidDynamic*)">
            <summary>Returns the mass-normalized kinetic energy below which an actor may participate in stabilization.  Actors whose kinetic energy divided by their mass is above this threshold will not participate in stabilization.  The energy threshold for participating in stabilization.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidDynamic_getRigidDynamicLockFlags(MagicPhysX.PxRigidDynamic*)">
            <summary>Reads the PxRigidDynamic lock flags.  See the list of flags [`PxRigidDynamicLockFlag`]  The values of the PxRigidDynamicLock flags.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidDynamic_setRigidDynamicLockFlag_mut(MagicPhysX.PxRigidDynamic*,MagicPhysX.PxRigidDynamicLockFlag,System.Boolean)">
            <summary>Raises or clears a particular rigid dynamic lock flag.  See the list of flags [`PxRigidDynamicLockFlag`]  Default: no flags are set</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidDynamic_getLinearVelocity(MagicPhysX.PxRigidDynamic*)">
            <summary>Retrieves the linear velocity of an actor.  It is not allowed to use this method while the simulation is running (except during PxScene::collide(), in PxContactModifyCallback or in contact report callbacks).  The linear velocity of the actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidDynamic_setLinearVelocity_mut(MagicPhysX.PxRigidDynamic*,MagicPhysX.PxVec3*,System.Boolean)">
            <summary>Sets the linear velocity of the actor.  Note that if you continuously set the velocity of an actor yourself, forces such as gravity or friction will not be able to manifest themselves, because forces directly influence only the velocity/momentum of an actor.  Default: (0.0, 0.0, 0.0)  Sleeping: This call wakes the actor if it is sleeping, and the autowake parameter is true (default) or the new velocity is non-zero.  It is invalid to use this method if PxActorFlag::eDISABLE_SIMULATION is set.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidDynamic_getAngularVelocity(MagicPhysX.PxRigidDynamic*)">
            <summary>Retrieves the angular velocity of the actor.  It is not allowed to use this method while the simulation is running (except during PxScene::collide(), in PxContactModifyCallback or in contact report callbacks).  The angular velocity of the actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidDynamic_setAngularVelocity_mut(MagicPhysX.PxRigidDynamic*,MagicPhysX.PxVec3*,System.Boolean)">
            <summary>Sets the angular velocity of the actor.  Note that if you continuously set the angular velocity of an actor yourself, forces such as friction will not be able to rotate the actor, because forces directly influence only the velocity/momentum.  Default: (0.0, 0.0, 0.0)  Sleeping: This call wakes the actor if it is sleeping, and the autowake parameter is true (default) or the new velocity is non-zero.  It is invalid to use this method if PxActorFlag::eDISABLE_SIMULATION is set.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidDynamic_setWakeCounter_mut(MagicPhysX.PxRigidDynamic*,System.Single)">
            <summary>Sets the wake counter for the actor.  The wake counter value determines the minimum amount of time until the body can be put to sleep. Please note that a body will not be put to sleep if the energy is above the specified threshold (see [`setSleepThreshold`]()) or if other awake bodies are touching it.  Passing in a positive value will wake the actor up automatically.  It is invalid to use this method for kinematic actors since the wake counter for kinematics is defined based on whether a target pose has been set (see the comment in [`isSleeping`]()).  It is invalid to use this method if PxActorFlag::eDISABLE_SIMULATION is set.  Default: 0.4 (which corresponds to 20 frames for a time step of 0.02)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidDynamic_getWakeCounter(MagicPhysX.PxRigidDynamic*)">
            <summary>Returns the wake counter of the actor.  It is not allowed to use this method while the simulation is running.  The wake counter of the actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidDynamic_wakeUp_mut(MagicPhysX.PxRigidDynamic*)">
            <summary>Wakes up the actor if it is sleeping.  The actor will get woken up and might cause other touching actors to wake up as well during the next simulation step.  This will set the wake counter of the actor to the value specified in [`PxSceneDesc::wakeCounterResetValue`].  It is invalid to use this method if the actor has not been added to a scene already or if PxActorFlag::eDISABLE_SIMULATION is set.  It is invalid to use this method for kinematic actors since the sleep state for kinematics is defined based on whether a target pose has been set (see the comment in [`isSleeping`]()).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidDynamic_putToSleep_mut(MagicPhysX.PxRigidDynamic*)">
            <summary>Forces the actor to sleep.  The actor will stay asleep during the next simulation step if not touched by another non-sleeping actor.  Any applied force will be cleared and the velocity and the wake counter of the actor will be set to 0.  It is invalid to use this method if the actor has not been added to a scene already or if PxActorFlag::eDISABLE_SIMULATION is set.  It is invalid to use this method for kinematic actors since the sleep state for kinematics is defined based on whether a target pose has been set (see the comment in [`isSleeping`]()).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidDynamic_setSolverIterationCounts_mut(MagicPhysX.PxRigidDynamic*,System.UInt32,System.UInt32)">
            <summary>Sets the solver iteration counts for the body.  The solver iteration count determines how accurately joints and contacts are resolved. If you are having trouble with jointed bodies oscillating and behaving erratically, then setting a higher position iteration count may improve their stability.  If intersecting bodies are being depenetrated too violently, increase the number of velocity iterations. More velocity iterations will drive the relative exit velocity of the intersecting objects closer to the correct value given the restitution.  Default: 4 position iterations, 1 velocity iteration</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidDynamic_getSolverIterationCounts(MagicPhysX.PxRigidDynamic*,System.UInt32*,System.UInt32*)">
            <summary>Retrieves the solver iteration counts.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidDynamic_getContactReportThreshold(MagicPhysX.PxRigidDynamic*)">
            <summary>Retrieves the force threshold for contact reports.  The contact report threshold is a force threshold. If the force between two actors exceeds this threshold for either of the two actors, a contact report will be generated according to the contact report threshold flags provided by the filter shader/callback. See [`PxPairFlag`].  The threshold used for a collision between a dynamic actor and the static environment is the threshold of the dynamic actor, and all contacts with static actors are summed to find the total normal force.  Default: PX_MAX_F32  Force threshold for contact reports.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidDynamic_setContactReportThreshold_mut(MagicPhysX.PxRigidDynamic*,System.Single)">
            <summary>Sets the force threshold for contact reports.  See [`getContactReportThreshold`]().</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQueryDesc_new">
            <summary>constructor sets to default.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQueryDesc_setToDefault_mut(MagicPhysX.PxSceneQueryDesc*)">
            <summary>(re)sets the structure to the default.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQueryDesc_isValid(MagicPhysX.PxSceneQueryDesc*)">
            <summary>Returns true if the descriptor is valid.  true if the current settings are valid.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQuerySystemBase_setDynamicTreeRebuildRateHint_mut(MagicPhysX.PxSceneQuerySystemBase*,System.UInt32)">
            <summary>Sets the rebuild rate of the dynamic tree pruning structures.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQuerySystemBase_getDynamicTreeRebuildRateHint(MagicPhysX.PxSceneQuerySystemBase*)">
            <summary>Retrieves the rebuild rate of the dynamic tree pruning structures.  The rebuild rate of the dynamic tree pruning structures.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQuerySystemBase_forceRebuildDynamicTree_mut(MagicPhysX.PxSceneQuerySystemBase*,System.UInt32)">
            <summary>Forces dynamic trees to be immediately rebuilt.  PxScene will call this function with the PX_SCENE_PRUNER_STATIC or PX_SCENE_PRUNER_DYNAMIC value.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQuerySystemBase_setUpdateMode_mut(MagicPhysX.PxSceneQuerySystemBase*,MagicPhysX.PxSceneQueryUpdateMode)">
            <summary>Sets scene query update mode</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQuerySystemBase_getUpdateMode(MagicPhysX.PxSceneQuerySystemBase*)">
            <summary>Gets scene query update mode  Current scene query update mode.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQuerySystemBase_getStaticTimestamp(MagicPhysX.PxSceneQuerySystemBase*)">
            <summary>Retrieves the system's internal scene query timestamp, increased each time a change to the static scene query structure is performed.  scene query static timestamp</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQuerySystemBase_flushUpdates_mut(MagicPhysX.PxSceneQuerySystemBase*)">
            <summary>Flushes any changes to the scene query representation.  This method updates the state of the scene query representation to match changes in the scene state.  By default, these changes are buffered until the next query is submitted. Calling this function will not change the results from scene queries, but can be used to ensure that a query will not perform update work in the course of its execution.  A thread performing updates will hold a write lock on the query structure, and thus stall other querying threads. In multithread scenarios it can be useful to explicitly schedule the period where this lock may be held for a significant period, so that subsequent queries issued from multiple threads will not block.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQuerySystemBase_raycast(MagicPhysX.PxSceneQuerySystemBase*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxRaycastCallback*,MagicPhysX.PxHitFlags,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryFilterCallback*,MagicPhysX.PxQueryCache*,MagicPhysX.PxGeometryQueryFlags)">
            <summary>Performs a raycast against objects in the scene, returns results in a PxRaycastBuffer object or via a custom user callback implementation inheriting from PxRaycastCallback.  Touching hits are not ordered.  Shooting a ray from within an object leads to different results depending on the shape type. Please check the details in user guide article SceneQuery. User can ignore such objects by employing one of the provided filter mechanisms.  True if any touching or blocking hits were found or any hit was found in case PxQueryFlag::eANY_HIT was specified.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQuerySystemBase_sweep(MagicPhysX.PxSceneQuerySystemBase*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxSweepCallback*,MagicPhysX.PxHitFlags,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryFilterCallback*,MagicPhysX.PxQueryCache*,System.Single,MagicPhysX.PxGeometryQueryFlags)">
            <summary>Performs a sweep test against objects in the scene, returns results in a PxSweepBuffer object or via a custom user callback implementation inheriting from PxSweepCallback.  Touching hits are not ordered.  If a shape from the scene is already overlapping with the query shape in its starting position, the hit is returned unless eASSUME_NO_INITIAL_OVERLAP was specified.  True if any touching or blocking hits were found or any hit was found in case PxQueryFlag::eANY_HIT was specified.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQuerySystemBase_overlap(MagicPhysX.PxSceneQuerySystemBase*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxOverlapCallback*,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryFilterCallback*,MagicPhysX.PxQueryCache*,MagicPhysX.PxGeometryQueryFlags)">
            <summary>Performs an overlap test of a given geometry against objects in the scene, returns results in a PxOverlapBuffer object or via a custom user callback implementation inheriting from PxOverlapCallback.  Filtering: returning eBLOCK from user filter for overlap queries will cause a warning (see [`PxQueryHitType`]).  True if any touching or blocking hits were found or any hit was found in case PxQueryFlag::eANY_HIT was specified.  eBLOCK should not be returned from user filters for overlap(). Doing so will result in undefined behavior, and a warning will be issued.  If the PxQueryFlag::eNO_BLOCK flag is set, the eBLOCK will instead be automatically converted to an eTOUCH and the warning suppressed.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneSQSystem_setSceneQueryUpdateMode_mut(MagicPhysX.PxSceneSQSystem*,MagicPhysX.PxSceneQueryUpdateMode)">
            <summary>Sets scene query update mode</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneSQSystem_getSceneQueryUpdateMode(MagicPhysX.PxSceneSQSystem*)">
            <summary>Gets scene query update mode  Current scene query update mode.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneSQSystem_getSceneQueryStaticTimestamp(MagicPhysX.PxSceneSQSystem*)">
            <summary>Retrieves the scene's internal scene query timestamp, increased each time a change to the static scene query structure is performed.  scene query static timestamp</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneSQSystem_flushQueryUpdates_mut(MagicPhysX.PxSceneSQSystem*)">
            <summary>Flushes any changes to the scene query representation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneSQSystem_forceDynamicTreeRebuild_mut(MagicPhysX.PxSceneSQSystem*,System.Boolean,System.Boolean)">
            <summary>Forces dynamic trees to be immediately rebuilt.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneSQSystem_getStaticStructure(MagicPhysX.PxSceneSQSystem*)">
            <summary>Return the value of PxSceneQueryDesc::staticStructure that was set when creating the scene with PxPhysics::createScene</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneSQSystem_getDynamicStructure(MagicPhysX.PxSceneSQSystem*)">
            <summary>Return the value of PxSceneQueryDesc::dynamicStructure that was set when creating the scene with PxPhysics::createScene</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneSQSystem_sceneQueriesUpdate_mut(MagicPhysX.PxSceneSQSystem*,MagicPhysX.PxBaseTask*,System.Boolean)">
            <summary>Executes scene queries update tasks.  This function will refit dirty shapes within the pruner and will execute a task to build a new AABB tree, which is build on a different thread. The new AABB tree is built based on the dynamic tree rebuild hint rate. Once the new tree is ready it will be commited in next fetchQueries call, which must be called after.  This function is equivalent to the following PxSceneQuerySystem calls: Synchronous calls: - PxSceneQuerySystemBase::flushUpdates() - handle0 = PxSceneQuerySystem::prepareSceneQueryBuildStep(PX_SCENE_PRUNER_STATIC) - handle1 = PxSceneQuerySystem::prepareSceneQueryBuildStep(PX_SCENE_PRUNER_DYNAMIC) Asynchronous calls: - PxSceneQuerySystem::sceneQueryBuildStep(handle0); - PxSceneQuerySystem::sceneQueryBuildStep(handle1);  This function is part of the PxSceneSQSystem interface because it uses the PxScene task system under the hood. But it calls PxSceneQuerySystem functions, which are independent from this system and could be called in a similar fashion by a separate, possibly user-defined task manager.  If PxSceneQueryUpdateMode::eBUILD_DISABLED_COMMIT_DISABLED is used, it is required to update the scene queries using this function.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneSQSystem_checkQueries_mut(MagicPhysX.PxSceneSQSystem*,System.Boolean)">
            <summary>This checks to see if the scene queries update has completed.  This does not cause the data available for reading to be updated with the results of the scene queries update, it is simply a status check. The bool will allow it to either return immediately or block waiting for the condition to be met so that it can return true  True if the results are available.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneSQSystem_fetchQueries_mut(MagicPhysX.PxSceneSQSystem*,System.Boolean)">
            <summary>This method must be called after sceneQueriesUpdate. It will wait for the scene queries update to finish. If the user makes an illegal scene queries update call, the SDK will issue an error message.  If a new AABB tree build finished, then during fetchQueries the current tree within the pruning structure is swapped with the new tree.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQuerySystem_release_mut(MagicPhysX.PxSceneQuerySystem*)">
            <summary>Decrements the reference count of the object and releases it if the new reference count is zero.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQuerySystem_acquireReference_mut(MagicPhysX.PxSceneQuerySystem*)">
            <summary>Acquires a counted reference to this object.  This method increases the reference count of the object by 1. Decrement the reference count by calling release()</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQuerySystem_preallocate_mut(MagicPhysX.PxSceneQuerySystem*,System.UInt32,System.UInt32)">
            <summary>Preallocates internal arrays to minimize the amount of reallocations.  The system does not prevent more allocations than given numbers. It is legal to not call this function at all, or to add more shapes to the system than the preallocated amounts.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQuerySystem_flushMemory_mut(MagicPhysX.PxSceneQuerySystem*)">
            <summary>Frees internal memory that may not be in-use anymore.  This is an entry point for reclaiming transient memory allocated at some point by the SQ system, but which wasn't been immediately freed for performance reason. Calling this function might free some memory, but it might also produce a new set of allocations in the next frame.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQuerySystem_addSQShape_mut(MagicPhysX.PxSceneQuerySystem*,MagicPhysX.PxRigidActor*,MagicPhysX.PxShape*,MagicPhysX.PxBounds3*,MagicPhysX.PxTransform*,System.UInt32*,System.Boolean)">
            <summary>Adds a shape to the SQ system.  The same function is used to add either a regular shape, or a SQ compound shape.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQuerySystem_removeSQShape_mut(MagicPhysX.PxSceneQuerySystem*,MagicPhysX.PxRigidActor*,MagicPhysX.PxShape*)">
            <summary>Removes a shape from the SQ system.  The same function is used to remove either a regular shape, or a SQ compound shape.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQuerySystem_updateSQShape_mut(MagicPhysX.PxSceneQuerySystem*,MagicPhysX.PxRigidActor*,MagicPhysX.PxShape*,MagicPhysX.PxTransform*)">
            <summary>Updates a shape in the SQ system.  The same function is used to update either a regular shape, or a SQ compound shape.  The transforms are eager-evaluated, but the bounds are lazy-evaluated. This means that the updated transform has to be passed to the update function, while the bounds are automatically recomputed by the system whenever needed.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQuerySystem_addSQCompound_mut(MagicPhysX.PxSceneQuerySystem*,MagicPhysX.PxRigidActor*,MagicPhysX.PxShape**,MagicPhysX.PxBVH*,MagicPhysX.PxTransform*)">
            <summary>Adds a compound to the SQ system.  SQ compound handle</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQuerySystem_removeSQCompound_mut(MagicPhysX.PxSceneQuerySystem*,System.UInt32)">
            <summary>Removes a compound from the SQ system.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQuerySystem_updateSQCompound_mut(MagicPhysX.PxSceneQuerySystem*,System.UInt32,MagicPhysX.PxTransform*)">
            <summary>Updates a compound in the SQ system.  The compound structures are immediately updated when the call occurs.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQuerySystem_shiftOrigin_mut(MagicPhysX.PxSceneQuerySystem*,MagicPhysX.PxVec3*)">
            <summary>Shift the data structures' origin by the specified vector.  Please refer to the notes of the similar function in PxScene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQuerySystem_merge_mut(MagicPhysX.PxSceneQuerySystem*,MagicPhysX.PxPruningStructure*)">
            <summary>Merges a pruning structure with the SQ system's internal pruners.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQuerySystem_getHandle(MagicPhysX.PxSceneQuerySystem*,MagicPhysX.PxRigidActor*,MagicPhysX.PxShape*,System.UInt32*)">
            <summary>Shape to SQ-pruner-handle mapping function.  This function finds and returns the SQ pruner handle associated with a given (actor/shape) couple that was previously added to the system. This is needed for the sync function.  Associated SQ pruner handle.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQuerySystem_sync_mut(MagicPhysX.PxSceneQuerySystem*,System.UInt32,System.UInt32*,System.UInt32*,MagicPhysX.PxBounds3*,MagicPhysX.PxTransformPadded*,System.UInt32,MagicPhysX.PxBitMap*)">
            <summary>Synchronizes the scene-query system with another system that references the same objects.  This function is used when the scene-query objects also exist in another system that can also update them. For example the scene-query objects (used for raycast, overlap or sweep queries) might be driven by equivalent objects in an external rigid-body simulation engine. In this case the rigid-body simulation engine computes the new poses and transforms, and passes them to the scene-query system using this function. It is more efficient than calling updateSQShape on each object individually, since updateSQShape would end up recomputing the bounds already available in the rigid-body engine.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQuerySystem_finalizeUpdates_mut(MagicPhysX.PxSceneQuerySystem*)">
            <summary>Finalizes updates made to the SQ system.  This function should be called after updates have been made to the SQ system, to fully reflect the changes inside the internal pruners. In particular it should be called: - after calls to updateSQShape - after calls to sync  This function: - recomputes bounds of manually updated shapes (i.e. either regular or SQ compound shapes modified by updateSQShape) - updates dynamic pruners (refit operations) - incrementally rebuilds AABB-trees  The amount of work performed in this function depends on PxSceneQueryUpdateMode.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQuerySystem_prepareSceneQueryBuildStep_mut(MagicPhysX.PxSceneQuerySystem*,System.UInt32)">
            <summary>Prepares asynchronous build step.  This is directly called (synchronously) by PxSceneSQSystem::sceneQueriesUpdate(). See the comments there.  This function is called to let the system execute any necessary synchronous operation before the asynchronous sceneQueryBuildStep() function is called.  If there is any work to do for the specific pruner, the function returns a pruner-specific handle that will be passed to the corresponding, asynchronous sceneQueryBuildStep function.  A pruner-specific handle that will be sent to sceneQueryBuildStep if there is any work to do, i.e. to execute the corresponding sceneQueryBuildStep() call.  Null if there is no work to do, otherwise a pruner-specific handle.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQuerySystem_sceneQueryBuildStep_mut(MagicPhysX.PxSceneQuerySystem*,System.Void*)">
            <summary>Executes asynchronous build step.  This is directly called (asynchronously) by PxSceneSQSystem::sceneQueriesUpdate(). See the comments there.  This function incrementally builds the internal trees/pruners. It is called asynchronously, i.e. this can be called from different threads for building multiple trees at the same time.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxGetBroadPhaseStaticFilterGroup">
            <summary>Retrieves the filter group for static objects.  Mark static objects with this group when adding them to the broadphase. Overlaps between static objects will not be detected. All static objects should have the same group.  Filter group for static objects.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxGetBroadPhaseDynamicFilterGroup(System.UInt32)">
            <summary>Retrieves a filter group for dynamic objects.  Mark dynamic objects with this group when adding them to the broadphase. Each dynamic object must have an ID, and overlaps between dynamic objects that have the same ID will not be detected. This is useful to dismiss overlaps between shapes of the same (compound) actor directly within the broadphase.  Filter group for the object.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxGetBroadPhaseKinematicFilterGroup(System.UInt32)">
            <summary>Retrieves a filter group for kinematic objects.  Mark kinematic objects with this group when adding them to the broadphase. Each kinematic object must have an ID, and overlaps between kinematic objects that have the same ID will not be detected.  Filter group for the object.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBroadPhaseRegions_getNbRegions(MagicPhysX.PxBroadPhaseRegions*)">
            <summary>Returns number of regions currently registered in the broad-phase.  Number of regions</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBroadPhaseRegions_getRegions(MagicPhysX.PxBroadPhaseRegions*,MagicPhysX.PxBroadPhaseRegionInfo*,System.UInt32,System.UInt32)">
            <summary>Gets broad-phase regions.  Number of written out regions.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBroadPhaseRegions_addRegion_mut(MagicPhysX.PxBroadPhaseRegions*,MagicPhysX.PxBroadPhaseRegion*,System.Boolean,MagicPhysX.PxBounds3*,System.Single*)">
            <summary>Adds a new broad-phase region.  The total number of regions is limited to PxBroadPhaseCaps::mMaxNbRegions. If that number is exceeded, the call is ignored.  The newly added region will be automatically populated with already existing objects that touch it, if the 'populateRegion' parameter is set to true. Otherwise the newly added region will be empty, and it will only be populated with objects when those objects are added to the simulation, or updated if they already exist.  Using 'populateRegion=true' has a cost, so it is best to avoid it if possible. In particular it is more efficient to create the empty regions first (with populateRegion=false) and then add the objects afterwards (rather than the opposite).  Objects automatically move from one region to another during their lifetime. The system keeps tracks of what regions a given object is in. It is legal for an object to be in an arbitrary number of regions. However if an object leaves all regions, or is created outside of all regions, several things happen: - collisions get disabled for this object - the object appears in the getOutOfBoundsObjects() array  If an out-of-bounds object, whose collisions are disabled, re-enters a valid broadphase region, then collisions are re-enabled for that object.  Handle for newly created region, or 0xffffffff in case of failure.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBroadPhaseRegions_removeRegion_mut(MagicPhysX.PxBroadPhaseRegions*,System.UInt32)">
            <summary>Removes a broad-phase region.  If the region still contains objects, and if those objects do not overlap any region any more, they are not automatically removed from the simulation. Instead, the PxBroadPhaseCallback::onObjectOutOfBounds notification is used for each object. Users are responsible for removing the objects from the simulation if this is the desired behavior.  If the handle is invalid, or if a valid handle is removed twice, an error message is sent to the error stream.  True if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBroadPhase_getType(MagicPhysX.PxBroadPhase*)">
            <summary>Gets the broadphase type.  Broadphase type.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBroadPhase_getCaps(MagicPhysX.PxBroadPhase*,MagicPhysX.PxBroadPhaseCaps*)">
            <summary>Gets broad-phase caps.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBroadPhase_getRegions_mut(MagicPhysX.PxBroadPhase*)">
            <summary>Retrieves the regions API if applicable.  For broadphases that do not use explicit user-defined regions, this call returns NULL.  Region API, or NULL.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBroadPhase_getAllocator_mut(MagicPhysX.PxBroadPhase*)">
            <summary>Retrieves the broadphase allocator.  User-provided buffers should ideally be allocated with this allocator, for best performance. This is especially true for the GPU broadphases, whose buffers need to be allocated in CUDA host memory.  The broadphase allocator.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBroadPhase_getContextID(MagicPhysX.PxBroadPhase*)">
            <summary>Retrieves the profiler's context ID.  The context ID.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBroadPhase_setScratchBlock_mut(MagicPhysX.PxBroadPhase*,System.Void*,System.UInt32)">
            <summary>Sets a scratch buffer  Some broadphases might take advantage of a scratch buffer to limit runtime allocations.  All broadphases still work without providing a scratch buffer, this is an optional function that can potentially reduce runtime allocations.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBroadPhase_update_mut(MagicPhysX.PxBroadPhase*,MagicPhysX.PxBroadPhaseUpdateData*,MagicPhysX.PxBaseTask*)">
            <summary>Updates the broadphase and computes the lists of created/deleted pairs.  The provided update data describes changes to objects since the last broadphase update.  To benefit from potentially multithreaded implementations, it is necessary to provide a continuation task to the function. It is legal to pass NULL there, but the underlying (CPU) implementations will then run single-threaded.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBroadPhase_fetchResults_mut(MagicPhysX.PxBroadPhase*,MagicPhysX.PxBroadPhaseResults*)">
            <summary>Retrieves the broadphase results after an update.  This should be called once after each update call to retrieve the results of the broadphase. The results are incremental, i.e. the system only returns new and lost pairs, not all current pairs.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBroadPhase_update_mut_1(MagicPhysX.PxBroadPhase*,MagicPhysX.PxBroadPhaseResults*,MagicPhysX.PxBroadPhaseUpdateData*)">
            <summary>Helper for single-threaded updates.  This short helper function performs a single-theaded update and reports the results in a single call.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCreateBroadPhase(MagicPhysX.PxBroadPhaseDesc*)">
            <summary>Broadphase factory function.  Use this function to create a new standalone broadphase.  Newly created broadphase, or NULL</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxAABBManager_getBroadPhase_mut(MagicPhysX.PxAABBManager*)">
            <summary>Retrieves the underlying broadphase.  The managed broadphase.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxAABBManager_getBounds(MagicPhysX.PxAABBManager*)">
            <summary>Retrieves the managed bounds.  This is needed as input parameters to functions like PxBroadPhaseRegions::addRegion.  The managed object bounds.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxAABBManager_getDistances(MagicPhysX.PxAABBManager*)">
            <summary>Retrieves the managed distances.  This is needed as input parameters to functions like PxBroadPhaseRegions::addRegion.  The managed object distances.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxAABBManager_getGroups(MagicPhysX.PxAABBManager*)">
            <summary>Retrieves the managed filter groups.  The managed object groups.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxAABBManager_getCapacity(MagicPhysX.PxAABBManager*)">
            <summary>Retrieves the managed buffers' capacity.  Bounds, distances and groups buffers have the same capacity.  The managed buffers' capacity.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxAABBManager_addObject_mut(MagicPhysX.PxAABBManager*,System.UInt32,MagicPhysX.PxBounds3*,System.UInt32,System.Single)">
            <summary>Adds an object to the manager.  Objects' indices are externally managed, i.e. they must be provided by users (as opposed to handles that could be returned by this manager). The design allows users to identify an object by a single ID, and use the same ID in multiple sub-systems.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxAABBManager_removeObject_mut(MagicPhysX.PxAABBManager*,System.UInt32)">
            <summary>Removes an object from the manager.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxAABBManager_updateObject_mut(MagicPhysX.PxAABBManager*,System.UInt32,MagicPhysX.PxBounds3*,System.Single*)">
            <summary>Updates an object in the manager.  This call can update an object's bounds, distance, or both. It is not possible to update an object's filter group.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxAABBManager_update_mut(MagicPhysX.PxAABBManager*,MagicPhysX.PxBaseTask*)">
            <summary>Updates the broadphase and computes the lists of created/deleted pairs.  The data necessary for updating the broadphase is internally computed by the AABB manager.  To benefit from potentially multithreaded implementations, it is necessary to provide a continuation task to the function. It is legal to pass NULL there, but the underlying (CPU) implementations will then run single-threaded.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxAABBManager_fetchResults_mut(MagicPhysX.PxAABBManager*,MagicPhysX.PxBroadPhaseResults*)">
            <summary>Retrieves the broadphase results after an update.  This should be called once after each update call to retrieve the results of the broadphase. The results are incremental, i.e. the system only returns new and lost pairs, not all current pairs.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxAABBManager_update_mut_1(MagicPhysX.PxAABBManager*,MagicPhysX.PxBroadPhaseResults*)">
            <summary>Helper for single-threaded updates.  This short helper function performs a single-theaded update and reports the results in a single call.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCreateAABBManager(MagicPhysX.PxBroadPhase*)">
            <summary>AABB manager factory function.  Use this function to create a new standalone high-level broadphase.  Newly created AABB manager, or NULL</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneLimits_new">
            <summary>constructor sets to default</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneLimits_setToDefault_mut(MagicPhysX.PxSceneLimits*)">
            <summary>(re)sets the structure to the default</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneLimits_isValid(MagicPhysX.PxSceneLimits*)">
            <summary>Returns true if the descriptor is valid.  true if the current settings are valid.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneDesc_new(MagicPhysX.PxTolerancesScale*)">
            <summary>constructor sets to default.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneDesc_setToDefault_mut(MagicPhysX.PxSceneDesc*,MagicPhysX.PxTolerancesScale*)">
            <summary>(re)sets the structure to the default.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneDesc_isValid(MagicPhysX.PxSceneDesc*)">
            <summary>Returns true if the descriptor is valid.  true if the current settings are valid.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSimulationStatistics_getNbBroadPhaseAdds(MagicPhysX.PxSimulationStatistics*)">
            <summary>Get number of broadphase volumes added for the current simulation step.  Number of broadphase volumes added.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSimulationStatistics_getNbBroadPhaseRemoves(MagicPhysX.PxSimulationStatistics*)">
            <summary>Get number of broadphase volumes removed for the current simulation step.  Number of broadphase volumes removed.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSimulationStatistics_getRbPairStats(MagicPhysX.PxSimulationStatistics*,MagicPhysX.RbPairStatsType,MagicPhysX.PxGeometryType,MagicPhysX.PxGeometryType)">
            <summary>Get number of shape collision pairs of a certain type processed for the current simulation step.  There is an entry for each geometry pair type.  entry[i][j] = entry[j][i], hence, if you want the sum of all pair types, you need to discard the symmetric entries  Number of processed pairs of the specified geometry types.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPvdSceneClient_setScenePvdFlag_mut(MagicPhysX.PxPvdSceneClient*,MagicPhysX.PxPvdSceneFlag,System.Boolean)">
            <summary>Sets the PVD flag. See PxPvdSceneFlag.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPvdSceneClient_setScenePvdFlags_mut(MagicPhysX.PxPvdSceneClient*,MagicPhysX.PxPvdSceneFlags)">
            <summary>Sets the PVD flags. See PxPvdSceneFlags.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPvdSceneClient_getScenePvdFlags(MagicPhysX.PxPvdSceneClient*)">
            <summary>Retrieves the PVD flags. See PxPvdSceneFlags.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPvdSceneClient_updateCamera_mut(MagicPhysX.PxPvdSceneClient*,System.Byte*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>update camera on PVD application's render window</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPvdSceneClient_drawPoints_mut(MagicPhysX.PxPvdSceneClient*,MagicPhysX.PxDebugPoint*,System.UInt32)">
            <summary>draw points on PVD application's render window</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPvdSceneClient_drawLines_mut(MagicPhysX.PxPvdSceneClient*,MagicPhysX.PxDebugLine*,System.UInt32)">
            <summary>draw lines on PVD application's render window</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPvdSceneClient_drawTriangles_mut(MagicPhysX.PxPvdSceneClient*,MagicPhysX.PxDebugTriangle*,System.UInt32)">
            <summary>draw triangles on PVD application's render window</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPvdSceneClient_drawText_mut(MagicPhysX.PxPvdSceneClient*,MagicPhysX.PxDebugText*)">
            <summary>draw text on PVD application's render window</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBroadPhaseCallback_onObjectOutOfBounds_mut(MagicPhysX.PxBroadPhaseCallback*,MagicPhysX.PxShape*,MagicPhysX.PxActor*)">
            <summary>Out-of-bounds notification.  This function is called when an object leaves the broad-phase.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBroadPhaseCallback_onObjectOutOfBounds_mut_1(MagicPhysX.PxBroadPhaseCallback*,MagicPhysX.PxAggregate*)">
            <summary>Out-of-bounds notification.  This function is called when an aggregate leaves the broad-phase.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_release_mut(MagicPhysX.PxScene*)">
            <summary>Deletes the scene.  Removes any actors and constraint shaders from this scene (if the user hasn't already done so).  Be sure to not keep a reference to this object after calling release. Avoid release calls while the scene is simulating (in between simulate() and fetchResults() calls).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_setFlag_mut(MagicPhysX.PxScene*,MagicPhysX.PxSceneFlag,System.Boolean)">
            <summary>Sets a scene flag. You can only set one flag at a time.  Not all flags are mutable and changing some will result in an error. Please check [`PxSceneFlag`] to see which flags can be changed.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getFlags(MagicPhysX.PxScene*)">
            <summary>Get the scene flags.  The scene flags. See [`PxSceneFlag`]</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_setLimits_mut(MagicPhysX.PxScene*,MagicPhysX.PxSceneLimits*)">
            <summary>Set new scene limits.  Increase the maximum capacity of various data structures in the scene. The new capacities will be at least as large as required to deal with the objects currently in the scene. Further, these values are for preallocation and do not represent hard limits.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getLimits(MagicPhysX.PxScene*)">
            <summary>Get current scene limits.  Current scene limits.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getPhysics_mut(MagicPhysX.PxScene*)">
            <summary>Call this method to retrieve the Physics SDK.  The physics SDK this scene is associated with.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getTimestamp(MagicPhysX.PxScene*)">
            <summary>Retrieves the scene's internal timestamp, increased each time a simulation step is completed.  scene timestamp</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_addArticulation_mut(MagicPhysX.PxScene*,MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Adds an articulation to this scene.  If the articulation is already assigned to a scene (see [`PxArticulationReducedCoordinate::getScene`]), the call is ignored and an error is issued.  True if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_removeArticulation_mut(MagicPhysX.PxScene*,MagicPhysX.PxArticulationReducedCoordinate*,System.Boolean)">
            <summary>Removes an articulation from this scene.  If the articulation is not part of this scene (see [`PxArticulationReducedCoordinate::getScene`]), the call is ignored and an error is issued.  If the articulation is in an aggregate it will be removed from the aggregate.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_addActor_mut(MagicPhysX.PxScene*,MagicPhysX.PxActor*,MagicPhysX.PxBVH*)">
            <summary>Adds an actor to this scene.  If the actor is already assigned to a scene (see [`PxActor::getScene`]), the call is ignored and an error is issued.  If the actor has an invalid constraint, in checked builds the call is ignored and an error is issued.  You can not add individual articulation links (see [`PxArticulationLink`]) to the scene. Use #addArticulation() instead.  If the actor is a PxRigidActor then each assigned PxConstraint object will get added to the scene automatically if it connects to another actor that is part of the scene already.  When a BVH is provided the actor shapes are grouped together. The scene query pruning structure inside PhysX SDK will store/update one bound per actor. The scene queries against such an actor will query actor bounds and then make a local space query against the provided BVH, which is in actor's local space.  True if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_addActors_mut(MagicPhysX.PxScene*,MagicPhysX.PxActor**,System.UInt32)">
            <summary>Adds actors to this scene. Only supports actors of type PxRigidStatic and PxRigidDynamic.  This method only supports actors of type PxRigidStatic and PxRigidDynamic. For other actors, use addActor() instead. For articulation links, use addArticulation().  If one of the actors is already assigned to a scene (see [`PxActor::getScene`]), the call is ignored and an error is issued.  If an actor in the array contains an invalid constraint, in checked builds the call is ignored and an error is issued.  If an actor in the array is a PxRigidActor then each assigned PxConstraint object will get added to the scene automatically if it connects to another actor that is part of the scene already.  this method is optimized for high performance.  True if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_addActors_mut_1(MagicPhysX.PxScene*,MagicPhysX.PxPruningStructure*)">
            <summary>Adds a pruning structure together with its actors to this scene. Only supports actors of type PxRigidStatic and PxRigidDynamic.  This method only supports actors of type PxRigidStatic and PxRigidDynamic. For other actors, use addActor() instead. For articulation links, use addArticulation().  If an actor in the pruning structure contains an invalid constraint, in checked builds the call is ignored and an error is issued.  For all actors in the pruning structure each assigned PxConstraint object will get added to the scene automatically if it connects to another actor that is part of the scene already.  This method is optimized for high performance.  Merging a PxPruningStructure into an active scene query optimization AABB tree might unbalance the tree. A typical use case for PxPruningStructure is a large world scenario where blocks of closely positioned actors get streamed in. The merge process finds the best node in the active scene query optimization AABB tree and inserts the PxPruningStructure. Therefore using PxPruningStructure for actors scattered throughout the world will result in an unbalanced tree.  True if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_removeActor_mut(MagicPhysX.PxScene*,MagicPhysX.PxActor*,System.Boolean)">
            <summary>Removes an actor from this scene.  If the actor is not part of this scene (see [`PxActor::getScene`]), the call is ignored and an error is issued.  You can not remove individual articulation links (see [`PxArticulationLink`]) from the scene. Use #removeArticulation() instead.  If the actor is a PxRigidActor then all assigned PxConstraint objects will get removed from the scene automatically.  If the actor is in an aggregate it will be removed from the aggregate.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_removeActors_mut(MagicPhysX.PxScene*,MagicPhysX.PxActor**,System.UInt32,System.Boolean)">
            <summary>Removes actors from this scene. Only supports actors of type PxRigidStatic and PxRigidDynamic.  This method only supports actors of type PxRigidStatic and PxRigidDynamic. For other actors, use removeActor() instead. For articulation links, use removeArticulation().  If some actor is not part of this scene (see [`PxActor::getScene`]), the actor remove is ignored and an error is issued.  You can not remove individual articulation links (see [`PxArticulationLink`]) from the scene. Use #removeArticulation() instead.  If the actor is a PxRigidActor then all assigned PxConstraint objects will get removed from the scene automatically.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_addAggregate_mut(MagicPhysX.PxScene*,MagicPhysX.PxAggregate*)">
            <summary>Adds an aggregate to this scene.  If the aggregate is already assigned to a scene (see [`PxAggregate::getScene`]), the call is ignored and an error is issued.  If the aggregate contains an actor with an invalid constraint, in checked builds the call is ignored and an error is issued.  If the aggregate already contains actors, those actors are added to the scene as well.  True if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_removeAggregate_mut(MagicPhysX.PxScene*,MagicPhysX.PxAggregate*,System.Boolean)">
            <summary>Removes an aggregate from this scene.  If the aggregate is not part of this scene (see [`PxAggregate::getScene`]), the call is ignored and an error is issued.  If the aggregate contains actors, those actors are removed from the scene as well.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_addCollection_mut(MagicPhysX.PxScene*,MagicPhysX.PxCollection*)">
            <summary>Adds objects in the collection to this scene.  This function adds the following types of objects to this scene: PxRigidActor (except PxArticulationLink), PxAggregate, PxArticulationReducedCoordinate. This method is typically used after deserializing the collection in order to populate the scene with deserialized objects.  If the collection contains an actor with an invalid constraint, in checked builds the call is ignored and an error is issued.  True if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getNbActors(MagicPhysX.PxScene*,MagicPhysX.PxActorTypeFlags)">
            <summary>Retrieve the number of actors of certain types in the scene. For supported types, see PxActorTypeFlags.  the number of actors.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getActors(MagicPhysX.PxScene*,MagicPhysX.PxActorTypeFlags,MagicPhysX.PxActor**,System.UInt32,System.UInt32)">
            <summary>Retrieve an array of all the actors of certain types in the scene. For supported types, see PxActorTypeFlags.  Number of actors written to the buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getActiveActors_mut(MagicPhysX.PxScene*,System.UInt32*)">
            <summary>Queries the PxScene for a list of the PxActors whose transforms have been updated during the previous simulation step. Only includes actors of type PxRigidDynamic and PxArticulationLink.  PxSceneFlag::eENABLE_ACTIVE_ACTORS must be set.  Do not use this method while the simulation is running. Calls to this method while the simulation is running will be ignored and NULL will be returned.  A pointer to the list of active PxActors generated during the last call to fetchResults().</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getNbArticulations(MagicPhysX.PxScene*)">
            <summary>Returns the number of articulations in the scene.  the number of articulations in this scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getArticulations(MagicPhysX.PxScene*,MagicPhysX.PxArticulationReducedCoordinate**,System.UInt32,System.UInt32)">
            <summary>Retrieve all the articulations in the scene.  Number of articulations written to the buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getNbConstraints(MagicPhysX.PxScene*)">
            <summary>Returns the number of constraint shaders in the scene.  the number of constraint shaders in this scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getConstraints(MagicPhysX.PxScene*,MagicPhysX.PxConstraint**,System.UInt32,System.UInt32)">
            <summary>Retrieve all the constraint shaders in the scene.  Number of constraint shaders written to the buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getNbAggregates(MagicPhysX.PxScene*)">
            <summary>Returns the number of aggregates in the scene.  the number of aggregates in this scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getAggregates(MagicPhysX.PxScene*,MagicPhysX.PxAggregate**,System.UInt32,System.UInt32)">
            <summary>Retrieve all the aggregates in the scene.  Number of aggregates written to the buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_setDominanceGroupPair_mut(MagicPhysX.PxScene*,System.Byte,System.Byte,MagicPhysX.PxDominanceGroupPair*)">
            <summary>Specifies the dominance behavior of contacts between two actors with two certain dominance groups.  It is possible to assign each actor to a dominance groups using [`PxActor::setDominanceGroup`]().  With dominance groups one can have all contacts created between actors act in one direction only. This is useful, for example, if you want an object to push debris out of its way and be unaffected,while still responding physically to forces and collisions with non-debris objects.  Whenever a contact between two actors (a0, a1) needs to be solved, the groups (g0, g1) of both actors are retrieved. Then the PxDominanceGroupPair setting for this group pair is retrieved with getDominanceGroupPair(g0, g1).  In the contact, PxDominanceGroupPair::dominance0 becomes the dominance setting for a0, and PxDominanceGroupPair::dominance1 becomes the dominance setting for a1. A dominanceN setting of 1.0f, the default, will permit aN to be pushed or pulled by a(1-N) through the contact. A dominanceN setting of 0.0f, will however prevent aN to be pushed by a(1-N) via the contact. Thus, a PxDominanceGroupPair of (1.0f, 0.0f) makes the interaction one-way.  The matrix sampled by getDominanceGroupPair(g1, g2) is initialised by default such that:  if g1 == g2, then (1.0f, 1.0f) is returned if g1 &lt; g2, then (0.0f, 1.0f) is returned if g1 &gt;  g2, then (1.0f, 0.0f) is returned  In other words, we permit actors in higher groups to be pushed around by actors in lower groups by default.  These settings should cover most applications, and in fact not overriding these settings may likely result in higher performance.  It is not possible to make the matrix asymetric, or to change the diagonal. In other words:  it is not possible to change (g1, g2) if (g1==g2) if you set  (g1, g2) to X, then (g2, g1) will implicitly and automatically be set to ~X, where:  ~(1.0f, 1.0f) is (1.0f, 1.0f) ~(0.0f, 1.0f) is (1.0f, 0.0f) ~(1.0f, 0.0f) is (0.0f, 1.0f)  These two restrictions are to make sure that contacts between two actors will always evaluate to the same dominance setting, regardless of the order of the actors.  Dominance settings are currently specified as floats 0.0f or 1.0f because in the future we may permit arbitrary fractional settings to express 'partly-one-way' interactions.  Sleeping: Does NOT wake actors up automatically.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getDominanceGroupPair(MagicPhysX.PxScene*,System.Byte,System.Byte)">
            <summary>Samples the dominance matrix.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getCpuDispatcher(MagicPhysX.PxScene*)">
            <summary>Return the cpu dispatcher that was set in PxSceneDesc::cpuDispatcher when creating the scene with PxPhysics::createScene</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_createClient_mut(MagicPhysX.PxScene*)">
            <summary>Reserves a new client ID.  PX_DEFAULT_CLIENT is always available as the default clientID. Additional clients are returned by this function. Clients cannot be released once created. An error is reported when more than a supported number of clients (currently 128) are created.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_setSimulationEventCallback_mut(MagicPhysX.PxScene*,MagicPhysX.PxSimulationEventCallback*)">
            <summary>Sets a user notify object which receives special simulation events when they occur.  Do not set the callback while the simulation is running. Calls to this method while the simulation is running will be ignored.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getSimulationEventCallback(MagicPhysX.PxScene*)">
            <summary>Retrieves the simulationEventCallback pointer set with setSimulationEventCallback().  The current user notify pointer. See [`PxSimulationEventCallback`].</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_setContactModifyCallback_mut(MagicPhysX.PxScene*,MagicPhysX.PxContactModifyCallback*)">
            <summary>Sets a user callback object, which receives callbacks on all contacts generated for specified actors.  Do not set the callback while the simulation is running. Calls to this method while the simulation is running will be ignored.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_setCCDContactModifyCallback_mut(MagicPhysX.PxScene*,MagicPhysX.PxCCDContactModifyCallback*)">
            <summary>Sets a user callback object, which receives callbacks on all CCD contacts generated for specified actors.  Do not set the callback while the simulation is running. Calls to this method while the simulation is running will be ignored.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getContactModifyCallback(MagicPhysX.PxScene*)">
            <summary>Retrieves the PxContactModifyCallback pointer set with setContactModifyCallback().  The current user contact modify callback pointer. See [`PxContactModifyCallback`].</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getCCDContactModifyCallback(MagicPhysX.PxScene*)">
            <summary>Retrieves the PxCCDContactModifyCallback pointer set with setContactModifyCallback().  The current user contact modify callback pointer. See [`PxContactModifyCallback`].</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_setBroadPhaseCallback_mut(MagicPhysX.PxScene*,MagicPhysX.PxBroadPhaseCallback*)">
            <summary>Sets a broad-phase user callback object.  Do not set the callback while the simulation is running. Calls to this method while the simulation is running will be ignored.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getBroadPhaseCallback(MagicPhysX.PxScene*)">
            <summary>Retrieves the PxBroadPhaseCallback pointer set with setBroadPhaseCallback().  The current broad-phase callback pointer. See [`PxBroadPhaseCallback`].</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_setFilterShaderData_mut(MagicPhysX.PxScene*,System.Void*,System.UInt32)">
            <summary>Sets the shared global filter data which will get passed into the filter shader.  It is the user's responsibility to ensure that changing the shared global filter data does not change the filter output value for existing pairs. If the filter output for existing pairs does change nonetheless then such a change will not take effect until the pair gets refiltered. resetFiltering() can be used to explicitly refilter the pairs of specific objects.  The provided data will get copied to internal buffers and this copy will be used for filtering calls.  Do not use this method while the simulation is running. Calls to this method while the simulation is running will be ignored.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getFilterShaderData(MagicPhysX.PxScene*)">
            <summary>Gets the shared global filter data in use for this scene.  The reference points to a copy of the original filter data specified in [`PxSceneDesc`].filterShaderData or provided by #setFilterShaderData().  Shared filter data for filter shader.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getFilterShaderDataSize(MagicPhysX.PxScene*)">
            <summary>Gets the size of the shared global filter data ([`PxSceneDesc`].filterShaderData)  Size of shared filter data [bytes].</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_resetFiltering_mut(MagicPhysX.PxScene*,MagicPhysX.PxActor*)">
            <summary>Marks the object to reset interactions and re-run collision filters in the next simulation step.  This call forces the object to remove all existing collision interactions, to search anew for existing contact pairs and to run the collision filters again for found collision pairs.  The operation is supported for PxRigidActor objects only.  All persistent state of existing interactions will be lost and can not be retrieved even if the same collison pair is found again in the next step. This will mean, for example, that you will not get notified about persistent contact for such an interaction (see [`PxPairFlag::eNOTIFY_TOUCH_PERSISTS`]), the contact pair will be interpreted as newly found instead.  Lost touch contact reports will be sent for every collision pair which includes this shape, if they have been requested through [`PxPairFlag::eNOTIFY_TOUCH_LOST`] or #PxPairFlag::eNOTIFY_THRESHOLD_FORCE_LOST.  This is an expensive operation, don't use it if you don't have to.  Can be used to retrieve collision pairs that were killed by the collision filters (see [`PxFilterFlag::eKILL`])  It is invalid to use this method if the actor has not been added to a scene already.  It is invalid to use this method if PxActorFlag::eDISABLE_SIMULATION is set.  Do not use this method while the simulation is running.  Sleeping: Does wake up the actor.  True if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_resetFiltering_mut_1(MagicPhysX.PxScene*,MagicPhysX.PxRigidActor*,MagicPhysX.PxShape**,System.UInt32)">
            <summary>Marks the object to reset interactions and re-run collision filters for specified shapes in the next simulation step.  This is a specialization of the resetFiltering(PxActor &amp; actor) method and allows to reset interactions for specific shapes of a PxRigidActor.  Do not use this method while the simulation is running.  Sleeping: Does wake up the actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getKinematicKinematicFilteringMode(MagicPhysX.PxScene*)">
            <summary>Gets the pair filtering mode for kinematic-kinematic pairs.  Filtering mode for kinematic-kinematic pairs.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getStaticKinematicFilteringMode(MagicPhysX.PxScene*)">
            <summary>Gets the pair filtering mode for static-kinematic pairs.  Filtering mode for static-kinematic pairs.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_simulate_mut(MagicPhysX.PxScene*,System.Single,MagicPhysX.PxBaseTask*,System.Void*,System.UInt32,System.Boolean)">
            <summary>Advances the simulation by an elapsedTime time.  Large elapsedTime values can lead to instabilities. In such cases elapsedTime should be subdivided into smaller time intervals and simulate() should be called multiple times for each interval.  Calls to simulate() should pair with calls to fetchResults(): Each fetchResults() invocation corresponds to exactly one simulate() invocation; calling simulate() twice without an intervening fetchResults() or fetchResults() twice without an intervening simulate() causes an error condition.  scene-&gt;simulate(); ...do some processing until physics is computed... scene-&gt;fetchResults(); ...now results of run may be retrieved.  True if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_advance_mut(MagicPhysX.PxScene*,MagicPhysX.PxBaseTask*)">
            <summary>Performs dynamics phase of the simulation pipeline.  Calls to advance() should follow calls to fetchCollision(). An error message will be issued if this sequence is not followed.  True if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_collide_mut(MagicPhysX.PxScene*,System.Single,MagicPhysX.PxBaseTask*,System.Void*,System.UInt32,System.Boolean)">
            <summary>Performs collision detection for the scene over elapsedTime  Calls to collide() should be the first method called to simulate a frame.  True if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_checkResults_mut(MagicPhysX.PxScene*,System.Boolean)">
            <summary>This checks to see if the simulation run has completed.  This does not cause the data available for reading to be updated with the results of the simulation, it is simply a status check. The bool will allow it to either return immediately or block waiting for the condition to be met so that it can return true  True if the results are available.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_fetchCollision_mut(MagicPhysX.PxScene*,System.Boolean)">
            <summary>This method must be called after collide() and before advance(). It will wait for the collision phase to finish. If the user makes an illegal simulation call, the SDK will issue an error message.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_fetchResults_mut(MagicPhysX.PxScene*,System.Boolean,System.UInt32*)">
            <summary>This is the big brother to checkResults() it basically does the following:  True if the results have been fetched.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_fetchResultsStart_mut(MagicPhysX.PxScene*,MagicPhysX.PxContactPairHeader**,System.UInt32*,System.Boolean)">
            <summary>This call performs the first section of fetchResults, and returns a pointer to the contact streams output by the simulation. It can be used to process contact pairs in parallel, which is often a limiting factor for fetchResults() performance.  After calling this function and processing the contact streams, call fetchResultsFinish(). Note that writes to the simulation are not permitted between the start of fetchResultsStart() and the end of fetchResultsFinish().  True if the results have been fetched.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_processCallbacks_mut(MagicPhysX.PxScene*,MagicPhysX.PxBaseTask*)">
            <summary>This call processes all event callbacks in parallel. It takes a continuation task, which will be executed once all callbacks have been processed.  This is a utility function to make it easier to process callbacks in parallel using the PhysX task system. It can only be used in conjunction with fetchResultsStart(...) and fetchResultsFinish(...)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_fetchResultsFinish_mut(MagicPhysX.PxScene*,System.UInt32*)">
            <summary>This call performs the second section of fetchResults.  It must be called after fetchResultsStart() returns and contact reports have been processed.  Note that once fetchResultsFinish() has been called, the contact streams returned in fetchResultsStart() will be invalid.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_fetchResultsParticleSystem_mut(MagicPhysX.PxScene*)">
            <summary>This call performs the synchronization of particle system data copies.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_flushSimulation_mut(MagicPhysX.PxScene*,System.Boolean)">
            <summary>Clear internal buffers and free memory.  This method can be used to clear buffers and free internal memory without having to destroy the scene. Can be useful if the physics data gets streamed in and a checkpoint with a clean state should be created.  It is not allowed to call this method while the simulation is running. The call will fail.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_setGravity_mut(MagicPhysX.PxScene*,MagicPhysX.PxVec3*)">
            <summary>Sets a constant gravity for the entire scene.  Do not use this method while the simulation is running.  Sleeping: Does NOT wake the actor up automatically.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getGravity(MagicPhysX.PxScene*)">
            <summary>Retrieves the current gravity setting.  The current gravity for the scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_setBounceThresholdVelocity_mut(MagicPhysX.PxScene*,System.Single)">
            <summary>Set the bounce threshold velocity.  Collision speeds below this threshold will not cause a bounce.  Do not use this method while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getBounceThresholdVelocity(MagicPhysX.PxScene*)">
            <summary>Return the bounce threshold velocity.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_setCCDMaxPasses_mut(MagicPhysX.PxScene*,System.UInt32)">
            <summary>Sets the maximum number of CCD passes  Do not use this method while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getCCDMaxPasses(MagicPhysX.PxScene*)">
            <summary>Gets the maximum number of CCD passes.  The maximum number of CCD passes.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_setCCDMaxSeparation_mut(MagicPhysX.PxScene*,System.Single)">
            <summary>Set the maximum CCD separation.  Do not use this method while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getCCDMaxSeparation(MagicPhysX.PxScene*)">
            <summary>Gets the maximum CCD separation.  The maximum CCD separation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_setCCDThreshold_mut(MagicPhysX.PxScene*,System.Single)">
            <summary>Set the CCD threshold.  Do not use this method while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getCCDThreshold(MagicPhysX.PxScene*)">
            <summary>Gets the CCD threshold.  The CCD threshold.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_setMaxBiasCoefficient_mut(MagicPhysX.PxScene*,System.Single)">
            <summary>Set the max bias coefficient.  Do not use this method while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getMaxBiasCoefficient(MagicPhysX.PxScene*)">
            <summary>Gets the max bias coefficient.  The max bias coefficient.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_setFrictionOffsetThreshold_mut(MagicPhysX.PxScene*,System.Single)">
            <summary>Set the friction offset threshold.  Do not use this method while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getFrictionOffsetThreshold(MagicPhysX.PxScene*)">
            <summary>Gets the friction offset threshold.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_setFrictionCorrelationDistance_mut(MagicPhysX.PxScene*,System.Single)">
            <summary>Set the friction correlation distance.  Do not use this method while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getFrictionCorrelationDistance(MagicPhysX.PxScene*)">
            <summary>Gets the friction correlation distance.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getFrictionType(MagicPhysX.PxScene*)">
            <summary>Return the friction model.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getSolverType(MagicPhysX.PxScene*)">
            <summary>Return the solver model.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_setVisualizationParameter_mut(MagicPhysX.PxScene*,MagicPhysX.PxVisualizationParameter,System.Single)">
            <summary>Function that lets you set debug visualization parameters.  Returns false if the value passed is out of range for usage specified by the enum.  Do not use this method while the simulation is running.  False if the parameter is out of range.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getVisualizationParameter(MagicPhysX.PxScene*,MagicPhysX.PxVisualizationParameter)">
            <summary>Function that lets you query debug visualization parameters.  The value of the parameter.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_setVisualizationCullingBox_mut(MagicPhysX.PxScene*,MagicPhysX.PxBounds3*)">
            <summary>Defines a box in world space to which visualization geometry will be (conservatively) culled. Use a non-empty culling box to enable the feature, and an empty culling box to disable it.  Do not use this method while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getVisualizationCullingBox(MagicPhysX.PxScene*)">
            <summary>Retrieves the visualization culling box.  the box to which the geometry will be culled.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getRenderBuffer_mut(MagicPhysX.PxScene*)">
            <summary>Retrieves the render buffer.  This will contain the results of any active visualization for this scene.  Do not use this method while the simulation is running. Calls to this method while the simulation is running will result in undefined behaviour.  The render buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getSimulationStatistics(MagicPhysX.PxScene*,MagicPhysX.PxSimulationStatistics*)">
            <summary>Call this method to retrieve statistics for the current simulation step.  Do not use this method while the simulation is running. Calls to this method while the simulation is running will be ignored.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getBroadPhaseType(MagicPhysX.PxScene*)">
            <summary>Returns broad-phase type.  Broad-phase type</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getBroadPhaseCaps(MagicPhysX.PxScene*,MagicPhysX.PxBroadPhaseCaps*)">
            <summary>Gets broad-phase caps.  True if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getNbBroadPhaseRegions(MagicPhysX.PxScene*)">
            <summary>Returns number of regions currently registered in the broad-phase.  Number of regions</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getBroadPhaseRegions(MagicPhysX.PxScene*,MagicPhysX.PxBroadPhaseRegionInfo*,System.UInt32,System.UInt32)">
            <summary>Gets broad-phase regions.  Number of written out regions</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_addBroadPhaseRegion_mut(MagicPhysX.PxScene*,MagicPhysX.PxBroadPhaseRegion*,System.Boolean)">
            <summary>Adds a new broad-phase region.  The bounds for the new region must be non-empty, otherwise an error occurs and the call is ignored.  Note that by default, objects already existing in the SDK that might touch this region will not be automatically added to the region. In other words the newly created region will be empty, and will only be populated with new objects when they are added to the simulation, or with already existing objects when they are updated.  It is nonetheless possible to override this default behavior and let the SDK populate the new region automatically with already existing objects overlapping the incoming region. This has a cost though, and it should only be used when the game can not guarantee that all objects within the new region will be added to the simulation after the region itself.  Objects automatically move from one region to another during their lifetime. The system keeps tracks of what regions a given object is in. It is legal for an object to be in an arbitrary number of regions. However if an object leaves all regions, or is created outside of all regions, several things happen: - collisions get disabled for this object - if a PxBroadPhaseCallback object is provided, an \"out-of-bounds\" event is generated via that callback - if a PxBroadPhaseCallback object is not provided, a warning/error message is sent to the error stream  If an object goes out-of-bounds and user deletes it during the same frame, neither the out-of-bounds event nor the error message is generated.  Handle for newly created region, or 0xffffffff in case of failure.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_removeBroadPhaseRegion_mut(MagicPhysX.PxScene*,System.UInt32)">
            <summary>Removes a new broad-phase region.  If the region still contains objects, and if those objects do not overlap any region any more, they are not automatically removed from the simulation. Instead, the PxBroadPhaseCallback::onObjectOutOfBounds notification is used for each object. Users are responsible for removing the objects from the simulation if this is the desired behavior.  If the handle is invalid, or if a valid handle is removed twice, an error message is sent to the error stream.  True if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getTaskManager(MagicPhysX.PxScene*)">
            <summary>Get the task manager associated with this scene  the task manager associated with the scene</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_lockRead_mut(MagicPhysX.PxScene*,System.Byte*,System.UInt32)">
            <summary>Lock the scene for reading from the calling thread.  When the PxSceneFlag::eREQUIRE_RW_LOCK flag is enabled lockRead() must be called before any read calls are made on the scene.  Multiple threads may read at the same time, no threads may read while a thread is writing. If a call to lockRead() is made while another thread is holding a write lock then the calling thread will be blocked until the writing thread calls unlockWrite().  Lock upgrading is *not* supported, that means it is an error to call lockRead() followed by lockWrite().  Recursive locking is supported but each lockRead() call must be paired with an unlockRead().</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_unlockRead_mut(MagicPhysX.PxScene*)">
            <summary>Unlock the scene from reading.  Each unlockRead() must be paired with a lockRead() from the same thread.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_lockWrite_mut(MagicPhysX.PxScene*,System.Byte*,System.UInt32)">
            <summary>Lock the scene for writing from this thread.  When the PxSceneFlag::eREQUIRE_RW_LOCK flag is enabled lockWrite() must be called before any write calls are made on the scene.  Only one thread may write at a time and no threads may read while a thread is writing. If a call to lockWrite() is made and there are other threads reading then the calling thread will be blocked until the readers complete.  Writers have priority. If a thread is blocked waiting to write then subsequent calls to lockRead() from other threads will be blocked until the writer completes.  If multiple threads are waiting to write then the thread that is first granted access depends on OS scheduling.  Recursive locking is supported but each lockWrite() call must be paired with an unlockWrite().  If a thread has already locked the scene for writing then it may call lockRead().</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_unlockWrite_mut(MagicPhysX.PxScene*)">
            <summary>Unlock the scene from writing.  Each unlockWrite() must be paired with a lockWrite() from the same thread.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_setNbContactDataBlocks_mut(MagicPhysX.PxScene*,System.UInt32)">
            <summary>set the cache blocks that can be used during simulate().  Each frame the simulation requires memory to store contact, friction, and contact cache data. This memory is used in blocks of 16K. Each frame the blocks used by the previous frame are freed, and may be retrieved by the application using PxScene::flushSimulation()  This call will force allocation of cache blocks if the numBlocks parameter is greater than the currently allocated number of blocks, and less than the max16KContactDataBlocks parameter specified at scene creation time.  Do not use this method while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getNbContactDataBlocksUsed(MagicPhysX.PxScene*)">
            <summary>get the number of cache blocks currently used by the scene  This function may not be called while the scene is simulating  the number of cache blocks currently used by the scene</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getMaxNbContactDataBlocksUsed(MagicPhysX.PxScene*)">
            <summary>get the maximum number of cache blocks used by the scene  This function may not be called while the scene is simulating  the maximum number of cache blocks everused by the scene</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getContactReportStreamBufferSize(MagicPhysX.PxScene*)">
            <summary>Return the value of PxSceneDesc::contactReportStreamBufferSize that was set when creating the scene with PxPhysics::createScene</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_setSolverBatchSize_mut(MagicPhysX.PxScene*,System.UInt32)">
            <summary>Sets the number of actors required to spawn a separate rigid body solver thread.  Do not use this method while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getSolverBatchSize(MagicPhysX.PxScene*)">
            <summary>Retrieves the number of actors required to spawn a separate rigid body solver thread.  Current number of actors required to spawn a separate rigid body solver thread.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_setSolverArticulationBatchSize_mut(MagicPhysX.PxScene*,System.UInt32)">
            <summary>Sets the number of articulations required to spawn a separate rigid body solver thread.  Do not use this method while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getSolverArticulationBatchSize(MagicPhysX.PxScene*)">
            <summary>Retrieves the number of articulations required to spawn a separate rigid body solver thread.  Current number of articulations required to spawn a separate rigid body solver thread.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getWakeCounterResetValue(MagicPhysX.PxScene*)">
            <summary>Returns the wake counter reset value.  Wake counter reset value</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_shiftOrigin_mut(MagicPhysX.PxScene*,MagicPhysX.PxVec3*)">
            <summary>Shift the scene origin by the specified vector.  The poses of all objects in the scene and the corresponding data structures will get adjusted to reflect the new origin location (the shift vector will get subtracted from all object positions).  It is the user's responsibility to keep track of the summed total origin shift and adjust all input/output to/from PhysX accordingly.  Do not use this method while the simulation is running. Calls to this method while the simulation is running will be ignored.  Make sure to propagate the origin shift to other dependent modules (for example, the character controller module etc.).  This is an expensive operation and we recommend to use it only in the case where distance related precision issues may arise in areas far from the origin.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_getScenePvdClient_mut(MagicPhysX.PxScene*)">
            <summary>Returns the Pvd client associated with the scene.  the client, NULL if no PVD supported.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_copyArticulationData_mut(MagicPhysX.PxScene*,System.Void*,System.Void*,MagicPhysX.PxArticulationGpuDataType,System.UInt32,System.Void*)">
            <summary>Copy GPU articulation data from the internal GPU buffer to a user-provided device buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_applyArticulationData_mut(MagicPhysX.PxScene*,System.Void*,System.Void*,MagicPhysX.PxArticulationGpuDataType,System.UInt32,System.Void*,System.Void*)">
            <summary>Apply GPU articulation data from a user-provided device buffer to the internal GPU buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_copySoftBodyData_mut(MagicPhysX.PxScene*,System.Void**,System.Void*,System.Void*,MagicPhysX.PxSoftBodyDataFlag,System.UInt32,System.UInt32,System.Void*)">
            <summary>Copy GPU softbody data from the internal GPU buffer to a user-provided device buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_applySoftBodyData_mut(MagicPhysX.PxScene*,System.Void**,System.Void*,System.Void*,MagicPhysX.PxSoftBodyDataFlag,System.UInt32,System.UInt32,System.Void*)">
            <summary>Apply user-provided data to the internal softbody system.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_copyContactData_mut(MagicPhysX.PxScene*,System.Void*,System.UInt32,System.Void*,System.Void*)">
            <summary>Copy contact data from the internal GPU buffer to a user-provided device buffer.  The contact data contains pointers to internal state and is only valid until the next call to simulate().</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_copyBodyData_mut(MagicPhysX.PxScene*,MagicPhysX.PxGpuBodyData*,MagicPhysX.PxGpuActorPair*,System.UInt32,System.Void*)">
            <summary>Copy GPU rigid body data from the internal GPU buffer to a user-provided device buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_applyActorData_mut(MagicPhysX.PxScene*,System.Void*,MagicPhysX.PxGpuActorPair*,MagicPhysX.PxActorCacheFlag,System.UInt32,System.Void*,System.Void*)">
            <summary>Apply user-provided data to rigid body.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_computeDenseJacobians_mut(MagicPhysX.PxScene*,MagicPhysX.PxIndexDataPair*,System.UInt32,System.Void*)">
            <summary>Compute dense Jacobian matrices for specified articulations on the GPU.  The size of Jacobians can vary by articulation, since it depends on the number of links, degrees-of-freedom, and whether the base is fixed.  The size is determined using these formulas: nCols = (fixedBase ? 0 : 6) + dofCount nRows = (fixedBase ? 0 : 6) + (linkCount - 1) * 6;  The user must ensure that adequate space is provided for each Jacobian matrix.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_computeGeneralizedMassMatrices_mut(MagicPhysX.PxScene*,MagicPhysX.PxIndexDataPair*,System.UInt32,System.Void*)">
            <summary>Compute the joint-space inertia matrices that maps joint accelerations to joint forces: forces = M * accelerations on the GPU.  The size of matrices can vary by articulation, since it depends on the number of links and degrees-of-freedom.  The size is determined using this formula: sizeof(float) * dofCount * dofCount  The user must ensure that adequate space is provided for each mass matrix.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_computeGeneralizedGravityForces_mut(MagicPhysX.PxScene*,MagicPhysX.PxIndexDataPair*,System.UInt32,System.Void*)">
            <summary>Computes the joint DOF forces required to counteract gravitational forces for the given articulation pose.  The size of the result can vary by articulation, since it depends on the number of links and degrees-of-freedom.  The size is determined using this formula: sizeof(float) * dofCount  The user must ensure that adequate space is provided for each articulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_computeCoriolisAndCentrifugalForces_mut(MagicPhysX.PxScene*,MagicPhysX.PxIndexDataPair*,System.UInt32,System.Void*)">
            <summary>Computes the joint DOF forces required to counteract coriolis and centrifugal forces for the given articulation pose.  The size of the result can vary by articulation, since it depends on the number of links and degrees-of-freedom.  The size is determined using this formula: sizeof(float) * dofCount  The user must ensure that adequate space is provided for each articulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxScene_applyParticleBufferData_mut(MagicPhysX.PxScene*,System.UInt32*,MagicPhysX.PxGpuParticleBufferIndexPair*,MagicPhysX.PxParticleBufferFlags*,System.UInt32,System.Void*,System.Void*)">
            <summary>Apply user-provided data to particle buffers.  This function should be used if the particle buffer flags are already on the device. Otherwise, use PxParticleBuffer::raiseFlags() from the CPU.  This assumes the data has been changed directly in the PxParticleBuffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneReadLock_new_alloc(MagicPhysX.PxScene*,System.Byte*,System.UInt32)">
            <summary>Constructor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneWriteLock_new_alloc(MagicPhysX.PxScene*,System.Byte*,System.UInt32)">
            <summary>Constructor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactPairExtraDataIterator_new(System.Byte*,System.UInt32)">
            <summary>Constructor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactPairExtraDataIterator_nextItemSet_mut(MagicPhysX.PxContactPairExtraDataIterator*)">
            <summary>Advances the iterator to next set of extra data items.  The contact pair extra data stream contains sets of items as requested by the corresponding [`PxPairFlag`] flags [`PxPairFlag::ePRE_SOLVER_VELOCITY`], #PxPairFlag::ePOST_SOLVER_VELOCITY, #PxPairFlag::eCONTACT_EVENT_POSE. A set can contain one item of each plus the PxContactPairIndex item. This method parses the stream and points the iterator member variables to the corresponding items of the current set, if they are available. If CCD is not enabled, you should only get one set of items. If CCD with multiple passes is enabled, you might get more than one item set.  Even though contact pair extra data is requested per shape pair, you will not get an item set per shape pair but one per actor pair. If, for example, an actor has two shapes and both collide with another actor, then there will only be one item set (since it applies to both shape pairs).  True if there was another set of extra data items in the stream, else false.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactPair_extractContacts(MagicPhysX.PxContactPair*,MagicPhysX.PxContactPairPoint*,System.UInt32)">
            <summary>Extracts the contact points from the stream and stores them in a convenient format.  Number of contact points written to the buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactPair_bufferContacts(MagicPhysX.PxContactPair*,MagicPhysX.PxContactPair*,System.Byte*)">
            <summary>Helper method to clone the contact pair and copy the contact data stream into a user buffer.  The contact data stream is only accessible during the contact report callback. This helper function provides copy functionality to buffer the contact stream information such that it can get accessed at a later stage.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSimulationEventCallback_onConstraintBreak_mut(MagicPhysX.PxSimulationEventCallback*,MagicPhysX.PxConstraintInfo*,System.UInt32)">
            <summary>This is called when a breakable constraint breaks.  The user should not release the constraint shader inside this call!  No event will get reported if the constraint breaks but gets deleted while the time step is still being simulated.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSimulationEventCallback_onWake_mut(MagicPhysX.PxSimulationEventCallback*,MagicPhysX.PxActor**,System.UInt32)">
            <summary>This is called with the actors which have just been woken up.  Only supported by rigid bodies yet.  Only called on actors for which the PxActorFlag eSEND_SLEEP_NOTIFIES has been set.  Only the latest sleep state transition happening between fetchResults() of the previous frame and fetchResults() of the current frame will get reported. For example, let us assume actor A is awake, then A-&gt;putToSleep() gets called, then later A-&gt;wakeUp() gets called. At the next simulate/fetchResults() step only an onWake() event will get triggered because that was the last transition.  If an actor gets newly added to a scene with properties such that it is awake and the sleep state does not get changed by the user or simulation, then an onWake() event will get sent at the next simulate/fetchResults() step.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSimulationEventCallback_onSleep_mut(MagicPhysX.PxSimulationEventCallback*,MagicPhysX.PxActor**,System.UInt32)">
            <summary>This is called with the actors which have just been put to sleep.  Only supported by rigid bodies yet.  Only called on actors for which the PxActorFlag eSEND_SLEEP_NOTIFIES has been set.  Only the latest sleep state transition happening between fetchResults() of the previous frame and fetchResults() of the current frame will get reported. For example, let us assume actor A is asleep, then A-&gt;wakeUp() gets called, then later A-&gt;putToSleep() gets called. At the next simulate/fetchResults() step only an onSleep() event will get triggered because that was the last transition (assuming the simulation does not wake the actor up).  If an actor gets newly added to a scene with properties such that it is asleep and the sleep state does not get changed by the user or simulation, then an onSleep() event will get sent at the next simulate/fetchResults() step.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSimulationEventCallback_onContact_mut(MagicPhysX.PxSimulationEventCallback*,MagicPhysX.PxContactPairHeader*,MagicPhysX.PxContactPair*,System.UInt32)">
            <summary>This is called when certain contact events occur.  The method will be called for a pair of actors if one of the colliding shape pairs requested contact notification. You request which events are reported using the filter shader/callback mechanism (see [`PxSimulationFilterShader`], [`PxSimulationFilterCallback`], #PxPairFlag).  Do not keep references to the passed objects, as they will be invalid after this function returns.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSimulationEventCallback_onTrigger_mut(MagicPhysX.PxSimulationEventCallback*,MagicPhysX.PxTriggerPair*,System.UInt32)">
            <summary>This is called with the current trigger pair events.  Shapes which have been marked as triggers using PxShapeFlag::eTRIGGER_SHAPE will send events according to the pair flag specification in the filter shader (see [`PxPairFlag`], #PxSimulationFilterShader).  Trigger shapes will no longer send notification events for interactions with other trigger shapes.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSimulationEventCallback_onAdvance_mut(MagicPhysX.PxSimulationEventCallback*,MagicPhysX.PxRigidBody**,MagicPhysX.PxTransform*,System.UInt32)">
            <summary>Provides early access to the new pose of moving rigid bodies.  When this call occurs, rigid bodies having the [`PxRigidBodyFlag::eENABLE_POSE_INTEGRATION_PREVIEW`] flag set, were moved by the simulation and their new poses can be accessed through the provided buffers.  The provided buffers are valid and can be read until the next call to [`PxScene::simulate`]() or #PxScene::collide().  This callback gets triggered while the simulation is running. If the provided rigid body references are used to read properties of the object, then the callback has to guarantee no other thread is writing to the same body at the same time.  The code in this callback should be lightweight as it can block the simulation, that is, the [`PxScene::fetchResults`]() call.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPruningStructure_release_mut(MagicPhysX.PxPruningStructure*)">
            <summary>Release this object.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPruningStructure_getRigidActors(MagicPhysX.PxPruningStructure*,MagicPhysX.PxRigidActor**,System.UInt32,System.UInt32)">
            <summary>Retrieve rigid actors in the pruning structure.  You can retrieve the number of rigid actor pointers by calling [`getNbRigidActors`]()  Number of rigid actor pointers written to the buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPruningStructure_getNbRigidActors(MagicPhysX.PxPruningStructure*)">
            <summary>Returns the number of rigid actors in the pruning structure.  You can use [`getRigidActors`]() to retrieve the rigid actor pointers.  Number of rigid actors in the pruning structure.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPruningStructure_getStaticMergeData(MagicPhysX.PxPruningStructure*)">
            <summary>Gets the merge data for static actors  This is mainly called by the PxSceneQuerySystem::merge() function to merge a PxPruningStructure with the internal data-structures of the scene-query system.  Implementation-dependent merge data for static actors.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPruningStructure_getDynamicMergeData(MagicPhysX.PxPruningStructure*)">
            <summary>Gets the merge data for dynamic actors  This is mainly called by the PxSceneQuerySystem::merge() function to merge a PxPruningStructure with the internal data-structures of the scene-query system.  Implementation-dependent merge data for dynamic actors.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxObstacleContext_release_mut(MagicPhysX.PxObstacleContext*)">
            <summary>Releases the context.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxObstacleContext_getControllerManager(MagicPhysX.PxObstacleContext*)">
            <summary>Retrieves the controller manager associated with this context.  The associated controller manager</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxObstacleContext_addObstacle_mut(MagicPhysX.PxObstacleContext*,MagicPhysX.PxObstacle*)">
            <summary>Adds an obstacle to the context.  Handle for newly-added obstacle</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxObstacleContext_removeObstacle_mut(MagicPhysX.PxObstacleContext*,System.UInt32)">
            <summary>Removes an obstacle from the context.  True if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxObstacleContext_updateObstacle_mut(MagicPhysX.PxObstacleContext*,System.UInt32,MagicPhysX.PxObstacle*)">
            <summary>Updates data for an existing obstacle.  True if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxObstacleContext_getNbObstacles(MagicPhysX.PxObstacleContext*)">
            <summary>Retrieves number of obstacles in the context.  Number of obstacles in the context</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxObstacleContext_getObstacle(MagicPhysX.PxObstacleContext*,System.UInt32)">
            <summary>Retrieves desired obstacle.  Desired obstacle</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxObstacleContext_getObstacleByHandle(MagicPhysX.PxObstacleContext*,System.UInt32)">
            <summary>Retrieves desired obstacle by given handle.  Desired obstacle</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxUserControllerHitReport_onShapeHit_mut(MagicPhysX.PxUserControllerHitReport*,MagicPhysX.PxControllerShapeHit*)">
            <summary>Called when current controller hits a shape.  This is called when the CCT moves and hits a shape. This will not be called when a moving shape hits a non-moving CCT.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxUserControllerHitReport_onControllerHit_mut(MagicPhysX.PxUserControllerHitReport*,MagicPhysX.PxControllersHit*)">
            <summary>Called when current controller hits another controller.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxUserControllerHitReport_onObstacleHit_mut(MagicPhysX.PxUserControllerHitReport*,MagicPhysX.PxControllerObstacleHit*)">
            <summary>Called when current controller hits a user-defined obstacle.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxControllerFilterCallback_filter_mut(MagicPhysX.PxControllerFilterCallback*,MagicPhysX.PxController*,MagicPhysX.PxController*)">
            <summary>Filtering method for CCT-vs-CCT.  true to keep the pair, false to filter it out</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxControllerDesc_isValid(MagicPhysX.PxControllerDesc*)">
            <summary>returns true if the current settings are valid  True if the descriptor is valid.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxControllerDesc_getType(MagicPhysX.PxControllerDesc*)">
            <summary>Returns the character controller type  The controllers type.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxController_getType(MagicPhysX.PxController*)">
            <summary>Return the type of controller</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxController_release_mut(MagicPhysX.PxController*)">
            <summary>Releases the controller.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxController_move_mut(MagicPhysX.PxController*,MagicPhysX.PxVec3*,System.Single,System.Single,MagicPhysX.PxControllerFilters*,MagicPhysX.PxObstacleContext*)">
            <summary>Moves the character using a \"collide-and-slide\" algorithm.  Collision flags, collection of ::PxControllerCollisionFlags</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxController_setPosition_mut(MagicPhysX.PxController*,MagicPhysX.PxExtendedVec3*)">
            <summary>Sets controller's position.  The position controlled by this function is the center of the collision shape.  This is a 'teleport' function, it doesn't check for collisions.  The character's position must be such that it does not overlap the static geometry.  To move the character under normal conditions use the [`move`]() function.  Currently always returns true.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxController_getPosition(MagicPhysX.PxController*)">
            <summary>Retrieve the raw position of the controller.  The position retrieved by this function is the center of the collision shape. To retrieve the bottom position of the shape, a.k.a. the foot position, use the getFootPosition() function.  The position is updated by calls to move(). Calling this method without calling move() will return the last position or the initial position of the controller.  The controller's center position</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxController_setFootPosition_mut(MagicPhysX.PxController*,MagicPhysX.PxExtendedVec3*)">
            <summary>Set controller's foot position.  The position controlled by this function is the bottom of the collision shape, a.k.a. the foot position.  The foot position takes the contact offset into account  This is a 'teleport' function, it doesn't check for collisions.  To move the character under normal conditions use the [`move`]() function.  Currently always returns true.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxController_getFootPosition(MagicPhysX.PxController*)">
            <summary>Retrieve the \"foot\" position of the controller, i.e. the position of the bottom of the CCT's shape.  The foot position takes the contact offset into account  The controller's foot position</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxController_getActor(MagicPhysX.PxController*)">
            <summary>Get the rigid body actor associated with this controller (see PhysX documentation). The behavior upon manually altering this actor is undefined, you should primarily use it for reading const properties.  the actor associated with the controller.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxController_setStepOffset_mut(MagicPhysX.PxController*,System.Single)">
            <summary>The step height.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxController_getStepOffset(MagicPhysX.PxController*)">
            <summary>Retrieve the step height.  The step offset for the controller.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxController_setNonWalkableMode_mut(MagicPhysX.PxController*,MagicPhysX.PxControllerNonWalkableMode)">
            <summary>Sets the non-walkable mode for the CCT.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxController_getNonWalkableMode(MagicPhysX.PxController*)">
            <summary>Retrieves the non-walkable mode for the CCT.  The current non-walkable mode.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxController_getContactOffset(MagicPhysX.PxController*)">
            <summary>Retrieve the contact offset.  The contact offset for the controller.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxController_setContactOffset_mut(MagicPhysX.PxController*,System.Single)">
            <summary>Sets the contact offset.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxController_getUpDirection(MagicPhysX.PxController*)">
            <summary>Retrieve the 'up' direction.  The up direction for the controller.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxController_setUpDirection_mut(MagicPhysX.PxController*,MagicPhysX.PxVec3*)">
            <summary>Sets the 'up' direction.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxController_getSlopeLimit(MagicPhysX.PxController*)">
            <summary>Retrieve the slope limit.  The slope limit for the controller.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxController_setSlopeLimit_mut(MagicPhysX.PxController*,System.Single)">
            <summary>Sets the slope limit.  This feature can not be enabled at runtime, i.e. if the slope limit is zero when creating the CCT (which disables the feature) then changing the slope limit at runtime will not have any effect, and the call will be ignored.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxController_invalidateCache_mut(MagicPhysX.PxController*)">
            <summary>Flushes internal geometry cache.  The character controller uses caching in order to speed up collision testing. The cache is automatically flushed when a change to static objects is detected in the scene. For example when a static shape is added, updated, or removed from the scene, the cache is automatically invalidated.  However there may be situations that cannot be automatically detected, and those require manual invalidation of the cache. Currently the user must call this when the filtering behavior changes (the PxControllerFilters parameter of the PxController::move call).  While the controller in principle could detect a change in these parameters, it cannot detect a change in the behavior of the filtering function.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxController_getScene_mut(MagicPhysX.PxController*)">
            <summary>Retrieve the scene associated with the controller.  The physics scene</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxController_getUserData(MagicPhysX.PxController*)">
            <summary>Returns the user data associated with this controller.  The user pointer associated with the controller.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxController_setUserData_mut(MagicPhysX.PxController*,System.Void*)">
            <summary>Sets the user data associated with this controller.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxController_getState(MagicPhysX.PxController*,MagicPhysX.PxControllerState*)">
            <summary>Returns information about the controller's internal state.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxController_getStats(MagicPhysX.PxController*,MagicPhysX.PxControllerStats*)">
            <summary>Returns the controller's internal statistics.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxController_resize_mut(MagicPhysX.PxController*,System.Single)">
            <summary>Resizes the controller.  This function attempts to resize the controller to a given size, while making sure the bottom position of the controller remains constant. In other words the function modifies both the height and the (center) position of the controller. This is a helper function that can be used to implement a 'crouch' functionality for example.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBoxControllerDesc_new_alloc">
            <summary>constructor sets to default.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBoxControllerDesc_setToDefault_mut(MagicPhysX.PxBoxControllerDesc*)">
            <summary>(re)sets the structure to the default.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBoxControllerDesc_isValid(MagicPhysX.PxBoxControllerDesc*)">
            <summary>returns true if the current settings are valid  True if the descriptor is valid.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBoxController_getHalfHeight(MagicPhysX.PxBoxController*)">
            <summary>Gets controller's half height.  The half height of the controller.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBoxController_getHalfSideExtent(MagicPhysX.PxBoxController*)">
            <summary>Gets controller's half side extent.  The half side extent of the controller.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBoxController_getHalfForwardExtent(MagicPhysX.PxBoxController*)">
            <summary>Gets controller's half forward extent.  The half forward extent of the controller.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBoxController_setHalfHeight_mut(MagicPhysX.PxBoxController*,System.Single)">
            <summary>Sets controller's half height.  this doesn't check for collisions.  Currently always true.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBoxController_setHalfSideExtent_mut(MagicPhysX.PxBoxController*,System.Single)">
            <summary>Sets controller's half side extent.  this doesn't check for collisions.  Currently always true.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBoxController_setHalfForwardExtent_mut(MagicPhysX.PxBoxController*,System.Single)">
            <summary>Sets controller's half forward extent.  this doesn't check for collisions.  Currently always true.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCapsuleControllerDesc_new_alloc">
            <summary>constructor sets to default.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCapsuleControllerDesc_setToDefault_mut(MagicPhysX.PxCapsuleControllerDesc*)">
            <summary>(re)sets the structure to the default.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCapsuleControllerDesc_isValid(MagicPhysX.PxCapsuleControllerDesc*)">
            <summary>returns true if the current settings are valid  True if the descriptor is valid.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCapsuleController_getRadius(MagicPhysX.PxCapsuleController*)">
            <summary>Gets controller's radius.  The radius of the controller.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCapsuleController_setRadius_mut(MagicPhysX.PxCapsuleController*,System.Single)">
            <summary>Sets controller's radius.  this doesn't check for collisions.  Currently always true.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCapsuleController_getHeight(MagicPhysX.PxCapsuleController*)">
            <summary>Gets controller's height.  The height of the capsule controller.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCapsuleController_setHeight_mut(MagicPhysX.PxCapsuleController*,System.Single)">
            <summary>Resets controller's height.  this doesn't check for collisions.  Currently always true.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCapsuleController_getClimbingMode(MagicPhysX.PxCapsuleController*)">
            <summary>Gets controller's climbing mode.  The capsule controller's climbing mode.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCapsuleController_setClimbingMode_mut(MagicPhysX.PxCapsuleController*,MagicPhysX.PxCapsuleClimbingMode)">
            <summary>Sets controller's climbing mode.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxControllerBehaviorCallback_getBehaviorFlags_mut(MagicPhysX.PxControllerBehaviorCallback*,MagicPhysX.PxShape*,MagicPhysX.PxActor*)">
            <summary>Retrieve behavior flags for a shape.  When the CCT touches a shape, the CCT's behavior w.r.t. this shape can be customized by users. This function retrieves the desired PxControllerBehaviorFlag flags capturing the desired behavior.  See comments about deprecated functions at the start of this class  Desired behavior flags for the given shape</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxControllerBehaviorCallback_getBehaviorFlags_mut_1(MagicPhysX.PxControllerBehaviorCallback*,MagicPhysX.PxController*)">
            <summary>Retrieve behavior flags for a controller.  When the CCT touches a controller, the CCT's behavior w.r.t. this controller can be customized by users. This function retrieves the desired PxControllerBehaviorFlag flags capturing the desired behavior.  The flag PxControllerBehaviorFlag::eCCT_CAN_RIDE_ON_OBJECT is not supported.  See comments about deprecated functions at the start of this class  Desired behavior flags for the given controller</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxControllerBehaviorCallback_getBehaviorFlags_mut_2(MagicPhysX.PxControllerBehaviorCallback*,MagicPhysX.PxObstacle*)">
            <summary>Retrieve behavior flags for an obstacle.  When the CCT touches an obstacle, the CCT's behavior w.r.t. this obstacle can be customized by users. This function retrieves the desired PxControllerBehaviorFlag flags capturing the desired behavior.  See comments about deprecated functions at the start of this class  Desired behavior flags for the given obstacle</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxControllerManager_release_mut(MagicPhysX.PxControllerManager*)">
            <summary>Releases the controller manager.  This will release all associated controllers and obstacle contexts.  This function is required to be called to release foundation usage.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxControllerManager_getScene(MagicPhysX.PxControllerManager*)">
            <summary>Returns the scene the manager is adding the controllers to.  The associated physics scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxControllerManager_getNbControllers(MagicPhysX.PxControllerManager*)">
            <summary>Returns the number of controllers that are being managed.  The number of controllers.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxControllerManager_getController_mut(MagicPhysX.PxControllerManager*,System.UInt32)">
            <summary>Retrieve one of the controllers in the manager.  The controller with the specified index.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxControllerManager_createController_mut(MagicPhysX.PxControllerManager*,MagicPhysX.PxControllerDesc*)">
            <summary>Creates a new character controller.  The new controller</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxControllerManager_purgeControllers_mut(MagicPhysX.PxControllerManager*)">
            <summary>Releases all the controllers that are being managed.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxControllerManager_getRenderBuffer_mut(MagicPhysX.PxControllerManager*)">
            <summary>Retrieves debug data.  The render buffer filled with debug-render data</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxControllerManager_setDebugRenderingFlags_mut(MagicPhysX.PxControllerManager*,MagicPhysX.PxControllerDebugRenderFlags)">
            <summary>Sets debug rendering flags</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxControllerManager_getNbObstacleContexts(MagicPhysX.PxControllerManager*)">
            <summary>Returns the number of obstacle contexts that are being managed.  The number of obstacle contexts.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxControllerManager_getObstacleContext_mut(MagicPhysX.PxControllerManager*,System.UInt32)">
            <summary>Retrieve one of the obstacle contexts in the manager.  The obstacle context with the specified index.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxControllerManager_createObstacleContext_mut(MagicPhysX.PxControllerManager*)">
            <summary>Creates an obstacle context.  New obstacle context</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxControllerManager_computeInteractions_mut(MagicPhysX.PxControllerManager*,System.Single,MagicPhysX.PxControllerFilterCallback*)">
            <summary>Computes character-character interactions.  This function is an optional helper to properly resolve interactions between characters, in case they overlap (which can happen for gameplay reasons, etc).  You should call this once per frame, before your PxController::move() calls. The function will not move the characters directly, but it will compute overlap information for each character that will be used in the next move() call.  You need to provide a proper time value here so that interactions are resolved in a way that do not depend on the framerate.  If you only have one character in the scene, or if you can guarantee your characters will never overlap, then you do not need to call this function.  Releasing the manager will automatically release all the associated obstacle contexts.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxControllerManager_setTessellation_mut(MagicPhysX.PxControllerManager*,System.Boolean,System.Single)">
            <summary>Enables or disables runtime tessellation.  Large triangles can create accuracy issues in the sweep code, which in turn can lead to characters not sliding smoothly against geometries, or even penetrating them. This feature allows one to reduce those issues by tessellating large triangles at runtime, before performing sweeps against them. The amount of tessellation is controlled by the 'maxEdgeLength' parameter. Any triangle with at least one edge length greater than the maxEdgeLength will get recursively tessellated, until resulting triangles are small enough.  This features only applies to triangle meshes, convex meshes, heightfields and boxes.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxControllerManager_setOverlapRecoveryModule_mut(MagicPhysX.PxControllerManager*,System.Boolean)">
            <summary>Enables or disables the overlap recovery module.  The overlap recovery module can be used to depenetrate CCTs from static objects when an overlap is detected. This can happen in three main cases: - when the CCT is directly spawned or teleported in another object - when the CCT algorithm fails due to limited FPU accuracy - when the \"up vector\" is modified, making the rotated CCT shape overlap surrounding objects  When activated, the CCT module will automatically try to resolve the penetration, and move the CCT to a safe place where it does not overlap other objects anymore. This only concerns static objects, dynamic objects are ignored by the recovery module.  When the recovery module is not activated, it is possible for the CCTs to go through static objects. By default, the recovery module is enabled.  The recovery module currently works with all geometries except heightfields.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxControllerManager_setPreciseSweeps_mut(MagicPhysX.PxControllerManager*,System.Boolean)">
            <summary>Enables or disables the precise sweeps.  Precise sweeps are more accurate, but also potentially slower than regular sweeps.  By default, precise sweeps are enabled.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxControllerManager_setPreventVerticalSlidingAgainstCeiling_mut(MagicPhysX.PxControllerManager*,System.Boolean)">
            <summary>Enables or disables vertical sliding against ceilings.  Geometry is seen as \"ceilings\" when the following condition is met:  dot product(contact normal, up direction) &lt; 0.0f  This flag controls whether characters should slide vertically along the geometry in that case.  By default, sliding is allowed.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxControllerManager_shiftOrigin_mut(MagicPhysX.PxControllerManager*,MagicPhysX.PxVec3*)">
            <summary>Shift the origin of the character controllers and obstacle objects by the specified vector.  The positions of all character controllers, obstacle objects and the corresponding data structures will get adjusted to reflect the shifted origin location (the shift vector will get subtracted from all character controller and obstacle object positions).  It is the user's responsibility to keep track of the summed total origin shift and adjust all input/output to/from PhysXCharacterKinematic accordingly.  This call will not automatically shift the PhysX scene and its objects. You need to call PxScene::shiftOrigin() seperately to keep the systems in sync.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCreateControllerManager(MagicPhysX.PxScene*,System.Boolean)">
            <summary>Creates the controller manager.  The character controller is informed by [`PxDeletionListener::onRelease`]() when actors or shapes are released, and updates its internal caches accordingly. If character controller movement or a call to [`PxControllerManager::shiftOrigin`]() may overlap with actor/shape releases, internal data structures must be guarded against concurrent access.  Locking guarantees thread safety in such scenarios.  locking may result in significant slowdown for release of actors or shapes.  By default, locking is disabled.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSDFDesc_new">
            <summary>Constructor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSDFDesc_isValid(MagicPhysX.PxSDFDesc*)">
            <summary>Returns true if the descriptor is valid.  true if the current settings are valid</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConvexMeshDesc_new">
            <summary>constructor sets to default.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConvexMeshDesc_setToDefault_mut(MagicPhysX.PxConvexMeshDesc*)">
            <summary>(re)sets the structure to the default.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxConvexMeshDesc_isValid(MagicPhysX.PxConvexMeshDesc*)">
            <summary>Returns true if the descriptor is valid.  True if the current settings are valid</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTriangleMeshDesc_new">
            <summary>Constructor sets to default.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTriangleMeshDesc_setToDefault_mut(MagicPhysX.PxTriangleMeshDesc*)">
            <summary>(re)sets the structure to the default.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTriangleMeshDesc_isValid(MagicPhysX.PxTriangleMeshDesc*)">
            <summary>Returns true if the descriptor is valid.  true if the current settings are valid</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTetrahedronMeshDesc_new">
            <summary>Constructor to build an empty tetmesh description</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSoftBodySimulationDataDesc_new">
            <summary>Constructor to build an empty simulation description</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBVH34MidphaseDesc_setToDefault_mut(MagicPhysX.PxBVH34MidphaseDesc*)">
            <summary>Desc initialization to default value.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBVH34MidphaseDesc_isValid(MagicPhysX.PxBVH34MidphaseDesc*)">
            <summary>Returns true if the descriptor is valid.  true if the current settings are valid.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMidphaseDesc_getType(MagicPhysX.PxMidphaseDesc*)">
            <summary>Returns type of midphase mesh structure.  PxMeshMidPhase::Enum</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMidphaseDesc_setToDefault_mut(MagicPhysX.PxMidphaseDesc*,MagicPhysX.PxMeshMidPhase)">
            <summary>Initialize the midphase mesh structure descriptor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMidphaseDesc_isValid(MagicPhysX.PxMidphaseDesc*)">
            <summary>Returns true if the descriptor is valid.  true if the current settings are valid.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBVHDesc_setToDefault_mut(MagicPhysX.PxBVHDesc*)">
            <summary>Initialize the BVH descriptor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBVHDesc_isValid(MagicPhysX.PxBVHDesc*)">
            <summary>Returns true if the descriptor is valid.  true if the current settings are valid.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCookBVH(MagicPhysX.PxBVHDesc*,MagicPhysX.PxOutputStream*)">
            <summary>Cooks a bounding volume hierarchy. The results are written to the stream.  PxCookBVH() allows a BVH description to be cooked into a binary stream suitable for loading and performing BVH detection at runtime.  true on success.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCreateBVH(MagicPhysX.PxBVHDesc*,MagicPhysX.PxInsertionCallback*)">
            <summary>Cooks and creates a bounding volume hierarchy without going through a stream.  This method does the same as cookBVH, but the produced BVH is not stored into a stream but is either directly inserted in PxPhysics, or created as a standalone object. Use this method if you are unable to cook offline.  PxInsertionCallback can be obtained through PxPhysics::getPhysicsInsertionCallback() or PxCooking::getStandaloneInsertionCallback().  PxBVH pointer on success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCookHeightField(MagicPhysX.PxHeightFieldDesc*,MagicPhysX.PxOutputStream*)">
            <summary>Cooks a heightfield. The results are written to the stream.  To create a heightfield object there is an option to precompute some of calculations done while loading the heightfield data.  cookHeightField() allows a heightfield description to be cooked into a binary stream suitable for loading and performing collision detection at runtime.  true on success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCreateHeightField(MagicPhysX.PxHeightFieldDesc*,MagicPhysX.PxInsertionCallback*)">
            <summary>Cooks and creates a heightfield mesh and inserts it into PxPhysics.  PxHeightField pointer on success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCookConvexMesh(MagicPhysX.PxCookingParams*,MagicPhysX.PxConvexMeshDesc*,MagicPhysX.PxOutputStream*,MagicPhysX.PxConvexMeshCookingResult*)">
            <summary>Cooks a convex mesh. The results are written to the stream.  To create a triangle mesh object it is necessary to first 'cook' the mesh data into a form which allows the SDK to perform efficient collision detection.  cookConvexMesh() allows a mesh description to be cooked into a binary stream suitable for loading and performing collision detection at runtime.  The number of vertices and the number of convex polygons in a cooked convex mesh is limited to 255.  If those limits are exceeded in either the user-provided data or the final cooked mesh, an error is reported.  true on success.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCreateConvexMesh(MagicPhysX.PxCookingParams*,MagicPhysX.PxConvexMeshDesc*,MagicPhysX.PxInsertionCallback*,MagicPhysX.PxConvexMeshCookingResult*)">
            <summary>Cooks and creates a convex mesh without going through a stream.  This method does the same as cookConvexMesh, but the produced mesh is not stored into a stream but is either directly inserted in PxPhysics, or created as a standalone object. Use this method if you are unable to cook offline.  PxInsertionCallback can be obtained through PxPhysics::getPhysicsInsertionCallback() or PxCooking::getStandaloneInsertionCallback().  PxConvexMesh pointer on success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxValidateConvexMesh(MagicPhysX.PxCookingParams*,MagicPhysX.PxConvexMeshDesc*)">
            <summary>Verifies if the convex mesh is valid. Prints an error message for each inconsistency found.  The convex mesh descriptor must contain an already created convex mesh - the vertices, indices and polygons must be provided.  This function should be used if PxConvexFlag::eDISABLE_MESH_VALIDATION is planned to be used in release builds.  true if all the validity conditions hold, false otherwise.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxComputeHullPolygons(MagicPhysX.PxCookingParams*,MagicPhysX.PxSimpleTriangleMesh*,MagicPhysX.PxAllocatorCallback*,System.UInt32*,MagicPhysX.PxVec3**,System.UInt32*,System.UInt32**,System.UInt32*,MagicPhysX.PxHullPolygon**)">
            <summary>Computed hull polygons from given vertices and triangles. Polygons are needed for PxConvexMeshDesc rather than triangles.  Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. The output vertices, indices and polygons must be used to construct a hull.  The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those array's.  true on success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxValidateTriangleMesh(MagicPhysX.PxCookingParams*,MagicPhysX.PxTriangleMeshDesc*)">
            <summary>Verifies if the triangle mesh is valid. Prints an error message for each inconsistency found.  The following conditions are true for a valid triangle mesh: 1. There are no duplicate vertices (within specified vertexWeldTolerance. See PxCookingParams::meshWeldTolerance) 2. There are no large triangles (within specified PxTolerancesScale.)  true if all the validity conditions hold, false otherwise.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCreateTriangleMesh(MagicPhysX.PxCookingParams*,MagicPhysX.PxTriangleMeshDesc*,MagicPhysX.PxInsertionCallback*,MagicPhysX.PxTriangleMeshCookingResult*)">
            <summary>Cooks and creates a triangle mesh without going through a stream.  This method does the same as cookTriangleMesh, but the produced mesh is not stored into a stream but is either directly inserted in PxPhysics, or created as a standalone object. Use this method if you are unable to cook offline.  PxInsertionCallback can be obtained through PxPhysics::getPhysicsInsertionCallback() or PxCooking::getStandaloneInsertionCallback().  PxTriangleMesh pointer on success.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCookTriangleMesh(MagicPhysX.PxCookingParams*,MagicPhysX.PxTriangleMeshDesc*,MagicPhysX.PxOutputStream*,MagicPhysX.PxTriangleMeshCookingResult*)">
            <summary>Cooks a triangle mesh. The results are written to the stream.  To create a triangle mesh object it is necessary to first 'cook' the mesh data into a form which allows the SDK to perform efficient collision detection.  PxCookTriangleMesh() allows a mesh description to be cooked into a binary stream suitable for loading and performing collision detection at runtime.  true on success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJoint_setActors_mut(MagicPhysX.PxJoint*,MagicPhysX.PxRigidActor*,MagicPhysX.PxRigidActor*)">
            <summary>Set the actors for this joint.  An actor may be NULL to indicate the world frame. At most one of the actors may be NULL.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJoint_getActors(MagicPhysX.PxJoint*,MagicPhysX.PxRigidActor**,MagicPhysX.PxRigidActor**)">
            <summary>Get the actors for this joint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJoint_setLocalPose_mut(MagicPhysX.PxJoint*,MagicPhysX.PxJointActorIndex,MagicPhysX.PxTransform*)">
            <summary>Set the joint local pose for an actor.  This is the relative pose which locates the joint frame relative to the actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJoint_getLocalPose(MagicPhysX.PxJoint*,MagicPhysX.PxJointActorIndex)">
            <summary>get the joint local pose for an actor.  return the local pose for this joint</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJoint_getRelativeTransform(MagicPhysX.PxJoint*)">
            <summary>get the relative pose for this joint  This function returns the pose of the joint frame of actor1 relative to actor0</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJoint_getRelativeLinearVelocity(MagicPhysX.PxJoint*)">
            <summary>get the relative linear velocity of the joint  This function returns the linear velocity of the origin of the constraint frame of actor1, relative to the origin of the constraint frame of actor0. The value is returned in the constraint frame of actor0</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJoint_getRelativeAngularVelocity(MagicPhysX.PxJoint*)">
            <summary>get the relative angular velocity of the joint  This function returns the angular velocity of  actor1 relative to actor0. The value is returned in the constraint frame of actor0</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJoint_setBreakForce_mut(MagicPhysX.PxJoint*,System.Single,System.Single)">
            <summary>set the break force for this joint.  if the constraint force or torque on the joint exceeds the specified values, the joint will break, at which point it will not constrain the two actors and the flag PxConstraintFlag::eBROKEN will be set. The force and torque are measured in the joint frame of the first actor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJoint_getBreakForce(MagicPhysX.PxJoint*,System.Single*,System.Single*)">
            <summary>get the break force for this joint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJoint_setConstraintFlags_mut(MagicPhysX.PxJoint*,MagicPhysX.PxConstraintFlags)">
            <summary>set the constraint flags for this joint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJoint_setConstraintFlag_mut(MagicPhysX.PxJoint*,MagicPhysX.PxConstraintFlag,System.Boolean)">
            <summary>set a constraint flags for this joint to a specified value.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJoint_getConstraintFlags(MagicPhysX.PxJoint*)">
            <summary>get the constraint flags for this joint.  the constraint flags</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJoint_setInvMassScale0_mut(MagicPhysX.PxJoint*,System.Single)">
            <summary>set the inverse mass scale for actor0.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJoint_getInvMassScale0(MagicPhysX.PxJoint*)">
            <summary>get the inverse mass scale for actor0.  inverse mass scale for actor0</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJoint_setInvInertiaScale0_mut(MagicPhysX.PxJoint*,System.Single)">
            <summary>set the inverse inertia scale for actor0.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJoint_getInvInertiaScale0(MagicPhysX.PxJoint*)">
            <summary>get the inverse inertia scale for actor0.  inverse inertia scale for actor0</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJoint_setInvMassScale1_mut(MagicPhysX.PxJoint*,System.Single)">
            <summary>set the inverse mass scale for actor1.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJoint_getInvMassScale1(MagicPhysX.PxJoint*)">
            <summary>get the inverse mass scale for actor1.  inverse mass scale for actor1</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJoint_setInvInertiaScale1_mut(MagicPhysX.PxJoint*,System.Single)">
            <summary>set the inverse inertia scale for actor1.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJoint_getInvInertiaScale1(MagicPhysX.PxJoint*)">
            <summary>get the inverse inertia scale for actor1.  inverse inertia scale for actor1</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJoint_getConstraint(MagicPhysX.PxJoint*)">
            <summary>Retrieves the PxConstraint corresponding to this joint.  This can be used to determine, among other things, the force applied at the joint.  the constraint</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJoint_setName_mut(MagicPhysX.PxJoint*,System.Byte*)">
            <summary>Sets a name string for the object that can be retrieved with getName().  This is for debugging and is not used by the SDK. The string is not copied by the SDK, only the pointer is stored.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJoint_getName(MagicPhysX.PxJoint*)">
            <summary>Retrieves the name string set with setName().  Name string associated with object.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJoint_release_mut(MagicPhysX.PxJoint*)">
            <summary>Deletes the joint.  This call does not wake up the connected rigid bodies.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJoint_getScene(MagicPhysX.PxJoint*)">
            <summary>Retrieves the scene which this joint belongs to.  Owner Scene. NULL if not part of a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJoint_getBinaryMetaData(MagicPhysX.PxOutputStream*)">
            <summary>Put class meta data in stream, used for serialization</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxSetJointGlobalFrame(MagicPhysX.PxJoint*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>Helper function to setup a joint's global frame  This replaces the following functions from previous SDK versions:  void NxJointDesc::setGlobalAnchor(const NxVec3 &amp; wsAnchor); void NxJointDesc::setGlobalAxis(const NxVec3 &amp; wsAxis);  The function sets the joint's localPose using world-space input parameters.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxDistanceJointCreate(MagicPhysX.PxPhysics*,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*)">
            <summary>Create a distance Joint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxDistanceJoint_getDistance(MagicPhysX.PxDistanceJoint*)">
            <summary>Return the current distance of the joint</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxDistanceJoint_setMinDistance_mut(MagicPhysX.PxDistanceJoint*,System.Single)">
            <summary>Set the allowed minimum distance for the joint.  The minimum distance must be no more than the maximum distance  Default 0.0f Range [0, PX_MAX_F32)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxDistanceJoint_getMinDistance(MagicPhysX.PxDistanceJoint*)">
            <summary>Get the allowed minimum distance for the joint.  the allowed minimum distance</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxDistanceJoint_setMaxDistance_mut(MagicPhysX.PxDistanceJoint*,System.Single)">
            <summary>Set the allowed maximum distance for the joint.  The maximum distance must be no less than the minimum distance.  Default 0.0f Range [0, PX_MAX_F32)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxDistanceJoint_getMaxDistance(MagicPhysX.PxDistanceJoint*)">
            <summary>Get the allowed maximum distance for the joint.  the allowed maximum distance</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxDistanceJoint_setTolerance_mut(MagicPhysX.PxDistanceJoint*,System.Single)">
            <summary>Set the error tolerance of the joint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxDistanceJoint_getTolerance(MagicPhysX.PxDistanceJoint*)">
            <summary>Get the error tolerance of the joint.  the distance beyond the joint's [min, max] range before the joint becomes active.  Default 0.25f * PxTolerancesScale::length Range (0, PX_MAX_F32)  This value should be used to ensure that if the minimum distance is zero and the spring function is in use, the rest length of the spring is non-zero.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxDistanceJoint_setStiffness_mut(MagicPhysX.PxDistanceJoint*,System.Single)">
            <summary>Set the strength of the joint spring.  The spring is used if enabled, and the distance exceeds the range [min-error, max+error].  Default 0.0f Range [0, PX_MAX_F32)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxDistanceJoint_getStiffness(MagicPhysX.PxDistanceJoint*)">
            <summary>Get the strength of the joint spring.  stiffness the spring strength of the joint</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxDistanceJoint_setDamping_mut(MagicPhysX.PxDistanceJoint*,System.Single)">
            <summary>Set the damping of the joint spring.  The spring is used if enabled, and the distance exceeds the range [min-error, max+error].  Default 0.0f Range [0, PX_MAX_F32)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxDistanceJoint_getDamping(MagicPhysX.PxDistanceJoint*)">
            <summary>Get the damping of the joint spring.  the degree of damping of the joint spring of the joint</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxDistanceJoint_setContactDistance_mut(MagicPhysX.PxDistanceJoint*,System.Single)">
            <summary>Set the contact distance for the min &amp; max distance limits.  This is similar to the PxJointLimitParameters::contactDistance parameter for regular limits.  The two most common values are 0 and infinite. Infinite means the internal constraints are always created, resulting in the best simulation quality but slower performance. Zero means the internal constraints are only created when the limits are violated, resulting in best performance but worse simulation quality.  Default 0.0f Range [0, PX_MAX_F32)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxDistanceJoint_getContactDistance(MagicPhysX.PxDistanceJoint*)">
            <summary>Get the contact distance.  the contact distance</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxDistanceJoint_setDistanceJointFlags_mut(MagicPhysX.PxDistanceJoint*,MagicPhysX.PxDistanceJointFlags)">
            <summary>Set the flags specific to the Distance Joint.  Default PxDistanceJointFlag::eMAX_DISTANCE_ENABLED</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxDistanceJoint_setDistanceJointFlag_mut(MagicPhysX.PxDistanceJoint*,MagicPhysX.PxDistanceJointFlag,System.Boolean)">
            <summary>Set a single flag specific to a Distance Joint to true or false.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxDistanceJoint_getDistanceJointFlags(MagicPhysX.PxDistanceJoint*)">
            <summary>Get the flags specific to the Distance Joint.  the joint flags</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxDistanceJoint_getConcreteTypeName(MagicPhysX.PxDistanceJoint*)">
            <summary>Returns string name of PxDistanceJoint, used for serialization</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxContactJointCreate(MagicPhysX.PxPhysics*,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*)">
            <summary>Create a distance Joint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactJoint_setContact_mut(MagicPhysX.PxContactJoint*,MagicPhysX.PxVec3*)">
            <summary>Set the current contact of the joint</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactJoint_setContactNormal_mut(MagicPhysX.PxContactJoint*,MagicPhysX.PxVec3*)">
            <summary>Set the current contact normal of the joint</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactJoint_setPenetration_mut(MagicPhysX.PxContactJoint*,System.Single)">
            <summary>Set the current penetration of the joint</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactJoint_getContact(MagicPhysX.PxContactJoint*)">
            <summary>Return the current contact of the joint</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactJoint_getContactNormal(MagicPhysX.PxContactJoint*)">
            <summary>Return the current contact normal of the joint</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactJoint_getPenetration(MagicPhysX.PxContactJoint*)">
            <summary>Return the current penetration value of the joint</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxContactJoint_getConcreteTypeName(MagicPhysX.PxContactJoint*)">
            <summary>Returns string name of PxContactJoint, used for serialization</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxFixedJointCreate(MagicPhysX.PxPhysics*,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*)">
            <summary>Create a fixed joint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxFixedJoint_getConcreteTypeName(MagicPhysX.PxFixedJoint*)">
            <summary>Returns string name of PxFixedJoint, used for serialization</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJointLimitParameters_isValid(MagicPhysX.PxJointLimitParameters*)">
            <summary>Returns true if the current settings are valid.  true if the current settings are valid</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJointLinearLimit_new(MagicPhysX.PxTolerancesScale*,System.Single,System.Single)">
            <summary>construct a linear hard limit</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJointLinearLimit_new_1(System.Single,MagicPhysX.PxSpring*)">
            <summary>construct a linear soft limit</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJointLinearLimit_isValid(MagicPhysX.PxJointLinearLimit*)">
            <summary>Returns true if the limit is valid  true if the current settings are valid</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJointLinearLimitPair_new(MagicPhysX.PxTolerancesScale*,System.Single,System.Single,System.Single)">
            <summary>Construct a linear hard limit pair. The lower distance value must be less than the upper distance value.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJointLinearLimitPair_new_1(System.Single,System.Single,MagicPhysX.PxSpring*)">
            <summary>construct a linear soft limit pair</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJointLinearLimitPair_isValid(MagicPhysX.PxJointLinearLimitPair*)">
            <summary>Returns true if the limit is valid.  true if the current settings are valid</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJointAngularLimitPair_new(System.Single,System.Single,System.Single)">
            <summary>construct an angular hard limit pair.  The lower value must be less than the upper value.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJointAngularLimitPair_new_1(System.Single,System.Single,MagicPhysX.PxSpring*)">
            <summary>construct an angular soft limit pair.  The lower value must be less than the upper value.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJointAngularLimitPair_isValid(MagicPhysX.PxJointAngularLimitPair*)">
            <summary>Returns true if the limit is valid.  true if the current settings are valid</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJointLimitCone_new(System.Single,System.Single,System.Single)">
            <summary>Construct a cone hard limit.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJointLimitCone_new_1(System.Single,System.Single,MagicPhysX.PxSpring*)">
            <summary>Construct a cone soft limit.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJointLimitCone_isValid(MagicPhysX.PxJointLimitCone*)">
            <summary>Returns true if the limit is valid.  true if the current settings are valid</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJointLimitPyramid_new(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>Construct a pyramid hard limit.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJointLimitPyramid_new_1(System.Single,System.Single,System.Single,System.Single,MagicPhysX.PxSpring*)">
            <summary>Construct a pyramid soft limit.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxJointLimitPyramid_isValid(MagicPhysX.PxJointLimitPyramid*)">
            <summary>Returns true if the limit is valid.  true if the current settings are valid</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxPrismaticJointCreate(MagicPhysX.PxPhysics*,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*)">
            <summary>Create a prismatic joint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPrismaticJoint_getPosition(MagicPhysX.PxPrismaticJoint*)">
            <summary>returns the displacement of the joint along its axis.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPrismaticJoint_getVelocity(MagicPhysX.PxPrismaticJoint*)">
            <summary>returns the velocity of the joint along its axis</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPrismaticJoint_setLimit_mut(MagicPhysX.PxPrismaticJoint*,MagicPhysX.PxJointLinearLimitPair*)">
            <summary>sets the joint limit  parameters.  The limit range is [-PX_MAX_F32, PX_MAX_F32], but note that the width of the limit (upper-lower) must also be a valid float.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPrismaticJoint_getLimit(MagicPhysX.PxPrismaticJoint*)">
            <summary>gets the joint limit  parameters.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPrismaticJoint_setPrismaticJointFlags_mut(MagicPhysX.PxPrismaticJoint*,MagicPhysX.PxPrismaticJointFlags)">
            <summary>Set the flags specific to the Prismatic Joint.  Default PxPrismaticJointFlags(0)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPrismaticJoint_setPrismaticJointFlag_mut(MagicPhysX.PxPrismaticJoint*,MagicPhysX.PxPrismaticJointFlag,System.Boolean)">
            <summary>Set a single flag specific to a Prismatic Joint to true or false.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPrismaticJoint_getPrismaticJointFlags(MagicPhysX.PxPrismaticJoint*)">
            <summary>Get the flags specific to the Prismatic Joint.  the joint flags</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPrismaticJoint_getConcreteTypeName(MagicPhysX.PxPrismaticJoint*)">
            <summary>Returns string name of PxPrismaticJoint, used for serialization</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxRevoluteJointCreate(MagicPhysX.PxPhysics*,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*)">
            <summary>Create a revolute joint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRevoluteJoint_getAngle(MagicPhysX.PxRevoluteJoint*)">
            <summary>return the angle of the joint, in the range (-2*Pi, 2*Pi]</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRevoluteJoint_getVelocity(MagicPhysX.PxRevoluteJoint*)">
            <summary>return the velocity of the joint</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRevoluteJoint_setLimit_mut(MagicPhysX.PxRevoluteJoint*,MagicPhysX.PxJointAngularLimitPair*)">
            <summary>set the joint limit parameters.  The limit is activated using the flag PxRevoluteJointFlag::eLIMIT_ENABLED  The limit angle range is (-2*Pi, 2*Pi).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRevoluteJoint_getLimit(MagicPhysX.PxRevoluteJoint*)">
            <summary>get the joint limit parameters.  the joint limit parameters</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRevoluteJoint_setDriveVelocity_mut(MagicPhysX.PxRevoluteJoint*,System.Single,System.Boolean)">
            <summary>set the target velocity for the drive model.  The motor will only be able to reach this velocity if the maxForce is sufficiently large. If the joint is spinning faster than this velocity, the motor will actually try to brake (see PxRevoluteJointFlag::eDRIVE_FREESPIN.)  The sign of this variable determines the rotation direction, with positive values going the same way as positive joint angles. Setting a very large target velocity may cause undesirable results.  Range: (-PX_MAX_F32, PX_MAX_F32) Default: 0.0</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRevoluteJoint_getDriveVelocity(MagicPhysX.PxRevoluteJoint*)">
            <summary>gets the target velocity for the drive model.  the drive target velocity</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRevoluteJoint_setDriveForceLimit_mut(MagicPhysX.PxRevoluteJoint*,System.Single)">
            <summary>sets the maximum torque the drive can exert.  The value set here may be used either as an impulse limit or a force limit, depending on the flag PxConstraintFlag::eDRIVE_LIMITS_ARE_FORCES  Range: [0, PX_MAX_F32) Default: PX_MAX_F32</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRevoluteJoint_getDriveForceLimit(MagicPhysX.PxRevoluteJoint*)">
            <summary>gets the maximum torque the drive can exert.  the torque limit</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRevoluteJoint_setDriveGearRatio_mut(MagicPhysX.PxRevoluteJoint*,System.Single)">
            <summary>sets the gear ratio for the drive.  When setting up the drive constraint, the velocity of the first actor is scaled by this value, and its response to drive torque is scaled down. So if the drive target velocity is zero, the second actor will be driven to the velocity of the first scaled by the gear ratio  Range: [0, PX_MAX_F32) Default: 1.0</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRevoluteJoint_getDriveGearRatio(MagicPhysX.PxRevoluteJoint*)">
            <summary>gets the gear ratio.  the drive gear ratio</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRevoluteJoint_setRevoluteJointFlags_mut(MagicPhysX.PxRevoluteJoint*,MagicPhysX.PxRevoluteJointFlags)">
            <summary>sets the flags specific to the Revolute Joint.  Default PxRevoluteJointFlags(0)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRevoluteJoint_setRevoluteJointFlag_mut(MagicPhysX.PxRevoluteJoint*,MagicPhysX.PxRevoluteJointFlag,System.Boolean)">
            <summary>sets a single flag specific to a Revolute Joint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRevoluteJoint_getRevoluteJointFlags(MagicPhysX.PxRevoluteJoint*)">
            <summary>gets the flags specific to the Revolute Joint.  the joint flags</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRevoluteJoint_getConcreteTypeName(MagicPhysX.PxRevoluteJoint*)">
            <summary>Returns string name of PxRevoluteJoint, used for serialization</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxSphericalJointCreate(MagicPhysX.PxPhysics*,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*)">
            <summary>Create a spherical joint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSphericalJoint_getLimitCone(MagicPhysX.PxSphericalJoint*)">
            <summary>Set the limit cone.  If enabled, the limit cone will constrain the angular movement of the joint to lie within an elliptical cone.  the limit cone</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSphericalJoint_setLimitCone_mut(MagicPhysX.PxSphericalJoint*,MagicPhysX.PxJointLimitCone*)">
            <summary>Get the limit cone.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSphericalJoint_getSwingYAngle(MagicPhysX.PxSphericalJoint*)">
            <summary>get the swing angle of the joint from the Y axis</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSphericalJoint_getSwingZAngle(MagicPhysX.PxSphericalJoint*)">
            <summary>get the swing angle of the joint from the Z axis</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSphericalJoint_setSphericalJointFlags_mut(MagicPhysX.PxSphericalJoint*,MagicPhysX.PxSphericalJointFlags)">
            <summary>Set the flags specific to the Spherical Joint.  Default PxSphericalJointFlags(0)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSphericalJoint_setSphericalJointFlag_mut(MagicPhysX.PxSphericalJoint*,MagicPhysX.PxSphericalJointFlag,System.Boolean)">
            <summary>Set a single flag specific to a Spherical Joint to true or false.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSphericalJoint_getSphericalJointFlags(MagicPhysX.PxSphericalJoint*)">
            <summary>Get the flags specific to the Spherical Joint.  the joint flags</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSphericalJoint_getConcreteTypeName(MagicPhysX.PxSphericalJoint*)">
            <summary>Returns string name of PxSphericalJoint, used for serialization</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxD6JointCreate(MagicPhysX.PxPhysics*,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*)">
            <summary>Create a D6 joint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxD6JointDrive_new">
            <summary>default constructor for PxD6JointDrive.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxD6JointDrive_new_1(System.Single,System.Single,System.Single,System.Boolean)">
            <summary>constructor a PxD6JointDrive.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxD6JointDrive_isValid(MagicPhysX.PxD6JointDrive*)">
            <summary>returns true if the drive is valid</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxD6Joint_setMotion_mut(MagicPhysX.PxD6Joint*,MagicPhysX.PxD6Axis,MagicPhysX.PxD6Motion)">
            <summary>Set the motion type around the specified axis.  Each axis may independently specify that the degree of freedom is locked (blocking relative movement along or around this axis), limited by the corresponding limit, or free.  Default: all degrees of freedom are locked</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxD6Joint_getMotion(MagicPhysX.PxD6Joint*,MagicPhysX.PxD6Axis)">
            <summary>Get the motion type around the specified axis.  the motion type around the specified axis</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxD6Joint_getTwistAngle(MagicPhysX.PxD6Joint*)">
            <summary>get the twist angle of the joint, in the range (-2*Pi, 2*Pi]</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxD6Joint_getSwingYAngle(MagicPhysX.PxD6Joint*)">
            <summary>get the swing angle of the joint from the Y axis</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxD6Joint_getSwingZAngle(MagicPhysX.PxD6Joint*)">
            <summary>get the swing angle of the joint from the Z axis</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxD6Joint_setDistanceLimit_mut(MagicPhysX.PxD6Joint*,MagicPhysX.PxJointLinearLimit*)">
            <summary>Set the distance limit for the joint.  A single limit constraints all linear limited degrees of freedom, forming a linear, circular or spherical constraint on motion depending on the number of limited degrees. This is similar to a distance limit.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxD6Joint_getDistanceLimit(MagicPhysX.PxD6Joint*)">
            <summary>Get the distance limit for the joint.  the distance limit structure</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxD6Joint_setLinearLimit_mut(MagicPhysX.PxD6Joint*,MagicPhysX.PxD6Axis,MagicPhysX.PxJointLinearLimitPair*)">
            <summary>Set the linear limit for a given linear axis.  This function extends the previous setDistanceLimit call with the following features: - there can be a different limit for each linear axis - each limit is defined by two values, i.e. it can now be asymmetric  This can be used to create prismatic joints similar to PxPrismaticJoint, or point-in-quad joints, or point-in-box joints.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxD6Joint_getLinearLimit(MagicPhysX.PxD6Joint*,MagicPhysX.PxD6Axis)">
            <summary>Get the linear limit for a given linear axis.  the linear limit pair structure from desired axis</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxD6Joint_setTwistLimit_mut(MagicPhysX.PxD6Joint*,MagicPhysX.PxJointAngularLimitPair*)">
            <summary>Set the twist limit for the joint.  The twist limit controls the range of motion around the twist axis.  The limit angle range is (-2*Pi, 2*Pi).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxD6Joint_getTwistLimit(MagicPhysX.PxD6Joint*)">
            <summary>Get the twist limit for the joint.  the twist limit structure</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxD6Joint_setSwingLimit_mut(MagicPhysX.PxD6Joint*,MagicPhysX.PxJointLimitCone*)">
            <summary>Set the swing cone limit for the joint.  The cone limit is used if either or both swing axes are limited. The extents are symmetrical and measured in the frame of the parent. If only one swing degree of freedom is limited, the corresponding value from the cone limit defines the limit range.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxD6Joint_getSwingLimit(MagicPhysX.PxD6Joint*)">
            <summary>Get the cone limit for the joint.  the swing limit structure</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxD6Joint_setPyramidSwingLimit_mut(MagicPhysX.PxD6Joint*,MagicPhysX.PxJointLimitPyramid*)">
            <summary>Set a pyramidal swing limit for the joint.  The pyramid limits will only be used in the following cases: - both swing Y and Z are limited. The limit shape is then a pyramid. - Y is limited and Z is locked, or vice versa. The limit shape is an asymmetric angular section, similar to what is supported for the twist axis. The remaining cases (Y limited and Z is free, or vice versa) are not supported.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxD6Joint_getPyramidSwingLimit(MagicPhysX.PxD6Joint*)">
            <summary>Get the pyramidal swing limit for the joint.  the swing limit structure</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxD6Joint_setDrive_mut(MagicPhysX.PxD6Joint*,MagicPhysX.PxD6Drive,MagicPhysX.PxD6JointDrive*)">
            <summary>Set the drive parameters for the specified drive type.  Default The default drive spring and damping values are zero, the force limit is zero, and no flags are set.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxD6Joint_getDrive(MagicPhysX.PxD6Joint*,MagicPhysX.PxD6Drive)">
            <summary>Get the drive parameters for the specified drive type.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxD6Joint_setDrivePosition_mut(MagicPhysX.PxD6Joint*,MagicPhysX.PxTransform*,System.Boolean)">
            <summary>Set the drive goal pose  The goal is relative to the constraint frame of actor[0]  Default the identity transform</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxD6Joint_getDrivePosition(MagicPhysX.PxD6Joint*)">
            <summary>Get the drive goal pose.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxD6Joint_setDriveVelocity_mut(MagicPhysX.PxD6Joint*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,System.Boolean)">
            <summary>Set the target goal velocity for drive.  The velocity is measured in the constraint frame of actor[0]</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxD6Joint_getDriveVelocity(MagicPhysX.PxD6Joint*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>Get the target goal velocity for joint drive.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxD6Joint_setProjectionLinearTolerance_mut(MagicPhysX.PxD6Joint*,System.Single)">
            <summary>Set the linear tolerance threshold for projection. Projection is enabled if PxConstraintFlag::ePROJECTION is set for the joint.  If the joint separates by more than this distance along its locked degrees of freedom, the solver will move the bodies to close the distance.  Setting a very small tolerance may result in simulation jitter or other artifacts.  Sometimes it is not possible to project (for example when the joints form a cycle).  Range: [0, PX_MAX_F32) Default: 1e10f</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxD6Joint_getProjectionLinearTolerance(MagicPhysX.PxD6Joint*)">
            <summary>Get the linear tolerance threshold for projection.  the linear tolerance threshold</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxD6Joint_setProjectionAngularTolerance_mut(MagicPhysX.PxD6Joint*,System.Single)">
            <summary>Set the angular tolerance threshold for projection. Projection is enabled if PxConstraintFlag::ePROJECTION is set for the joint.  If the joint deviates by more than this angle around its locked angular degrees of freedom, the solver will move the bodies to close the angle.  Setting a very small tolerance may result in simulation jitter or other artifacts.  Sometimes it is not possible to project (for example when the joints form a cycle).  Range: [0,Pi] Default: Pi  Angular projection is implemented only for the case of two or three locked angular degrees of freedom.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxD6Joint_getProjectionAngularTolerance(MagicPhysX.PxD6Joint*)">
            <summary>Get the angular tolerance threshold for projection.  tolerance the angular tolerance threshold in radians</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxD6Joint_getConcreteTypeName(MagicPhysX.PxD6Joint*)">
            <summary>Returns string name of PxD6Joint, used for serialization</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxGearJointCreate(MagicPhysX.PxPhysics*,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*)">
            <summary>Create a gear Joint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxGearJoint_setHinges_mut(MagicPhysX.PxGearJoint*,MagicPhysX.PxBase*,MagicPhysX.PxBase*)">
            <summary>Set the hinge/revolute joints connected by the gear joint.  The passed joints can be either PxRevoluteJoint, PxD6Joint or PxArticulationJointReducedCoordinate. The joints must define degrees of freedom around the twist axis. They cannot be null.  Note that these joints are only used to compute the positional error correction term, used to adjust potential drift between jointed actors. The gear joint can run without calling this function, but in that case some visible overlap may develop over time between the teeth of the gear meshes.  Calling this function resets the internal positional error correction term.  true if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxGearJoint_setGearRatio_mut(MagicPhysX.PxGearJoint*,System.Single)">
            <summary>Set the desired gear ratio.  For two gears with n0 and n1 teeth respectively, the gear ratio is n0/n1.  You may need to use a negative gear ratio if the joint frames of involved actors are not oriented in the same direction.  Calling this function resets the internal positional error correction term.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxGearJoint_getGearRatio(MagicPhysX.PxGearJoint*)">
            <summary>Get the gear ratio.  Current ratio</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxRackAndPinionJointCreate(MagicPhysX.PxPhysics*,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*)">
            <summary>Create a rack &amp; pinion Joint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRackAndPinionJoint_setJoints_mut(MagicPhysX.PxRackAndPinionJoint*,MagicPhysX.PxBase*,MagicPhysX.PxBase*)">
            <summary>Set the hinge &amp; prismatic joints connected by the rack &amp; pinion joint.  The passed hinge joint can be either PxRevoluteJoint, PxD6Joint or PxArticulationJointReducedCoordinate. It cannot be null. The passed prismatic joint can be either PxPrismaticJoint or PxD6Joint. It cannot be null.  Note that these joints are only used to compute the positional error correction term, used to adjust potential drift between jointed actors. The rack &amp; pinion joint can run without calling this function, but in that case some visible overlap may develop over time between the teeth of the rack &amp; pinion meshes.  Calling this function resets the internal positional error correction term.  true if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRackAndPinionJoint_setRatio_mut(MagicPhysX.PxRackAndPinionJoint*,System.Single)">
            <summary>Set the desired ratio directly.  You may need to use a negative gear ratio if the joint frames of involved actors are not oriented in the same direction.  Calling this function resets the internal positional error correction term.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRackAndPinionJoint_getRatio(MagicPhysX.PxRackAndPinionJoint*)">
            <summary>Get the ratio.  Current ratio</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRackAndPinionJoint_setData_mut(MagicPhysX.PxRackAndPinionJoint*,System.UInt32,System.UInt32,System.Single)">
            <summary>Set the desired ratio indirectly.  This is a simple helper function that computes the ratio from passed data:  ratio = (PI*2*nbRackTeeth)/(rackLength*nbPinionTeeth)  Calling this function resets the internal positional error correction term.  true if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxDefaultSimulationFilterShader(System.UInt32,MagicPhysX.PxFilterData,System.UInt32,MagicPhysX.PxFilterData,MagicPhysX.PxPairFlags*,System.Void*,System.UInt32)">
            <summary>Implementation of a simple filter shader that emulates PhysX 2.8.x filtering  This shader provides the following logic:  If one of the two filter objects is a trigger, the pair is acccepted and [`PxPairFlag::eTRIGGER_DEFAULT`] will be used for trigger reports  Else, if the filter mask logic (see further below) discards the pair it will be suppressed ([`PxFilterFlag::eSUPPRESS`])  Else, the pair gets accepted and collision response gets enabled ([`PxPairFlag::eCONTACT_DEFAULT`])  Filter mask logic: Given the two [`PxFilterData`] structures fd0 and fd1 of two collision objects, the pair passes the filter if the following conditions are met:  1) Collision groups of the pair are enabled 2) Collision filtering equation is satisfied</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxGetGroupCollisionFlag(System.UInt16,System.UInt16)">
            <summary>Determines if collision detection is performed between a pair of groups  Collision group is an integer between 0 and 31.  True if the groups could collide</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxSetGroupCollisionFlag(System.UInt16,System.UInt16,System.Boolean)">
            <summary>Specifies if collision should be performed by a pair of groups  Collision group is an integer between 0 and 31.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxGetGroup(MagicPhysX.PxActor*)">
            <summary>Retrieves the value set with PxSetGroup()  Collision group is an integer between 0 and 31.  The collision group this actor belongs to</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxSetGroup(MagicPhysX.PxActor*,System.UInt16)">
            <summary>Sets which collision group this actor is part of  Collision group is an integer between 0 and 31.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxGetFilterOps(MagicPhysX.PxFilterOp*,MagicPhysX.PxFilterOp*,MagicPhysX.PxFilterOp*)">
            <summary>Retrieves filtering operation. See comments for PxGroupsMask</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxSetFilterOps(MagicPhysX.PxFilterOp*,MagicPhysX.PxFilterOp*,MagicPhysX.PxFilterOp*)">
            <summary>Setups filtering operations. See comments for PxGroupsMask</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxGetFilterBool">
            <summary>Retrieves filtering's boolean value. See comments for PxGroupsMask  flag Boolean value for filter.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxSetFilterBool(System.Boolean)">
            <summary>Setups filtering's boolean value. See comments for PxGroupsMask</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxGetFilterConstants(MagicPhysX.PxGroupsMask*,MagicPhysX.PxGroupsMask*)">
            <summary>Gets filtering constant K0 and K1. See comments for PxGroupsMask</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxSetFilterConstants(MagicPhysX.PxGroupsMask*,MagicPhysX.PxGroupsMask*)">
            <summary>Setups filtering's K0 and K1 value. See comments for PxGroupsMask</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxGetGroupsMask(MagicPhysX.PxActor*)">
            <summary>Gets 64-bit mask used for collision filtering. See comments for PxGroupsMask  The group mask for the actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxSetGroupsMask(MagicPhysX.PxActor*,MagicPhysX.PxGroupsMask*)">
            <summary>Sets 64-bit mask used for collision filtering. See comments for PxGroupsMask</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidActorExt_createExclusiveShape(MagicPhysX.PxRigidActor*,MagicPhysX.PxGeometry*,MagicPhysX.PxMaterial**,System.UInt16,MagicPhysX.PxShapeFlags)">
            <summary>Creates a new shape with default properties and a list of materials and adds it to the list of shapes of this actor.  This is equivalent to the following  ```cpp // reference count is 1 PxShape* shape(...) = PxGetPhysics().createShape(...); // increments reference count actor-&gt;attachShape(shape); // releases user reference, leaving reference count at 1 shape-&gt;release(); ```  As a consequence, detachShape() will result in the release of the last reference, and the shape will be deleted.  The default shape flags to be set are: eVISUALIZATION, eSIMULATION_SHAPE, eSCENE_QUERY_SHAPE (see [`PxShapeFlag`]). Triangle mesh, heightfield or plane geometry shapes configured as eSIMULATION_SHAPE are not supported for non-kinematic PxRigidDynamic instances.  Creating compounds with a very large number of shapes may adversely affect performance and stability.  Sleeping: Does NOT wake the actor up automatically.  The newly created shape.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidActorExt_createExclusiveShape_1(MagicPhysX.PxRigidActor*,MagicPhysX.PxGeometry*,MagicPhysX.PxMaterial*,MagicPhysX.PxShapeFlags)">
            <summary>Creates a new shape with default properties and a single material adds it to the list of shapes of this actor.  This is equivalent to the following  ```cpp // reference count is 1 PxShape* shape(...) = PxGetPhysics().createShape(...); // increments reference count actor-&gt;attachShape(shape); // releases user reference, leaving reference count at 1 shape-&gt;release(); ```  As a consequence, detachShape() will result in the release of the last reference, and the shape will be deleted.  The default shape flags to be set are: eVISUALIZATION, eSIMULATION_SHAPE, eSCENE_QUERY_SHAPE (see [`PxShapeFlag`]). Triangle mesh, heightfield or plane geometry shapes configured as eSIMULATION_SHAPE are not supported for non-kinematic PxRigidDynamic instances.  Creating compounds with a very large number of shapes may adversely affect performance and stability.  Sleeping: Does NOT wake the actor up automatically.  The newly created shape.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidActorExt_getRigidActorShapeLocalBoundsList(MagicPhysX.PxRigidActor*,System.UInt32*)">
            <summary>Gets a list of bounds based on shapes in rigid actor. This list can be used to cook/create bounding volume hierarchy though PxCooking API.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidActorExt_createBVHFromActor(MagicPhysX.PxPhysics*,MagicPhysX.PxRigidActor*)">
            <summary>Convenience function to create a PxBVH object from a PxRigidActor.  The computed PxBVH can then be used in PxScene::addActor() or PxAggregate::addActor(). After adding the actor &amp; BVH to the scene/aggregate, release the PxBVH object by calling PxBVH::release().  The PxBVH for this actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMassProperties_new">
            <summary>Default constructor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMassProperties_new_1(System.Single,MagicPhysX.PxMat33*,MagicPhysX.PxVec3*)">
            <summary>Construct from individual elements.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMassProperties_new_2(MagicPhysX.PxGeometry*)">
            <summary>Compute mass properties based on a provided geometry structure.  This constructor assumes the geometry has a density of 1. Mass and inertia tensor scale linearly with density.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMassProperties_translate_mut(MagicPhysX.PxMassProperties*,MagicPhysX.PxVec3*)">
            <summary>Translate the center of mass by a given vector and adjust the inertia tensor accordingly.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMassProperties_getMassSpaceInertia(MagicPhysX.PxMat33*,MagicPhysX.PxQuat*)">
            <summary>Get the entries of the diagonalized inertia tensor and the corresponding reference rotation.  The entries of the diagonalized inertia tensor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMassProperties_translateInertia(MagicPhysX.PxMat33*,System.Single,MagicPhysX.PxVec3*)">
            <summary>Translate an inertia tensor using the parallel axis theorem  The translated inertia tensor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMassProperties_rotateInertia(MagicPhysX.PxMat33*,MagicPhysX.PxQuat*)">
            <summary>Rotate an inertia tensor around the center of mass  The rotated inertia tensor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMassProperties_scaleInertia(MagicPhysX.PxMat33*,MagicPhysX.PxQuat*,MagicPhysX.PxVec3*)">
            <summary>Non-uniform scaling of the inertia tensor  The scaled inertia tensor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMassProperties_sum(MagicPhysX.PxMassProperties*,MagicPhysX.PxTransform*,System.UInt32)">
            <summary>Sum up individual mass properties.  The summed up mass properties.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBodyExt_updateMassAndInertia(MagicPhysX.PxRigidBody*,System.Single*,System.UInt32,MagicPhysX.PxVec3*,System.Boolean)">
            <summary>Computation of mass properties for a rigid body actor  To simulate a dynamic rigid actor, the SDK needs a mass and an inertia tensor.  This method offers functionality to compute the necessary mass and inertia properties based on the shapes declared in the PxRigidBody descriptor and some additionally specified parameters. For each shape, the shape geometry, the shape positioning within the actor and the specified shape density are used to compute the body's mass and inertia properties.  Shapes without PxShapeFlag::eSIMULATION_SHAPE set are ignored unless includeNonSimShapes is true. Shapes with plane, triangle mesh or heightfield geometry and PxShapeFlag::eSIMULATION_SHAPE set are not allowed for PxRigidBody collision.  This method will set the mass, center of mass, and inertia tensor  if no collision shapes are found, the inertia tensor is set to (1,1,1) and the mass to 1  if massLocalPose is non-NULL, the rigid body's center of mass parameter  will be set to the user provided value (massLocalPose) and the inertia tensor will be resolved at that point.  If all shapes of the actor have the same density then the overloaded method updateMassAndInertia() with a single density parameter can be used instead.  Boolean. True on success else false.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBodyExt_updateMassAndInertia_1(MagicPhysX.PxRigidBody*,System.Single,MagicPhysX.PxVec3*,System.Boolean)">
            <summary>Computation of mass properties for a rigid body actor  See previous method for details.  Boolean. True on success else false.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBodyExt_setMassAndUpdateInertia(MagicPhysX.PxRigidBody*,System.Single*,System.UInt32,MagicPhysX.PxVec3*,System.Boolean)">
            <summary>Computation of mass properties for a rigid body actor  This method sets the mass, inertia and center of mass of a rigid body. The mass is set to the sum of all user-supplied shape mass values, and the inertia and center of mass are computed according to the rigid body's shapes and the per shape mass input values.  If no collision shapes are found, the inertia tensor is set to (1,1,1)  If a single mass value should be used for the actor as a whole then the overloaded method setMassAndUpdateInertia() with a single mass parameter can be used instead.  Boolean. True on success else false.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBodyExt_setMassAndUpdateInertia_1(MagicPhysX.PxRigidBody*,System.Single,MagicPhysX.PxVec3*,System.Boolean)">
            <summary>Computation of mass properties for a rigid body actor  This method sets the mass, inertia and center of mass of a rigid body. The mass is set to the user-supplied value, and the inertia and center of mass are computed according to the rigid body's shapes and the input mass.  If no collision shapes are found, the inertia tensor is set to (1,1,1)  Boolean. True on success else false.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBodyExt_computeMassPropertiesFromShapes(MagicPhysX.PxShape**,System.UInt32)">
            <summary>Compute the mass, inertia tensor and center of mass from a list of shapes.  The mass properties from the combined shapes.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBodyExt_addForceAtPos(MagicPhysX.PxRigidBody*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxForceMode,System.Boolean)">
            <summary>Applies a force (or impulse) defined in the global coordinate frame, acting at a particular point in global coordinates, to the actor.  Note that if the force does not act along the center of mass of the actor, this will also add the corresponding torque. Because forces are reset at the end of every timestep, you can maintain a total external force on an object by calling this once every frame.  if this call is used to apply a force or impulse to an articulation link, only the link is updated, not the entire articulation  ::PxForceMode determines if the force is to be conventional or impulsive. Only eFORCE and eIMPULSE are supported, as the force required to produce a given velocity change or acceleration is underdetermined given only the desired change at a given point.  Sleeping: This call wakes the actor if it is sleeping and the wakeup parameter is true (default).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBodyExt_addForceAtLocalPos(MagicPhysX.PxRigidBody*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxForceMode,System.Boolean)">
            <summary>Applies a force (or impulse) defined in the global coordinate frame, acting at a particular point in local coordinates, to the actor.  Note that if the force does not act along the center of mass of the actor, this will also add the corresponding torque. Because forces are reset at the end of every timestep, you can maintain a total external force on an object by calling this once every frame.  if this call is used to apply a force or impulse to an articulation link, only the link is updated, not the entire articulation  ::PxForceMode determines if the force is to be conventional or impulsive. Only eFORCE and eIMPULSE are supported, as the force required to produce a given velocity change or acceleration is underdetermined given only the desired change at a given point.  Sleeping: This call wakes the actor if it is sleeping and the wakeup parameter is true (default).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBodyExt_addLocalForceAtPos(MagicPhysX.PxRigidBody*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxForceMode,System.Boolean)">
            <summary>Applies a force (or impulse) defined in the actor local coordinate frame, acting at a particular point in global coordinates, to the actor.  Note that if the force does not act along the center of mass of the actor, this will also add the corresponding torque. Because forces are reset at the end of every timestep, you can maintain a total external force on an object by calling this once every frame.  if this call is used to apply a force or impulse to an articulation link, only the link is updated, not the entire articulation  ::PxForceMode determines if the force is to be conventional or impulsive. Only eFORCE and eIMPULSE are supported, as the force required to produce a given velocity change or acceleration is underdetermined given only the desired change at a given point.  Sleeping: This call wakes the actor if it is sleeping and the wakeup parameter is true (default).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBodyExt_addLocalForceAtLocalPos(MagicPhysX.PxRigidBody*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxForceMode,System.Boolean)">
            <summary>Applies a force (or impulse) defined in the actor local coordinate frame, acting at a particular point in local coordinates, to the actor.  Note that if the force does not act along the center of mass of the actor, this will also add the corresponding torque. Because forces are reset at the end of every timestep, you can maintain a total external force on an object by calling this once every frame.  if this call is used to apply a force or impulse to an articulation link, only the link is updated, not the entire articulation  ::PxForceMode determines if the force is to be conventional or impulsive. Only eFORCE and eIMPULSE are supported, as the force required to produce a given velocity change or acceleration is underdetermined given only the desired change at a given point.  Sleeping: This call wakes the actor if it is sleeping and the wakeup parameter is true (default).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBodyExt_getVelocityAtPos(MagicPhysX.PxRigidBody*,MagicPhysX.PxVec3*)">
            <summary>Computes the velocity of a point given in world coordinates if it were attached to the specified body and moving with it.  The velocity of point in the global frame.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBodyExt_getLocalVelocityAtLocalPos(MagicPhysX.PxRigidBody*,MagicPhysX.PxVec3*)">
            <summary>Computes the velocity of a point given in local coordinates if it were attached to the specified body and moving with it.  The velocity of point in the local frame.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBodyExt_getVelocityAtOffset(MagicPhysX.PxRigidBody*,MagicPhysX.PxVec3*)">
            <summary>Computes the velocity of a point (offset from the origin of the body) given in world coordinates if it were attached to the specified body and moving with it.  The velocity of point (offset from the origin of the body) in the global frame.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBodyExt_computeVelocityDeltaFromImpulse(MagicPhysX.PxRigidBody*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>Compute the change to linear and angular velocity that would occur if an impulsive force and torque were to be applied to a specified rigid body.  The rigid body is left unaffected unless a subsequent independent call is executed that actually applies the computed changes to velocity and angular velocity.  if this call is used to determine the velocity delta for an articulation link, only the mass properties of the link are taken into account.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBodyExt_computeVelocityDeltaFromImpulse_1(MagicPhysX.PxRigidBody*,MagicPhysX.PxTransform*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,System.Single,System.Single,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>Computes the linear and angular velocity change vectors for a given impulse at a world space position taking a mass and inertia scale into account  This function is useful for extracting the respective linear and angular velocity changes from a contact or joint when the mass/inertia ratios have been adjusted.  if this call is used to determine the velocity delta for an articulation link, only the mass properties of the link are taken into account.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBodyExt_computeLinearAngularImpulse(MagicPhysX.PxRigidBody*,MagicPhysX.PxTransform*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,System.Single,System.Single,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>Computes the linear and angular impulse vectors for a given impulse at a world space position taking a mass and inertia scale into account  This function is useful for extracting the respective linear and angular impulses from a contact or joint when the mass/inertia ratios have been adjusted.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBodyExt_linearSweepSingle(MagicPhysX.PxRigidBody*,MagicPhysX.PxScene*,MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxHitFlags,MagicPhysX.PxSweepHit*,System.UInt32*,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryFilterCallback*,MagicPhysX.PxQueryCache*,System.Single)">
            <summary>Performs a linear sweep through space with the body's geometry objects.  Supported geometries are: box, sphere, capsule, convex. Other geometry types will be ignored.  If eTOUCH is returned from the filter callback, it will trigger an error and the hit will be discarded.  The function sweeps all shapes attached to a given rigid body through space and reports the nearest object in the scene which intersects any of of the shapes swept paths. Information about the closest intersection is written to a [`PxSweepHit`] structure.  True if a blocking hit was found.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRigidBodyExt_linearSweepMultiple(MagicPhysX.PxRigidBody*,MagicPhysX.PxScene*,MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxHitFlags,MagicPhysX.PxSweepHit*,System.UInt32*,System.UInt32,MagicPhysX.PxSweepHit*,System.Int32*,System.Boolean*,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryFilterCallback*,MagicPhysX.PxQueryCache*,System.Single)">
            <summary>Performs a linear sweep through space with the body's geometry objects, returning all overlaps.  Supported geometries are: box, sphere, capsule, convex. Other geometry types will be ignored.  This function sweeps all shapes attached to a given rigid body through space and reports all objects in the scene that intersect any of the shapes' swept paths until there are no more objects to report or a blocking hit is encountered.  the number of touching hits. If overflow is set to true, the results are incomplete. In case of overflow there are also no guarantees that all touching hits returned are closer than the blocking hit.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShapeExt_getGlobalPose(MagicPhysX.PxShape*,MagicPhysX.PxRigidActor*)">
            <summary>Retrieves the world space pose of the shape.  Global pose of shape.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShapeExt_raycast(MagicPhysX.PxShape*,MagicPhysX.PxRigidActor*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxHitFlags,System.UInt32,MagicPhysX.PxRaycastHit*)">
            <summary>Raycast test against the shape.  Number of hits between the ray and the shape</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShapeExt_overlap(MagicPhysX.PxShape*,MagicPhysX.PxRigidActor*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*)">
            <summary>Test overlap between the shape and a geometry object  True if the shape overlaps the geometry object</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShapeExt_sweep(MagicPhysX.PxShape*,MagicPhysX.PxRigidActor*,MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxSweepHit*,MagicPhysX.PxHitFlags)">
            <summary>Sweep a geometry object against the shape.  Currently only box, sphere, capsule and convex mesh shapes are supported, i.e. the swept geometry object must be one of those types.  True if the swept geometry object hits the shape</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxShapeExt_getWorldBounds(MagicPhysX.PxShape*,MagicPhysX.PxRigidActor*,System.Single)">
            <summary>Retrieves the axis aligned bounding box enclosing the shape.  The shape's bounding box.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMeshOverlapUtil_findOverlap_mut(MagicPhysX.PxMeshOverlapUtil*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxTriangleMeshGeometry*,MagicPhysX.PxTransform*)">
            <summary>Find the mesh triangles which touch the specified geometry object.  Number of overlaps found. Triangle indices can then be accessed through the [`getResults`]() function.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMeshOverlapUtil_findOverlap_mut_1(MagicPhysX.PxMeshOverlapUtil*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxHeightFieldGeometry*,MagicPhysX.PxTransform*)">
            <summary>Find the height field triangles which touch the specified geometry object.  Number of overlaps found. Triangle indices can then be accessed through the [`getResults`]() function.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMeshOverlapUtil_getResults(MagicPhysX.PxMeshOverlapUtil*)">
            <summary>Retrieves array of triangle indices after a findOverlap call.  Indices of touched triangles</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxMeshOverlapUtil_getNbResults(MagicPhysX.PxMeshOverlapUtil*)">
            <summary>Retrieves number of triangle indices after a findOverlap call.  Number of touched triangles</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxComputeTriangleMeshPenetration(MagicPhysX.PxVec3*,System.Single*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxTriangleMeshGeometry*,MagicPhysX.PxTransform*,System.UInt32,System.UInt32*)">
            <summary>Computes an approximate minimum translational distance (MTD) between a geometry object and a mesh.  This iterative function computes an approximate vector that can be used to depenetrate a geom object from a triangle mesh. Returned depenetration vector should be applied to 'geom', to get out of the mesh.  The function works best when the amount of overlap between the geom object and the mesh is small. If the geom object's center goes inside the mesh, backface culling usually kicks in, no overlap is detected, and the function does not compute an MTD vector.  The function early exits if no overlap is detected after a depenetration attempt. This means that if maxIter = N, the code will attempt at most N iterations but it might exit earlier if depenetration has been successful. Usually N = 4 gives good results.  True if the MTD has successfully been computed, i.e. if objects do overlap.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxComputeHeightFieldPenetration(MagicPhysX.PxVec3*,System.Single*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxHeightFieldGeometry*,MagicPhysX.PxTransform*,System.UInt32,System.UInt32*)">
            <summary>Computes an approximate minimum translational distance (MTD) between a geometry object and a heightfield.  This iterative function computes an approximate vector that can be used to depenetrate a geom object from a heightfield. Returned depenetration vector should be applied to 'geom', to get out of the heightfield.  The function works best when the amount of overlap between the geom object and the mesh is small. If the geom object's center goes inside the heightfield, backface culling usually kicks in, no overlap is detected, and the function does not compute an MTD vector.  The function early exits if no overlap is detected after a depenetration attempt. This means that if maxIter = N, the code will attempt at most N iterations but it might exit earlier if depenetration has been successful. Usually N = 4 gives good results.  True if the MTD has successfully been computed, i.e. if objects do overlap.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSerialization_isSerializable(MagicPhysX.PxCollection*,MagicPhysX.PxSerializationRegistry*,MagicPhysX.PxCollection*)">
            <summary>Returns whether the collection is serializable with the externalReferences collection.  Some definitions to explain whether a collection can be serialized or not:  For definitions of requires and complete see [`PxSerialization::complete`]  A serializable object is subordinate if it cannot be serialized on its own The following objects are subordinate: - articulation links - articulation joints - joints  A collection C can be serialized with external references collection D iff - C is complete relative to D (no dangling references) - Every object in D required by an object in C has a valid ID (no unnamed references) - Every subordinate object in C is required by another object in C (no orphans)  Whether the collection is serializable</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSerialization_complete(MagicPhysX.PxCollection*,MagicPhysX.PxSerializationRegistry*,MagicPhysX.PxCollection*,System.Boolean)">
            <summary>Adds to a collection all objects such that it can be successfully serialized.  A collection C is complete relative to an other collection D if every object required by C is either in C or D. This function adds objects to a collection, such that it becomes complete with respect to the exceptFor collection. Completeness is needed for serialization. See [`PxSerialization::serializeCollectionToBinary`], [`PxSerialization::serializeCollectionToXml`].  Sdk objects require other sdk object according to the following rules: - joints require their actors and constraint - rigid actors require their shapes - shapes require their material(s) and mesh (triangle mesh, convex mesh or height field), if any - articulations require their links and joints - aggregates require their actors  If followJoints is specified another rule is added: - actors require their joints  Specifying followJoints will make whole jointed actor chains being added to the collection. Following chains is interrupted whenever a object in exceptFor is encountered.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSerialization_createSerialObjectIds(MagicPhysX.PxCollection*,System.UInt64)">
            <summary>Creates PxSerialObjectId values for unnamed objects in a collection.  Creates PxSerialObjectId names for unnamed objects in a collection starting at a base value and incrementing, skipping values that are already assigned to objects in the collection.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSerialization_createCollectionFromXml(MagicPhysX.PxInputData*,MagicPhysX.PxCooking*,MagicPhysX.PxSerializationRegistry*,MagicPhysX.PxCollection*,MagicPhysX.PxStringTable*,MagicPhysX.PxXmlMiscParameter*)">
            <summary>Creates a PxCollection from XML data.  a pointer to a PxCollection if successful or NULL if it failed.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSerialization_createCollectionFromBinary(System.Void*,MagicPhysX.PxSerializationRegistry*,MagicPhysX.PxCollection*)">
            <summary>Deserializes a PxCollection from memory.  Creates a collection from memory. If the collection has external dependencies another collection can be provided to resolve these.  The memory block provided has to be 128 bytes aligned and contain a contiguous serialized collection as written by PxSerialization::serializeCollectionToBinary. The contained binary data needs to be compatible with the current binary format version which is defined by \"PX_PHYSICS_VERSION_MAJOR.PX_PHYSICS_VERSION_MINOR.PX_PHYSICS_VERSION_BUGFIX-PX_BINARY_SERIAL_VERSION\". For a list of compatible sdk releases refer to the documentation of PX_BINARY_SERIAL_VERSION.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSerialization_serializeCollectionToXml(MagicPhysX.PxOutputStream*,MagicPhysX.PxCollection*,MagicPhysX.PxSerializationRegistry*,MagicPhysX.PxCooking*,MagicPhysX.PxCollection*,MagicPhysX.PxXmlMiscParameter*)">
            <summary>Serializes a physics collection to an XML output stream.  The collection to be serialized needs to be complete  Serialization of objects in a scene that is simultaneously being simulated is not supported and leads to undefined behavior.  true if the collection is successfully serialized.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSerialization_serializeCollectionToBinary(MagicPhysX.PxOutputStream*,MagicPhysX.PxCollection*,MagicPhysX.PxSerializationRegistry*,MagicPhysX.PxCollection*,System.Boolean)">
            <summary>Serializes a collection to a binary stream.  Serializes a collection to a stream. In order to resolve external dependencies the externalReferences collection has to be provided. Optionally names of objects that where set for example with [`PxActor::setName`] are serialized along with the objects.  The collection can be successfully serialized if isSerializable(collection) returns true. See [`isSerializable`].  The implementation of the output stream needs to fulfill the requirements on the memory block input taken by PxSerialization::createCollectionFromBinary.  Serialization of objects in a scene that is simultaneously being simulated is not supported and leads to undefined behavior.  Whether serialization was successful</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSerialization_createSerializationRegistry(MagicPhysX.PxPhysics*)">
            <summary>Creates an application managed registry for serialization.  PxSerializationRegistry instance.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxDefaultCpuDispatcher_release_mut(MagicPhysX.PxDefaultCpuDispatcher*)">
            <summary>Deletes the dispatcher.  Do not keep a reference to the deleted instance.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxDefaultCpuDispatcher_setRunProfiled_mut(MagicPhysX.PxDefaultCpuDispatcher*,System.Boolean)">
            <summary>Enables profiling at task level.  By default enabled only in profiling builds.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxDefaultCpuDispatcher_getRunProfiled(MagicPhysX.PxDefaultCpuDispatcher*)">
            <summary>Checks if profiling is enabled at task level.  True if tasks should be profiled.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxDefaultCpuDispatcherCreate(System.UInt32,System.UInt32*,MagicPhysX.PxDefaultCpuDispatcherWaitForWorkMode,System.UInt32)">
            <summary>Create default dispatcher, extensions SDK needs to be initialized first.  numThreads may be zero in which case no worker thread are initialized and simulation tasks will be executed on the thread that calls PxScene::simulate()  yieldProcessorCount must be greater than zero if eYIELD_PROCESSOR is the chosen mode and equal to zero for all other modes.  eYIELD_THREAD and eYIELD_PROCESSOR modes will use compute resources even if the simulation is not running. It is left to users to keep threads inactive, if so desired, when no simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxBuildSmoothNormals(System.UInt32,System.UInt32,MagicPhysX.PxVec3*,System.UInt32*,System.UInt16*,MagicPhysX.PxVec3*,System.Boolean)">
            <summary>Builds smooth vertex normals over a mesh.  - \"smooth\" because smoothing groups are not supported here - takes angles into account for correct cube normals computation  To use 32bit indices pass a pointer in dFaces and set wFaces to zero. Alternatively pass a pointer to wFaces and set dFaces to zero.  True on success.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCreateDynamic(MagicPhysX.PxPhysics*,MagicPhysX.PxTransform*,MagicPhysX.PxGeometry*,MagicPhysX.PxMaterial*,System.Single,MagicPhysX.PxTransform*)">
            <summary>simple method to create a PxRigidDynamic actor with a single PxShape.  a new dynamic actor with the PxRigidBodyFlag, or NULL if it could not be constructed</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCreateDynamic_1(MagicPhysX.PxPhysics*,MagicPhysX.PxTransform*,MagicPhysX.PxShape*,System.Single)">
            <summary>simple method to create a PxRigidDynamic actor with a single PxShape.  a new dynamic actor with the PxRigidBodyFlag, or NULL if it could not be constructed</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCreateKinematic(MagicPhysX.PxPhysics*,MagicPhysX.PxTransform*,MagicPhysX.PxGeometry*,MagicPhysX.PxMaterial*,System.Single,MagicPhysX.PxTransform*)">
            <summary>simple method to create a kinematic PxRigidDynamic actor with a single PxShape.  unlike PxCreateDynamic, the geometry is not restricted to box, capsule, sphere or convex. However, kinematics of other geometry types may not participate in simulation collision and may be used only for triggers or scene queries of moving objects under animation control. In this case the density parameter will be ignored and the created shape will be set up as a scene query only shape (see [`PxShapeFlag::eSCENE_QUERY_SHAPE`])  a new dynamic actor with the PxRigidBodyFlag::eKINEMATIC set, or NULL if it could not be constructed</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCreateKinematic_1(MagicPhysX.PxPhysics*,MagicPhysX.PxTransform*,MagicPhysX.PxShape*,System.Single)">
            <summary>simple method to create a kinematic PxRigidDynamic actor with a single PxShape.  unlike PxCreateDynamic, the geometry is not restricted to box, capsule, sphere or convex. However, kinematics of other geometry types may not participate in simulation collision and may be used only for triggers or scene queries of moving objects under animation control. In this case the density parameter will be ignored and the created shape will be set up as a scene query only shape (see [`PxShapeFlag::eSCENE_QUERY_SHAPE`])  a new dynamic actor with the PxRigidBodyFlag::eKINEMATIC set, or NULL if it could not be constructed</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCreateStatic(MagicPhysX.PxPhysics*,MagicPhysX.PxTransform*,MagicPhysX.PxGeometry*,MagicPhysX.PxMaterial*,MagicPhysX.PxTransform*)">
            <summary>simple method to create a PxRigidStatic actor with a single PxShape.  a new static actor, or NULL if it could not be constructed</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCreateStatic_1(MagicPhysX.PxPhysics*,MagicPhysX.PxTransform*,MagicPhysX.PxShape*)">
            <summary>simple method to create a PxRigidStatic actor with a single PxShape.  a new static actor, or NULL if it could not be constructed</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCloneShape(MagicPhysX.PxPhysics*,MagicPhysX.PxShape*,System.Boolean)">
            <summary>create a shape by copying attributes from another shape  The function clones a PxShape. The following properties are copied: - geometry - flags - materials - actor-local pose - contact offset - rest offset - simulation filter data - query filter data - torsional patch radius - minimum torsional patch radius  The following are not copied and retain their default values: - name - user data  the newly-created rigid static</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCloneStatic(MagicPhysX.PxPhysics*,MagicPhysX.PxTransform*,MagicPhysX.PxRigidActor*)">
            <summary>create a static body by copying attributes from another rigid actor  The function clones a PxRigidDynamic or PxRigidStatic as a PxRigidStatic. A uniform scale is applied. The following properties are copied: - shapes - actor flags - owner client and client behavior bits - dominance group  The following are not copied and retain their default values: - name - joints or observers - aggregate or scene membership - user data  Transforms are not copied with bit-exact accuracy.  the newly-created rigid static</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCloneDynamic(MagicPhysX.PxPhysics*,MagicPhysX.PxTransform*,MagicPhysX.PxRigidDynamic*)">
            <summary>create a dynamic body by copying attributes from an existing body  The following properties are copied: - shapes - actor flags, rigidDynamic flags and rigidDynamic lock flags - mass, moment of inertia, and center of mass frame - linear and angular velocity - linear and angular damping - maximum linear velocity - maximum angular velocity - position and velocity solver iterations - maximum depenetration velocity - sleep threshold - contact report threshold - dominance group - owner client and client behavior bits - name pointer - kinematic target  The following are not copied and retain their default values: - name - joints or observers - aggregate or scene membership - sleep timer - user data  Transforms are not copied with bit-exact accuracy.  the newly-created rigid static</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCreatePlane(MagicPhysX.PxPhysics*,MagicPhysX.PxPlane*,MagicPhysX.PxMaterial*)">
            <summary>create a plane actor. The plane equation is n.x + d = 0  a new static actor, or NULL if it could not be constructed</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxScaleRigidActor(MagicPhysX.PxRigidActor*,System.Single,System.Boolean)">
            <summary>scale a rigid actor by a uniform scale  The geometry and relative positions of the actor are multiplied by the given scale value. If the actor is a rigid body or an articulation link and the scaleMassProps value is true, the mass properties are scaled assuming the density is constant: the center of mass is linearly scaled, the mass is multiplied by the cube of the scale, and the inertia tensor by the fifth power of the scale.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBroadPhaseExt_createRegionsFromWorldBounds(MagicPhysX.PxBounds3*,MagicPhysX.PxBounds3*,System.UInt32,System.UInt32)">
            <summary>Creates regions for PxSceneDesc, from a global box.  This helper simply subdivides the given global box into a 2D grid of smaller boxes. Each one of those smaller boxes is a region of interest for the broadphase. There are nbSubdiv*nbSubdiv regions in the 2D grid. The function does not subdivide along the given up axis.  This is the simplest setup one can use with PxBroadPhaseType::eMBP. A more sophisticated setup would try to cover the game world with a non-uniform set of regions (i.e. not just a grid).  number of regions written out to the 'regions' array</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQueryExt_raycastAny(MagicPhysX.PxScene*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxQueryHit*,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryFilterCallback*,MagicPhysX.PxQueryCache*)">
            <summary>Raycast returning any blocking hit, not necessarily the closest.  Returns whether any rigid actor is hit along the ray.  Shooting a ray from within an object leads to different results depending on the shape type. Please check the details in article SceneQuery. User can ignore such objects by using one of the provided filter mechanisms.  True if a blocking hit was found.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQueryExt_raycastSingle(MagicPhysX.PxScene*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxHitFlags,MagicPhysX.PxRaycastHit*,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryFilterCallback*,MagicPhysX.PxQueryCache*)">
            <summary>Raycast returning a single result.  Returns the first rigid actor that is hit along the ray. Data for a blocking hit will be returned as specified by the outputFlags field. Touching hits will be ignored.  Shooting a ray from within an object leads to different results depending on the shape type. Please check the details in article SceneQuery. User can ignore such objects by using one of the provided filter mechanisms.  True if a blocking hit was found.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQueryExt_raycastMultiple(MagicPhysX.PxScene*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxHitFlags,MagicPhysX.PxRaycastHit*,System.UInt32,System.Boolean*,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryFilterCallback*,MagicPhysX.PxQueryCache*)">
            <summary>Raycast returning multiple results.  Find all rigid actors that get hit along the ray. Each result contains data as specified by the outputFlags field.  Touching hits are not ordered.  Shooting a ray from within an object leads to different results depending on the shape type. Please check the details in article SceneQuery. User can ignore such objects by using one of the provided filter mechanisms.  Number of hits in the buffer, or -1 if the buffer overflowed.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQueryExt_sweepAny(MagicPhysX.PxScene*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxHitFlags,MagicPhysX.PxQueryHit*,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryFilterCallback*,MagicPhysX.PxQueryCache*,System.Single)">
            <summary>Sweep returning any blocking hit, not necessarily the closest.  Returns whether any rigid actor is hit along the sweep path.  If a shape from the scene is already overlapping with the query shape in its starting position, behavior is controlled by the PxSceneQueryFlag::eINITIAL_OVERLAP flag.  True if a blocking hit was found.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQueryExt_sweepSingle(MagicPhysX.PxScene*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxHitFlags,MagicPhysX.PxSweepHit*,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryFilterCallback*,MagicPhysX.PxQueryCache*,System.Single)">
            <summary>Sweep returning a single result.  Returns the first rigid actor that is hit along the ray. Data for a blocking hit will be returned as specified by the outputFlags field. Touching hits will be ignored.  If a shape from the scene is already overlapping with the query shape in its starting position, behavior is controlled by the PxSceneQueryFlag::eINITIAL_OVERLAP flag.  True if a blocking hit was found.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQueryExt_sweepMultiple(MagicPhysX.PxScene*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxHitFlags,MagicPhysX.PxSweepHit*,System.UInt32,System.Boolean*,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryFilterCallback*,MagicPhysX.PxQueryCache*,System.Single)">
            <summary>Sweep returning multiple results.  Find all rigid actors that get hit along the sweep. Each result contains data as specified by the outputFlags field.  Touching hits are not ordered.  If a shape from the scene is already overlapping with the query shape in its starting position, behavior is controlled by the PxSceneQueryFlag::eINITIAL_OVERLAP flag.  Number of hits in the buffer, or -1 if the buffer overflowed.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQueryExt_overlapMultiple(MagicPhysX.PxScene*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxOverlapHit*,System.UInt32,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryFilterCallback*)">
            <summary>Test overlap between a geometry and objects in the scene.  Filtering: Overlap tests do not distinguish between touching and blocking hit types. Both get written to the hit buffer.  PxHitFlag::eMESH_MULTIPLE and PxHitFlag::eMESH_BOTH_SIDES have no effect in this case  Number of hits in the buffer, or -1 if the buffer overflowed.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxSceneQueryExt_overlapAny(MagicPhysX.PxScene*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxOverlapHit*,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryFilterCallback*)">
            <summary>Test returning, for a given geometry, any overlapping object in the scene.  Filtering: Overlap tests do not distinguish between touching and blocking hit types. Both trigger a hit.  PxHitFlag::eMESH_MULTIPLE and PxHitFlag::eMESH_BOTH_SIDES have no effect in this case  True if an overlap was found.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBatchQueryExt_raycast_mut(MagicPhysX.PxBatchQueryExt*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,System.Single,System.UInt16,MagicPhysX.PxHitFlags,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryCache*)">
            <summary>Performs a raycast against objects in the scene.  Touching hits are not ordered.  Shooting a ray from within an object leads to different results depending on the shape type. Please check the details in article SceneQuery. User can ignore such objects by using one of the provided filter mechanisms.  This query call writes to a list associated with the query object and is NOT thread safe (for performance reasons there is no lock and overlapping writes from different threads may result in undefined behavior).  Returns a PxRaycastBuffer pointer that will store the result of the query after execute() is completed. This will point either to an element of the buffer allocated on construction or to a user buffer passed to the constructor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBatchQueryExt_sweep_mut(MagicPhysX.PxBatchQueryExt*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxVec3*,System.Single,System.UInt16,MagicPhysX.PxHitFlags,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryCache*,System.Single)">
            <summary>Performs a sweep test against objects in the scene.  Touching hits are not ordered.  If a shape from the scene is already overlapping with the query shape in its starting position, the hit is returned unless eASSUME_NO_INITIAL_OVERLAP was specified.  This query call writes to a list associated with the query object and is NOT thread safe (for performance reasons there is no lock and overlapping writes from different threads may result in undefined behavior).  Returns a PxSweepBuffer pointer that will store the result of the query after execute() is completed. This will point either to an element of the buffer allocated on construction or to a user buffer passed to the constructor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxBatchQueryExt_overlap_mut(MagicPhysX.PxBatchQueryExt*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,System.UInt16,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryCache*)">
            <summary>Performs an overlap test of a given geometry against objects in the scene.  Filtering: returning eBLOCK from user filter for overlap queries will cause a warning (see [`PxQueryHitType`]).  eBLOCK should not be returned from user filters for overlap(). Doing so will result in undefined behavior, and a warning will be issued.  If the PxQueryFlag::eNO_BLOCK flag is set, the eBLOCK will instead be automatically converted to an eTOUCH and the warning suppressed.  This query call writes to a list associated with the query object and is NOT thread safe (for performance reasons there is no lock and overlapping writes from different threads may result in undefined behavior).  Returns a PxOverlapBuffer pointer that will store the result of the query after execute() is completed. This will point either to an element of the buffer allocated on construction or to a user buffer passed to the constructor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCreateBatchQueryExt(MagicPhysX.PxScene*,MagicPhysX.PxQueryFilterCallback*,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>Create a PxBatchQueryExt without the need for pre-allocated result or touch buffers.  Returns a PxBatchQueryExt instance. A NULL pointer will be returned if the subsequent allocations fail or if any of the arguments are illegal. In the event that a NULL pointer is returned a corresponding error will be issued to the error stream.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCreateBatchQueryExt_1(MagicPhysX.PxScene*,MagicPhysX.PxQueryFilterCallback*,MagicPhysX.PxRaycastBuffer*,System.UInt32,MagicPhysX.PxRaycastHit*,System.UInt32,MagicPhysX.PxSweepBuffer*,System.UInt32,MagicPhysX.PxSweepHit*,System.UInt32,MagicPhysX.PxOverlapBuffer*,System.UInt32,MagicPhysX.PxOverlapHit*,System.UInt32)">
            <summary>Create a PxBatchQueryExt with user-supplied result and touch buffers.  Returns a PxBatchQueryExt instance. A NULL pointer will be returned if the subsequent allocations fail or if any of the arguments are illegal. In the event that a NULL pointer is returned a corresponding error will be issued to the error stream.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCreateExternalSceneQuerySystem(MagicPhysX.PxSceneQueryDesc*,System.UInt64)">
            <summary>Creates an external scene query system.  An external SQ system is the part of a PxScene that deals with scene queries (SQ). This is usually taken care of by an internal implementation inside PxScene, but it is also possible to re-route all SQ calls to an external implementation, potentially opening the door to some customizations in behavior and features for advanced users.  The following external SQ system is an example of how an implementation would look like. It re-uses much of the same code as the internal version, but it could be re-implemented in a completely different way to match users' specific needs.  An external SQ system instance</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCustomSceneQuerySystem_addPruner_mut(MagicPhysX.PxCustomSceneQuerySystem*,MagicPhysX.PxPruningStructureType,MagicPhysX.PxDynamicTreeSecondaryPruner,System.UInt32)">
            <summary>Adds a pruner to the system.  The internal PhysX scene-query system uses two regular pruners (one for static shapes, one for dynamic shapes) and an optional compound pruner. Our custom scene query system supports an arbitrary number of regular pruners.  This can be useful to reduce the load on each pruner, in particular during updates, when internal trees are rebuilt in the background. On the other hand this implementation simply iterates over all created pruners to perform queries, so their cost might increase if a large number of pruners is used.  In any case this serves as an example of how the PxSceneQuerySystem API can be used to customize scene queries.  A pruner index</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCustomSceneQuerySystem_startCustomBuildstep_mut(MagicPhysX.PxCustomSceneQuerySystem*)">
            <summary>Start custom build-steps for all pruners  This function is used in combination with customBuildstep() and finishCustomBuildstep() to let users take control of the pruners' build-step &amp; commit calls - basically the pruners' update functions. These functions should be used with the PxSceneQueryUpdateMode::eBUILD_DISABLED_COMMIT_DISABLED update mode, otherwise the build-steps will happen automatically in fetchResults. For N pruners it can be more efficient to use these custom build-step functions to perform the updates in parallel:  - call startCustomBuildstep() first (one synchronous call) - for each pruner, call customBuildstep() (asynchronous calls from multiple threads) - once it is done, call finishCustomBuildstep() to finish the update (synchronous call)  The multi-threaded update is more efficient here than what it is in PxScene, because the \"flushShapes()\" call is also multi-threaded (while it is not in PxScene).  Note that users are responsible for locks here, and these calls should not overlap with other SQ calls. In particular one should not add new objects to the SQ system or perform queries while these calls are happening.  The number of pruners in the system.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCustomSceneQuerySystem_customBuildstep_mut(MagicPhysX.PxCustomSceneQuerySystem*,System.UInt32)">
            <summary>Perform a custom build-step for a given pruner.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCustomSceneQuerySystem_finishCustomBuildstep_mut(MagicPhysX.PxCustomSceneQuerySystem*)">
            <summary>Finish custom build-steps  Call this function once after all the customBuildstep() calls are done.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCustomSceneQuerySystemAdapter_getPrunerIndex(MagicPhysX.PxCustomSceneQuerySystemAdapter*,MagicPhysX.PxRigidActor*,MagicPhysX.PxShape*)">
            <summary>Gets a pruner index for an actor/shape.  This user-defined function tells the system in which pruner a given actor/shape should go.  The returned index must be valid, i.e. it must have been previously returned to users by PxCustomSceneQuerySystem::addPruner.  A pruner index for this actor/shape.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxCustomSceneQuerySystemAdapter_processPruner(MagicPhysX.PxCustomSceneQuerySystemAdapter*,System.UInt32,MagicPhysX.PxQueryThreadContext*,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryFilterCallback*)">
            <summary>Pruner filtering callback.  This will be called for each query to validate whether it should process a given pruner.  True to process the pruner, false to skip it entirely</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCreateCustomSceneQuerySystem(MagicPhysX.PxSceneQueryUpdateMode,System.UInt64,MagicPhysX.PxCustomSceneQuerySystemAdapter*,System.Boolean)">
            <summary>Creates a custom scene query system.  This is similar to PxCreateExternalSceneQuerySystem, except this function creates a PxCustomSceneQuerySystem object. It can be plugged to PxScene the same way, via PxSceneDesc::sceneQuerySystem.  A custom SQ system instance</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxFindFaceIndex(MagicPhysX.PxConvexMeshGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>Computes closest polygon of the convex hull geometry for a given impact point and impact direction. When doing sweeps against a scene, one might want to delay the rather expensive computation of the hit face index for convexes until it is clear the information is really needed and then use this method to get the corresponding face index.  Closest face index of the convex geometry.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPoissonSampler_setSamplingRadius_mut(MagicPhysX.PxPoissonSampler*,System.Single)">
            <summary>Sets the sampling radius  Returns true if the sampling was successful and false if there was a problem. Usually an internal overflow is the problem for very big meshes or very small sampling radii.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPoissonSampler_addSamplesInSphere_mut(MagicPhysX.PxPoissonSampler*,MagicPhysX.PxVec3*,System.Single,System.Boolean)">
            <summary>Adds new Poisson Samples inside the sphere specified</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPoissonSampler_addSamplesInBox_mut(MagicPhysX.PxPoissonSampler*,MagicPhysX.PxBounds3*,MagicPhysX.PxQuat*,System.Boolean)">
            <summary>Adds new Poisson Samples inside the box specified</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCreateShapeSampler(MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxBounds3*,System.Single,System.Int32)">
            <summary>Creates a shape sampler  Returns the sampler</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTriangleMeshPoissonSampler_isPointInTriangleMesh_mut(MagicPhysX.PxTriangleMeshPoissonSampler*,MagicPhysX.PxVec3*)">
            <summary>Checks whether a point is inside the triangle mesh  Returns true if the point is inside the triangle mesh</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCreateTriangleMeshSampler(System.UInt32*,System.UInt32,MagicPhysX.PxVec3*,System.UInt32,System.Single,System.Int32)">
            <summary>Creates a triangle mesh sampler  Returns the sampler</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTetrahedronMeshExt_findTetrahedronContainingPoint(MagicPhysX.PxTetrahedronMesh*,MagicPhysX.PxVec3*,MagicPhysX.PxVec4*,System.Single)">
            <summary>Returns the index of the tetrahedron that contains a point  The index of the tetrahedon containing the point, -1 if not tetrahedron contains the opoint</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxTetrahedronMeshExt_findTetrahedronClosestToPoint(MagicPhysX.PxTetrahedronMesh*,MagicPhysX.PxVec3*,MagicPhysX.PxVec4*)">
            <summary>Returns the index of the tetrahedron closest to a point  The index of the tetrahedon closest to the point</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxInitExtensions(MagicPhysX.PxPhysics*,MagicPhysX.PxPvd*)">
            <summary>Initialize the PhysXExtensions library.  This should be called before calling any functions or methods in extensions which may require allocation.  This function does not need to be called before creating a PxDefaultAllocator object.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCloseExtensions">
            <summary>Shut down the PhysXExtensions library.  This function should be called to cleanly shut down the PhysXExtensions library before application exit.  This function is required to be called to release foundation usage.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRepXSerializer_getTypeName_mut(MagicPhysX.PxRepXSerializer*)">
            <summary>The type this Serializer is meant to operate on.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRepXSerializer_objectToFile_mut(MagicPhysX.PxRepXSerializer*,MagicPhysX.PxRepXObject*,MagicPhysX.PxCollection*,MagicPhysX.XmlWriter*,MagicPhysX.MemoryBuffer*,MagicPhysX.PxRepXInstantiationArgs*)">
            <summary>Convert from a RepX object to a key-value pair hierarchy</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxRepXSerializer_fileToObject_mut(MagicPhysX.PxRepXSerializer*,MagicPhysX.XmlReader*,MagicPhysX.XmlMemoryAllocator*,MagicPhysX.PxRepXInstantiationArgs*,MagicPhysX.PxCollection*)">
            <summary>Convert from a descriptor to a live object.  Must be an object of this Serializer type.  The new live object.  It can be an invalid object if the instantiation cannot take place.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPvd_connect_mut(MagicPhysX.PxPvd*,MagicPhysX.PxPvdTransport*,MagicPhysX.PxPvdInstrumentationFlags)">
            <summary>Connects the SDK to the PhysX Visual Debugger application.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPvd_disconnect_mut(MagicPhysX.PxPvd*)">
            <summary>Disconnects the SDK from the PhysX Visual Debugger application. If we are still connected, this will kill the entire debugger connection.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPvd_isConnected_mut(MagicPhysX.PxPvd*,System.Boolean)">
            <summary>Return if connection to PVD is created.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPvd_getTransport_mut(MagicPhysX.PxPvd*)">
            <summary>returns the PVD data transport returns NULL if no transport is present.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPvd_getInstrumentationFlags_mut(MagicPhysX.PxPvd*)">
            <summary>Retrieves the PVD flags. See PxPvdInstrumentationFlags.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPvd_release_mut(MagicPhysX.PxPvd*)">
            <summary>Releases the pvd instance.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxCreatePvd(MagicPhysX.PxFoundation*)">
            <summary>Create a pvd instance.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPvdTransport_connect_mut(MagicPhysX.PxPvdTransport*)">
            <summary>Connects to the Visual Debugger application. return True if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPvdTransport_disconnect_mut(MagicPhysX.PxPvdTransport*)">
            <summary>Disconnects from the Visual Debugger application. If we are still connected, this will kill the entire debugger connection.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPvdTransport_isConnected_mut(MagicPhysX.PxPvdTransport*)">
            <summary>Return if connection to PVD is created.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPvdTransport_write_mut(MagicPhysX.PxPvdTransport*,System.Byte*,System.UInt32)">
            <summary>write bytes to the other endpoint of the connection. should lock before witre. If an error occurs this connection will assume to be dead.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPvdTransport_flush_mut(MagicPhysX.PxPvdTransport*)">
            <summary>send any data and block until we know it is at least on the wire.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.PxPvdTransport_getWrittenDataSize_mut(MagicPhysX.PxPvdTransport*)">
            <summary>Return size of written data.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxDefaultPvdSocketTransportCreate(System.Byte*,System.Int32,System.UInt32)">
            <summary>Create a default socket transport.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethods.phys_PxDefaultPvdFileTransportCreate(System.Byte*)">
            <summary>Create a default file transport.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxFoundation@)">
            <summary>Destroys the instance it is called on.  The operation will fail, if there are still modules referencing the foundation object. Release all dependent modules prior to calling this method.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetErrorCallbackMut(MagicPhysX.PxFoundation@)">
            <summary>retrieves error callback</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetErrorLevelMut(MagicPhysX.PxFoundation@,System.UInt32)">
            <summary>Sets mask of errors to report.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetErrorLevel(MagicPhysX.PxFoundation@)">
            <summary>Retrieves mask of errors to be reported.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetAllocatorCallbackMut(MagicPhysX.PxFoundation@)">
            <summary>Retrieves the allocator this object was created with.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetReportAllocationNames(MagicPhysX.PxFoundation@)">
            <summary>Retrieves if allocation names are being passed to allocator callback.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetReportAllocationNamesMut(MagicPhysX.PxFoundation@,System.Boolean)">
            <summary>Set if allocation names are being passed to allocator callback.  Enabled by default in debug and checked build, disabled by default in profile and release build.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxCreatePvd(MagicPhysX.PxFoundation@)">
            <summary>Create a pvd instance.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CreateRaycastFilterCallback(MagicPhysX.PxRigidActor@)">
            <summary>Destroy the returned callback object using PxQueryFilterCallback_delete.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxRigidActor@)">
            <summary>Deletes the rigid actor object.  Also releases any shapes associated with the actor.  Releasing an actor will affect any objects that are connected to the actor (constraint shaders like joints etc.). Such connected objects will be deleted upon scene deletion, or explicitly by the user by calling release() on these objects. It is recommended to always remove all objects that reference actors before the actors themselves are removed. It is not possible to retrieve list of dead connected objects.  Sleeping: This call will awaken any sleeping actors contacting the deleted actor (directly or indirectly).  Calls [`PxActor::release`]() so you might want to check the documentation of that method as well.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetInternalActorIndex(MagicPhysX.PxRigidActor@)">
            <summary>Returns the internal actor index.  This is only defined for actors that have been added to a scene.  The internal actor index, or 0xffffffff if the actor is not part of a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetGlobalPose(MagicPhysX.PxRigidActor@)">
            <summary>Retrieves the actors world space transform.  The getGlobalPose() method retrieves the actor's current actor space to world space transformation.  It is not allowed to use this method while the simulation is running (except during PxScene::collide(), in PxContactModifyCallback or in contact report callbacks).  Global pose of object.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetGlobalPoseMut(MagicPhysX.PxRigidActor@,MagicPhysX.PxTransform*,System.Boolean)">
            <summary>Method for setting an actor's pose in the world.  This method instantaneously changes the actor space to world space transformation.  This method is mainly for dynamic rigid bodies (see [`PxRigidDynamic`]). Calling this method on static actors is likely to result in a performance penalty, since internal optimization structures for static actors may need to be recomputed. In addition, moving static actors will not interact correctly with dynamic actors or joints.  To directly control an actor's position and have it correctly interact with dynamic bodies and joints, create a dynamic body with the PxRigidBodyFlag::eKINEMATIC flag, then use the setKinematicTarget() commands to define its path.  Even when moving dynamic actors, exercise restraint in making use of this method. Where possible, avoid:  moving actors into other actors, thus causing overlap (an invalid physical state)  moving an actor that is connected by a joint to another away from the other (thus causing joint error)  Sleeping: This call wakes dynamic actors if they are sleeping and the autowake parameter is true (default).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AttachShapeMut(MagicPhysX.PxRigidActor@,MagicPhysX.PxShape*)">
            <summary>Attach a shape to an actor  This call will increment the reference count of the shape.  Mass properties of dynamic rigid actors will not automatically be recomputed to reflect the new mass distribution implied by the shape. Follow this call with a call to the PhysX extensions method [`PxRigidBodyExt::updateMassAndInertia`]() to do that.  Attaching a triangle mesh, heightfield or plane geometry shape configured as eSIMULATION_SHAPE is not supported for non-kinematic PxRigidDynamic instances.  Sleeping: Does NOT wake the actor up automatically.  True if success.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.DetachShapeMut(MagicPhysX.PxRigidActor@,MagicPhysX.PxShape*,System.Boolean)">
            <summary>Detach a shape from an actor.  This will also decrement the reference count of the PxShape, and if the reference count is zero, will cause it to be deleted.  Sleeping: Does NOT wake the actor up automatically.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbShapes(MagicPhysX.PxRigidActor@)">
            <summary>Returns the number of shapes assigned to the actor.  You can use [`getShapes`]() to retrieve the shape pointers.  Number of shapes associated with this actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetShapes(MagicPhysX.PxRigidActor@,MagicPhysX.PxShape**,System.UInt32,System.UInt32)">
            <summary>Retrieve all the shape pointers belonging to the actor.  These are the shapes used by the actor for collision detection.  You can retrieve the number of shape pointers by calling [`getNbShapes`]()  Note: Removing shapes with [`PxShape::release`]() will invalidate the pointer of the released shape.  Number of shape pointers written to the buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbConstraints(MagicPhysX.PxRigidActor@)">
            <summary>Returns the number of constraint shaders attached to the actor.  You can use [`getConstraints`]() to retrieve the constraint shader pointers.  Number of constraint shaders attached to this actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetConstraints(MagicPhysX.PxRigidActor@,MagicPhysX.PxConstraint**,System.UInt32,System.UInt32)">
            <summary>Retrieve all the constraint shader pointers belonging to the actor.  You can retrieve the number of constraint shader pointers by calling [`getNbConstraints`]()  Note: Removing constraint shaders with [`PxConstraint::release`]() will invalidate the pointer of the released constraint.  Number of constraint shader pointers written to the buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ExtCreateExclusiveShape(MagicPhysX.PxRigidActor@,MagicPhysX.PxGeometry*,MagicPhysX.PxMaterial**,System.UInt16,MagicPhysX.PxShapeFlags)">
            <summary>Creates a new shape with default properties and a list of materials and adds it to the list of shapes of this actor.  This is equivalent to the following  ```cpp // reference count is 1 PxShape* shape(...) = PxGetPhysics().createShape(...); // increments reference count actor-&gt;attachShape(shape); // releases user reference, leaving reference count at 1 shape-&gt;release(); ```  As a consequence, detachShape() will result in the release of the last reference, and the shape will be deleted.  The default shape flags to be set are: eVISUALIZATION, eSIMULATION_SHAPE, eSCENE_QUERY_SHAPE (see [`PxShapeFlag`]). Triangle mesh, heightfield or plane geometry shapes configured as eSIMULATION_SHAPE are not supported for non-kinematic PxRigidDynamic instances.  Creating compounds with a very large number of shapes may adversely affect performance and stability.  Sleeping: Does NOT wake the actor up automatically.  The newly created shape.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ExtCreateExclusiveShape1(MagicPhysX.PxRigidActor@,MagicPhysX.PxGeometry*,MagicPhysX.PxMaterial*,MagicPhysX.PxShapeFlags)">
            <summary>Creates a new shape with default properties and a single material adds it to the list of shapes of this actor.  This is equivalent to the following  ```cpp // reference count is 1 PxShape* shape(...) = PxGetPhysics().createShape(...); // increments reference count actor-&gt;attachShape(shape); // releases user reference, leaving reference count at 1 shape-&gt;release(); ```  As a consequence, detachShape() will result in the release of the last reference, and the shape will be deleted.  The default shape flags to be set are: eVISUALIZATION, eSIMULATION_SHAPE, eSCENE_QUERY_SHAPE (see [`PxShapeFlag`]). Triangle mesh, heightfield or plane geometry shapes configured as eSIMULATION_SHAPE are not supported for non-kinematic PxRigidDynamic instances.  Creating compounds with a very large number of shapes may adversely affect performance and stability.  Sleeping: Does NOT wake the actor up automatically.  The newly created shape.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ExtGetRigidActorShapeLocalBoundsList(MagicPhysX.PxRigidActor@,System.UInt32*)">
            <summary>Gets a list of bounds based on shapes in rigid actor. This list can be used to cook/create bounding volume hierarchy though PxCooking API.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxScaleRigidActor(MagicPhysX.PxRigidActor@,System.Single,System.Boolean)">
            <summary>scale a rigid actor by a uniform scale  The geometry and relative positions of the actor are multiplied by the given scale value. If the actor is a rigid body or an articulation link and the scaleMassProps value is true, the mass properties are scaled assuming the density is constant: the center of mass is linearly scaled, the mass is multiplied by the cube of the scale, and the inertia tensor by the fifth power of the scale.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AllocateMut(MagicPhysX.PxAllocatorCallback@,System.UIntPtr,System.Byte*,System.Byte*,System.Int32)">
            <summary>Allocates size bytes of memory, which must be 16-byte aligned.  This method should never return NULL.  If you run out of memory, then you should terminate the app or take some other appropriate action.  Threading: This function should be thread safe as it can be called in the context of the user thread and physics processing thread(s).  The allocated block of memory.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.DeallocateMut(MagicPhysX.PxAllocatorCallback@,System.Void*)">
            <summary>Frees memory previously allocated by allocate().  Threading: This function should be thread safe as it can be called in the context of the user thread and physics processing thread(s).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.BroadcastingAllocatorNewAlloc(MagicPhysX.PxAllocatorCallback@,MagicPhysX.PxErrorCallback*)">
            <summary>The default constructor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CreateSimulationEventCallbacks(MagicPhysX.SimulationEventCallbackInfo@)">
            <summary>New interface to handle simulation events, replacing create_contact_callback.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.OnConstraintBreakMut(MagicPhysX.PxSimulationEventCallback@,MagicPhysX.PxConstraintInfo*,System.UInt32)">
            <summary>This is called when a breakable constraint breaks.  The user should not release the constraint shader inside this call!  No event will get reported if the constraint breaks but gets deleted while the time step is still being simulated.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.OnWakeMut(MagicPhysX.PxSimulationEventCallback@,MagicPhysX.PxActor**,System.UInt32)">
            <summary>This is called with the actors which have just been woken up.  Only supported by rigid bodies yet.  Only called on actors for which the PxActorFlag eSEND_SLEEP_NOTIFIES has been set.  Only the latest sleep state transition happening between fetchResults() of the previous frame and fetchResults() of the current frame will get reported. For example, let us assume actor A is awake, then A-&gt;putToSleep() gets called, then later A-&gt;wakeUp() gets called. At the next simulate/fetchResults() step only an onWake() event will get triggered because that was the last transition.  If an actor gets newly added to a scene with properties such that it is awake and the sleep state does not get changed by the user or simulation, then an onWake() event will get sent at the next simulate/fetchResults() step.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.OnSleepMut(MagicPhysX.PxSimulationEventCallback@,MagicPhysX.PxActor**,System.UInt32)">
            <summary>This is called with the actors which have just been put to sleep.  Only supported by rigid bodies yet.  Only called on actors for which the PxActorFlag eSEND_SLEEP_NOTIFIES has been set.  Only the latest sleep state transition happening between fetchResults() of the previous frame and fetchResults() of the current frame will get reported. For example, let us assume actor A is asleep, then A-&gt;wakeUp() gets called, then later A-&gt;putToSleep() gets called. At the next simulate/fetchResults() step only an onSleep() event will get triggered because that was the last transition (assuming the simulation does not wake the actor up).  If an actor gets newly added to a scene with properties such that it is asleep and the sleep state does not get changed by the user or simulation, then an onSleep() event will get sent at the next simulate/fetchResults() step.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.OnContactMut(MagicPhysX.PxSimulationEventCallback@,MagicPhysX.PxContactPairHeader*,MagicPhysX.PxContactPair*,System.UInt32)">
            <summary>This is called when certain contact events occur.  The method will be called for a pair of actors if one of the colliding shape pairs requested contact notification. You request which events are reported using the filter shader/callback mechanism (see [`PxSimulationFilterShader`], [`PxSimulationFilterCallback`], #PxPairFlag).  Do not keep references to the passed objects, as they will be invalid after this function returns.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.OnTriggerMut(MagicPhysX.PxSimulationEventCallback@,MagicPhysX.PxTriggerPair*,System.UInt32)">
            <summary>This is called with the current trigger pair events.  Shapes which have been marked as triggers using PxShapeFlag::eTRIGGER_SHAPE will send events according to the pair flag specification in the filter shader (see [`PxPairFlag`], #PxSimulationFilterShader).  Trigger shapes will no longer send notification events for interactions with other trigger shapes.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.OnAdvanceMut(MagicPhysX.PxSimulationEventCallback@,MagicPhysX.PxRigidBody**,MagicPhysX.PxTransform*,System.UInt32)">
            <summary>Provides early access to the new pose of moving rigid bodies.  When this call occurs, rigid bodies having the [`PxRigidBodyFlag::eENABLE_POSE_INTEGRATION_PREVIEW`] flag set, were moved by the simulation and their new poses can be accessed through the provided buffers.  The provided buffers are valid and can be read until the next call to [`PxScene::simulate`]() or #PxScene::collide().  This callback gets triggered while the simulation is running. If the provided rigid body references are used to read properties of the object, then the callback has to guarantee no other thread is writing to the same body at the same time.  The code in this callback should be lightweight as it can block the simulation, that is, the [`PxScene::fetchResults`]() call.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.EnableCustomFilterShader(MagicPhysX.PxSceneDesc@,,System.UInt32)">
            <summary>Override the default filter shader in the scene with a custom function. If call_default_filter_shader_first is set to true, this will first call the built-in PhysX filter (that matches Physx 2.8 behavior) before your callback.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetToDefaultMut(MagicPhysX.PxSceneDesc@,MagicPhysX.PxTolerancesScale*)">
            <summary>(re)sets the structure to the default.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxSceneDesc@)">
            <summary>Returns true if the descriptor is valid.  true if the current settings are valid.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.OpCallMut(MagicPhysX.PxAssertHandler@,System.SByte*,System.SByte*,System.Int32,System.Boolean*)">
            <summary>(hidden) Should only be used in testing etc! This isn't generated as we don't generate op functions.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxSetProfilerCallback(MagicPhysX.PxProfilerCallback@)">
            <summary>Set the callback that will be used for all profiling.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ZoneStartMut(MagicPhysX.PxProfilerCallback@,System.Byte*,System.Boolean,System.UInt64)">
            <summary>Mark the beginning of a nested profile block  Returns implementation-specific profiler data for this event</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ZoneEndMut(MagicPhysX.PxProfilerCallback@,System.Void*,System.Byte*,System.Boolean,System.UInt64)">
            <summary>Mark the end of a nested profile block  eventName plus contextId can be used to uniquely match up start and end of a zone.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsZero(MagicPhysX.PxVec3@)">
            <summary>tests for exact zero vector</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsFinite(MagicPhysX.PxVec3@)">
            <summary>returns true if all 3 elems of the vector are finite (not NAN or INF, etc.)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsNormalized(MagicPhysX.PxVec3@)">
            <summary>is normalized - used by API parameter validation</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.MagnitudeSquared(MagicPhysX.PxVec3@)">
            <summary>returns the squared magnitude  Avoids calling PxSqrt()!</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Magnitude(MagicPhysX.PxVec3@)">
            <summary>returns the magnitude</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Dot(MagicPhysX.PxVec3@,MagicPhysX.PxVec3*)">
            <summary>returns the scalar product of this and other.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Cross(MagicPhysX.PxVec3@,MagicPhysX.PxVec3*)">
            <summary>cross product</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNormalized(MagicPhysX.PxVec3@)">
            <summary>returns a unit vector</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.NormalizeMut(MagicPhysX.PxVec3@)">
            <summary>normalizes the vector in place</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.NormalizeSafeMut(MagicPhysX.PxVec3@)">
            <summary>normalizes the vector in place. Does nothing if vector magnitude is under PX_NORMALIZATION_EPSILON. Returns vector magnitude if &gt;= PX_NORMALIZATION_EPSILON and 0.0f otherwise.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.NormalizeFastMut(MagicPhysX.PxVec3@)">
            <summary>normalizes the vector in place. Asserts if vector magnitude is under PX_NORMALIZATION_EPSILON. returns vector magnitude.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Multiply(MagicPhysX.PxVec3@,MagicPhysX.PxVec3*)">
            <summary>a[i] * b[i], for all i.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Minimum(MagicPhysX.PxVec3@,MagicPhysX.PxVec3*)">
            <summary>element-wise minimum</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.MinElement(MagicPhysX.PxVec3@)">
            <summary>returns MIN(x, y, z);</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Maximum(MagicPhysX.PxVec3@,MagicPhysX.PxVec3*)">
            <summary>element-wise maximum</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.MaxElement(MagicPhysX.PxVec3@)">
            <summary>returns MAX(x, y, z);</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Abs(MagicPhysX.PxVec3@)">
            <summary>returns absolute values of components;</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Mat33New3(MagicPhysX.PxVec3@,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>Construct from three base vectors</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Mat33CreateDiagonal(MagicPhysX.PxVec3@)">
            <summary>Construct from diagonal, off-diagonals are zero.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Mat33Outer(MagicPhysX.PxVec3@,MagicPhysX.PxVec3*)">
            <summary>Computes the outer product of two vectors</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Bounds3New1(MagicPhysX.PxVec3@,MagicPhysX.PxVec3*)">
            <summary>Construct from two bounding points</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Bounds3BoundsOfPoints(MagicPhysX.PxVec3@,MagicPhysX.PxVec3*)">
            <summary>returns the AABB containing v0 and v1.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Bounds3CenterExtents(MagicPhysX.PxVec3@,MagicPhysX.PxVec3*)">
            <summary>returns the AABB from center and extents vectors.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Bounds3BasisExtent(MagicPhysX.PxVec3@,MagicPhysX.PxMat33*,MagicPhysX.PxVec3*)">
            <summary>Construct from center, extent, and (not necessarily orthogonal) basis</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Vec4New4(MagicPhysX.PxVec3@,System.Single)">
            <summary>Initializes from 3 scalar parameters.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Mat44New5(MagicPhysX.PxVec3@,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>Construct from three base vectors and a translation</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PlaneNew2(MagicPhysX.PxVec3@,System.Single)">
            <summary>Constructor from a normal and a distance</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PlaneNew3(MagicPhysX.PxVec3@,MagicPhysX.PxVec3*)">
            <summary>Constructor from a point on the plane and a normal</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PlaneNew4(MagicPhysX.PxVec3@,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>Constructor from three points</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxShortestRotation(MagicPhysX.PxVec3@,MagicPhysX.PxVec3*)">
            <summary>finds the shortest rotation between two vectors.  a rotation about an axis normal to the two vectors which takes one to the other via the shortest path</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxTransformFromSegment(MagicPhysX.PxVec3@,MagicPhysX.PxVec3*,System.Single*)">
            <summary>creates a transform from the endpoints of a segment, suitable for an actor transform for a PxCapsuleGeometry  A PxTransform which will transform the vector (1,0,0) to the capsule axis shrunk by the halfHeight</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxExp(MagicPhysX.PxVec3@)">
            <summary>Compute the exponent of a PxVec3</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxLargestAxis(MagicPhysX.PxVec3@)">
            <summary>return Returns 0 if v.x is largest element of v, 1 if v.y is largest element, 2 if v.z is largest element.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxEllipseClamp(MagicPhysX.PxVec3@,MagicPhysX.PxVec3*)">
            <summary>Compute the closest point on an 2d ellipse to a given 2d point.  Returns the 2d position on the surface of the ellipse that is closest to point.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxComputeAngle(MagicPhysX.PxVec3@,MagicPhysX.PxVec3*)">
            <summary>Compute the angle between two non-unit vectors  Returns the angle (in radians) between the two vector v0 and v1.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxComputeBasisVectors(MagicPhysX.PxVec3@,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>Compute two normalized vectors (right and up) that are perpendicular to an input normalized vector (dir).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxComputeBasisVectors1(MagicPhysX.PxVec3@,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>Compute three normalized vectors (dir, right and up) that are parallel to (dir) and perpendicular to (right, up) the normalized direction vector (p1 - p0)/||p1 - p0||.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.MeshScaleNew2(MagicPhysX.PxVec3@)">
            <summary>Constructor to initialize to arbitrary scale and identity scale rotation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.MeshScaleNew3(MagicPhysX.PxVec3@,MagicPhysX.PxQuat*)">
            <summary>Constructor to initialize to arbitrary scaling.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GeometryQueryRaycast(MagicPhysX.PxVec3@,MagicPhysX.PxVec3*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,System.Single,MagicPhysX.PxHitFlags,System.UInt32,MagicPhysX.PxGeomRaycastHit*,System.UInt32,MagicPhysX.PxGeometryQueryFlags,MagicPhysX.PxQueryThreadContext*)">
            <summary>Raycast test against a geometry object.  All geometry types are supported except PxParticleSystemGeometry, PxTetrahedronMeshGeometry and PxHairSystemGeometry.  Number of hits between the ray and the geometry object</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GeometryQuerySweep(MagicPhysX.PxVec3@,System.Single,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxGeomSweepHit*,MagicPhysX.PxHitFlags,System.Single,MagicPhysX.PxGeometryQueryFlags,MagicPhysX.PxQueryThreadContext*)">
            <summary>Sweep a specified geometry object in space and test for collision with a given object.  The following combinations are supported.  PxSphereGeometry vs. {PxSphereGeometry, PxPlaneGeometry, PxCapsuleGeometry, PxBoxGeometry, PxConvexMeshGeometry, PxTriangleMeshGeometry, PxHeightFieldGeometry}  PxCapsuleGeometry vs. {PxSphereGeometry, PxPlaneGeometry, PxCapsuleGeometry, PxBoxGeometry, PxConvexMeshGeometry, PxTriangleMeshGeometry, PxHeightFieldGeometry}  PxBoxGeometry vs. {PxSphereGeometry, PxPlaneGeometry, PxCapsuleGeometry, PxBoxGeometry, PxConvexMeshGeometry, PxTriangleMeshGeometry, PxHeightFieldGeometry}  PxConvexMeshGeometry vs. {PxSphereGeometry, PxPlaneGeometry, PxCapsuleGeometry, PxBoxGeometry, PxConvexMeshGeometry, PxTriangleMeshGeometry, PxHeightFieldGeometry}  True if the swept geometry object geom0 hits the object geom1</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GeometryQueryComputePenetration(MagicPhysX.PxVec3@,System.Single*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxGeometryQueryFlags)">
            <summary>Compute minimum translational distance (MTD) between two geometry objects.  All combinations of geom objects are supported except: - plane/plane - plane/mesh - plane/heightfield - mesh/mesh - mesh/heightfield - heightfield/heightfield - anything involving PxParticleSystemGeometry, PxTetrahedronMeshGeometry or PxHairSystemGeometry  The function returns a unit vector ('direction') and a penetration depth ('depth').  The depenetration vector D = direction * depth should be applied to the first object, to get out of the second object.  Returned depth should always be positive or null.  If objects do not overlap, the function can not compute the MTD and returns false.  True if the MTD has successfully been computed, i.e. if objects do overlap.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GeometryQueryPointDistance(MagicPhysX.PxVec3@,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxVec3*,System.UInt32*,MagicPhysX.PxGeometryQueryFlags)">
            <summary>Computes distance between a point and a geometry object.  Currently supported geometry objects: box, sphere, capsule, convex, mesh.  For meshes, only the BVH34 midphase data-structure is supported.  Square distance between the point and the geom object, or 0.0 if the point is inside the object, or -1.0 if an error occured (geometry type is not supported, or invalid pose)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.MeshQuerySweep(MagicPhysX.PxVec3@,System.Single,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,System.UInt32,MagicPhysX.PxTriangle*,MagicPhysX.PxGeomSweepHit*,MagicPhysX.PxHitFlags,System.UInt32*,System.Single,System.Boolean,MagicPhysX.PxGeometryQueryFlags)">
            <summary>Sweep a specified geometry object in space and test for collision with a set of given triangles.  This function simply sweeps input geometry against each input triangle, in the order they are given. This is an O(N) operation with N = number of input triangles. It does not use any particular acceleration structure.  True if the swept geometry object hits the specified triangles  Only the following geometry types are currently supported: PxSphereGeometry, PxCapsuleGeometry, PxBoxGeometry  If a shape from the scene is already overlapping with the query shape in its starting position, the hit is returned unless eASSUME_NO_INITIAL_OVERLAP was specified.  This function returns a single closest hit across all the input triangles. Multiple hits are not supported.  Supported hitFlags are PxHitFlag::eDEFAULT, PxHitFlag::eASSUME_NO_INITIAL_OVERLAP, PxHitFlag::ePRECISE_SWEEP, PxHitFlag::eMESH_BOTH_SIDES, PxHitFlag::eMESH_ANY.  ePOSITION is only defined when there is no initial overlap (sweepHit.hadInitialOverlap() == false)  The returned normal for initially overlapping sweeps is set to -unitDir.  Otherwise the returned normal is the front normal of the triangle even if PxHitFlag::eMESH_BOTH_SIDES is set.  The returned PxGeomSweepHit::faceIndex parameter will hold the index of the hit triangle in input array, i.e. the range is [0; triangleCount). For initially overlapping sweeps, this is the index of overlapping triangle.  The inflation parameter is not compatible with PxHitFlag::ePRECISE_SWEEP.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.TriangleNewAlloc1(MagicPhysX.PxVec3@,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>Constructor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.TetrahedronNewAlloc1(MagicPhysX.PxVec3@,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>Constructor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxComputeTriangleMeshPenetration(MagicPhysX.PxVec3@,System.Single*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxTriangleMeshGeometry*,MagicPhysX.PxTransform*,System.UInt32,System.UInt32*)">
            <summary>Computes an approximate minimum translational distance (MTD) between a geometry object and a mesh.  This iterative function computes an approximate vector that can be used to depenetrate a geom object from a triangle mesh. Returned depenetration vector should be applied to 'geom', to get out of the mesh.  The function works best when the amount of overlap between the geom object and the mesh is small. If the geom object's center goes inside the mesh, backface culling usually kicks in, no overlap is detected, and the function does not compute an MTD vector.  The function early exits if no overlap is detected after a depenetration attempt. This means that if maxIter = N, the code will attempt at most N iterations but it might exit earlier if depenetration has been successful. Usually N = 4 gives good results.  True if the MTD has successfully been computed, i.e. if objects do overlap.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxComputeHeightFieldPenetration(MagicPhysX.PxVec3@,System.Single*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxHeightFieldGeometry*,MagicPhysX.PxTransform*,System.UInt32,System.UInt32*)">
            <summary>Computes an approximate minimum translational distance (MTD) between a geometry object and a heightfield.  This iterative function computes an approximate vector that can be used to depenetrate a geom object from a heightfield. Returned depenetration vector should be applied to 'geom', to get out of the heightfield.  The function works best when the amount of overlap between the geom object and the mesh is small. If the geom object's center goes inside the heightfield, backface culling usually kicks in, no overlap is detected, and the function does not compute an MTD vector.  The function early exits if no overlap is detected after a depenetration attempt. This means that if maxIter = N, the code will attempt at most N iterations but it might exit earlier if depenetration has been successful. Usually N = 4 gives good results.  True if the MTD has successfully been computed, i.e. if objects do overlap.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.QuatNew5(MagicPhysX.PxMat33@)">
            <summary>Creates from orientation matrix.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetTranspose(MagicPhysX.PxMat33@)">
            <summary>Get transposed matrix</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetInverse(MagicPhysX.PxMat33@)">
            <summary>Get the real inverse</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetDeterminant(MagicPhysX.PxMat33@)">
            <summary>Get determinant</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Transform(MagicPhysX.PxMat33@,MagicPhysX.PxVec3*)">
            <summary>Transform vector by matrix, equal to v' = M*v</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.TransformTranspose(MagicPhysX.PxMat33@,MagicPhysX.PxVec3*)">
            <summary>Transform vector by matrix transpose, v' = M^t*v</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Bounds3TransformSafe(MagicPhysX.PxMat33@,MagicPhysX.PxBounds3*)">
            <summary>gets the transformed bounds of the passed AABB (resulting in a bigger AABB).  This version is safe to call for empty bounds.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Bounds3TransformFast(MagicPhysX.PxMat33@,MagicPhysX.PxBounds3*)">
            <summary>gets the transformed bounds of the passed AABB (resulting in a bigger AABB).  Calling this method for empty bounds leads to undefined behavior. Use [`transformSafe`]() instead.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Mat44New9(MagicPhysX.PxMat33@,MagicPhysX.PxVec3*)">
            <summary>Construct from Mat33 and a translation</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxOptimizeBoundingBox(MagicPhysX.PxMat33@)">
            <summary>computes a oriented bounding box around the scaled basis.  Bounding box extent.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.MassPropertiesGetMassSpaceInertia(MagicPhysX.PxMat33@,MagicPhysX.PxQuat*)">
            <summary>Get the entries of the diagonalized inertia tensor and the corresponding reference rotation.  The entries of the diagonalized inertia tensor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.MassPropertiesTranslateInertia(MagicPhysX.PxMat33@,System.Single,MagicPhysX.PxVec3*)">
            <summary>Translate an inertia tensor using the parallel axis theorem  The translated inertia tensor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.MassPropertiesRotateInertia(MagicPhysX.PxMat33@,MagicPhysX.PxQuat*)">
            <summary>Rotate an inertia tensor around the center of mass  The rotated inertia tensor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.MassPropertiesScaleInertia(MagicPhysX.PxMat33@,MagicPhysX.PxQuat*,MagicPhysX.PxVec3*)">
            <summary>Non-uniform scaling of the inertia tensor  The scaled inertia tensor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsIdentity(MagicPhysX.PxQuat@)">
            <summary>returns true if quat is identity</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsFinite(MagicPhysX.PxQuat@)">
            <summary>returns true if all elements are finite (not NAN or INF, etc.)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsUnit(MagicPhysX.PxQuat@)">
            <summary>returns true if finite and magnitude is close to unit</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsSane(MagicPhysX.PxQuat@)">
            <summary>returns true if finite and magnitude is reasonably close to unit to allow for some accumulation of error vs isValid</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ToRadiansAndUnitAxis(MagicPhysX.PxQuat@,System.Single*,MagicPhysX.PxVec3*)">
            <summary>converts this quaternion to angle-axis representation</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetAngle(MagicPhysX.PxQuat@)">
            <summary>Gets the angle between this quat and the identity quaternion.  Unit: Radians</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetAngle1(MagicPhysX.PxQuat@,MagicPhysX.PxQuat*)">
            <summary>Gets the angle between this quat and the argument  Unit: Radians</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.MagnitudeSquared(MagicPhysX.PxQuat@)">
            <summary>This is the squared 4D vector length, should be 1 for unit quaternions.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Dot(MagicPhysX.PxQuat@,MagicPhysX.PxQuat*)">
            <summary>returns the scalar product of this and other.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.NormalizeMut(MagicPhysX.PxQuat@)">
            <summary>maps to the closest unit quaternion.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetBasisVector0(MagicPhysX.PxQuat@)">
            <summary>brief computes rotation of x-axis</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetBasisVector1(MagicPhysX.PxQuat@)">
            <summary>brief computes rotation of y-axis</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetBasisVector2(MagicPhysX.PxQuat@)">
            <summary>brief computes rotation of z-axis</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Rotate(MagicPhysX.PxQuat@,MagicPhysX.PxVec3*)">
            <summary>rotates passed vec by this (assumed unitary)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.RotateInv(MagicPhysX.PxQuat@,MagicPhysX.PxVec3*)">
            <summary>inverse rotates passed vec by this (assumed unitary)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Mat33New6(MagicPhysX.PxQuat@)">
            <summary>Construct from a quaternion</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Mat44New7(MagicPhysX.PxQuat@)">
            <summary>Construct from a quaternion</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxLog(MagicPhysX.PxQuat@)">
            <summary>return Returns the log of a PxQuat</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxSeparateSwingTwist(MagicPhysX.PxQuat@,MagicPhysX.PxQuat*,MagicPhysX.PxQuat*)">
            <summary>Compute from an input quaternion q a pair of quaternions (swing, twist) such that q = swing * twist with the caveats that swing.x = twist.y = twist.z = 0.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetTranspose(MagicPhysX.PxMat44@)">
            <summary>Get transposed matrix</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Transform(MagicPhysX.PxMat44@,MagicPhysX.PxVec4*)">
            <summary>Transform vector by matrix, equal to v' = M*v</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Transform1(MagicPhysX.PxMat44@,MagicPhysX.PxVec3*)">
            <summary>Transform vector by matrix, equal to v' = M*v</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Rotate(MagicPhysX.PxMat44@,MagicPhysX.PxVec4*)">
            <summary>Rotate vector by matrix, equal to v' = M*v</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Rotate1(MagicPhysX.PxMat44@,MagicPhysX.PxVec3*)">
            <summary>Rotate vector by matrix, equal to v' = M*v</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Transform1(MagicPhysX.PxTransform@,MagicPhysX.PxTransform*)">
            <summary>Transform transform to parent (returns compound transform: first src, then *this)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxTransform@)">
            <summary>returns true if finite and q is a unit quaternion</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsSane(MagicPhysX.PxTransform@)">
            <summary>returns true if finite and quat magnitude is reasonably close to unit to allow for some accumulation of error vs isValid</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsFinite(MagicPhysX.PxTransform@)">
            <summary>returns true if all elems are finite (not NAN or INF, etc.)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.TransformInv1(MagicPhysX.PxTransform@,MagicPhysX.PxTransform*)">
            <summary>Transform transform from parent (returns compound transform: first src, then this-&gt;inverse)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNormalized(MagicPhysX.PxTransform@)">
            <summary>return a normalized transform (i.e. one in which the quaternion has unit magnitude)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Bounds3PoseExtent(MagicPhysX.PxTransform@,MagicPhysX.PxVec3*)">
            <summary>Construct from pose and extent</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Bounds3TransformSafe1(MagicPhysX.PxTransform@,MagicPhysX.PxBounds3*)">
            <summary>gets the transformed bounds of the passed AABB (resulting in a bigger AABB).  This version is safe to call for empty bounds.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Bounds3TransformFast1(MagicPhysX.PxTransform@,MagicPhysX.PxBounds3*)">
            <summary>gets the transformed bounds of the passed AABB (resulting in a bigger AABB).  Calling this method for empty bounds leads to undefined behavior. Use [`transformSafe`]() instead.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxPlaneEquationFromTransform(MagicPhysX.PxTransform@)">
            <summary>creates a plane equation from a transform, such as the actor transform for a PxPlaneGeometry  the plane</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxIntegrateTransform(MagicPhysX.PxTransform@,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxTransform*)">
            <summary>integrate transform.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetEmptyMut(MagicPhysX.PxBounds3@)">
            <summary>Sets empty to true</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetMaximalMut(MagicPhysX.PxBounds3@)">
            <summary>Sets the bounds to maximum size [-PX_MAX_BOUNDS_EXTENTS, PX_MAX_BOUNDS_EXTENTS].</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IncludeMut(MagicPhysX.PxBounds3@,MagicPhysX.PxVec3*)">
            <summary>expands the volume to include v</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IncludeMut1(MagicPhysX.PxBounds3@,MagicPhysX.PxBounds3*)">
            <summary>expands the volume to include b.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Intersects(MagicPhysX.PxBounds3@,MagicPhysX.PxBounds3*)">
            <summary>indicates whether the intersection of this and b is empty or not.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Intersects1D(MagicPhysX.PxBounds3@,MagicPhysX.PxBounds3*,System.UInt32)">
            <summary>computes the 1D-intersection between two AABBs, on a given axis.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Contains(MagicPhysX.PxBounds3@,MagicPhysX.PxVec3*)">
            <summary>indicates if these bounds contain v.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsInside(MagicPhysX.PxBounds3@,MagicPhysX.PxBounds3*)">
            <summary>checks a box is inside another box.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetCenter(MagicPhysX.PxBounds3@)">
            <summary>returns the center of this axis aligned box.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetCenter1(MagicPhysX.PxBounds3@,System.UInt32)">
            <summary>get component of the box's center along a given axis</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetExtents(MagicPhysX.PxBounds3@,System.UInt32)">
            <summary>get component of the box's extents along a given axis</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetDimensions(MagicPhysX.PxBounds3@)">
            <summary>returns the dimensions (width/height/depth) of this axis aligned box.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetExtents1(MagicPhysX.PxBounds3@)">
            <summary>returns the extents, which are half of the width/height/depth.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ScaleSafeMut(MagicPhysX.PxBounds3@,System.Single)">
            <summary>scales the AABB.  This version is safe to call for empty bounds.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ScaleFastMut(MagicPhysX.PxBounds3@,System.Single)">
            <summary>scales the AABB.  Calling this method for empty bounds leads to undefined behavior. Use [`scaleSafe`]() instead.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.FattenSafeMut(MagicPhysX.PxBounds3@,System.Single)">
            <summary>fattens the AABB in all 3 dimensions by the given distance.  This version is safe to call for empty bounds.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.FattenFastMut(MagicPhysX.PxBounds3@,System.Single)">
            <summary>fattens the AABB in all 3 dimensions by the given distance.  Calling this method for empty bounds leads to undefined behavior. Use [`fattenSafe`]() instead.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsFinite(MagicPhysX.PxBounds3@)">
            <summary>checks that the AABB values are not NaN</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxBounds3@)">
            <summary>checks that the AABB values describe a valid configuration.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ClosestPoint(MagicPhysX.PxBounds3@,MagicPhysX.PxVec3*)">
            <summary>Finds the closest point in the box to the point p. If p is contained, this will be p, otherwise it will be the closest point on the surface of the box.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GeometryQueryComputeGeomBounds(MagicPhysX.PxBounds3@,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,System.Single,System.Single,MagicPhysX.PxGeometryQueryFlags)">
            <summary>computes the bounds for a geometry object</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.BroadPhaseExtCreateRegionsFromWorldBounds(MagicPhysX.PxBounds3@,MagicPhysX.PxBounds3*,System.UInt32,System.UInt32)">
            <summary>Creates regions for PxSceneDesc, from a global box.  This helper simply subdivides the given global box into a 2D grid of smaller boxes. Each one of those smaller boxes is a region of interest for the broadphase. There are nbSubdiv*nbSubdiv regions in the 2D grid. The function does not subdivide along the given up axis.  This is the simplest setup one can use with PxBroadPhaseType::eMBP. A more sophisticated setup would try to cover the game world with a non-uniform set of regions (i.e. not just a grid).  number of regions written out to the 'regions' array</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReportErrorMut(MagicPhysX.PxErrorCallback@,MagicPhysX.PxErrorCode,System.Byte*,System.Byte*,System.Int32)">
            <summary>Reports an error code.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.BroadcastingErrorCallbackNewAlloc(MagicPhysX.PxErrorCallback@)">
            <summary>The default constructor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.TaskManagerCreateTaskManager(MagicPhysX.PxErrorCallback@,MagicPhysX.PxCpuDispatcher*)">
            <summary>Construct a new PxTaskManager instance with the given [optional] dispatchers</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.OnAllocationMut(MagicPhysX.PxAllocationListener@,System.UIntPtr,System.Byte*,System.Byte*,System.Int32,System.Void*)">
            <summary>callback when memory is allocated.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.OnDeallocationMut(MagicPhysX.PxAllocationListener@,System.Void*)">
            <summary>callback when memory is deallocated.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Delete(MagicPhysX.PxBroadcastingAllocator@)">
            <summary>The default constructor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AllocateMut(MagicPhysX.PxBroadcastingAllocator@,System.UIntPtr,System.Byte*,System.Byte*,System.Int32)">
            <summary>Allocates size bytes of memory, which must be 16-byte aligned.  This method should never return NULL.  If you run out of memory, then you should terminate the app or take some other appropriate action.  Threading: This function should be thread safe as it can be called in the context of the user thread and physics processing thread(s).  The allocated block of memory.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.DeallocateMut(MagicPhysX.PxBroadcastingAllocator@,System.Void*)">
            <summary>Frees memory previously allocated by allocate().  Threading: This function should be thread safe as it can be called in the context of the user thread and physics processing thread(s).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Delete(MagicPhysX.PxBroadcastingErrorCallback@)">
            <summary>The default destructor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReportErrorMut(MagicPhysX.PxBroadcastingErrorCallback@,MagicPhysX.PxErrorCode,System.Byte*,System.Byte*,System.Int32)">
            <summary>Reports an error code.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReadMut(MagicPhysX.PxInputStream@,System.Void*,System.UInt32)">
            <summary>read from the stream. The number of bytes read may be less than the number requested.  the number of bytes read from the stream.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetLength(MagicPhysX.PxInputData@)">
            <summary>return the length of the input data  size in bytes of the input data</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SeekMut(MagicPhysX.PxInputData@,System.UInt32)">
            <summary>seek to the given offset from the start of the data.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Tell(MagicPhysX.PxInputData@)">
            <summary>return the current offset from the start of the data  the offset to seek to.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SerializationCreateCollectionFromXml(MagicPhysX.PxInputData@,MagicPhysX.PxCooking*,MagicPhysX.PxSerializationRegistry*,MagicPhysX.PxCollection*,MagicPhysX.PxStringTable*,MagicPhysX.PxXmlMiscParameter*)">
            <summary>Creates a PxCollection from XML data.  a pointer to a PxCollection if successful or NULL if it failed.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.WriteMut(MagicPhysX.PxOutputStream@,System.Void*,System.UInt32)">
            <summary>write to the stream. The number of bytes written may be less than the number sent.  the number of bytes written to the stream by this call.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.JointGetBinaryMetaData(MagicPhysX.PxOutputStream@)">
            <summary>Put class meta data in stream, used for serialization</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SerializationSerializeCollectionToXml(MagicPhysX.PxOutputStream@,MagicPhysX.PxCollection*,MagicPhysX.PxSerializationRegistry*,MagicPhysX.PxCooking*,MagicPhysX.PxCollection*,MagicPhysX.PxXmlMiscParameter*)">
            <summary>Serializes a physics collection to an XML output stream.  The collection to be serialized needs to be complete  Serialization of objects in a scene that is simultaneously being simulated is not supported and leads to undefined behavior.  true if the collection is successfully serialized.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SerializationSerializeCollectionToBinary(MagicPhysX.PxOutputStream@,MagicPhysX.PxCollection*,MagicPhysX.PxSerializationRegistry*,MagicPhysX.PxCollection*,System.Boolean)">
            <summary>Serializes a collection to a binary stream.  Serializes a collection to a stream. In order to resolve external dependencies the externalReferences collection has to be provided. Optionally names of objects that where set for example with [`PxActor::setName`] are serialized along with the objects.  The collection can be successfully serialized if isSerializable(collection) returns true. See [`isSerializable`].  The implementation of the output stream needs to fulfill the requirements on the memory block input taken by PxSerialization::createCollectionFromBinary.  Serialization of objects in a scene that is simultaneously being simulated is not supported and leads to undefined behavior.  Whether serialization was successful</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsZero(MagicPhysX.PxVec4@)">
            <summary>tests for exact zero vector</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsFinite(MagicPhysX.PxVec4@)">
            <summary>returns true if all 3 elems of the vector are finite (not NAN or INF, etc.)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsNormalized(MagicPhysX.PxVec4@)">
            <summary>is normalized - used by API parameter validation</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.MagnitudeSquared(MagicPhysX.PxVec4@)">
            <summary>returns the squared magnitude  Avoids calling PxSqrt()!</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Magnitude(MagicPhysX.PxVec4@)">
            <summary>returns the magnitude</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Dot(MagicPhysX.PxVec4@,MagicPhysX.PxVec4*)">
            <summary>returns the scalar product of this and other.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNormalized(MagicPhysX.PxVec4@)">
            <summary>returns a unit vector</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.NormalizeMut(MagicPhysX.PxVec4@)">
            <summary>normalizes the vector in place</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Multiply(MagicPhysX.PxVec4@,MagicPhysX.PxVec4*)">
            <summary>a[i] * b[i], for all i.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Minimum(MagicPhysX.PxVec4@,MagicPhysX.PxVec4*)">
            <summary>element-wise minimum</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Maximum(MagicPhysX.PxVec4@,MagicPhysX.PxVec4*)">
            <summary>element-wise maximum</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Mat44New3(MagicPhysX.PxVec4@,MagicPhysX.PxVec4*,MagicPhysX.PxVec4*,MagicPhysX.PxVec4*)">
            <summary>Construct from four 4-vectors</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Mat44New8(MagicPhysX.PxVec4@)">
            <summary>Construct from a diagonal vector</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Project(MagicPhysX.PxPlane@,MagicPhysX.PxVec3*)">
            <summary>projects p into the plane</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PointInPlane(MagicPhysX.PxPlane@)">
            <summary>find an arbitrary point in the plane</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.NormalizeMut(MagicPhysX.PxPlane@)">
            <summary>equivalent plane with unit normal</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Transform(MagicPhysX.PxPlane@,MagicPhysX.PxTransform*)">
            <summary>transform plane</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.InverseTransform(MagicPhysX.PxPlane@,MagicPhysX.PxTransform*)">
            <summary>inverse-transform plane</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxTransformFromPlaneEquation(MagicPhysX.PxPlane@)">
            <summary>creates a transform from a plane equation, suitable for an actor transform for a PxPlaneGeometry  a PxTransform which will transform the plane PxPlane(1,0,0,0) to the specified plane</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Delete(MagicPhysX.PxMutexImpl@)">
            <summary>The destructor for Mutex deletes the mutex.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.LockMut(MagicPhysX.PxMutexImpl@)">
            <summary>Acquire (lock) the mutex. If the mutex is already locked by another thread, this method blocks until the mutex is unlocked.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.TrylockMut(MagicPhysX.PxMutexImpl@)">
            <summary>Acquire (lock) the mutex. If the mutex is already locked by another thread, this method returns false without blocking.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.UnlockMut(MagicPhysX.PxMutexImpl@)">
            <summary>Release (unlock) the mutex.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.WaitMut(MagicPhysX.PxSyncImpl@,System.UInt32)">
            <summary>Wait on the object for at most the given number of ms. Returns true if the object is signaled. Sync::waitForever will block forever or until the object is signaled.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetMut(MagicPhysX.PxSyncImpl@)">
            <summary>Signal the synchronization object, waking all threads waiting on it</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ResetMut(MagicPhysX.PxSyncImpl@)">
            <summary>Reset the synchronization object</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsZero(MagicPhysX.PxVec2@)">
            <summary>tests for exact zero vector</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsFinite(MagicPhysX.PxVec2@)">
            <summary>returns true if all 2 elems of the vector are finite (not NAN or INF, etc.)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsNormalized(MagicPhysX.PxVec2@)">
            <summary>is normalized - used by API parameter validation</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.MagnitudeSquared(MagicPhysX.PxVec2@)">
            <summary>returns the squared magnitude  Avoids calling PxSqrt()!</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Magnitude(MagicPhysX.PxVec2@)">
            <summary>returns the magnitude</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Dot(MagicPhysX.PxVec2@,MagicPhysX.PxVec2*)">
            <summary>returns the scalar product of this and other.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNormalized(MagicPhysX.PxVec2@)">
            <summary>returns a unit vector</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.NormalizeMut(MagicPhysX.PxVec2@)">
            <summary>normalizes the vector in place</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Multiply(MagicPhysX.PxVec2@,MagicPhysX.PxVec2*)">
            <summary>a[i] * b[i], for all i.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Minimum(MagicPhysX.PxVec2@,MagicPhysX.PxVec2*)">
            <summary>element-wise minimum</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.MinElement(MagicPhysX.PxVec2@)">
            <summary>returns MIN(x, y);</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Maximum(MagicPhysX.PxVec2@,MagicPhysX.PxVec2*)">
            <summary>element-wise maximum</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.MaxElement(MagicPhysX.PxVec2@)">
            <summary>returns MAX(x, y);</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.RegisterReferenceMut(MagicPhysX.PxSerializationContext@,MagicPhysX.PxBase*,System.UInt32,System.UIntPtr)">
            <summary>Registers a reference value corresponding to a PxBase object.  This method is assumed to be called in the implementation of PxSerializer::registerReferences for serialized references that need to be resolved on deserialization.  A reference needs to be associated with exactly one PxBase object in either the collection or the external references collection.  Different kinds of references are supported and need to be specified. In the most common case (PX_SERIAL_REF_KIND_PXBASE) the PxBase object matches the reference value (which is the pointer to the PxBase object). Integer references maybe registered as well (used for internal material indices with PX_SERIAL_REF_KIND_MATERIAL_IDX). Other kinds could be added with the restriction that for pointer types the kind value needs to be marked with the PX_SERIAL_REF_KIND_PTR_TYPE_BIT.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetCollection(MagicPhysX.PxSerializationContext@)">
            <summary>Returns the collection that is being serialized.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.WriteDataMut(MagicPhysX.PxSerializationContext@,System.Void*,System.UInt32)">
            <summary>Serializes object data and object extra data.  This function is assumed to be called within the implementation of PxSerializer::exportData and PxSerializer::exportExtraData.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AlignDataMut(MagicPhysX.PxSerializationContext@,System.UInt32)">
            <summary>Aligns the serialized data.  This function is assumed to be called within the implementation of PxSerializer::exportData and PxSerializer::exportExtraData.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.WriteNameMut(MagicPhysX.PxSerializationContext@,System.Byte*)">
            <summary>Helper function to write a name to the extraData if serialization is configured to save names.  This function is assumed to be called within the implementation of PxSerializer::exportExtraData.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ResolveReference(MagicPhysX.PxDeserializationContext@,System.UInt32,System.UIntPtr)">
            <summary>Retrieves a pointer to a deserialized PxBase object given a corresponding deserialized reference value  This method is assumed to be called in the implementation of PxSerializer::createObject in order to update reference values on deserialization.  To update a PxBase reference the corresponding deserialized pointer value needs to be provided in order to retrieve the location of the corresponding deserialized PxBase object. (PxDeserializationContext::translatePxBase simplifies this common case).  For other kinds of references the reverence values need to be updated by deduction given the corresponding PxBase instance.  PxBase object associated with the reference value</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReadNameMut(MagicPhysX.PxDeserializationContext@,System.Byte**)">
            <summary>Helper function to read a name from the extra data during deserialization.  This function is assumed to be called within the implementation of PxSerializer::createObject.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AlignExtraDataMut(MagicPhysX.PxDeserializationContext@,System.UInt32)">
            <summary>Function to align the extra data stream to a power of 2 alignment  This function is assumed to be called within the implementation of PxSerializer::createObject.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.RegisterSerializerMut(MagicPhysX.PxSerializationRegistry@,System.UInt16,MagicPhysX.PxSerializer*)">
            <summary>Register a serializer for a concrete type</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.UnregisterSerializerMut(MagicPhysX.PxSerializationRegistry@,System.UInt16)">
            <summary>Unregister a serializer for a concrete type, and retrieves the corresponding serializer object.  Unregistered serializer corresponding to type, NULL for types for which no serializer has been registered.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSerializer(MagicPhysX.PxSerializationRegistry@,System.UInt16)">
            <summary>Returns PxSerializer corresponding to type  Registered PxSerializer object corresponding to type</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.RegisterRepXSerializerMut(MagicPhysX.PxSerializationRegistry@,System.UInt16,MagicPhysX.PxRepXSerializer*)">
            <summary>Register a RepX serializer for a concrete type</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.UnregisterRepXSerializerMut(MagicPhysX.PxSerializationRegistry@,System.UInt16)">
            <summary>Unregister a RepX serializer for a concrete type, and retrieves the corresponding serializer object.  Unregistered PxRepxSerializer corresponding to type, NULL for types for which no RepX serializer has been registered.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetRepXSerializer(MagicPhysX.PxSerializationRegistry@,System.Byte*)">
            <summary>Returns RepX serializer given the corresponding type name  Registered PxRepXSerializer object corresponding to type name</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxSerializationRegistry@)">
            <summary>Releases PxSerializationRegistry instance.  This unregisters all PhysX and PhysXExtension serializers. Make sure to unregister all custom type serializers before releasing the PxSerializationRegistry.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AddMut(MagicPhysX.PxCollection@,MagicPhysX.PxBase*,System.UInt64)">
            <summary>Adds a PxBase object to the collection.  Adds a PxBase object to the collection. Optionally a PxSerialObjectId can be provided in order to resolve dependencies between collections. A PxSerialObjectId value of PX_SERIAL_OBJECT_ID_INVALID means the object remains without id. Objects can be added regardless of other objects they require. If the object is already in the collection, the ID will be set if it was PX_SERIAL_OBJECT_ID_INVALID previously, otherwise the operation fails.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.RemoveMut(MagicPhysX.PxCollection@,MagicPhysX.PxBase*)">
            <summary>Removes a PxBase member object from the collection.  Object needs to be contained by the collection.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Contains(MagicPhysX.PxCollection@,MagicPhysX.PxBase*)">
            <summary>Returns whether the collection contains a certain PxBase object.  Whether object is contained.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AddIdMut(MagicPhysX.PxCollection@,MagicPhysX.PxBase*,System.UInt64)">
            <summary>Adds an id to a member PxBase object.  If the object is already associated with an id within the collection, the id is replaced. May only be called for objects that are members of the collection. The id needs to be unique within the collection.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.RemoveIdMut(MagicPhysX.PxCollection@,System.UInt64)">
            <summary>Removes id from a contained PxBase object.  May only be called for ids that are associated with an object in the collection.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AddMut1(MagicPhysX.PxCollection@,MagicPhysX.PxCollection*)">
            <summary>Adds all PxBase objects and their ids of collection to this collection.  PxBase objects already in this collection are ignored. Object ids need to be conflict free, i.e. the same object may not have two different ids within the two collections.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.RemoveMut1(MagicPhysX.PxCollection@,MagicPhysX.PxCollection*)">
            <summary>Removes all PxBase objects of collection from this collection.  PxBase objects not present in this collection are ignored. Ids of objects which are removed are also removed.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbObjects(MagicPhysX.PxCollection@)">
            <summary>Gets number of PxBase objects in this collection.  Number of objects in this collection</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetObject(MagicPhysX.PxCollection@,System.UInt32)">
            <summary>Gets the PxBase object of this collection given its index.  PxBase object at index index</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetObjects(MagicPhysX.PxCollection@,MagicPhysX.PxBase**,System.UInt32,System.UInt32)">
            <summary>Copies member PxBase pointers to a user specified buffer.  number of members PxBase objects that have been written to the userBuffer</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Find(MagicPhysX.PxCollection@,System.UInt64)">
            <summary>Looks for a PxBase object given a PxSerialObjectId value.  If there is no PxBase object in the collection with the given id, NULL is returned.  PxBase object with the given id value or NULL</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbIds(MagicPhysX.PxCollection@)">
            <summary>Gets number of PxSerialObjectId names in this collection.  Number of PxSerialObjectId names in this collection</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetIds(MagicPhysX.PxCollection@,System.UInt64*,System.UInt32,System.UInt32)">
            <summary>Copies member PxSerialObjectId values to a user specified buffer.  number of members PxSerialObjectId values that have been written to the userBuffer</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetId(MagicPhysX.PxCollection@,MagicPhysX.PxBase*)">
            <summary>Gets the PxSerialObjectId name of a PxBase object within the collection.  The PxBase object needs to be a member of the collection.  PxSerialObjectId name of the object or PX_SERIAL_OBJECT_ID_INVALID if the object is unnamed</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxCollection@)">
            <summary>Deletes a collection object.  This function only deletes the collection object, i.e. the container class. It doesn't delete objects that are part of the collection.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SerializationIsSerializable(MagicPhysX.PxCollection@,MagicPhysX.PxSerializationRegistry*,MagicPhysX.PxCollection*)">
            <summary>Returns whether the collection is serializable with the externalReferences collection.  Some definitions to explain whether a collection can be serialized or not:  For definitions of requires and complete see [`PxSerialization::complete`]  A serializable object is subordinate if it cannot be serialized on its own The following objects are subordinate: - articulation links - articulation joints - joints  A collection C can be serialized with external references collection D iff - C is complete relative to D (no dangling references) - Every object in D required by an object in C has a valid ID (no unnamed references) - Every subordinate object in C is required by another object in C (no orphans)  Whether the collection is serializable</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SerializationComplete(MagicPhysX.PxCollection@,MagicPhysX.PxSerializationRegistry*,MagicPhysX.PxCollection*,System.Boolean)">
            <summary>Adds to a collection all objects such that it can be successfully serialized.  A collection C is complete relative to an other collection D if every object required by C is either in C or D. This function adds objects to a collection, such that it becomes complete with respect to the exceptFor collection. Completeness is needed for serialization. See [`PxSerialization::serializeCollectionToBinary`], [`PxSerialization::serializeCollectionToXml`].  Sdk objects require other sdk object according to the following rules: - joints require their actors and constraint - rigid actors require their shapes - shapes require their material(s) and mesh (triangle mesh, convex mesh or height field), if any - articulations require their links and joints - aggregates require their actors  If followJoints is specified another rule is added: - actors require their joints  Specifying followJoints will make whole jointed actor chains being added to the collection. Following chains is interrupted whenever a object in exceptFor is encountered.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SerializationCreateSerialObjectIds(MagicPhysX.PxCollection@,System.UInt64)">
            <summary>Creates PxSerialObjectId values for unnamed objects in a collection.  Creates PxSerialObjectId names for unnamed objects in a collection starting at a base value and incrementing, skipping values that are already assigned to objects in the collection.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxBase@)">
            <summary>Releases the PxBase instance, please check documentation of release in derived class.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetConcreteTypeName(MagicPhysX.PxBase@)">
            <summary>Returns string name of dynamic type.  Class name of most derived type of this object.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetConcreteType(MagicPhysX.PxBase@)">
            <summary>Returns concrete type of object.  PxConcreteType::Enum of serialized object</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetBaseFlagMut(MagicPhysX.PxBase@,MagicPhysX.PxBaseFlag,System.Boolean)">
            <summary>Set PxBaseFlag</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetBaseFlagsMut(MagicPhysX.PxBase@,MagicPhysX.PxBaseFlags)">
            <summary>Set PxBaseFlags</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetBaseFlags(MagicPhysX.PxBase@)">
            <summary>Returns PxBaseFlags  PxBaseFlags</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsReleasable(MagicPhysX.PxBase@)">
            <summary>Whether the object is subordinate.  A class is subordinate, if it can only be instantiated in the context of another class.  Whether the class is subordinate</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxRefCounted@)">
            <summary>Decrements the reference count of the object and releases it if the new reference count is zero.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetReferenceCount(MagicPhysX.PxRefCounted@)">
            <summary>Returns the reference count of the object.  At creation, the reference count of the object is 1. Every other object referencing this object increments the count by 1. When the reference count reaches 0, and only then, the object gets destroyed automatically.  the current reference count.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AcquireReferenceMut(MagicPhysX.PxRefCounted@)">
            <summary>Acquires a counted reference to this object.  This method increases the reference count of the object by 1. Decrement the reference count by calling release()</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxTolerancesScale@)">
            <summary>Returns true if the descriptor is valid.  true if the current settings are valid (returns always true).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SceneDescNew(MagicPhysX.PxTolerancesScale@)">
            <summary>constructor sets to default.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.JointLinearLimitNew(MagicPhysX.PxTolerancesScale@,System.Single,System.Single)">
            <summary>construct a linear hard limit</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.JointLinearLimitPairNew(MagicPhysX.PxTolerancesScale@,System.Single,System.Single,System.Single)">
            <summary>Construct a linear hard limit pair. The lower distance value must be less than the upper distance value.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AllocateStrMut(MagicPhysX.PxStringTable@,System.Byte*)">
            <summary>Allocate a new string.  *Always* a valid null terminated string.  \"\" is returned if \"\" or null is passed in.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxStringTable@)">
            <summary>Release the string table and all the strings associated with it.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetConcreteTypeName(MagicPhysX.PxSerializer@)">
            <summary>Returns string name of dynamic type.  Class name of most derived type of this object.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.RequiresObjects(MagicPhysX.PxSerializer@,MagicPhysX.PxBase*,MagicPhysX.PxProcessPxBaseCallback*)">
            <summary>Adds required objects to the collection.  This method does not add the required objects recursively, e.g. objects required by required objects.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsSubordinate(MagicPhysX.PxSerializer@)">
            <summary>Whether the object is subordinate.  A class is subordinate, if it can only be instantiated in the context of another class.  Whether the class is subordinate</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ExportExtraData(MagicPhysX.PxSerializer@,MagicPhysX.PxBase*,MagicPhysX.PxSerializationContext*)">
            <summary>Exports object's extra data to stream.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ExportData(MagicPhysX.PxSerializer@,MagicPhysX.PxBase*,MagicPhysX.PxSerializationContext*)">
            <summary>Exports object's data to stream.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.RegisterReferences(MagicPhysX.PxSerializer@,MagicPhysX.PxBase*,MagicPhysX.PxSerializationContext*)">
            <summary>Register references that the object maintains to other objects.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetClassSize(MagicPhysX.PxSerializer@)">
            <summary>Returns size needed to create the class instance.  sizeof class instance.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CreateObject(MagicPhysX.PxSerializer@,System.Byte**,MagicPhysX.PxDeserializationContext*)">
            <summary>Create object at a given address, resolve references and import extra data.  Created PxBase pointer (needs to be identical to address before increment).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Delete(MagicPhysX.PxSerializer@)">
            <summary>*******************************************************************************************************************</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.BuildObjectFromDataMut(MagicPhysX.PxInsertionCallback@,MagicPhysX.PxConcreteType,System.Void*)">
            <summary>Builds object (TriangleMesh, Heightfield, ConvexMesh or BVH) from given data in PxPhysics.  PxBase Created object in PxPhysics.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetCpuDispatcherMut(MagicPhysX.PxTaskManager@,MagicPhysX.PxCpuDispatcher*)">
            <summary>Set the user-provided dispatcher object for CPU tasks</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetCpuDispatcher(MagicPhysX.PxTaskManager@)">
            <summary>Get the user-provided dispatcher object for CPU tasks  The CPU dispatcher object.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ResetDependenciesMut(MagicPhysX.PxTaskManager@)">
            <summary>Reset any dependencies between Tasks  Will be called at the start of every frame before tasks are submitted.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.StartSimulationMut(MagicPhysX.PxTaskManager@)">
            <summary>Called by the owning scene to start the task graph.  All tasks with ref count of 1 will be dispatched.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.StopSimulationMut(MagicPhysX.PxTaskManager@)">
            <summary>Called by the owning scene at the end of a simulation step.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.TaskCompletedMut(MagicPhysX.PxTaskManager@,MagicPhysX.PxTask*)">
            <summary>Called by the worker threads to inform the PxTaskManager that a task has completed processing.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNamedTaskMut(MagicPhysX.PxTaskManager@,System.Byte*)">
            <summary>Retrieve a task by name  The ID of the task with that name, or eNOT_PRESENT if not found</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SubmitNamedTaskMut(MagicPhysX.PxTaskManager@,MagicPhysX.PxTask*,System.Byte*,MagicPhysX.PxTaskType)">
            <summary>Submit a task with a unique name.  The ID of the task with that name, or eNOT_PRESENT if not found</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SubmitUnnamedTaskMut(MagicPhysX.PxTaskManager@,MagicPhysX.PxTask*,MagicPhysX.PxTaskType)">
            <summary>Submit an unnamed task.  The ID of the task with that name, or eNOT_PRESENT if not found</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetTaskFromIDMut(MagicPhysX.PxTaskManager@,System.UInt32)">
            <summary>Retrieve a task given a task ID  The task associated with the ID</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxTaskManager@)">
            <summary>Release the PxTaskManager object, referenced dispatchers will not be released</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SubmitTaskMut(MagicPhysX.PxCpuDispatcher@,MagicPhysX.PxBaseTask*)">
            <summary>Called by the TaskManager when a task is to be queued for execution.  Upon receiving a task, the dispatcher should schedule the task to run. After the task has been run, it should call the release() method and discard its pointer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetWorkerCount(MagicPhysX.PxCpuDispatcher@)">
            <summary>Returns the number of available worker threads for this dispatcher.  The SDK will use this count to control how many tasks are submitted. By matching the number of tasks with the number of execution units task overhead can be reduced.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.RunMut(MagicPhysX.PxBaseTask@)">
            <summary>The user-implemented run method where the task's work should be performed  run() methods must be thread safe, stack friendly (no alloca, etc), and must never block.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetName(MagicPhysX.PxBaseTask@)">
            <summary>Return a user-provided task name for profiling purposes.  It does not have to be unique, but unique names are helpful.  The name of this task</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AddReferenceMut(MagicPhysX.PxBaseTask@)">
            <summary>Implemented by derived implementation classes</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.RemoveReferenceMut(MagicPhysX.PxBaseTask@)">
            <summary>Implemented by derived implementation classes</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetReference(MagicPhysX.PxBaseTask@)">
            <summary>Implemented by derived implementation classes</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxBaseTask@)">
            <summary>Implemented by derived implementation classes  A task may assume in its release() method that the task system no longer holds references to it - so it may safely run its destructor, recycle itself, etc. provided no additional user references to the task exist</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetTaskManager(MagicPhysX.PxBaseTask@)">
            <summary>Return PxTaskManager to which this task was submitted  Note, can return NULL if task was not submitted, or has been completed.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxTask@)">
            <summary>Release method implementation</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.FinishBeforeMut(MagicPhysX.PxTask@,System.UInt32)">
            <summary>Inform the PxTaskManager this task must finish before the given</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.StartAfterMut(MagicPhysX.PxTask@,System.UInt32)">
            <summary>Inform the PxTaskManager this task cannot start until the given</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AddReferenceMut(MagicPhysX.PxTask@)">
            <summary>Manually increment this task's reference count. The task will not be allowed to run until removeReference() is called.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.RemoveReferenceMut(MagicPhysX.PxTask@)">
            <summary>Manually decrement this task's reference count. If the reference count reaches zero, the task will be dispatched.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetReference(MagicPhysX.PxTask@)">
            <summary>Return the ref-count for this task</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetTaskID(MagicPhysX.PxTask@)">
            <summary>Return the unique ID for this task</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SubmittedMut(MagicPhysX.PxTask@)">
            <summary>Called by PxTaskManager at submission time for initialization  Perform simulation step initialization here.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetContinuationMut(MagicPhysX.PxLightCpuTask@,MagicPhysX.PxTaskManager*,MagicPhysX.PxBaseTask*)">
            <summary>Initialize this task and specify the task that will have its ref count decremented on completion.  Submission is deferred until the task's mRefCount is decremented to zero. Note that we only use the PxTaskManager to query the appropriate dispatcher.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetContinuationMut1(MagicPhysX.PxLightCpuTask@,MagicPhysX.PxBaseTask*)">
            <summary>Initialize this task and specify the task that will have its ref count decremented on completion.  This overload of setContinuation() queries the PxTaskManager from the continuation task, which cannot be NULL.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetContinuation(MagicPhysX.PxLightCpuTask@)">
            <summary>Retrieves continuation task</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.RemoveReferenceMut(MagicPhysX.PxLightCpuTask@)">
            <summary>Manually decrement this task's reference count. If the reference count reaches zero, the task will be dispatched.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetReference(MagicPhysX.PxLightCpuTask@)">
            <summary>Return the ref-count for this task</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AddReferenceMut(MagicPhysX.PxLightCpuTask@)">
            <summary>Manually increment this task's reference count. The task will not be allowed to run until removeReference() is called.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxLightCpuTask@)">
            <summary>called by CpuDispatcher after run method has completed  Decrements the continuation task's reference count, if specified.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetType(MagicPhysX.PxGeometry@)">
            <summary>Returns the type of the geometry.  The type of the object.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.QueryOverlap(MagicPhysX.PxGeometry@,MagicPhysX.PxTransform*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxGeometryQueryFlags,MagicPhysX.PxQueryThreadContext*)">
            <summary>Overlap test for two geometry objects.  All combinations are supported except:  PxPlaneGeometry vs. {PxPlaneGeometry, PxTriangleMeshGeometry, PxHeightFieldGeometry}  PxTriangleMeshGeometry vs. PxHeightFieldGeometry  PxHeightFieldGeometry vs. PxHeightFieldGeometry  Anything involving PxParticleSystemGeometry, PxTetrahedronMeshGeometry or PxHairSystemGeometry.  True if the two geometry objects overlap</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.QueryIsValid(MagicPhysX.PxGeometry@)">
            <summary>Checks if provided geometry is valid.  True if geometry is valid.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.MeshQueryFindOverlapTriangleMesh(MagicPhysX.PxGeometry@,MagicPhysX.PxTransform*,MagicPhysX.PxTriangleMeshGeometry*,MagicPhysX.PxTransform*,System.UInt32*,System.UInt32,System.UInt32,System.Boolean*,MagicPhysX.PxGeometryQueryFlags)">
            <summary>Find the mesh triangles which touch the specified geometry object.  For mesh-vs-mesh overlap tests, please use the specialized function below.  Returned triangle indices can be used with [`getTriangle`]() to retrieve the triangle properties.  Number of overlaps found, i.e. number of elements written to the results buffer</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.MeshQueryFindOverlapHeightField(MagicPhysX.PxGeometry@,MagicPhysX.PxTransform*,MagicPhysX.PxHeightFieldGeometry*,MagicPhysX.PxTransform*,System.UInt32*,System.UInt32,System.UInt32,System.Boolean*,MagicPhysX.PxGeometryQueryFlags)">
            <summary>Find the height field triangles which touch the specified geometry object.  Returned triangle indices can be used with [`getTriangle`]() to retrieve the triangle properties.  Number of overlaps found, i.e. number of elements written to the results buffer</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.MassPropertiesNew2(MagicPhysX.PxGeometry@)">
            <summary>Compute mass properties based on a provided geometry structure.  This constructor assumes the geometry has a density of 1. Mass and inertia tensor scale linearly with density.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxCreateShapeSampler(MagicPhysX.PxGeometry@,MagicPhysX.PxTransform*,MagicPhysX.PxBounds3*,System.Single,System.Int32)">
            <summary>Creates a shape sampler  Returns the sampler</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxBoxGeometry@)">
            <summary>Returns true if the geometry is valid.  True if the current settings are valid  A valid box has a positive extent in each direction (halfExtents.x &gt; 0, halfExtents.y &gt; 0, halfExtents.z &gt; 0). It is illegal to call PxRigidActor::createShape and PxPhysics::createShape with a box that has zero extent in any direction.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Raycast(MagicPhysX.PxBVH@,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxBVHRaycastCallback*,MagicPhysX.PxGeometryQueryFlags)">
            <summary>Raycast test against a BVH.  false if query has been aborted</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Sweep(MagicPhysX.PxBVH@,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxBVHRaycastCallback*,MagicPhysX.PxGeometryQueryFlags)">
            <summary>Sweep test against a BVH.  false if query has been aborted</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Overlap(MagicPhysX.PxBVH@,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxBVHOverlapCallback*,MagicPhysX.PxGeometryQueryFlags)">
            <summary>Overlap test against a BVH.  false if query has been aborted</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Cull(MagicPhysX.PxBVH@,System.UInt32,MagicPhysX.PxPlane*,MagicPhysX.PxBVHOverlapCallback*,MagicPhysX.PxGeometryQueryFlags)">
            <summary>Frustum culling test against a BVH.  This is similar in spirit to an overlap query using a convex object around the frustum. However this specialized query has better performance, and can support more than the 6 planes of a frustum, which can be useful in portal-based engines.  On the other hand this test only returns a conservative number of bounds, i.e. some of the returned bounds may actually be outside the frustum volume, close to it but not touching it. This is usually an ok performance trade-off when the function is used for view-frustum culling.  false if query has been aborted</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbBounds(MagicPhysX.PxBVH@)">
            <summary>Returns the number of bounds in the BVH.  You can use [`getBounds`]() to retrieve the bounds.  These are the user-defined bounds passed to the BVH builder, not the internal bounds around each BVH node.  Number of bounds in the BVH.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetBounds(MagicPhysX.PxBVH@)">
            <summary>Retrieve the read-only bounds in the BVH.  These are the user-defined bounds passed to the BVH builder, not the internal bounds around each BVH node.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetBoundsForModificationMut(MagicPhysX.PxBVH@)">
            <summary>Retrieve the bounds in the BVH.  These bounds can be modified. Call refit() after modifications are done.  These are the user-defined bounds passed to the BVH builder, not the internal bounds around each BVH node.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.RefitMut(MagicPhysX.PxBVH@)">
            <summary>Refit the BVH.  This function \"refits\" the tree, i.e. takes the new (leaf) bounding boxes into account and recomputes all the BVH bounds accordingly. This is an O(n) operation with n = number of bounds in the BVH.  This works best with minor bounds modifications, i.e. when the bounds remain close to their initial values. With large modifications the tree quality degrades more and more, and subsequent query performance suffers. It might be a better strategy to create a brand new BVH if bounds change drastically.  This function refits the whole tree after an arbitrary number of bounds have potentially been modified by users (via getBoundsForModification()). If you only have a small number of bounds to update, it might be more efficient to use setBounds() and partialRefit() instead.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.UpdateBoundsMut(MagicPhysX.PxBVH@,System.UInt32,MagicPhysX.PxBounds3*)">
            <summary>Update single bounds.  This is an alternative to getBoundsForModification() / refit(). If you only have a small set of bounds to update, it can be inefficient to call the refit() function, because it refits the whole BVH.  Instead, one can update individual bounds with this updateBounds() function. It sets the new bounds and marks the corresponding BVH nodes for partial refit. Once all the individual bounds have been updated, call partialRefit() to only refit the subset of marked nodes.  true if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PartialRefitMut(MagicPhysX.PxBVH@)">
            <summary>Refits subset of marked nodes.  This is an alternative to the refit() function, to be called after updateBounds() calls. See updateBounds() for details.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Traverse(MagicPhysX.PxBVH@,MagicPhysX.PxBVHTraversalCallback*)">
            <summary>Generic BVH traversal function.  This can be used to implement custom BVH traversal functions if provided ones are not enough. In particular this can be used to visualize the tree's bounds.  false if query has been aborted</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxCapsuleGeometry@)">
            <summary>Returns true if the geometry is valid.  True if the current settings are valid.  A valid capsule has radius &gt; 0, halfHeight &gt;= 0. It is illegal to call PxRigidActor::createShape and PxPhysics::createShape with a capsule that has zero radius or height.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbVertices(MagicPhysX.PxConvexMesh@)">
            <summary>Returns the number of vertices.  Number of vertices.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetVertices(MagicPhysX.PxConvexMesh@)">
            <summary>Returns the vertices.  Array of vertices.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetIndexBuffer(MagicPhysX.PxConvexMesh@)">
            <summary>Returns the index buffer.  Index buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbPolygons(MagicPhysX.PxConvexMesh@)">
            <summary>Returns the number of polygons.  Number of polygons.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetPolygonData(MagicPhysX.PxConvexMesh@,System.UInt32,MagicPhysX.PxHullPolygon*)">
            <summary>Returns the polygon data.  True if success.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxConvexMesh@)">
            <summary>Decrements the reference count of a convex mesh and releases it if the new reference count is zero.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetMassInformation(MagicPhysX.PxConvexMesh@,System.Single*,MagicPhysX.PxMat33*,MagicPhysX.PxVec3*)">
            <summary>Returns the mass properties of the mesh assuming unit density.  The following relationship holds between mass and volume:  mass = volume * density  The mass of a unit density mesh is equal to its volume, so this function returns the volume of the mesh.  Similarly, to obtain the localInertia of an identically shaped object with a uniform density of d, simply multiply the localInertia of the unit density mesh by d.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetLocalBounds(MagicPhysX.PxConvexMesh@)">
            <summary>Returns the local-space (vertex space) AABB from the convex mesh.  local-space bounds</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSDF(MagicPhysX.PxConvexMesh@)">
            <summary>Returns the local-space Signed Distance Field for this mesh if it has one.  local-space SDF.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsGpuCompatible(MagicPhysX.PxConvexMesh@)">
            <summary>This method decides whether a convex mesh is gpu compatible. If the total number of vertices are more than 64 or any number of vertices in a polygon is more than 32, or convex hull data was not cooked with GPU data enabled during cooking or was loaded from a serialized collection, the convex hull is incompatible with GPU collision detection. Otherwise it is compatible.  True if the convex hull is gpu compatible</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GeometryNew(MagicPhysX.PxConvexMesh@,MagicPhysX.PxMeshScale*,MagicPhysX.PxConvexMeshGeometryFlags)">
            <summary>Constructor. By default creates an empty object with a NULL mesh and identity scale.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsIdentity(MagicPhysX.PxMeshScale@)">
            <summary>Returns true if the scaling is an identity transformation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetInverse(MagicPhysX.PxMeshScale@)">
            <summary>Returns the inverse of this scaling transformation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ToMat33(MagicPhysX.PxMeshScale@)">
            <summary>Converts this transformation to a 3x3 matrix representation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.HasNegativeDeterminant(MagicPhysX.PxMeshScale@)">
            <summary>Returns true if combination of negative scale components will cause the triangle normal to flip. The SDK will flip the normals internally.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxConvexMeshGeometry@)">
            <summary>Returns true if the geometry is valid.  True if the current settings are valid for shape creation.  A valid convex mesh has a positive scale value in each direction (scale.x &gt; 0, scale.y &gt; 0, scale.z &gt; 0). It is illegal to call PxRigidActor::createShape and PxPhysics::createShape with a convex that has zero extent in any direction.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxFindFaceIndex(MagicPhysX.PxConvexMeshGeometry@,MagicPhysX.PxTransform*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>Computes closest polygon of the convex hull geometry for a given impact point and impact direction. When doing sweeps against a scene, one might want to delay the rather expensive computation of the hit face index for convexes until it is clear the information is really needed and then use this method to get the corresponding face index.  Closest face index of the convex geometry.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxSphereGeometry@)">
            <summary>Returns true if the geometry is valid.  True if the current settings are valid  A valid sphere has radius &gt; 0. It is illegal to call PxRigidActor::createShape and PxPhysics::createShape with a sphere that has zero radius.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxPlaneGeometry@)">
            <summary>Returns true if the geometry is valid.  True if the current settings are valid</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GeometryNew(MagicPhysX.PxTriangleMesh@,MagicPhysX.PxMeshScale*,MagicPhysX.PxMeshGeometryFlags)">
            <summary>Constructor. By default creates an empty object with a NULL mesh and identity scale.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbVertices(MagicPhysX.PxTriangleMesh@)">
            <summary>Returns the number of vertices.  number of vertices</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetVertices(MagicPhysX.PxTriangleMesh@)">
            <summary>Returns the vertices.  array of vertices</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetVerticesForModificationMut(MagicPhysX.PxTriangleMesh@)">
            <summary>Returns all mesh vertices for modification.  This function will return the vertices of the mesh so that their positions can be changed in place. After modifying the vertices you must call refitBVH for the refitting to actually take place. This function maintains the old mesh topology (triangle indices).  inplace vertex coordinates for each existing mesh vertex.  It is recommended to use this feature for scene queries only.  Size of array returned is equal to the number returned by getNbVertices().  This function operates on cooked vertex indices.  This means the index mapping and vertex count can be different from what was provided as an input to the cooking routine.  To achieve unchanged 1-to-1 index mapping with orignal mesh data (before cooking) please use the following cooking flags:  eWELD_VERTICES = 0, eDISABLE_CLEAN_MESH = 1.  It is also recommended to make sure that a call to validateTriangleMesh returns true if mesh cleaning is disabled.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.RefitBVHMut(MagicPhysX.PxTriangleMesh@)">
            <summary>Refits BVH for mesh vertices.  This function will refit the mesh BVH to correctly enclose the new positions updated by getVerticesForModification. Mesh BVH will not be reoptimized by this function so significantly different new positions will cause significantly reduced performance.  New bounds for the entire mesh.  For PxMeshMidPhase::eBVH34 trees the refit operation is only available on non-quantized trees (see PxBVH34MidphaseDesc::quantized)  PhysX does not keep a mapping from the mesh to mesh shapes that reference it.  Call PxShape::setGeometry on each shape which references the mesh, to ensure that internal data structures are updated to reflect the new geometry.  PxShape::setGeometry does not guarantee correct/continuous behavior when objects are resting on top of old or new geometry.  It is also recommended to make sure that a call to validateTriangleMesh returns true if mesh cleaning is disabled.  Active edges information will be lost during refit, the rigid body mesh contact generation might not perform as expected.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbTriangles(MagicPhysX.PxTriangleMesh@)">
            <summary>Returns the number of triangles.  number of triangles</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetTriangles(MagicPhysX.PxTriangleMesh@)">
            <summary>Returns the triangle indices.  The indices can be 16 or 32bit depending on the number of triangles in the mesh. Call getTriangleMeshFlags() to know if the indices are 16 or 32 bits.  The number of indices is the number of triangles * 3.  array of triangles</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetTriangleMeshFlags(MagicPhysX.PxTriangleMesh@)">
            <summary>Reads the PxTriangleMesh flags.  See the list of flags [`PxTriangleMeshFlag`]  The values of the PxTriangleMesh flags.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetTrianglesRemap(MagicPhysX.PxTriangleMesh@)">
            <summary>Returns the triangle remapping table.  The triangles are internally sorted according to various criteria. Hence the internal triangle order does not always match the original (user-defined) order. The remapping table helps finding the old indices knowing the new ones:  remapTable[ internalTriangleIndex ] = originalTriangleIndex  the remapping table (or NULL if 'PxCookingParams::suppressTriangleMeshRemapTable' has been used)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxTriangleMesh@)">
            <summary>Decrements the reference count of a triangle mesh and releases it if the new reference count is zero.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetTriangleMaterialIndex(MagicPhysX.PxTriangleMesh@,System.UInt32)">
            <summary>Returns material table index of given triangle  This function takes a post cooking triangle index.  Material table index, or 0xffff if no per-triangle materials are used</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetLocalBounds(MagicPhysX.PxTriangleMesh@)">
            <summary>Returns the local-space (vertex space) AABB from the triangle mesh.  local-space bounds</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSDF(MagicPhysX.PxTriangleMesh@)">
            <summary>Returns the local-space Signed Distance Field for this mesh if it has one.  local-space SDF.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSDFDimensions(MagicPhysX.PxTriangleMesh@,System.UInt32*,System.UInt32*,System.UInt32*)">
            <summary>Returns the resolution of the local-space dense SDF.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetPreferSDFProjectionMut(MagicPhysX.PxTriangleMesh@,System.Boolean)">
            <summary>Sets whether this mesh should be preferred for SDF projection.  By default, meshes are flagged as preferring projection and the decisions on which mesh to project is based on the triangle and vertex count. The model with the fewer triangles is projected onto the SDF of the more detailed mesh. If one of the meshes is set to prefer SDF projection (default) and the other is set to not prefer SDF projection, model flagged as preferring SDF projection will be projected onto the model flagged as not preferring, regardless of the detail of the respective meshes. Where both models are flagged as preferring no projection, the less detailed model will be projected as before.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetPreferSDFProjection(MagicPhysX.PxTriangleMesh@)">
            <summary>Returns whether this mesh prefers SDF projection.  whether this mesh prefers SDF projection.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetMassInformation(MagicPhysX.PxTriangleMesh@,System.Single*,MagicPhysX.PxMat33*,MagicPhysX.PxVec3*)">
            <summary>Returns the mass properties of the mesh assuming unit density.  The following relationship holds between mass and volume:  mass = volume * density  The mass of a unit density mesh is equal to its volume, so this function returns the volume of the mesh.  Similarly, to obtain the localInertia of an identically shaped object with a uniform density of d, simply multiply the localInertia of the unit density mesh by d.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxTriangleMeshGeometry@)">
            <summary>Returns true if the geometry is valid.  True if the current settings are valid for shape creation.  A valid triangle mesh has a positive scale value in each direction (scale.scale.x &gt; 0, scale.scale.y &gt; 0, scale.scale.z &gt; 0). It is illegal to call PxRigidActor::createShape and PxPhysics::createShape with a triangle mesh that has zero extents in any direction.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.MeshQueryGetTriangle(MagicPhysX.PxTriangleMeshGeometry@,MagicPhysX.PxTransform*,System.UInt32,MagicPhysX.PxTriangle*,System.UInt32*,System.UInt32*)">
            <summary>Retrieves triangle data from a triangle ID.  This function can be used together with [`findOverlapTriangleMesh`]() to retrieve triangle properties.  This function will flip the triangle normal whenever triGeom.scale.hasNegativeDeterminant() is true.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GeometryNew(MagicPhysX.PxHeightField@,MagicPhysX.PxMeshGeometryFlags,System.Single,System.Single,System.Single)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxHeightField@)">
            <summary>Decrements the reference count of a height field and releases it if the new reference count is zero.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SaveCells(MagicPhysX.PxHeightField@,System.Void*,System.UInt32)">
            <summary>Writes out the sample data array.  The user provides destBufferSize bytes storage at destBuffer. The data is formatted and arranged as PxHeightFieldDesc.samples.  The number of bytes written.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ModifySamplesMut(MagicPhysX.PxHeightField@,System.Int32,System.Int32,MagicPhysX.PxHeightFieldDesc*,System.Boolean)">
            <summary>Replaces a rectangular subfield in the sample data array.  The user provides the description of a rectangular subfield in subfieldDesc. The data is formatted and arranged as PxHeightFieldDesc.samples.  True on success, false on failure. Failure can occur due to format mismatch.  Modified samples are constrained to the same height quantization range as the original heightfield. Source samples that are out of range of target heightfield will be clipped with no error. PhysX does not keep a mapping from the heightfield to heightfield shapes that reference it. Call PxShape::setGeometry on each shape which references the height field, to ensure that internal data structures are updated to reflect the new geometry. Please note that PxShape::setGeometry does not guarantee correct/continuous behavior when objects are resting on top of old or new geometry.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbRows(MagicPhysX.PxHeightField@)">
            <summary>Retrieves the number of sample rows in the samples array.  The number of sample rows in the samples array.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbColumns(MagicPhysX.PxHeightField@)">
            <summary>Retrieves the number of sample columns in the samples array.  The number of sample columns in the samples array.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetFormat(MagicPhysX.PxHeightField@)">
            <summary>Retrieves the format of the sample data.  The format of the sample data.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSampleStride(MagicPhysX.PxHeightField@)">
            <summary>Retrieves the offset in bytes between consecutive samples in the array.  The offset in bytes between consecutive samples in the array.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetConvexEdgeThreshold(MagicPhysX.PxHeightField@)">
            <summary>Retrieves the convex edge threshold.  The convex edge threshold.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetFlags(MagicPhysX.PxHeightField@)">
            <summary>Retrieves the flags bits, combined from values of the enum ::PxHeightFieldFlag.  The flags bits, combined from values of the enum ::PxHeightFieldFlag.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetHeight(MagicPhysX.PxHeightField@,System.Single,System.Single)">
            <summary>Retrieves the height at the given coordinates in grid space.  The height at the given coordinates or 0 if the coordinates are out of range.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetTriangleMaterialIndex(MagicPhysX.PxHeightField@,System.UInt32)">
            <summary>Returns material table index of given triangle  This function takes a post cooking triangle index.  Material table index, or 0xffff if no per-triangle materials are used</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetTriangleNormal(MagicPhysX.PxHeightField@,System.UInt32)">
            <summary>Returns a triangle face normal for a given triangle index  This function takes a post cooking triangle index.  Triangle normal for a given triangle index</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSample(MagicPhysX.PxHeightField@,System.UInt32,System.UInt32)">
            <summary>Returns heightfield sample of given row and column  Heightfield sample</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetTimestamp(MagicPhysX.PxHeightField@)">
            <summary>Returns the number of times the heightfield data has been modified  This method returns the number of times modifySamples has been called on this heightfield, so that code that has retained state that depends on the heightfield can efficiently determine whether it has been modified.  the number of times the heightfield sample data has been modified.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxHeightFieldGeometry@)">
            <summary>Returns true if the geometry is valid.  True if the current settings are valid  A valid height field has a positive scale value in each direction (heightScale &gt; 0, rowScale &gt; 0, columnScale &gt; 0). It is illegal to call PxRigidActor::createShape and PxPhysics::createShape with a height field that has zero extents in any direction.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.MeshQueryGetTriangle1(MagicPhysX.PxHeightFieldGeometry@,MagicPhysX.PxTransform*,System.UInt32,MagicPhysX.PxTriangle*,System.UInt32*,System.UInt32*)">
            <summary>Retrieves triangle data from a triangle ID.  This function can be used together with [`findOverlapHeightField`]() to retrieve triangle properties.  This function will flip the triangle normal whenever triGeom.scale.hasNegativeDeterminant() is true.  TriangleIndex is an index used in internal format, which does have an index out of the bounds in last row. To traverse all tri indices in the HF, the following code can be applied: for (PxU32 row = 0; row &lt; (nbRows - 1); row++) { for (PxU32 col = 0; col &lt; (nbCols - 1); col++) { for (PxU32 k = 0; k &lt; 2; k++) { const PxU32 triIndex = 2 * (row*nbCols + col) + k; .... } } }</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxParticleSystemGeometry@)">
            <summary>Returns true if the geometry is valid.  True if the current settings are valid for shape creation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxHairSystemGeometry@)">
            <summary>Returns true if the geometry is valid.  True if the current settings are valid for shape creation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GeometryNew(MagicPhysX.PxTetrahedronMesh@)">
            <summary>Constructor. By default creates an empty object with a NULL mesh and identity scale.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbVertices(MagicPhysX.PxTetrahedronMesh@)">
            <summary>Returns the number of vertices.  number of vertices</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetVertices(MagicPhysX.PxTetrahedronMesh@)">
            <summary>Returns the vertices  array of vertices</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbTetrahedrons(MagicPhysX.PxTetrahedronMesh@)">
            <summary>Returns the number of tetrahedrons.  number of tetrahedrons</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetTetrahedrons(MagicPhysX.PxTetrahedronMesh@)">
            <summary>Returns the tetrahedron indices.  The indices can be 16 or 32bit depending on the number of tetrahedrons in the mesh. Call getTetrahedronMeshFlags() to know if the indices are 16 or 32 bits.  The number of indices is the number of tetrahedrons * 4.  array of tetrahedrons</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetTetrahedronMeshFlags(MagicPhysX.PxTetrahedronMesh@)">
            <summary>Reads the PxTetrahedronMesh flags.  See the list of flags [`PxTetrahedronMeshFlags`]  The values of the PxTetrahedronMesh flags.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetTetrahedraRemap(MagicPhysX.PxTetrahedronMesh@)">
            <summary>Returns the tetrahedra remapping table.  The tetrahedra are internally sorted according to various criteria. Hence the internal tetrahedron order does not always match the original (user-defined) order. The remapping table helps finding the old indices knowing the new ones:  remapTable[ internalTetrahedronIndex ] = originalTetrahedronIndex  the remapping table (or NULL if 'PxCookingParams::suppressTriangleMeshRemapTable' has been used)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetLocalBounds(MagicPhysX.PxTetrahedronMesh@)">
            <summary>Returns the local-space (vertex space) AABB from the tetrahedron mesh.  local-space bounds</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxTetrahedronMesh@)">
            <summary>Decrements the reference count of a tetrahedron mesh and releases it if the new reference count is zero.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ExtFindTetrahedronContainingPoint(MagicPhysX.PxTetrahedronMesh@,MagicPhysX.PxVec3*,MagicPhysX.PxVec4*,System.Single)">
            <summary>Returns the index of the tetrahedron that contains a point  The index of the tetrahedon containing the point, -1 if not tetrahedron contains the opoint</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ExtFindTetrahedronClosestToPoint(MagicPhysX.PxTetrahedronMesh@,MagicPhysX.PxVec3*,MagicPhysX.PxVec4*)">
            <summary>Returns the index of the tetrahedron closest to a point  The index of the tetrahedon closest to the point</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxTetrahedronMeshGeometry@)">
            <summary>Returns true if the geometry is valid.  True if the current settings are valid for shape creation.  A valid tetrahedron mesh has a positive scale value in each direction (scale.scale.x &gt; 0, scale.scale.y &gt; 0, scale.scale.z &gt; 0). It is illegal to call PxRigidActor::createShape and PxPhysics::createShape with a tetrahedron mesh that has zero extents in any direction.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.HadInitialOverlap(MagicPhysX.PxLocationHit@)">
            <summary>For raycast hits: true for shapes overlapping with raycast origin.  For sweep hits: true for shapes overlapping at zero sweep distance.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetCustomType(MagicPhysX.PxCustomGeometryCallbacks@)">
            <summary>Return custom type. The type purpose is for user to differentiate custom geometries. Not used by PhysX.  Unique ID of a custom geometry type.  User should use DECLARE_CUSTOM_GEOMETRY_TYPE and IMPLEMENT_CUSTOM_GEOMETRY_TYPE intead of overwriting this function.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetLocalBounds(MagicPhysX.PxCustomGeometryCallbacks@,MagicPhysX.PxGeometry*)">
            <summary>Return local bounds.  Bounding box in the geometry local space.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Raycast(MagicPhysX.PxCustomGeometryCallbacks@,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,System.Single,MagicPhysX.PxHitFlags,System.UInt32,MagicPhysX.PxGeomRaycastHit*,System.UInt32,MagicPhysX.PxQueryThreadContext*)">
            <summary>Raycast. Cast a ray against the geometry in given pose.  Number of hits.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Overlap(MagicPhysX.PxCustomGeometryCallbacks@,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxQueryThreadContext*)">
            <summary>Overlap. Test if geometries overlap.  True if there is overlap. False otherwise.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Sweep(MagicPhysX.PxCustomGeometryCallbacks@,MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxGeomSweepHit*,MagicPhysX.PxHitFlags,System.Single,MagicPhysX.PxQueryThreadContext*)">
            <summary>Sweep. Sweep one geometry against the other.  True if there is hit. False otherwise.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ComputeMassProperties(MagicPhysX.PxCustomGeometryCallbacks@,MagicPhysX.PxGeometry*,MagicPhysX.PxMassProperties*)">
            <summary>Compute custom geometry mass properties. For geometries usable with dynamic rigidbodies.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.UsePersistentContactManifold(MagicPhysX.PxCustomGeometryCallbacks@,MagicPhysX.PxGeometry*,System.Single*)">
            <summary>Compatible with PhysX's PCM feature. Allows to optimize contact generation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CustomGeometryNew1(MagicPhysX.PxCustomGeometryCallbacks@)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxCustomGeometry@)">
            <summary>Returns true if the geometry is valid.  True if the current settings are valid for shape creation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetCustomType(MagicPhysX.PxCustomGeometry@)">
            <summary>Returns the custom type of the custom geometry.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetToDefaultMut(MagicPhysX.PxHeightFieldDesc@)">
            <summary>(re)sets the structure to the default.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxHeightFieldDesc@)">
            <summary>Returns true if the descriptor is valid.  True if the current settings are valid.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxCookHeightField(MagicPhysX.PxHeightFieldDesc@,MagicPhysX.PxOutputStream*)">
            <summary>Cooks a heightfield. The results are written to the stream.  To create a heightfield object there is an option to precompute some of calculations done while loading the heightfield data.  cookHeightField() allows a heightfield description to be cooked into a binary stream suitable for loading and performing collision detection at runtime.  true on success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxCreateHeightField(MagicPhysX.PxHeightFieldDesc@,MagicPhysX.PxInsertionCallback*)">
            <summary>Cooks and creates a heightfield mesh and inserts it into PxPhysics.  PxHeightField pointer on success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetToDefaultMut(MagicPhysX.PxSimpleTriangleMesh@)">
            <summary>(re)sets the structure to the default.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxSimpleTriangleMesh@)">
            <summary>returns true if the current settings are valid</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Delete(MagicPhysX.PxTriangle@)">
            <summary>Destructor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Normal(MagicPhysX.PxTriangle@,MagicPhysX.PxVec3*)">
            <summary>Compute the normal of the Triangle.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.DenormalizedNormal(MagicPhysX.PxTriangle@,MagicPhysX.PxVec3*)">
            <summary>Compute the unnormalized normal of the triangle.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Area(MagicPhysX.PxTriangle@)">
            <summary>Compute the area of the triangle.  Area of the triangle.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PointFromUV(MagicPhysX.PxTriangle@,System.Single,System.Single)">
            <summary>Computes a point on the triangle from u and v barycentric coordinates.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Delete(MagicPhysX.PxTetrahedron@)">
            <summary>Destructor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxSoftBodyAuxData@)">
            <summary>Decrements the reference count of a tetrahedron mesh and releases it if the new reference count is zero.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetCollisionMesh(MagicPhysX.PxSoftBodyMesh@)">
            <summary>Const accecssor to the softbody's collision mesh.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetCollisionMeshMut(MagicPhysX.PxSoftBodyMesh@)">
            <summary>Accecssor to the softbody's collision mesh.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSimulationMesh(MagicPhysX.PxSoftBodyMesh@)">
            <summary>Const accessor to the softbody's simulation mesh.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSimulationMeshMut(MagicPhysX.PxSoftBodyMesh@)">
            <summary>Accecssor to the softbody's simulation mesh.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSoftBodyAuxData(MagicPhysX.PxSoftBodyMesh@)">
            <summary>Const accessor to the softbodies simulation state.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSoftBodyAuxDataMut(MagicPhysX.PxSoftBodyMesh@)">
            <summary>Accessor to the softbody's auxilary data like mass and rest pose information</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxSoftBodyMesh@)">
            <summary>Decrements the reference count of a tetrahedron mesh and releases it if the new reference count is zero.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxActor@)">
            <summary>Deletes the actor.  Do not keep a reference to the deleted instance.  If the actor belongs to a [`PxAggregate`] object, it is automatically removed from the aggregate.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetType(MagicPhysX.PxActor@)">
            <summary>Retrieves the type of actor.  The actor type of the actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetScene(MagicPhysX.PxActor@)">
            <summary>Retrieves the scene which this actor belongs to.  Owner Scene. NULL if not part of a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetNameMut(MagicPhysX.PxActor@,System.Byte*)">
            <summary>Sets a name string for the object that can be retrieved with getName().  This is for debugging and is not used by the SDK. The string is not copied by the SDK, only the pointer is stored.  Default: NULL</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetName(MagicPhysX.PxActor@)">
            <summary>Retrieves the name string set with setName().  Name string associated with object.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetWorldBounds(MagicPhysX.PxActor@,System.Single)">
            <summary>Retrieves the axis aligned bounding box enclosing the actor.  It is not allowed to use this method while the simulation is running (except during PxScene::collide(), in PxContactModifyCallback or in contact report callbacks).  The actor's bounding box.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetActorFlagMut(MagicPhysX.PxActor@,MagicPhysX.PxActorFlag,System.Boolean)">
            <summary>Raises or clears a particular actor flag.  See the list of flags [`PxActorFlag`]  Sleeping: Does NOT wake the actor up automatically.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetActorFlagsMut(MagicPhysX.PxActor@,MagicPhysX.PxActorFlags)">
            <summary>Sets the actor flags.  See the list of flags [`PxActorFlag`]</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetActorFlags(MagicPhysX.PxActor@)">
            <summary>Reads the PxActor flags.  See the list of flags [`PxActorFlag`]  The values of the PxActor flags.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetDominanceGroupMut(MagicPhysX.PxActor@,System.Byte)">
            <summary>Assigns dynamic actors a dominance group identifier.  PxDominanceGroup is a 5 bit group identifier (legal range from 0 to 31).  The PxScene::setDominanceGroupPair() lets you set certain behaviors for pairs of dominance groups. By default every dynamic actor is created in group 0.  Default: 0  Sleeping: Changing the dominance group does NOT wake the actor up automatically.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetDominanceGroup(MagicPhysX.PxActor@)">
            <summary>Retrieves the value set with setDominanceGroup().  The dominance group of this actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetOwnerClientMut(MagicPhysX.PxActor@,System.Byte)">
            <summary>Sets the owner client of an actor.  This cannot be done once the actor has been placed into a scene.  Default: PX_DEFAULT_CLIENT</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetOwnerClient(MagicPhysX.PxActor@)">
            <summary>Returns the owner client that was specified at creation time.  This value cannot be changed once the object is placed into the scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetAggregate(MagicPhysX.PxActor@)">
            <summary>Retrieves the aggregate the actor might be a part of.  The aggregate the actor is a part of, or NULL if the actor does not belong to an aggregate.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxGetGroup(MagicPhysX.PxActor@)">
            <summary>Retrieves the value set with PxSetGroup()  Collision group is an integer between 0 and 31.  The collision group this actor belongs to</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxSetGroup(MagicPhysX.PxActor@,System.UInt16)">
            <summary>Sets which collision group this actor is part of  Collision group is an integer between 0 and 31.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxGetGroupsMask(MagicPhysX.PxActor@)">
            <summary>Gets 64-bit mask used for collision filtering. See comments for PxGroupsMask  The group mask for the actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxSetGroupsMask(MagicPhysX.PxActor@,MagicPhysX.PxGroupsMask*)">
            <summary>Sets 64-bit mask used for collision filtering. See comments for PxGroupsMask</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxAggregate@)">
            <summary>Deletes the aggregate object.  Deleting the PxAggregate object does not delete the aggregated actors. If the PxAggregate object belongs to a scene, the aggregated actors are automatically re-inserted in that scene. If you intend to delete both the PxAggregate and its actors, it is best to release the actors first, then release the PxAggregate when it is empty.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AddActorMut(MagicPhysX.PxAggregate@,MagicPhysX.PxActor*,MagicPhysX.PxBVH*)">
            <summary>Adds an actor to the aggregate object.  A warning is output if the total number of actors is reached, or if the incoming actor already belongs to an aggregate.  If the aggregate belongs to a scene, adding an actor to the aggregate also adds the actor to that scene.  If the actor already belongs to a scene, a warning is output and the call is ignored. You need to remove the actor from the scene first, before adding it to the aggregate.  When a BVH is provided the actor shapes are grouped together. The scene query pruning structure inside PhysX SDK will store/update one bound per actor. The scene queries against such an actor will query actor bounds and then make a local space query against the provided BVH, which is in actor's local space.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.RemoveActorMut(MagicPhysX.PxAggregate@,MagicPhysX.PxActor*)">
            <summary>Removes an actor from the aggregate object.  A warning is output if the incoming actor does not belong to the aggregate. Otherwise the actor is removed from the aggregate. If the aggregate belongs to a scene, the actor is reinserted in that scene. If you intend to delete the actor, it is best to call [`PxActor::release`]() directly. That way the actor will be automatically removed from its aggregate (if any) and not reinserted in a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AddArticulationMut(MagicPhysX.PxAggregate@,MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Adds an articulation to the aggregate object.  A warning is output if the total number of actors is reached (every articulation link counts as an actor), or if the incoming articulation already belongs to an aggregate.  If the aggregate belongs to a scene, adding an articulation to the aggregate also adds the articulation to that scene.  If the articulation already belongs to a scene, a warning is output and the call is ignored. You need to remove the articulation from the scene first, before adding it to the aggregate.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.RemoveArticulationMut(MagicPhysX.PxAggregate@,MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Removes an articulation from the aggregate object.  A warning is output if the incoming articulation does not belong to the aggregate. Otherwise the articulation is removed from the aggregate. If the aggregate belongs to a scene, the articulation is reinserted in that scene. If you intend to delete the articulation, it is best to call [`PxArticulationReducedCoordinate::release`]() directly. That way the articulation will be automatically removed from its aggregate (if any) and not reinserted in a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbActors(MagicPhysX.PxAggregate@)">
            <summary>Returns the number of actors contained in the aggregate.  You can use [`getActors`]() to retrieve the actor pointers.  Number of actors contained in the aggregate.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetMaxNbShapes(MagicPhysX.PxAggregate@)">
            <summary>Retrieves max amount of shapes that can be contained in the aggregate.  Max shape size.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetActors(MagicPhysX.PxAggregate@,MagicPhysX.PxActor**,System.UInt32,System.UInt32)">
            <summary>Retrieve all actors contained in the aggregate.  You can retrieve the number of actor pointers by calling [`getNbActors`]()  Number of actor pointers written to the buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSceneMut(MagicPhysX.PxAggregate@)">
            <summary>Retrieves the scene which this aggregate belongs to.  Owner Scene. NULL if not part of a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSelfCollision(MagicPhysX.PxAggregate@)">
            <summary>Retrieves aggregate's self-collision flag.  self-collision flag</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.VisualizeJointFramesMut(MagicPhysX.PxConstraintVisualizer@,MagicPhysX.PxTransform*,MagicPhysX.PxTransform*)">
            <summary>Visualize joint frames</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.VisualizeLinearLimitMut(MagicPhysX.PxConstraintVisualizer@,MagicPhysX.PxTransform*,MagicPhysX.PxTransform*,System.Single,System.Boolean)">
            <summary>Visualize joint linear limit</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.VisualizeAngularLimitMut(MagicPhysX.PxConstraintVisualizer@,MagicPhysX.PxTransform*,System.Single,System.Single,System.Boolean)">
            <summary>Visualize joint angular limit</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.VisualizeLimitConeMut(MagicPhysX.PxConstraintVisualizer@,MagicPhysX.PxTransform*,System.Single,System.Single,System.Boolean)">
            <summary>Visualize limit cone</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.VisualizeDoubleConeMut(MagicPhysX.PxConstraintVisualizer@,MagicPhysX.PxTransform*,System.Single,System.Boolean)">
            <summary>Visualize joint double cone</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.VisualizeLineMut(MagicPhysX.PxConstraintVisualizer@,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,System.UInt32)">
            <summary>Visualize line</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PrepareDataMut(MagicPhysX.PxConstraintConnector@)">
            <summary>Pre-simulation data preparation when the constraint is marked dirty, this function is called at the start of the simulation step for the SDK to copy the constraint data block.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.OnConstraintReleaseMut(MagicPhysX.PxConstraintConnector@)">
            <summary>Constraint release callback  When the SDK deletes a PxConstraint object this function is called by the SDK. In general custom constraints should not be deleted directly by applications: rather, the constraint should respond to a release() request by calling PxConstraint::release(), then wait for this call to release its own resources.  This function is also called when a PxConstraint object is deleted on cleanup due to destruction of the PxPhysics object.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.OnComShiftMut(MagicPhysX.PxConstraintConnector@,System.UInt32)">
            <summary>Center-of-mass shift callback  This function is called by the SDK when the CoM of one of the actors is moved. Since the API specifies constraint positions relative to actors, and the constraint shader functions are supplied with coordinates relative to bodies, some synchronization is usually required when the application moves an object's center of mass.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.OnOriginShiftMut(MagicPhysX.PxConstraintConnector@,MagicPhysX.PxVec3*)">
            <summary>Origin shift callback  This function is called by the SDK when the scene origin gets shifted and allows to adjust custom data which contains world space transforms.  If the adjustments affect constraint shader data, it is necessary to call PxConstraint::markDirty() to make sure that the data gets synced at the beginning of the next simulation step.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSerializableMut(MagicPhysX.PxConstraintConnector@)">
            <summary>Obtain a reference to a PxBase interface if the constraint has one.  If the constraint does not implement the PxBase interface, it should return NULL.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetConstantBlock(MagicPhysX.PxConstraintConnector@)">
            <summary>Obtain the pointer to the constraint's constant data</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ConnectToConstraintMut(MagicPhysX.PxConstraintConnector@,MagicPhysX.PxConstraint*)">
            <summary>Let the connector know it has been connected to a constraint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Delete(MagicPhysX.PxConstraintConnector@)">
            <summary>virtual destructor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReserveConstraintDataMut(MagicPhysX.PxConstraintAllocator@,System.UInt32)">
            <summary>Allocates constraint data. It is the application's responsibility to release this memory after PxSolveConstraints has completed.  The allocated memory. This address must be 16-byte aligned.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReserveFrictionDataMut(MagicPhysX.PxConstraintAllocator@,System.UInt32)">
            <summary>Allocates friction data. Friction data can be retained by the application for a given pair and provided as an input to PxSolverContactDesc to improve simulation stability. It is the application's responsibility to release this memory. If this memory is released, the application should ensure it does not pass pointers to this memory to PxSolverContactDesc.  The allocated memory. This address must be 4-byte aligned.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetRestLengthMut(MagicPhysX.PxArticulationAttachment@,System.Single)">
            <summary>Sets the spring rest length for the sub-tendon from the root to this leaf attachment.  Setting this on non-leaf attachments has no effect.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetRestLength(MagicPhysX.PxArticulationAttachment@)">
            <summary>Gets the spring rest length for the sub-tendon from the root to this leaf attachment.  The rest length.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetLimitParametersMut(MagicPhysX.PxArticulationAttachment@,MagicPhysX.PxArticulationTendonLimit*)">
            <summary>Sets the low and high limit on the length of the sub-tendon from the root to this leaf attachment.  Setting this on non-leaf attachments has no effect.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetLimitParameters(MagicPhysX.PxArticulationAttachment@)">
            <summary>Gets the low and high limit on the length of the sub-tendon from the root to this leaf attachment.  Struct with the low and high limit.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetRelativeOffsetMut(MagicPhysX.PxArticulationAttachment@,MagicPhysX.PxVec3*)">
            <summary>Sets the attachment's relative offset in the link actor frame.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetRelativeOffset(MagicPhysX.PxArticulationAttachment@)">
            <summary>Gets the attachment's relative offset in the link actor frame.  The relative offset in the link actor frame.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetCoefficientMut(MagicPhysX.PxArticulationAttachment@,System.Single)">
            <summary>Sets the attachment coefficient.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetCoefficient(MagicPhysX.PxArticulationAttachment@)">
            <summary>Gets the attachment coefficient.  The scale that the distance between this attachment and its parent is multiplied by when summing up the spatial tendon's length.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetLink(MagicPhysX.PxArticulationAttachment@)">
            <summary>Gets the articulation link.  The articulation link that this attachment is attached to.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetParent(MagicPhysX.PxArticulationAttachment@)">
            <summary>Gets the parent attachment.  The parent attachment.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsLeaf(MagicPhysX.PxArticulationAttachment@)">
            <summary>Indicates that this attachment is a leaf, and thus defines a sub-tendon from the root to this attachment.  True: This attachment is a leaf and has zero children; False: Not a leaf.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetTendon(MagicPhysX.PxArticulationAttachment@)">
            <summary>Gets the spatial tendon that the attachment is a part of.  The tendon.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxArticulationAttachment@)">
            <summary>Releases the attachment.  Releasing the attachment is not allowed while the articulation is in a scene. In order to release the attachment, remove and then re-add the articulation to the scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetConcreteTypeName(MagicPhysX.PxArticulationAttachment@)">
            <summary>Returns the string name of the dynamic type.  The string name.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetCoefficientMut(MagicPhysX.PxArticulationTendonJoint@,MagicPhysX.PxArticulationAxis,System.Single,System.Single)">
            <summary>Sets the tendon joint coefficient.  RecipCoefficient is commonly expected to be 1/coefficient, but it can be set to different values to tune behavior; for example, zero can be used to have a joint axis only participate in the length computation of the tendon, but not have any tendon force applied to it.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetCoefficient(MagicPhysX.PxArticulationTendonJoint@,MagicPhysX.PxArticulationAxis*,System.Single*,System.Single*)">
            <summary>Gets the tendon joint coefficient.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetLink(MagicPhysX.PxArticulationTendonJoint@)">
            <summary>Gets the articulation link.  The articulation link (and its incoming joint in particular) that this tendon joint is associated with.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetParent(MagicPhysX.PxArticulationTendonJoint@)">
            <summary>Gets the parent tendon joint.  The parent tendon joint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetTendon(MagicPhysX.PxArticulationTendonJoint@)">
            <summary>Gets the tendon that the joint is a part of.  The tendon.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxArticulationTendonJoint@)">
            <summary>Releases a tendon joint.  Releasing a tendon joint is not allowed while the articulation is in a scene. In order to release the joint, remove and then re-add the articulation to the scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetConcreteTypeName(MagicPhysX.PxArticulationTendonJoint@)">
            <summary>Returns the string name of the dynamic type.  The string name.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetStiffnessMut(MagicPhysX.PxArticulationTendon@,System.Single)">
            <summary>Sets the spring stiffness term acting on the tendon length.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetStiffness(MagicPhysX.PxArticulationTendon@)">
            <summary>Gets the spring stiffness of the tendon.  The spring stiffness.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetDampingMut(MagicPhysX.PxArticulationTendon@,System.Single)">
            <summary>Sets the damping term acting both on the tendon length and tendon-length limits.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetDamping(MagicPhysX.PxArticulationTendon@)">
            <summary>Gets the damping term acting both on the tendon length and tendon-length limits.  The damping term.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetLimitStiffnessMut(MagicPhysX.PxArticulationTendon@,System.Single)">
            <summary>Sets the limit stiffness term acting on the tendon's length limits.  For spatial tendons, this parameter applies to all its leaf attachments / sub-tendons.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetLimitStiffness(MagicPhysX.PxArticulationTendon@)">
            <summary>Gets the limit stiffness term acting on the tendon's length limits.  For spatial tendons, this parameter applies to all its leaf attachments / sub-tendons.  The limit stiffness term.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetOffsetMut(MagicPhysX.PxArticulationTendon@,System.Single,System.Boolean)">
            <summary>Sets the length offset term for the tendon.  An offset defines an amount to be added to the accumulated length computed for the tendon. It allows the application to actuate the tendon by shortening or lengthening it.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetOffset(MagicPhysX.PxArticulationTendon@)">
            <summary>Gets the length offset term for the tendon.  The offset term.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetArticulation(MagicPhysX.PxArticulationTendon@)">
            <summary>Gets the articulation that the tendon is a part of.  The articulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxArticulationTendon@)">
            <summary>Releases a tendon to remove it from the articulation and free its associated memory.  When an articulation is released, its attached tendons are automatically released.  Releasing a tendon is not allowed while the articulation is in a scene. In order to release the tendon, remove and then re-add the articulation to the scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CreateAttachmentMut(MagicPhysX.PxArticulationSpatialTendon@,MagicPhysX.PxArticulationAttachment*,System.Single,MagicPhysX.PxVec3,MagicPhysX.PxArticulationLink*)">
            <summary>Creates an articulation attachment and adds it to the list of children in the parent attachment.  Creating an attachment is not allowed while the articulation is in a scene. In order to add the attachment, remove and then re-add the articulation to the scene.  The newly-created attachment if creation was successful, otherwise a null pointer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetAttachments(MagicPhysX.PxArticulationSpatialTendon@,MagicPhysX.PxArticulationAttachment**,System.UInt32,System.UInt32)">
            <summary>Fills a user-provided buffer of attachment pointers with the set of attachments.  The number of attachments that were filled into the user buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbAttachments(MagicPhysX.PxArticulationSpatialTendon@)">
            <summary>Returns the number of attachments in the tendon.  The number of attachments.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetConcreteTypeName(MagicPhysX.PxArticulationSpatialTendon@)">
            <summary>Returns the string name of the dynamic type.  The string name.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CreateTendonJointMut(MagicPhysX.PxArticulationFixedTendon@,MagicPhysX.PxArticulationTendonJoint*,MagicPhysX.PxArticulationAxis,System.Single,System.Single,MagicPhysX.PxArticulationLink*)">
            <summary>Creates an articulation tendon joint and adds it to the list of children in the parent tendon joint.  Creating a tendon joint is not allowed while the articulation is in a scene. In order to add the joint, remove and then re-add the articulation to the scene.  The newly-created tendon joint if creation was successful, otherwise a null pointer.  - The axis motion must not be configured as PxArticulationMotion::eLOCKED. - The axis cannot be part of a fixed joint, i.e. joint configured as PxArticulationJointType::eFIX.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetTendonJoints(MagicPhysX.PxArticulationFixedTendon@,MagicPhysX.PxArticulationTendonJoint**,System.UInt32,System.UInt32)">
            <summary>Fills a user-provided buffer of tendon-joint pointers with the set of tendon joints.  The number of tendon joints filled into the user buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbTendonJoints(MagicPhysX.PxArticulationFixedTendon@)">
            <summary>Returns the number of tendon joints in the tendon.  The number of tendon joints.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetRestLengthMut(MagicPhysX.PxArticulationFixedTendon@,System.Single)">
            <summary>Sets the spring rest length of the tendon.  The accumulated \"length\" of a fixed tendon is a linear combination of the joint axis positions that the tendon is associated with, scaled by the respective tendon joints' coefficients. As such, when the joint positions of all joints are zero, the accumulated length of a fixed tendon is zero.  The spring of the tendon is not exerting any force on the articulation when the rest length is equal to the tendon's accumulated length plus the tendon offset.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetRestLength(MagicPhysX.PxArticulationFixedTendon@)">
            <summary>Gets the spring rest length of the tendon.  The spring rest length of the tendon.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetLimitParametersMut(MagicPhysX.PxArticulationFixedTendon@,MagicPhysX.PxArticulationTendonLimit*)">
            <summary>Sets the low and high limit on the length of the tendon.  The limits, together with the damping and limit stiffness parameters, act on the accumulated length of the tendon.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetLimitParameters(MagicPhysX.PxArticulationFixedTendon@)">
            <summary>Gets the low and high limit on the length of the tendon.  Struct with the low and high limit.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetConcreteTypeName(MagicPhysX.PxArticulationFixedTendon@)">
            <summary>Returns the string name of the dynamic type.  The string name.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxArticulationCache@)">
            <summary>Releases an articulation cache.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxArticulationSensor@)">
            <summary>Releases the sensor.  Releasing a sensor is not allowed while the articulation is in a scene. In order to release a sensor, remove and then re-add the articulation to the scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetForces(MagicPhysX.PxArticulationSensor@)">
            <summary>Returns the spatial force in the local frame of the sensor.  The spatial force.  This call is not allowed while the simulation is running except in a split simulation during [`PxScene::collide`]() and up to #PxScene::advance(), and in PxContactModifyCallback or in contact report callbacks.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetRelativePose(MagicPhysX.PxArticulationSensor@)">
            <summary>Returns the relative pose between this sensor and the body frame of the link that the sensor is attached to.  The link body frame is at the center of mass and aligned with the principal axes of inertia, see PxRigidBody::getCMassLocalPose.  The transform link body frame -&gt; sensor frame.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetRelativePoseMut(MagicPhysX.PxArticulationSensor@,MagicPhysX.PxTransform*)">
            <summary>Sets the relative pose between this sensor and the body frame of the link that the sensor is attached to.  The link body frame is at the center of mass and aligned with the principal axes of inertia, see PxRigidBody::getCMassLocalPose.  Setting the sensor relative pose is not allowed while the articulation is in a scene. In order to set the pose, remove and then re-add the articulation to the scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetLink(MagicPhysX.PxArticulationSensor@)">
            <summary>Returns the link that this sensor is attached to.  A pointer to the link.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetIndex(MagicPhysX.PxArticulationSensor@)">
            <summary>Returns the index of this sensor inside the articulation.  The return value is only valid for sensors attached to articulations that are in a scene.  The low-level index, or 0xFFFFFFFF if the articulation is not in a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetArticulation(MagicPhysX.PxArticulationSensor@)">
            <summary>Returns the articulation that this sensor is part of.  A pointer to the articulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetFlags(MagicPhysX.PxArticulationSensor@)">
            <summary>Returns the sensor's flags.  The current set of flags of the sensor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetFlagMut(MagicPhysX.PxArticulationSensor@,MagicPhysX.PxArticulationSensorFlag,System.Boolean)">
            <summary>Sets a flag of the sensor.  Setting the sensor flags is not allowed while the articulation is in a scene. In order to set the flags, remove and then re-add the articulation to the scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetConcreteTypeName(MagicPhysX.PxArticulationSensor@)">
            <summary>Returns the string name of the dynamic type.  The string name.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetScene(MagicPhysX.PxArticulationReducedCoordinate@)">
            <summary>Returns the scene which this articulation belongs to.  Owner Scene. NULL if not part of a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetSolverIterationCountsMut(MagicPhysX.PxArticulationReducedCoordinate@,System.UInt32,System.UInt32)">
            <summary>Sets the solver iteration counts for the articulation.  The solver iteration count determines how accurately contacts, drives, and limits are resolved. Setting a higher position iteration count may therefore help in scenarios where the articulation is subject to many constraints; for example, a manipulator articulation with drives and joint limits that is grasping objects, or several such articulations interacting through contacts. Other situations where higher position iterations may improve simulation fidelity are: large mass ratios within the articulation or between the articulation and an object in contact with it; or strong drives in the articulation being used to manipulate a light object.  If intersecting bodies are being depenetrated too violently, increase the number of velocity iterations. More velocity iterations will drive the relative exit velocity of the intersecting objects closer to the correct value given the restitution.  This call may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSolverIterationCounts(MagicPhysX.PxArticulationReducedCoordinate@,System.UInt32*,System.UInt32*)">
            <summary>Returns the solver iteration counts.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsSleeping(MagicPhysX.PxArticulationReducedCoordinate@)">
            <summary>Returns true if this articulation is sleeping.  When an actor does not move for a period of time, it is no longer simulated in order to save time. This state is called sleeping. However, because the object automatically wakes up when it is either touched by an awake object, or a sleep-affecting property is changed by the user, the entire sleep mechanism should be transparent to the user.  An articulation can only go to sleep if all links are ready for sleeping. An articulation is guaranteed to be awake if at least one of the following holds:  The wake counter is positive (see [`setWakeCounter`]()).  The linear or angular velocity of any link is non-zero.  A non-zero force or torque has been applied to the articulation or any of its links.  If an articulation is sleeping, the following state is guaranteed:  The wake counter is zero.  The linear and angular velocity of all links is zero.  There is no force update pending.  When an articulation gets inserted into a scene, it will be considered asleep if all the points above hold, else it will be treated as awake.  If an articulation is asleep after the call to [`PxScene::fetchResults`]() returns, it is guaranteed that the poses of the links were not changed. You can use this information to avoid updating the transforms of associated objects.  True if the articulation is sleeping.  This call may only be made on articulations that are in a scene, and may not be made during simulation, except in a split simulation in-between [`PxScene::fetchCollision`] and #PxScene::advance.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetSleepThresholdMut(MagicPhysX.PxArticulationReducedCoordinate@,System.Single)">
            <summary>Sets the mass-normalized energy threshold below which the articulation may go to sleep.  The articulation will sleep if the energy of each link is below this threshold.  This call may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSleepThreshold(MagicPhysX.PxArticulationReducedCoordinate@)">
            <summary>Returns the mass-normalized energy below which the articulation may go to sleep.  The energy threshold for sleeping.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetStabilizationThresholdMut(MagicPhysX.PxArticulationReducedCoordinate@,System.Single)">
            <summary>Sets the mass-normalized kinetic energy threshold below which the articulation may participate in stabilization.  Articulations whose kinetic energy divided by their mass is above this threshold will not participate in stabilization.  This value has no effect if PxSceneFlag::eENABLE_STABILIZATION was not enabled on the PxSceneDesc.  Default: 0.01 * PxTolerancesScale::speed * PxTolerancesScale::speed  This call may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetStabilizationThreshold(MagicPhysX.PxArticulationReducedCoordinate@)">
            <summary>Returns the mass-normalized kinetic energy below which the articulation may participate in stabilization.  Articulations whose kinetic energy divided by their mass is above this threshold will not participate in stabilization.  The energy threshold for participating in stabilization.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetWakeCounterMut(MagicPhysX.PxArticulationReducedCoordinate@,System.Single)">
            <summary>Sets the wake counter for the articulation in seconds.  - The wake counter value determines the minimum amount of time until the articulation can be put to sleep. - An articulation will not be put to sleep if the energy is above the specified threshold (see [`setSleepThreshold`]()) or if other awake objects are touching it. - Passing in a positive value will wake up the articulation automatically.  Default: 0.4s (which corresponds to 20 frames for a time step of 0.02s)  This call may not be made during simulation, except in a split simulation in-between [`PxScene::fetchCollision`] and #PxScene::advance.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetWakeCounter(MagicPhysX.PxArticulationReducedCoordinate@)">
            <summary>Returns the wake counter of the articulation in seconds.  The wake counter of the articulation in seconds.  This call may not be made during simulation, except in a split simulation in-between [`PxScene::fetchCollision`] and #PxScene::advance.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.WakeUpMut(MagicPhysX.PxArticulationReducedCoordinate@)">
            <summary>Wakes up the articulation if it is sleeping.  - The articulation will get woken up and might cause other touching objects to wake up as well during the next simulation step. - This will set the wake counter of the articulation to the value specified in [`PxSceneDesc::wakeCounterResetValue`].  This call may only be made on articulations that are in a scene, and may not be made during simulation, except in a split simulation in-between [`PxScene::fetchCollision`] and #PxScene::advance.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PutToSleepMut(MagicPhysX.PxArticulationReducedCoordinate@)">
            <summary>Forces the articulation to sleep.  - The articulation will stay asleep during the next simulation step if not touched by another non-sleeping actor. - This will set any applied force, the velocity, and the wake counter of all bodies in the articulation to zero.  This call may not be made during simulation, and may only be made on articulations that are in a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetMaxCOMLinearVelocityMut(MagicPhysX.PxArticulationReducedCoordinate@,System.Single)">
            <summary>Sets the limit on the magnitude of the linear velocity of the articulation's center of mass.  - The limit acts on the linear velocity of the entire articulation. The velocity is calculated from the total momentum and the spatial inertia of the articulation. - The limit only applies to floating-base articulations. - A benefit of the COM velocity limit is that it is evenly applied to the whole articulation, which results in fewer visual artifacts compared to link rigid-body damping or joint-velocity limits. However, these per-link or per-degree-of-freedom limits may still help avoid numerical issues.  This call may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetMaxCOMLinearVelocity(MagicPhysX.PxArticulationReducedCoordinate@)">
            <summary>Gets the limit on the magnitude of the linear velocity of the articulation's center of mass.  The maximal linear velocity magnitude.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetMaxCOMAngularVelocityMut(MagicPhysX.PxArticulationReducedCoordinate@,System.Single)">
            <summary>Sets the limit on the magnitude of the angular velocity at the articulation's center of mass.  - The limit acts on the angular velocity of the entire articulation. The velocity is calculated from the total momentum and the spatial inertia of the articulation. - The limit only applies to floating-base articulations. - A benefit of the COM velocity limit is that it is evenly applied to the whole articulation, which results in fewer visual artifacts compared to link rigid-body damping or joint-velocity limits. However, these per-link or per-degree-of-freedom limits may still help avoid numerical issues.  This call may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetMaxCOMAngularVelocity(MagicPhysX.PxArticulationReducedCoordinate@)">
            <summary>Gets the limit on the magnitude of the angular velocity at the articulation's center of mass.  The maximal angular velocity magnitude.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CreateLinkMut(MagicPhysX.PxArticulationReducedCoordinate@,MagicPhysX.PxArticulationLink*,MagicPhysX.PxTransform*)">
            <summary>Adds a link to the articulation with default attribute values.  The new link, or NULL if the link cannot be created.  Creating a link is not allowed while the articulation is in a scene. In order to add a link, remove and then re-add the articulation to the scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxArticulationReducedCoordinate@)">
            <summary>Releases the articulation, and all its links and corresponding joints.  Attached sensors and tendons are released automatically when the articulation is released.  This call may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbLinks(MagicPhysX.PxArticulationReducedCoordinate@)">
            <summary>Returns the number of links in the articulation.  The number of links.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetLinks(MagicPhysX.PxArticulationReducedCoordinate@,MagicPhysX.PxArticulationLink**,System.UInt32,System.UInt32)">
            <summary>Returns the set of links in the articulation in the order that they were added to the articulation using createLink.  The number of links written into the buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbShapes(MagicPhysX.PxArticulationReducedCoordinate@)">
            <summary>Returns the number of shapes in the articulation.  The number of shapes.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetNameMut(MagicPhysX.PxArticulationReducedCoordinate@,System.Byte*)">
            <summary>Sets a name string for the articulation that can be retrieved with getName().  This is for debugging and is not used by the SDK. The string is not copied by the SDK, only the pointer is stored.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetName(MagicPhysX.PxArticulationReducedCoordinate@)">
            <summary>Returns the name string set with setName().  Name string associated with the articulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetWorldBounds(MagicPhysX.PxArticulationReducedCoordinate@,System.Single)">
            <summary>Returns the axis-aligned bounding box enclosing the articulation.  The articulation's bounding box.  It is not allowed to use this method while the simulation is running, except in a split simulation during [`PxScene::collide`]() and up to #PxScene::advance(), and in PxContactModifyCallback or in contact report callbacks.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetAggregate(MagicPhysX.PxArticulationReducedCoordinate@)">
            <summary>Returns the aggregate the articulation might be a part of.  The aggregate the articulation is a part of, or NULL if the articulation does not belong to an aggregate.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetArticulationFlagsMut(MagicPhysX.PxArticulationReducedCoordinate@,MagicPhysX.PxArticulationFlags)">
            <summary>Sets flags on the articulation.  This call may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetArticulationFlagMut(MagicPhysX.PxArticulationReducedCoordinate@,MagicPhysX.PxArticulationFlag,System.Boolean)">
            <summary>Raises or clears a flag on the articulation.  This call may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetArticulationFlags(MagicPhysX.PxArticulationReducedCoordinate@)">
            <summary>Returns the articulation's flags.  The flags.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetDofs(MagicPhysX.PxArticulationReducedCoordinate@)">
            <summary>Returns the total number of joint degrees-of-freedom (DOFs) of the articulation.  - The six DOFs of the base of a floating-base articulation are not included in this count. - Example: Both a fixed-base and a floating-base double-pendulum with two revolute joints will have getDofs() == 2. - The return value is only valid for articulations that are in a scene.  The number of joint DOFs, or 0xFFFFFFFF if the articulation is not in a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CreateCache(MagicPhysX.PxArticulationReducedCoordinate@)">
            <summary>Creates an articulation cache that can be used to read and write internal articulation data.  - When the structure of the articulation changes (e.g. adding a link or sensor) after the cache was created, the cache needs to be released and recreated. - Free the memory allocated for the cache by calling the release() method on the cache. - Caches can only be created by articulations that are in a scene.  The cache, or NULL if the articulation is not in a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetCacheDataSize(MagicPhysX.PxArticulationReducedCoordinate@)">
            <summary>Returns the size of the articulation cache in bytes.  - The size does not include: the user-allocated memory for the coefficient matrix or lambda values; the scratch-related memory/members; and the cache version. See comment in [`PxArticulationCache`]. - The return value is only valid for articulations that are in a scene.  The byte size of the cache, or 0xFFFFFFFF if the articulation is not in a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ZeroCache(MagicPhysX.PxArticulationReducedCoordinate@,MagicPhysX.PxArticulationCache*)">
            <summary>Zeroes all data in the articulation cache, except user-provided and scratch memory, and cache version.  This call may only be made on articulations that are in a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ApplyCacheMut(MagicPhysX.PxArticulationReducedCoordinate@,MagicPhysX.PxArticulationCache*,MagicPhysX.PxArticulationCacheFlags,System.Boolean)">
            <summary>Applies the data in the cache to the articulation.  This call wakes the articulation if it is sleeping, and the autowake parameter is true (default) or: - a nonzero joint velocity is applied or - a nonzero joint force is applied or - a nonzero root velocity is applied  This call may only be made on articulations that are in a scene, and may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CopyInternalStateToCache(MagicPhysX.PxArticulationReducedCoordinate@,MagicPhysX.PxArticulationCache*,MagicPhysX.PxArticulationCacheFlags)">
            <summary>Copies internal data of the articulation to the cache.  This call may only be made on articulations that are in a scene, and may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PackJointData(MagicPhysX.PxArticulationReducedCoordinate@,System.Single*,System.Single*)">
            <summary>Converts maximal-coordinate joint DOF data to reduced coordinates.  - Indexing into the maximal joint DOF data is via the link's low-level index minus 1 (the root link is not included). - The reduced-coordinate data follows the cache indexing convention, see PxArticulationCache::jointVelocity.  The articulation must be in a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.UnpackJointData(MagicPhysX.PxArticulationReducedCoordinate@,System.Single*,System.Single*)">
            <summary>Converts reduced-coordinate joint DOF data to maximal coordinates.  - Indexing into the maximal joint DOF data is via the link's low-level index minus 1 (the root link is not included). - The reduced-coordinate data follows the cache indexing convention, see PxArticulationCache::jointVelocity.  The articulation must be in a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CommonInit(MagicPhysX.PxArticulationReducedCoordinate@)">
            <summary>Prepares common articulation data based on articulation pose for inverse dynamics calculations.  Usage: 1. Set articulation pose (joint positions and base transform) via articulation cache and applyCache(). 1. Call commonInit. 1. Call inverse dynamics computation method.  This call may only be made on articulations that are in a scene, and may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ComputeGeneralizedGravityForce(MagicPhysX.PxArticulationReducedCoordinate@,MagicPhysX.PxArticulationCache*)">
            <summary>Computes the joint DOF forces required to counteract gravitational forces for the given articulation pose.  - Inputs - Articulation pose (joint positions + base transform). - Outputs - Joint forces to counteract gravity (in cache).  - The joint forces returned are determined purely by gravity for the articulation in the current joint and base pose, and joints at rest; i.e. external forces, joint velocities, and joint accelerations are set to zero. Joint drives are also not considered in the computation. - commonInit() must be called before the computation, and after setting the articulation pose via applyCache().  This call may only be made on articulations that are in a scene, and may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ComputeCoriolisAndCentrifugalForce(MagicPhysX.PxArticulationReducedCoordinate@,MagicPhysX.PxArticulationCache*)">
            <summary>Computes the joint DOF forces required to counteract Coriolis and centrifugal forces for the given articulation state.  - Inputs - Articulation state (joint positions and velocities (in cache), and base transform and spatial velocity). - Outputs - Joint forces to counteract Coriolis and centrifugal forces (in cache).  - The joint forces returned are determined purely by the articulation's state; i.e. external forces, gravity, and joint accelerations are set to zero. Joint drives and potential damping terms, such as link angular or linear damping, or joint friction, are also not considered in the computation. - Prior to the computation, update/set the base spatial velocity with PxArticulationCache::rootLinkData and applyCache(). - commonInit() must be called before the computation, and after setting the articulation pose via applyCache().  This call may only be made on articulations that are in a scene, and may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ComputeGeneralizedExternalForce(MagicPhysX.PxArticulationReducedCoordinate@,MagicPhysX.PxArticulationCache*)">
            <summary>Computes the joint DOF forces required to counteract external spatial forces applied to articulation links.  - Inputs - External forces on links (in cache), articulation pose (joint positions + base transform). - Outputs - Joint forces to counteract the external forces (in cache).  - Only the external spatial forces provided in the cache and the articulation pose are considered in the computation. - The external spatial forces are with respect to the links' centers of mass, and not the actor's origin. - commonInit() must be called before the computation, and after setting the articulation pose via applyCache().  This call may only be made on articulations that are in a scene, and may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ComputeJointAcceleration(MagicPhysX.PxArticulationReducedCoordinate@,MagicPhysX.PxArticulationCache*)">
            <summary>Computes the joint accelerations for the given articulation state and joint forces.  - Inputs - Joint forces (in cache) and articulation state (joint positions and velocities (in cache), and base transform and spatial velocity). - Outputs - Joint accelerations (in cache).  - The computation includes Coriolis terms and gravity. However, joint drives and potential damping terms are not considered in the computation (for example, linear link damping or joint friction). - Prior to the computation, update/set the base spatial velocity with PxArticulationCache::rootLinkData and applyCache(). - commonInit() must be called before the computation, and after setting the articulation pose via applyCache().  This call may only be made on articulations that are in a scene, and may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ComputeJointForce(MagicPhysX.PxArticulationReducedCoordinate@,MagicPhysX.PxArticulationCache*)">
            <summary>Computes the joint forces for the given articulation state and joint accelerations, not considering gravity.  - Inputs - Joint accelerations (in cache) and articulation state (joint positions and velocities (in cache), and base transform and spatial velocity). - Outputs - Joint forces (in cache).  - The computation includes Coriolis terms. However, joint drives and potential damping terms are not considered in the computation (for example, linear link damping or joint friction). - Prior to the computation, update/set the base spatial velocity with PxArticulationCache::rootLinkData and applyCache(). - commonInit() must be called before the computation, and after setting the articulation pose via applyCache().  This call may only be made on articulations that are in a scene, and may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ComputeDenseJacobian(MagicPhysX.PxArticulationReducedCoordinate@,MagicPhysX.PxArticulationCache*,System.UInt32*,System.UInt32*)">
            <summary>Compute the dense Jacobian for the articulation in world space, including the DOFs of a potentially floating base.  This computes the dense representation of an inherently sparse matrix. Multiplication with this matrix maps joint space velocities to world-space linear and angular (i.e. spatial) velocities of the centers of mass of the links.  This call may only be made on articulations that are in a scene, and may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ComputeCoefficientMatrix(MagicPhysX.PxArticulationReducedCoordinate@,MagicPhysX.PxArticulationCache*)">
            <summary>Computes the coefficient matrix for contact forces.  - The matrix dimension is getCoefficientMatrixSize() = getDofs() * getNbLoopJoints(), and the DOF (column) indexing follows the internal DOF order, see PxArticulationCache::jointVelocity. - Each column in the matrix is the joint forces effected by a contact based on impulse strength 1. - The user must allocate memory for PxArticulationCache::coefficientMatrix where the required size of the PxReal array is equal to getCoefficientMatrixSize(). - commonInit() must be called before the computation, and after setting the articulation pose via applyCache().  This call may only be made on articulations that are in a scene, and may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ComputeLambda(MagicPhysX.PxArticulationReducedCoordinate@,MagicPhysX.PxArticulationCache*,MagicPhysX.PxArticulationCache*,System.Single*,System.UInt32)">
            <summary>Computes the lambda values when the test impulse is 1.  - The user must allocate memory for PxArticulationCache::lambda where the required size of the PxReal array is equal to getNbLoopJoints(). - commonInit() must be called before the computation, and after setting the articulation pose via applyCache().  True if convergence was achieved within maxIter; False if convergence was not achieved or the operation failed otherwise.  This call may only be made on articulations that are in a scene, and may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ComputeGeneralizedMassMatrix(MagicPhysX.PxArticulationReducedCoordinate@,MagicPhysX.PxArticulationCache*)">
            <summary>Compute the joint-space inertia matrix that maps joint accelerations to joint forces: forces = M * accelerations.  - Inputs - Articulation pose (joint positions and base transform). - Outputs - Mass matrix (in cache).  commonInit() must be called before the computation, and after setting the articulation pose via applyCache().  This call may only be made on articulations that are in a scene, and may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AddLoopJointMut(MagicPhysX.PxArticulationReducedCoordinate@,MagicPhysX.PxConstraint*)">
            <summary>Adds a loop joint to the articulation system for inverse dynamics.  This call may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.RemoveLoopJointMut(MagicPhysX.PxArticulationReducedCoordinate@,MagicPhysX.PxConstraint*)">
            <summary>Removes a loop joint from the articulation for inverse dynamics.  This call may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbLoopJoints(MagicPhysX.PxArticulationReducedCoordinate@)">
            <summary>Returns the number of loop joints in the articulation for inverse dynamics.  The number of loop joints.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetLoopJoints(MagicPhysX.PxArticulationReducedCoordinate@,MagicPhysX.PxConstraint**,System.UInt32,System.UInt32)">
            <summary>Returns the set of loop constraints (i.e. joints) in the articulation.  The number of constraints written into the buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetCoefficientMatrixSize(MagicPhysX.PxArticulationReducedCoordinate@)">
            <summary>Returns the required size of the coefficient matrix in the articulation.  Size of the coefficient matrix (equal to getDofs() * getNbLoopJoints()).  This call may only be made on articulations that are in a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetRootGlobalPoseMut(MagicPhysX.PxArticulationReducedCoordinate@,MagicPhysX.PxTransform*,System.Boolean)">
            <summary>Sets the root link transform (world to actor frame).  - For performance, prefer PxArticulationCache::rootLinkData to set the root link transform in a batch articulation state update. - Use updateKinematic() after all state updates to the articulation via non-cache API such as this method, in order to update link states for the next simulation frame or querying.  This call may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetRootGlobalPose(MagicPhysX.PxArticulationReducedCoordinate@)">
            <summary>Returns the root link transform (world to actor frame).  For performance, prefer PxArticulationCache::rootLinkData to get the root link transform in a batch query.  The root link transform.  This call is not allowed while the simulation is running except in a split simulation during [`PxScene::collide`]() and up to #PxScene::advance(), and in PxContactModifyCallback or in contact report callbacks.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetRootLinearVelocityMut(MagicPhysX.PxArticulationReducedCoordinate@,MagicPhysX.PxVec3*,System.Boolean)">
            <summary>Sets the root link linear center-of-mass velocity.  - The linear velocity is with respect to the link's center of mass and not the actor frame origin. - For performance, prefer PxArticulationCache::rootLinkData to set the root link velocity in a batch articulation state update. - The articulation is woken up if the input velocity is nonzero (ignoring autowake) and the articulation is in a scene. - Use updateKinematic() after all state updates to the articulation via non-cache API such as this method, in order to update link states for the next simulation frame or querying.  This call may not be made during simulation, except in a split simulation in-between [`PxScene::fetchCollision`] and #PxScene::advance.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetRootLinearVelocity(MagicPhysX.PxArticulationReducedCoordinate@)">
            <summary>Gets the root link center-of-mass linear velocity.  - The linear velocity is with respect to the link's center of mass and not the actor frame origin. - For performance, prefer PxArticulationCache::rootLinkData to get the root link velocity in a batch query.  The root link center-of-mass linear velocity.  This call is not allowed while the simulation is running except in a split simulation during [`PxScene::collide`]() and up to #PxScene::advance(), and in PxContactModifyCallback or in contact report callbacks.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetRootAngularVelocityMut(MagicPhysX.PxArticulationReducedCoordinate@,MagicPhysX.PxVec3*,System.Boolean)">
            <summary>Sets the root link angular velocity.  - For performance, prefer PxArticulationCache::rootLinkData to set the root link velocity in a batch articulation state update. - The articulation is woken up if the input velocity is nonzero (ignoring autowake) and the articulation is in a scene. - Use updateKinematic() after all state updates to the articulation via non-cache API such as this method, in order to update link states for the next simulation frame or querying.  This call may not be made during simulation, except in a split simulation in-between [`PxScene::fetchCollision`] and #PxScene::advance.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetRootAngularVelocity(MagicPhysX.PxArticulationReducedCoordinate@)">
            <summary>Gets the root link angular velocity.  For performance, prefer PxArticulationCache::rootLinkData to get the root link velocity in a batch query.  The root link angular velocity.  This call is not allowed while the simulation is running except in a split simulation during [`PxScene::collide`]() and up to #PxScene::advance(), and in PxContactModifyCallback or in contact report callbacks.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetLinkAccelerationMut(MagicPhysX.PxArticulationReducedCoordinate@,System.UInt32)">
            <summary>Returns the (classical) link acceleration in world space for the given low-level link index.  - The returned acceleration is not a spatial, but a classical, i.e. body-fixed acceleration (https://en.wikipedia.org/wiki/Spatial_acceleration). - The (linear) acceleration is with respect to the link's center of mass and not the actor frame origin.  The link's center-of-mass classical acceleration, or 0 if the call is made before the articulation participated in a first simulation step.  This call may only be made on articulations that are in a scene, and it is not allowed to use this method while the simulation is running except in a split simulation during [`PxScene::collide`]() and up to #PxScene::advance(), and in PxContactModifyCallback or in contact report callbacks.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetGpuArticulationIndexMut(MagicPhysX.PxArticulationReducedCoordinate@)">
            <summary>Returns the GPU articulation index.  The GPU index, or 0xFFFFFFFF if the articulation is not in a scene or PxSceneFlag::eSUPPRESS_READBACK is not set.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CreateSpatialTendonMut(MagicPhysX.PxArticulationReducedCoordinate@)">
            <summary>Creates a spatial tendon to attach to the articulation with default attribute values.  The new spatial tendon.  Creating a spatial tendon is not allowed while the articulation is in a scene. In order to add the tendon, remove and then re-add the articulation to the scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CreateFixedTendonMut(MagicPhysX.PxArticulationReducedCoordinate@)">
            <summary>Creates a fixed tendon to attach to the articulation with default attribute values.  The new fixed tendon.  Creating a fixed tendon is not allowed while the articulation is in a scene. In order to add the tendon, remove and then re-add the articulation to the scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CreateSensorMut(MagicPhysX.PxArticulationReducedCoordinate@,MagicPhysX.PxArticulationLink*,MagicPhysX.PxTransform*)">
            <summary>Creates a force sensor attached to a link of the articulation.  The new sensor.  Creating a sensor is not allowed while the articulation is in a scene. In order to add the sensor, remove and then re-add the articulation to the scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSpatialTendons(MagicPhysX.PxArticulationReducedCoordinate@,MagicPhysX.PxArticulationSpatialTendon**,System.UInt32,System.UInt32)">
            <summary>Returns the spatial tendons attached to the articulation.  The order of the tendons in the buffer is not necessarily identical to the order in which the tendons were added to the articulation.  The number of tendons written into the buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbSpatialTendonsMut(MagicPhysX.PxArticulationReducedCoordinate@)">
            <summary>Returns the number of spatial tendons in the articulation.  The number of tendons.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetFixedTendons(MagicPhysX.PxArticulationReducedCoordinate@,MagicPhysX.PxArticulationFixedTendon**,System.UInt32,System.UInt32)">
            <summary>Returns the fixed tendons attached to the articulation.  The order of the tendons in the buffer is not necessarily identical to the order in which the tendons were added to the articulation.  The number of tendons written into the buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbFixedTendonsMut(MagicPhysX.PxArticulationReducedCoordinate@)">
            <summary>Returns the number of fixed tendons in the articulation.  The number of tendons.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSensors(MagicPhysX.PxArticulationReducedCoordinate@,MagicPhysX.PxArticulationSensor**,System.UInt32,System.UInt32)">
            <summary>Returns the sensors attached to the articulation.  The order of the sensors in the buffer is not necessarily identical to the order in which the sensors were added to the articulation.  The number of sensors written into the buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbSensorsMut(MagicPhysX.PxArticulationReducedCoordinate@)">
            <summary>Returns the number of sensors in the articulation.  The number of sensors.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.UpdateKinematicMut(MagicPhysX.PxArticulationReducedCoordinate@,MagicPhysX.PxArticulationKinematicFlags)">
            <summary>Update link velocities and/or positions in the articulation.  For performance, prefer the PxArticulationCache API that performs batch articulation state updates.  If the application updates the root state (position and velocity) or joint state via any combination of the non-cache API calls  - setRootGlobalPose(), setRootLinearVelocity(), setRootAngularVelocity() - PxArticulationJointReducedCoordinate::setJointPosition(), PxArticulationJointReducedCoordinate::setJointVelocity()  the application needs to call this method after the state setting in order to update the link states for the next simulation frame or querying.  Use - PxArticulationKinematicFlag::ePOSITION after any changes to the articulation root or joint positions using non-cache API calls. Updates links' positions and velocities. - PxArticulationKinematicFlag::eVELOCITY after velocity-only changes to the articulation root or joints using non-cache API calls. Updates links' velocities only.  This call may only be made on articulations that are in a scene, and may not be made during simulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetParentArticulationLink(MagicPhysX.PxArticulationJointReducedCoordinate@)">
            <summary>Gets the parent articulation link of this joint.  The parent link.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetParentPoseMut(MagicPhysX.PxArticulationJointReducedCoordinate@,MagicPhysX.PxTransform*)">
            <summary>Sets the joint pose in the parent link actor frame.  This call is not allowed while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetParentPose(MagicPhysX.PxArticulationJointReducedCoordinate@)">
            <summary>Gets the joint pose in the parent link actor frame.  The joint pose.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetChildArticulationLink(MagicPhysX.PxArticulationJointReducedCoordinate@)">
            <summary>Gets the child articulation link of this joint.  The child link.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetChildPoseMut(MagicPhysX.PxArticulationJointReducedCoordinate@,MagicPhysX.PxTransform*)">
            <summary>Sets the joint pose in the child link actor frame.  This call is not allowed while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetChildPose(MagicPhysX.PxArticulationJointReducedCoordinate@)">
            <summary>Gets the joint pose in the child link actor frame.  The joint pose.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetJointTypeMut(MagicPhysX.PxArticulationJointReducedCoordinate@,MagicPhysX.PxArticulationJointType)">
            <summary>Sets the joint type (e.g. revolute).  Setting the joint type is not allowed while the articulation is in a scene. In order to set the joint type, remove and then re-add the articulation to the scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetJointType(MagicPhysX.PxArticulationJointReducedCoordinate@)">
            <summary>Gets the joint type.  The joint type.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetMotionMut(MagicPhysX.PxArticulationJointReducedCoordinate@,MagicPhysX.PxArticulationAxis,MagicPhysX.PxArticulationMotion)">
            <summary>Sets the joint motion for a given axis.  Setting the motion of joint axes is not allowed while the articulation is in a scene. In order to set the motion, remove and then re-add the articulation to the scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetMotion(MagicPhysX.PxArticulationJointReducedCoordinate@,MagicPhysX.PxArticulationAxis)">
            <summary>Returns the joint motion for the given axis.  The joint motion of the given axis.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetLimitParamsMut(MagicPhysX.PxArticulationJointReducedCoordinate@,MagicPhysX.PxArticulationAxis,MagicPhysX.PxArticulationLimit*)">
            <summary>Sets the joint limits for a given axis.  - The motion of the corresponding axis should be set to PxArticulationMotion::eLIMITED in order for the limits to be enforced. - The lower limit should be strictly smaller than the higher limit. If the limits should be equal, use PxArticulationMotion::eLOCKED and an appropriate offset in the parent/child joint frames.  This call is not allowed while the simulation is running.  For spherical joints, limit.min and limit.max must both be in range [-Pi, Pi].</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetLimitParams(MagicPhysX.PxArticulationJointReducedCoordinate@,MagicPhysX.PxArticulationAxis)">
            <summary>Returns the joint limits for a given axis.  The joint limits.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetDriveParamsMut(MagicPhysX.PxArticulationJointReducedCoordinate@,MagicPhysX.PxArticulationAxis,MagicPhysX.PxArticulationDrive*)">
            <summary>Configures a joint drive for the given axis.  See PxArticulationDrive for parameter details; and the manual for further information, and the drives' implicit spring-damper (i.e. PD control) implementation in particular.  This call is not allowed while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetDriveParams(MagicPhysX.PxArticulationJointReducedCoordinate@,MagicPhysX.PxArticulationAxis)">
            <summary>Gets the joint drive configuration for the given axis.  The drive parameters.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetDriveTargetMut(MagicPhysX.PxArticulationJointReducedCoordinate@,MagicPhysX.PxArticulationAxis,System.Single,System.Boolean)">
            <summary>Sets the joint drive position target for the given axis.  The target units are linear units (equivalent to scene units) for a translational axis, or rad for a rotational axis.  This call is not allowed while the simulation is running.  For spherical joints, target must be in range [-Pi, Pi].  The target is specified in the parent frame of the joint. If Gp, Gc are the parent and child actor poses in the world frame and Lp, Lc are the parent and child joint frames expressed in the parent and child actor frames then the joint will drive the parent and child links to poses that obey Gp * Lp * J = Gc * Lc. For joints restricted to angular motion, J has the form PxTranfsorm(PxVec3(PxZero), PxExp(PxVec3(twistTarget, swing1Target, swing2Target))).  For joints restricted to linear motion, J has the form PxTransform(PxVec3(XTarget, YTarget, ZTarget), PxQuat(PxIdentity)).  For spherical joints with more than 1 degree of freedom, the joint target angles taken together can collectively represent a rotation of greater than Pi around a vector. When this happens the rotation that matches the joint drive target is not the shortest path rotation.  The joint pose J that is the outcome after driving to the target pose will always be the equivalent of the shortest path rotation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetDriveTarget(MagicPhysX.PxArticulationJointReducedCoordinate@,MagicPhysX.PxArticulationAxis)">
            <summary>Returns the joint drive position target for the given axis.  The target position.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetDriveVelocityMut(MagicPhysX.PxArticulationJointReducedCoordinate@,MagicPhysX.PxArticulationAxis,System.Single,System.Boolean)">
            <summary>Sets the joint drive velocity target for the given axis.  The target units are linear units (equivalent to scene units) per second for a translational axis, or radians per second for a rotational axis.  This call is not allowed while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetDriveVelocity(MagicPhysX.PxArticulationJointReducedCoordinate@,MagicPhysX.PxArticulationAxis)">
            <summary>Returns the joint drive velocity target for the given axis.  The target velocity.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetArmatureMut(MagicPhysX.PxArticulationJointReducedCoordinate@,MagicPhysX.PxArticulationAxis,System.Single)">
            <summary>Sets the joint armature for the given axis.  - The armature is directly added to the joint-space spatial inertia of the corresponding axis. - The armature is in mass units for a prismatic (i.e. linear) joint, and in mass units * (scene linear units)^2 for a rotational joint.  This call is not allowed while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetArmature(MagicPhysX.PxArticulationJointReducedCoordinate@,MagicPhysX.PxArticulationAxis)">
            <summary>Gets the joint armature for the given axis.  The armature set on the given axis.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetFrictionCoefficientMut(MagicPhysX.PxArticulationJointReducedCoordinate@,System.Single)">
            <summary>Sets the joint friction coefficient, which applies to all joint axes.  - The joint friction is unitless and relates the magnitude of the spatial force [F_trans, T_trans] transmitted from parent to child link to the maximal friction force F_resist that may be applied by the solver to resist joint motion, per axis; i.e. |F_resist| &lt; coefficient * (|F_trans| + |T_trans|), where F_resist may refer to a linear force or torque depending on the joint axis. - The simulated friction effect is therefore similar to static and Coulomb friction. In order to simulate dynamic joint friction, use a joint drive with zero stiffness and zero velocity target, and an appropriately dimensioned damping parameter.  This call is not allowed while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetFrictionCoefficient(MagicPhysX.PxArticulationJointReducedCoordinate@)">
            <summary>Gets the joint friction coefficient.  The joint friction coefficient.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetMaxJointVelocityMut(MagicPhysX.PxArticulationJointReducedCoordinate@,System.Single)">
            <summary>Sets the maximal joint velocity enforced for all axes.  - The solver will apply appropriate joint-space impulses in order to enforce the per-axis joint-velocity limit. - The velocity units are linear units (equivalent to scene units) per second for a translational axis, or radians per second for a rotational axis.  This call is not allowed while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetMaxJointVelocity(MagicPhysX.PxArticulationJointReducedCoordinate@)">
            <summary>Gets the maximal joint velocity enforced for all axes.  The maximal per-axis joint velocity.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetJointPositionMut(MagicPhysX.PxArticulationJointReducedCoordinate@,MagicPhysX.PxArticulationAxis,System.Single)">
            <summary>Sets the joint position for the given axis.  - For performance, prefer PxArticulationCache::jointPosition to set joint positions in a batch articulation state update. - Use PxArticulationReducedCoordinate::updateKinematic after all state updates to the articulation via non-cache API such as this method, in order to update link states for the next simulation frame or querying.  This call is not allowed while the simulation is running.  For spherical joints, jointPos must be in range [-Pi, Pi].  Joint position is specified in the parent frame of the joint. If Gp, Gc are the parent and child actor poses in the world frame and Lp, Lc are the parent and child joint frames expressed in the parent and child actor frames then the parent and child links will be given poses that obey Gp * Lp * J = Gc * Lc with J denoting the joint pose. For joints restricted to angular motion, J has the form PxTranfsorm(PxVec3(PxZero), PxExp(PxVec3(twistPos, swing1Pos, swing2Pos))).  For joints restricted to linear motion, J has the form PxTransform(PxVec3(xPos, yPos, zPos), PxQuat(PxIdentity)).  For spherical joints with more than 1 degree of freedom, the input joint positions taken together can collectively represent a rotation of greater than Pi around a vector. When this happens the rotation that matches the joint positions is not the shortest path rotation.  The joint pose J that is the outcome of setting and applying the joint positions will always be the equivalent of the shortest path rotation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetJointPosition(MagicPhysX.PxArticulationJointReducedCoordinate@,MagicPhysX.PxArticulationAxis)">
            <summary>Gets the joint position for the given axis, i.e. joint degree of freedom (DOF).  For performance, prefer PxArticulationCache::jointPosition to get joint positions in a batch query.  The joint position in linear units (equivalent to scene units) for a translational axis, or radians for a rotational axis.  This call is not allowed while the simulation is running except in a split simulation during [`PxScene::collide`]() and up to #PxScene::advance(), and in PxContactModifyCallback or in contact report callbacks.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetJointVelocityMut(MagicPhysX.PxArticulationJointReducedCoordinate@,MagicPhysX.PxArticulationAxis,System.Single)">
            <summary>Sets the joint velocity for the given axis.  - For performance, prefer PxArticulationCache::jointVelocity to set joint velocities in a batch articulation state update. - Use PxArticulationReducedCoordinate::updateKinematic after all state updates to the articulation via non-cache API such as this method, in order to update link states for the next simulation frame or querying.  This call is not allowed while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetJointVelocity(MagicPhysX.PxArticulationJointReducedCoordinate@,MagicPhysX.PxArticulationAxis)">
            <summary>Gets the joint velocity for the given axis.  For performance, prefer PxArticulationCache::jointVelocity to get joint velocities in a batch query.  The joint velocity in linear units (equivalent to scene units) per second for a translational axis, or radians per second for a rotational axis.  This call is not allowed while the simulation is running except in a split simulation during [`PxScene::collide`]() and up to #PxScene::advance(), and in PxContactModifyCallback or in contact report callbacks.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetConcreteTypeName(MagicPhysX.PxArticulationJointReducedCoordinate@)">
            <summary>Returns the string name of the dynamic type.  The string name.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxShape@)">
            <summary>Decrements the reference count of a shape and releases it if the new reference count is zero.  Note that in releases prior to PhysX 3.3 this method did not have reference counting semantics and was used to destroy a shape created with PxActor::createShape(). In PhysX 3.3 and above, this usage is deprecated, instead, use PxRigidActor::detachShape() to detach a shape from an actor. If the shape to be detached was created with PxActor::createShape(), the actor holds the only counted reference, and so when the shape is detached it will also be destroyed.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetGeometryMut(MagicPhysX.PxShape@,MagicPhysX.PxGeometry*)">
            <summary>Adjust the geometry of the shape.  The type of the passed in geometry must match the geometry type of the shape.  It is not allowed to change the geometry type of a shape.  This function does not guarantee correct/continuous behavior when objects are resting on top of old or new geometry.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetGeometry(MagicPhysX.PxShape@)">
            <summary>Retrieve a reference to the shape's geometry.  The returned reference has the same lifetime as the PxShape it comes from.  Reference to internal PxGeometry object.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetActor(MagicPhysX.PxShape@)">
            <summary>Retrieves the actor which this shape is associated with.  The actor this shape is associated with, if it is an exclusive shape, else NULL</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetLocalPoseMut(MagicPhysX.PxShape@,MagicPhysX.PxTransform*)">
            <summary>Sets the pose of the shape in actor space, i.e. relative to the actors to which they are attached.  This transformation is identity by default.  The local pose is an attribute of the shape, and so will apply to all actors to which the shape is attached.  Sleeping: Does NOT wake the associated actor up automatically.  Note: Does not automatically update the inertia properties of the owning actor (if applicable); use the PhysX extensions method [`PxRigidBodyExt::updateMassAndInertia`]() to do this.  Default: the identity transform</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetLocalPose(MagicPhysX.PxShape@)">
            <summary>Retrieves the pose of the shape in actor space, i.e. relative to the actor they are owned by.  This transformation is identity by default.  Pose of shape relative to the actor's frame.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetSimulationFilterDataMut(MagicPhysX.PxShape@,MagicPhysX.PxFilterData*)">
            <summary>Sets the user definable collision filter data.  Sleeping: Does wake up the actor if the filter data change causes a formerly suppressed collision pair to be enabled.  Default: (0,0,0,0)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSimulationFilterData(MagicPhysX.PxShape@)">
            <summary>Retrieves the shape's collision filter data.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetQueryFilterDataMut(MagicPhysX.PxShape@,MagicPhysX.PxFilterData*)">
            <summary>Sets the user definable query filter data.  Default: (0,0,0,0)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetQueryFilterData(MagicPhysX.PxShape@)">
            <summary>Retrieves the shape's Query filter data.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetMaterialsMut(MagicPhysX.PxShape@,MagicPhysX.PxMaterial**,System.UInt16)">
            <summary>Assigns material(s) to the shape. Will remove existing materials from the shape.  Sleeping: Does NOT wake the associated actor up automatically.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbMaterials(MagicPhysX.PxShape@)">
            <summary>Returns the number of materials assigned to the shape.  You can use [`getMaterials`]() to retrieve the material pointers.  Number of materials associated with this shape.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetMaterials(MagicPhysX.PxShape@,MagicPhysX.PxMaterial**,System.UInt32,System.UInt32)">
            <summary>Retrieve all the material pointers associated with the shape.  You can retrieve the number of material pointers by calling [`getNbMaterials`]()  Note: The returned data may contain invalid pointers if you release materials using [`PxMaterial::release`]().  Number of material pointers written to the buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetMaterialFromInternalFaceIndex(MagicPhysX.PxShape@,System.UInt32)">
            <summary>Retrieve material from given triangle index.  The input index is the internal triangle index as used inside the SDK. This is the index returned to users by various SDK functions such as raycasts.  This function is only useful for triangle meshes or heightfields, which have per-triangle materials. For other shapes or SDF triangle meshes, the function returns the single material associated with the shape, regardless of the index.  Material from input triangle  If faceIndex value of 0xFFFFffff is passed as an input for mesh and heightfield shapes, this function will issue a warning and return NULL.  Scene queries set the value of PxQueryHit::faceIndex to 0xFFFFffff whenever it is undefined or does not apply.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetContactOffsetMut(MagicPhysX.PxShape@,System.Single)">
            <summary>Sets the contact offset.  Shapes whose distance is less than the sum of their contactOffset values will generate contacts. The contact offset must be positive and greater than the rest offset. Having a contactOffset greater than than the restOffset allows the collision detection system to predictively enforce the contact constraint even when the objects are slightly separated. This prevents jitter that would occur if the constraint were enforced only when shapes were within the rest distance.  Default: 0.02f * PxTolerancesScale::length  Sleeping: Does NOT wake the associated actor up automatically.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetContactOffset(MagicPhysX.PxShape@)">
            <summary>Retrieves the contact offset.  The contact offset of the shape.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetRestOffsetMut(MagicPhysX.PxShape@,System.Single)">
            <summary>Sets the rest offset.  Two shapes will come to rest at a distance equal to the sum of their restOffset values. If the restOffset is 0, they should converge to touching exactly.  Having a restOffset greater than zero is useful to have objects slide smoothly, so that they do not get hung up on irregularities of each others' surfaces.  Default: 0.0f  Sleeping: Does NOT wake the associated actor up automatically.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetRestOffset(MagicPhysX.PxShape@)">
            <summary>Retrieves the rest offset.  The rest offset of the shape.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetDensityForFluidMut(MagicPhysX.PxShape@,System.Single)">
            <summary>Sets the density used to interact with fluids.  To be physically accurate, the density of a rigid body should be computed as its mass divided by its volume. To simplify tuning the interaction of fluid and rigid bodies, the density for fluid can differ from the real density. This allows to create floating bodies, even if they are supposed to sink with their mass and volume.  Default: 800.0f</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetDensityForFluid(MagicPhysX.PxShape@)">
            <summary>Retrieves the density used to interact with fluids.  The density of the body when interacting with fluid.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetTorsionalPatchRadiusMut(MagicPhysX.PxShape@,System.Single)">
            <summary>Sets torsional patch radius.  This defines the radius of the contact patch used to apply torsional friction. If the radius is 0, no torsional friction will be applied. If the radius is &gt; 0, some torsional friction will be applied. This is proportional to the penetration depth so, if the shapes are separated or penetration is zero, no torsional friction will be applied. It is used to approximate rotational friction introduced by the compression of contacting surfaces.  Default: 0.0</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetTorsionalPatchRadius(MagicPhysX.PxShape@)">
            <summary>Gets torsional patch radius.  This defines the radius of the contact patch used to apply torsional friction. If the radius is 0, no torsional friction will be applied. If the radius is &gt; 0, some torsional friction will be applied. This is proportional to the penetration depth so, if the shapes are separated or penetration is zero, no torsional friction will be applied. It is used to approximate rotational friction introduced by the compression of contacting surfaces.  The torsional patch radius of the shape.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetMinTorsionalPatchRadiusMut(MagicPhysX.PxShape@,System.Single)">
            <summary>Sets minimum torsional patch radius.  This defines the minimum radius of the contact patch used to apply torsional friction. If the radius is 0, the amount of torsional friction that will be applied will be entirely dependent on the value of torsionalPatchRadius.  If the radius is &gt; 0, some torsional friction will be applied regardless of the value of torsionalPatchRadius or the amount of penetration.  Default: 0.0</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetMinTorsionalPatchRadius(MagicPhysX.PxShape@)">
            <summary>Gets minimum torsional patch radius.  This defines the minimum radius of the contact patch used to apply torsional friction. If the radius is 0, the amount of torsional friction that will be applied will be entirely dependent on the value of torsionalPatchRadius.  If the radius is &gt; 0, some torsional friction will be applied regardless of the value of torsionalPatchRadius or the amount of penetration.  The minimum torsional patch radius of the shape.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetFlagMut(MagicPhysX.PxShape@,MagicPhysX.PxShapeFlag,System.Boolean)">
            <summary>Sets shape flags  Sleeping: Does NOT wake the associated actor up automatically.  Default: PxShapeFlag::eVISUALIZATION | PxShapeFlag::eSIMULATION_SHAPE | PxShapeFlag::eSCENE_QUERY_SHAPE</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetFlagsMut(MagicPhysX.PxShape@,MagicPhysX.PxShapeFlags)">
            <summary>Sets shape flags</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetFlags(MagicPhysX.PxShape@)">
            <summary>Retrieves shape flags.  The values of the shape flags.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsExclusive(MagicPhysX.PxShape@)">
            <summary>Returns true if the shape is exclusive to an actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetNameMut(MagicPhysX.PxShape@,System.Byte*)">
            <summary>Sets a name string for the object that can be retrieved with [`getName`]().  This is for debugging and is not used by the SDK. The string is not copied by the SDK, only the pointer is stored.  Default: NULL</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetName(MagicPhysX.PxShape@)">
            <summary>retrieves the name string set with setName().  The name associated with the shape.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.QueryCacheNew1(MagicPhysX.PxShape@,System.UInt32)">
            <summary>constructor to set properties</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ExtGetGlobalPose(MagicPhysX.PxShape@,MagicPhysX.PxRigidActor*)">
            <summary>Retrieves the world space pose of the shape.  Global pose of shape.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ExtRaycast(MagicPhysX.PxShape@,MagicPhysX.PxRigidActor*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxHitFlags,System.UInt32,MagicPhysX.PxRaycastHit*)">
            <summary>Raycast test against the shape.  Number of hits between the ray and the shape</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ExtOverlap(MagicPhysX.PxShape@,MagicPhysX.PxRigidActor*,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*)">
            <summary>Test overlap between the shape and a geometry object  True if the shape overlaps the geometry object</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ExtSweep(MagicPhysX.PxShape@,MagicPhysX.PxRigidActor*,MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxSweepHit*,MagicPhysX.PxHitFlags)">
            <summary>Sweep a geometry object against the shape.  Currently only box, sphere, capsule and convex mesh shapes are supported, i.e. the swept geometry object must be one of those types.  True if the swept geometry object hits the shape</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ExtGetWorldBounds(MagicPhysX.PxShape@,MagicPhysX.PxRigidActor*,System.Single)">
            <summary>Retrieves the axis aligned bounding box enclosing the shape.  The shape's bounding box.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetCMassLocalPoseMut(MagicPhysX.PxRigidBody@,MagicPhysX.PxTransform*)">
            <summary>Sets the pose of the center of mass relative to the actor.  Changing this transform will not move the actor in the world!  Setting an unrealistic center of mass which is a long way from the body can make it difficult for the SDK to solve constraints. Perhaps leading to instability and jittering bodies.  Default: the identity transform</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetCMassLocalPose(MagicPhysX.PxRigidBody@)">
            <summary>Retrieves the center of mass pose relative to the actor frame.  The center of mass pose relative to the actor frame.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetMassMut(MagicPhysX.PxRigidBody@,System.Single)">
            <summary>Sets the mass of a dynamic actor.  The mass must be non-negative.  setMass() does not update the inertial properties of the body, to change the inertia tensor use setMassSpaceInertiaTensor() or the PhysX extensions method [`PxRigidBodyExt::updateMassAndInertia`]().  A value of 0 is interpreted as infinite mass.  Values of 0 are not permitted for instances of PxArticulationLink but are permitted for instances of PxRigidDynamic.  Default: 1.0  Sleeping: Does NOT wake the actor up automatically.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetMass(MagicPhysX.PxRigidBody@)">
            <summary>Retrieves the mass of the actor.  A value of 0 is interpreted as infinite mass.  The mass of this actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetInvMass(MagicPhysX.PxRigidBody@)">
            <summary>Retrieves the inverse mass of the actor.  The inverse mass of this actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetMassSpaceInertiaTensorMut(MagicPhysX.PxRigidBody@,MagicPhysX.PxVec3*)">
            <summary>Sets the inertia tensor, using a parameter specified in mass space coordinates.  Note that such matrices are diagonal -- the passed vector is the diagonal.  If you have a non diagonal world/actor space inertia tensor(3x3 matrix). Then you need to diagonalize it and set an appropriate mass space transform. See [`setCMassLocalPose`]().  The inertia tensor elements must be non-negative.  A value of 0 in an element is interpreted as infinite inertia along that axis.  Values of 0 are not permitted for instances of PxArticulationLink but are permitted for instances of PxRigidDynamic.  Default: (1.0, 1.0, 1.0)  Sleeping: Does NOT wake the actor up automatically.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetMassSpaceInertiaTensor(MagicPhysX.PxRigidBody@)">
            <summary>Retrieves the diagonal inertia tensor of the actor relative to the mass coordinate frame.  This method retrieves a mass frame inertia vector.  The mass space inertia tensor of this actor.  A value of 0 in an element is interpreted as infinite inertia along that axis.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetMassSpaceInvInertiaTensor(MagicPhysX.PxRigidBody@)">
            <summary>Retrieves the diagonal inverse inertia tensor of the actor relative to the mass coordinate frame.  This method retrieves a mass frame inverse inertia vector.  A value of 0 in an element is interpreted as infinite inertia along that axis.  The mass space inverse inertia tensor of this actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetLinearDampingMut(MagicPhysX.PxRigidBody@,System.Single)">
            <summary>Sets the linear damping coefficient.  Zero represents no damping. The damping coefficient must be nonnegative.  Default: 0.0</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetLinearDamping(MagicPhysX.PxRigidBody@)">
            <summary>Retrieves the linear damping coefficient.  The linear damping coefficient associated with this actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetAngularDampingMut(MagicPhysX.PxRigidBody@,System.Single)">
            <summary>Sets the angular damping coefficient.  Zero represents no damping.  The angular damping coefficient must be nonnegative.  Default: 0.05</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetAngularDamping(MagicPhysX.PxRigidBody@)">
            <summary>Retrieves the angular damping coefficient.  The angular damping coefficient associated with this actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetLinearVelocity(MagicPhysX.PxRigidBody@)">
            <summary>Retrieves the linear velocity of an actor.  It is not allowed to use this method while the simulation is running (except during PxScene::collide(), in PxContactModifyCallback or in contact report callbacks).  The linear velocity of the actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetAngularVelocity(MagicPhysX.PxRigidBody@)">
            <summary>Retrieves the angular velocity of the actor.  It is not allowed to use this method while the simulation is running (except during PxScene::collide(), in PxContactModifyCallback or in contact report callbacks).  The angular velocity of the actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetMaxLinearVelocityMut(MagicPhysX.PxRigidBody@,System.Single)">
            <summary>Lets you set the maximum linear velocity permitted for this actor.  With this function, you can set the  maximum linear velocity permitted for this rigid body. Higher angular velocities are clamped to this value.  Note: The angular velocity is clamped to the set value before the solver, which means that the limit may still be momentarily exceeded.  Default: PX_MAX_F32</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetMaxLinearVelocity(MagicPhysX.PxRigidBody@)">
            <summary>Retrieves the maximum angular velocity permitted for this actor.  The maximum allowed angular velocity for this actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetMaxAngularVelocityMut(MagicPhysX.PxRigidBody@,System.Single)">
            <summary>Lets you set the maximum angular velocity permitted for this actor.  For various internal computations, very quickly rotating actors introduce error into the simulation, which leads to undesired results.  With this function, you can set the  maximum angular velocity permitted for this rigid body. Higher angular velocities are clamped to this value.  Note: The angular velocity is clamped to the set value before the solver, which means that the limit may still be momentarily exceeded.  Default: 100.0</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetMaxAngularVelocity(MagicPhysX.PxRigidBody@)">
            <summary>Retrieves the maximum angular velocity permitted for this actor.  The maximum allowed angular velocity for this actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AddForceMut(MagicPhysX.PxRigidBody@,MagicPhysX.PxVec3*,MagicPhysX.PxForceMode,System.Boolean)">
            <summary>Applies a force (or impulse) defined in the global coordinate frame to the actor at its center of mass.  This will not induce a torque .  ::PxForceMode determines if the force is to be conventional or impulsive.  Each actor has an acceleration and a velocity change accumulator which are directly modified using the modes PxForceMode::eACCELERATION and PxForceMode::eVELOCITY_CHANGE respectively.  The modes PxForceMode::eFORCE and PxForceMode::eIMPULSE also modify these same accumulators and are just short hand for multiplying the vector parameter by inverse mass and then using PxForceMode::eACCELERATION and PxForceMode::eVELOCITY_CHANGE respectively.  It is invalid to use this method if the actor has not been added to a scene already or if PxActorFlag::eDISABLE_SIMULATION is set.  The force modes PxForceMode::eIMPULSE and PxForceMode::eVELOCITY_CHANGE can not be applied to articulation links.  if this is called on an articulation link, only the link is updated, not the entire articulation.  see [`PxRigidBodyExt::computeVelocityDeltaFromImpulse`] for details of how to compute the change in linear velocity that will arise from the application of an impulsive force, where an impulsive force is applied force multiplied by a timestep.  Sleeping: This call wakes the actor if it is sleeping, and the autowake parameter is true (default) or the force is non-zero.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AddTorqueMut(MagicPhysX.PxRigidBody@,MagicPhysX.PxVec3*,MagicPhysX.PxForceMode,System.Boolean)">
            <summary>Applies an impulsive torque defined in the global coordinate frame to the actor.  ::PxForceMode determines if the torque is to be conventional or impulsive.  Each actor has an angular acceleration and an angular velocity change accumulator which are directly modified using the modes PxForceMode::eACCELERATION and PxForceMode::eVELOCITY_CHANGE respectively.  The modes PxForceMode::eFORCE and PxForceMode::eIMPULSE also modify these same accumulators and are just short hand for multiplying the vector parameter by inverse inertia and then using PxForceMode::eACCELERATION and PxForceMode::eVELOCITY_CHANGE respectively.  It is invalid to use this method if the actor has not been added to a scene already or if PxActorFlag::eDISABLE_SIMULATION is set.  The force modes PxForceMode::eIMPULSE and PxForceMode::eVELOCITY_CHANGE can not be applied to articulation links.  if this called on an articulation link, only the link is updated, not the entire articulation.  see [`PxRigidBodyExt::computeVelocityDeltaFromImpulse`] for details of how to compute the change in angular velocity that will arise from the application of an impulsive torque, where an impulsive torque is an applied torque multiplied by a timestep.  Sleeping: This call wakes the actor if it is sleeping, and the autowake parameter is true (default) or the torque is non-zero.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ClearForceMut(MagicPhysX.PxRigidBody@,MagicPhysX.PxForceMode)">
            <summary>Clears the accumulated forces (sets the accumulated force back to zero).  Each actor has an acceleration and a velocity change accumulator which are directly modified using the modes PxForceMode::eACCELERATION and PxForceMode::eVELOCITY_CHANGE respectively.  The modes PxForceMode::eFORCE and PxForceMode::eIMPULSE also modify these same accumulators (see PxRigidBody::addForce() for details); therefore the effect of calling clearForce(PxForceMode::eFORCE) is equivalent to calling clearForce(PxForceMode::eACCELERATION), and the effect of calling clearForce(PxForceMode::eIMPULSE) is equivalent to calling clearForce(PxForceMode::eVELOCITY_CHANGE).  ::PxForceMode determines if the cleared force is to be conventional or impulsive.  The force modes PxForceMode::eIMPULSE and PxForceMode::eVELOCITY_CHANGE can not be applied to articulation links.  It is invalid to use this method if the actor has not been added to a scene already or if PxActorFlag::eDISABLE_SIMULATION is set.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ClearTorqueMut(MagicPhysX.PxRigidBody@,MagicPhysX.PxForceMode)">
            <summary>Clears the impulsive torque defined in the global coordinate frame to the actor.  ::PxForceMode determines if the cleared torque is to be conventional or impulsive.  Each actor has an angular acceleration and a velocity change accumulator which are directly modified using the modes PxForceMode::eACCELERATION and PxForceMode::eVELOCITY_CHANGE respectively.  The modes PxForceMode::eFORCE and PxForceMode::eIMPULSE also modify these same accumulators (see PxRigidBody::addTorque() for details); therefore the effect of calling clearTorque(PxForceMode::eFORCE) is equivalent to calling clearTorque(PxForceMode::eACCELERATION), and the effect of calling clearTorque(PxForceMode::eIMPULSE) is equivalent to calling clearTorque(PxForceMode::eVELOCITY_CHANGE).  The force modes PxForceMode::eIMPULSE and PxForceMode::eVELOCITY_CHANGE can not be applied to articulation links.  It is invalid to use this method if the actor has not been added to a scene already or if PxActorFlag::eDISABLE_SIMULATION is set.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetForceAndTorqueMut(MagicPhysX.PxRigidBody@,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxForceMode)">
            <summary>Sets the impulsive force and torque defined in the global coordinate frame to the actor.  ::PxForceMode determines if the cleared torque is to be conventional or impulsive.  The force modes PxForceMode::eIMPULSE and PxForceMode::eVELOCITY_CHANGE can not be applied to articulation links.  It is invalid to use this method if the actor has not been added to a scene already or if PxActorFlag::eDISABLE_SIMULATION is set.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetRigidBodyFlagMut(MagicPhysX.PxRigidBody@,MagicPhysX.PxRigidBodyFlag,System.Boolean)">
            <summary>Raises or clears a particular rigid body flag.  See the list of flags [`PxRigidBodyFlag`]  Default: no flags are set  Sleeping: Does NOT wake the actor up automatically.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetRigidBodyFlags(MagicPhysX.PxRigidBody@)">
            <summary>Reads the PxRigidBody flags.  See the list of flags [`PxRigidBodyFlag`]  The values of the PxRigidBody flags.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetMinCCDAdvanceCoefficientMut(MagicPhysX.PxRigidBody@,System.Single)">
            <summary>Sets the CCD minimum advance coefficient.  The CCD minimum advance coefficient is a value in the range [0, 1] that is used to control the minimum amount of time a body is integrated when it has a CCD contact. The actual minimum amount of time that is integrated depends on various properties, including the relative speed and collision shapes of the bodies involved in the contact. From these properties, a numeric value is calculated that determines the maximum distance (and therefore maximum time) which these bodies could be integrated forwards that would ensure that these bodies did not pass through each-other. This value is then scaled by CCD minimum advance coefficient to determine the amount of time that will be consumed in the CCD pass.  Things to consider: A large value (approaching 1) ensures that the objects will always advance some time. However, larger values increase the chances of objects gently drifting through each-other in scenes which the constraint solver can't converge, e.g. scenes where an object is being dragged through a wall with a constraint. A value of 0 ensures that the pair of objects stop at the exact time-of-impact and will not gently drift through each-other. However, with very small/thin objects initially in contact, this can lead to a large amount of time being dropped and increases the chances of jamming. Jamming occurs when the an object is persistently in contact with an object such that the time-of-impact is 0, which results in no time being advanced for those objects in that CCD pass.  The chances of jamming can be reduced by increasing the number of CCD mass</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetMinCCDAdvanceCoefficient(MagicPhysX.PxRigidBody@)">
            <summary>Gets the CCD minimum advance coefficient.  The value of the CCD min advance coefficient.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetMaxDepenetrationVelocityMut(MagicPhysX.PxRigidBody@,System.Single)">
            <summary>Sets the maximum depenetration velocity permitted to be introduced by the solver. This value controls how much velocity the solver can introduce to correct for penetrations in contacts.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetMaxDepenetrationVelocity(MagicPhysX.PxRigidBody@)">
            <summary>Returns the maximum depenetration velocity the solver is permitted to introduced. This value controls how much velocity the solver can introduce to correct for penetrations in contacts.  The maximum penetration bias applied by the solver.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetMaxContactImpulseMut(MagicPhysX.PxRigidBody@,System.Single)">
            <summary>Sets a limit on the impulse that may be applied at a contact. The maximum impulse at a contact between two dynamic or kinematic bodies will be the minimum of the two limit values. For a collision between a static and a dynamic body, the impulse is limited by the value for the dynamic body.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetMaxContactImpulse(MagicPhysX.PxRigidBody@)">
            <summary>Returns the maximum impulse that may be applied at a contact.  The maximum impulse that may be applied at a contact</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetContactSlopCoefficientMut(MagicPhysX.PxRigidBody@,System.Single)">
            <summary>Sets a distance scale whereby the angular influence of a contact on the normal constraint in a contact is zeroed if normal.cross(offset) falls below this tolerance. Rather than acting as an absolute value, this tolerance is scaled by the ratio rXn.dot(angVel)/normal.dot(linVel) such that contacts that have relatively larger angular velocity than linear normal velocity (e.g. rolling wheels) achieve larger slop values as the angular velocity increases.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetContactSlopCoefficient(MagicPhysX.PxRigidBody@)">
            <summary>Returns the contact slop coefficient.  The contact slop coefficient.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetInternalIslandNodeIndex(MagicPhysX.PxRigidBody@)">
            <summary>Returns the island node index  The island node index.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ExtUpdateMassAndInertia(MagicPhysX.PxRigidBody@,System.Single*,System.UInt32,MagicPhysX.PxVec3*,System.Boolean)">
            <summary>Computation of mass properties for a rigid body actor  To simulate a dynamic rigid actor, the SDK needs a mass and an inertia tensor.  This method offers functionality to compute the necessary mass and inertia properties based on the shapes declared in the PxRigidBody descriptor and some additionally specified parameters. For each shape, the shape geometry, the shape positioning within the actor and the specified shape density are used to compute the body's mass and inertia properties.  Shapes without PxShapeFlag::eSIMULATION_SHAPE set are ignored unless includeNonSimShapes is true. Shapes with plane, triangle mesh or heightfield geometry and PxShapeFlag::eSIMULATION_SHAPE set are not allowed for PxRigidBody collision.  This method will set the mass, center of mass, and inertia tensor  if no collision shapes are found, the inertia tensor is set to (1,1,1) and the mass to 1  if massLocalPose is non-NULL, the rigid body's center of mass parameter  will be set to the user provided value (massLocalPose) and the inertia tensor will be resolved at that point.  If all shapes of the actor have the same density then the overloaded method updateMassAndInertia() with a single density parameter can be used instead.  Boolean. True on success else false.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ExtUpdateMassAndInertia1(MagicPhysX.PxRigidBody@,System.Single,MagicPhysX.PxVec3*,System.Boolean)">
            <summary>Computation of mass properties for a rigid body actor  See previous method for details.  Boolean. True on success else false.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ExtSetMassAndUpdateInertia(MagicPhysX.PxRigidBody@,System.Single*,System.UInt32,MagicPhysX.PxVec3*,System.Boolean)">
            <summary>Computation of mass properties for a rigid body actor  This method sets the mass, inertia and center of mass of a rigid body. The mass is set to the sum of all user-supplied shape mass values, and the inertia and center of mass are computed according to the rigid body's shapes and the per shape mass input values.  If no collision shapes are found, the inertia tensor is set to (1,1,1)  If a single mass value should be used for the actor as a whole then the overloaded method setMassAndUpdateInertia() with a single mass parameter can be used instead.  Boolean. True on success else false.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ExtSetMassAndUpdateInertia1(MagicPhysX.PxRigidBody@,System.Single,MagicPhysX.PxVec3*,System.Boolean)">
            <summary>Computation of mass properties for a rigid body actor  This method sets the mass, inertia and center of mass of a rigid body. The mass is set to the user-supplied value, and the inertia and center of mass are computed according to the rigid body's shapes and the input mass.  If no collision shapes are found, the inertia tensor is set to (1,1,1)  Boolean. True on success else false.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ExtAddForceAtPos(MagicPhysX.PxRigidBody@,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxForceMode,System.Boolean)">
            <summary>Applies a force (or impulse) defined in the global coordinate frame, acting at a particular point in global coordinates, to the actor.  Note that if the force does not act along the center of mass of the actor, this will also add the corresponding torque. Because forces are reset at the end of every timestep, you can maintain a total external force on an object by calling this once every frame.  if this call is used to apply a force or impulse to an articulation link, only the link is updated, not the entire articulation  ::PxForceMode determines if the force is to be conventional or impulsive. Only eFORCE and eIMPULSE are supported, as the force required to produce a given velocity change or acceleration is underdetermined given only the desired change at a given point.  Sleeping: This call wakes the actor if it is sleeping and the wakeup parameter is true (default).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ExtAddForceAtLocalPos(MagicPhysX.PxRigidBody@,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxForceMode,System.Boolean)">
            <summary>Applies a force (or impulse) defined in the global coordinate frame, acting at a particular point in local coordinates, to the actor.  Note that if the force does not act along the center of mass of the actor, this will also add the corresponding torque. Because forces are reset at the end of every timestep, you can maintain a total external force on an object by calling this once every frame.  if this call is used to apply a force or impulse to an articulation link, only the link is updated, not the entire articulation  ::PxForceMode determines if the force is to be conventional or impulsive. Only eFORCE and eIMPULSE are supported, as the force required to produce a given velocity change or acceleration is underdetermined given only the desired change at a given point.  Sleeping: This call wakes the actor if it is sleeping and the wakeup parameter is true (default).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ExtAddLocalForceAtPos(MagicPhysX.PxRigidBody@,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxForceMode,System.Boolean)">
            <summary>Applies a force (or impulse) defined in the actor local coordinate frame, acting at a particular point in global coordinates, to the actor.  Note that if the force does not act along the center of mass of the actor, this will also add the corresponding torque. Because forces are reset at the end of every timestep, you can maintain a total external force on an object by calling this once every frame.  if this call is used to apply a force or impulse to an articulation link, only the link is updated, not the entire articulation  ::PxForceMode determines if the force is to be conventional or impulsive. Only eFORCE and eIMPULSE are supported, as the force required to produce a given velocity change or acceleration is underdetermined given only the desired change at a given point.  Sleeping: This call wakes the actor if it is sleeping and the wakeup parameter is true (default).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ExtAddLocalForceAtLocalPos(MagicPhysX.PxRigidBody@,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxForceMode,System.Boolean)">
            <summary>Applies a force (or impulse) defined in the actor local coordinate frame, acting at a particular point in local coordinates, to the actor.  Note that if the force does not act along the center of mass of the actor, this will also add the corresponding torque. Because forces are reset at the end of every timestep, you can maintain a total external force on an object by calling this once every frame.  if this call is used to apply a force or impulse to an articulation link, only the link is updated, not the entire articulation  ::PxForceMode determines if the force is to be conventional or impulsive. Only eFORCE and eIMPULSE are supported, as the force required to produce a given velocity change or acceleration is underdetermined given only the desired change at a given point.  Sleeping: This call wakes the actor if it is sleeping and the wakeup parameter is true (default).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ExtGetVelocityAtPos(MagicPhysX.PxRigidBody@,MagicPhysX.PxVec3*)">
            <summary>Computes the velocity of a point given in world coordinates if it were attached to the specified body and moving with it.  The velocity of point in the global frame.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ExtGetLocalVelocityAtLocalPos(MagicPhysX.PxRigidBody@,MagicPhysX.PxVec3*)">
            <summary>Computes the velocity of a point given in local coordinates if it were attached to the specified body and moving with it.  The velocity of point in the local frame.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ExtGetVelocityAtOffset(MagicPhysX.PxRigidBody@,MagicPhysX.PxVec3*)">
            <summary>Computes the velocity of a point (offset from the origin of the body) given in world coordinates if it were attached to the specified body and moving with it.  The velocity of point (offset from the origin of the body) in the global frame.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ExtComputeVelocityDeltaFromImpulse(MagicPhysX.PxRigidBody@,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>Compute the change to linear and angular velocity that would occur if an impulsive force and torque were to be applied to a specified rigid body.  The rigid body is left unaffected unless a subsequent independent call is executed that actually applies the computed changes to velocity and angular velocity.  if this call is used to determine the velocity delta for an articulation link, only the mass properties of the link are taken into account.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ExtComputeVelocityDeltaFromImpulse1(MagicPhysX.PxRigidBody@,MagicPhysX.PxTransform*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,System.Single,System.Single,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>Computes the linear and angular velocity change vectors for a given impulse at a world space position taking a mass and inertia scale into account  This function is useful for extracting the respective linear and angular velocity changes from a contact or joint when the mass/inertia ratios have been adjusted.  if this call is used to determine the velocity delta for an articulation link, only the mass properties of the link are taken into account.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ExtComputeLinearAngularImpulse(MagicPhysX.PxRigidBody@,MagicPhysX.PxTransform*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,System.Single,System.Single,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>Computes the linear and angular impulse vectors for a given impulse at a world space position taking a mass and inertia scale into account  This function is useful for extracting the respective linear and angular impulses from a contact or joint when the mass/inertia ratios have been adjusted.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ExtLinearSweepSingle(MagicPhysX.PxRigidBody@,MagicPhysX.PxScene*,MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxHitFlags,MagicPhysX.PxSweepHit*,System.UInt32*,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryFilterCallback*,MagicPhysX.PxQueryCache*,System.Single)">
            <summary>Performs a linear sweep through space with the body's geometry objects.  Supported geometries are: box, sphere, capsule, convex. Other geometry types will be ignored.  If eTOUCH is returned from the filter callback, it will trigger an error and the hit will be discarded.  The function sweeps all shapes attached to a given rigid body through space and reports the nearest object in the scene which intersects any of of the shapes swept paths. Information about the closest intersection is written to a [`PxSweepHit`] structure.  True if a blocking hit was found.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ExtLinearSweepMultiple(MagicPhysX.PxRigidBody@,MagicPhysX.PxScene*,MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxHitFlags,MagicPhysX.PxSweepHit*,System.UInt32*,System.UInt32,MagicPhysX.PxSweepHit*,System.Int32*,System.Boolean*,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryFilterCallback*,MagicPhysX.PxQueryCache*,System.Single)">
            <summary>Performs a linear sweep through space with the body's geometry objects, returning all overlaps.  Supported geometries are: box, sphere, capsule, convex. Other geometry types will be ignored.  This function sweeps all shapes attached to a given rigid body through space and reports all objects in the scene that intersect any of the shapes' swept paths until there are no more objects to report or a blocking hit is encountered.  the number of touching hits. If overflow is set to true, the results are incomplete. In case of overflow there are also no guarantees that all touching hits returned are closer than the blocking hit.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxArticulationLink@)">
            <summary>Releases the link from the articulation.  Only a leaf articulation link can be released.  Releasing a link is not allowed while the articulation link is in a scene. In order to release a link, remove and then re-add the corresponding articulation to the scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetArticulation(MagicPhysX.PxArticulationLink@)">
            <summary>Gets the articulation that the link is a part of.  The articulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetInboundJoint(MagicPhysX.PxArticulationLink@)">
            <summary>Gets the joint which connects this link to its parent.  The joint connecting the link to the parent. NULL for the root link.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetInboundJointDof(MagicPhysX.PxArticulationLink@)">
            <summary>Gets the number of degrees of freedom of the joint which connects this link to its parent.  - The root link DOF-count is defined to be 0 regardless of PxArticulationFlag::eFIX_BASE. - The return value is only valid for articulations that are in a scene.  The number of degrees of freedom, or 0xFFFFFFFF if the articulation is not in a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbChildren(MagicPhysX.PxArticulationLink@)">
            <summary>Gets the number of child links.  The number of child links.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetLinkIndex(MagicPhysX.PxArticulationLink@)">
            <summary>Gets the low-level link index that may be used to index into members of PxArticulationCache.  The return value is only valid for articulations that are in a scene.  The low-level index, or 0xFFFFFFFF if the articulation is not in a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetChildren(MagicPhysX.PxArticulationLink@,MagicPhysX.PxArticulationLink**,System.UInt32,System.UInt32)">
            <summary>Retrieves the child links.  The number of articulation links written to the buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetCfmScaleMut(MagicPhysX.PxArticulationLink@,System.Single)">
            <summary>Set the constraint-force-mixing scale term.  The cfm scale term is a stabilization term that helps avoid instabilities with over-constrained configurations. It should be a small value that is multiplied by 1/mass internally to produce an additional bias added to the unit response term in the solver.  Default: 0.025 Range: [0, 1]  This call is not allowed while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetCfmScale(MagicPhysX.PxArticulationLink@)">
            <summary>Get the constraint-force-mixing scale term.  The constraint-force-mixing scale term.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetLinearVelocity(MagicPhysX.PxArticulationLink@)">
            <summary>Get the linear velocity of the link.  - The linear velocity is with respect to the link's center of mass and not the actor frame origin. - For performance, prefer PxArticulationCache::linkVelocity to get link spatial velocities in a batch query. - When the articulation state is updated via non-cache API, use PxArticulationReducedCoordinate::updateKinematic before querying velocity.  The linear velocity of the link.  This call is not allowed while the simulation is running except in a split simulation during [`PxScene::collide`]() and up to #PxScene::advance(), and in PxContactModifyCallback or in contact report callbacks.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetAngularVelocity(MagicPhysX.PxArticulationLink@)">
            <summary>Get the angular velocity of the link.  - For performance, prefer PxArticulationCache::linkVelocity to get link spatial velocities in a batch query. - When the articulation state is updated via non-cache API, use PxArticulationReducedCoordinate::updateKinematic before querying velocity.  The angular velocity of the link.  This call is not allowed while the simulation is running except in a split simulation during [`PxScene::collide`]() and up to #PxScene::advance(), and in PxContactModifyCallback or in contact report callbacks.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetConcreteTypeName(MagicPhysX.PxArticulationLink@)">
            <summary>Returns the string name of the dynamic type.  The string name.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxConstraint@)">
            <summary>Releases a PxConstraint instance.  This call does not wake up the connected rigid bodies.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetScene(MagicPhysX.PxConstraint@)">
            <summary>Retrieves the scene which this constraint belongs to.  Owner Scene. NULL if not part of a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetActors(MagicPhysX.PxConstraint@,MagicPhysX.PxRigidActor**,MagicPhysX.PxRigidActor**)">
            <summary>Retrieves the actors for this constraint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetActorsMut(MagicPhysX.PxConstraint@,MagicPhysX.PxRigidActor*,MagicPhysX.PxRigidActor*)">
            <summary>Sets the actors for this constraint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.MarkDirtyMut(MagicPhysX.PxConstraint@)">
            <summary>Notify the scene that the constraint shader data has been updated by the application</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetFlags(MagicPhysX.PxConstraint@)">
            <summary>Retrieve the flags for this constraint  the constraint flags</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetFlagsMut(MagicPhysX.PxConstraint@,MagicPhysX.PxConstraintFlags)">
            <summary>Set the flags for this constraint  default: PxConstraintFlag::eDRIVE_LIMITS_ARE_FORCES</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetFlagMut(MagicPhysX.PxConstraint@,MagicPhysX.PxConstraintFlag,System.Boolean)">
            <summary>Set a flag for this constraint</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetForce(MagicPhysX.PxConstraint@,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>Retrieve the constraint force most recently applied to maintain this constraint.  It is not allowed to use this method while the simulation is running (except during PxScene::collide(), in PxContactModifyCallback or in contact report callbacks).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxConstraint@)">
            <summary>whether the constraint is valid.  A constraint is valid if it has at least one dynamic rigid body or articulation link. A constraint that is not valid may not be inserted into a scene, and therefore a static actor to which an invalid constraint is attached may not be inserted into a scene.  Invalid constraints arise only when an actor to which the constraint is attached has been deleted.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetBreakForceMut(MagicPhysX.PxConstraint@,System.Single,System.Single)">
            <summary>Set the break force and torque thresholds for this constraint.  If either the force or torque measured at the constraint exceed these thresholds the constraint will break.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetBreakForce(MagicPhysX.PxConstraint@,System.Single*,System.Single*)">
            <summary>Retrieve the constraint break force and torque thresholds</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetMinResponseThresholdMut(MagicPhysX.PxConstraint@,System.Single)">
            <summary>Set the minimum response threshold for a constraint row  When using mass modification for a joint or infinite inertia for a jointed body, very stiff solver constraints can be generated which can destabilize simulation. Setting this value to a small positive value (e.g. 1e-8) will cause constraint rows to be ignored if very large changes in impulses will generate only small changes in velocity. When setting this value, also set PxConstraintFlag::eDISABLE_PREPROCESSING. The solver accuracy for this joint may be reduced.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetMinResponseThreshold(MagicPhysX.PxConstraint@)">
            <summary>Retrieve the constraint break force and torque thresholds  the minimum response threshold for a constraint row</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetExternalReferenceMut(MagicPhysX.PxConstraint@,System.UInt32*)">
            <summary>Fetch external owner of the constraint.  Provides a reference to the external owner of a constraint and a unique owner type ID.  Reference to the external object which owns the constraint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetConstraintFunctionsMut(MagicPhysX.PxConstraint@,MagicPhysX.PxConstraintConnector*,MagicPhysX.PxConstraintShaderTable*)">
            <summary>Set the constraint functions for this constraint</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.HasNextPatch(MagicPhysX.PxContactStreamIterator@)">
            <summary>Returns whether there are more patches in this stream.  Whether there are more patches in this stream.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetTotalContactCount(MagicPhysX.PxContactStreamIterator@)">
            <summary>Returns the total contact count.  Total contact count.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetTotalPatchCount(MagicPhysX.PxContactStreamIterator@)">
            <summary>Returns the total patch count.  Total patch count.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.NextPatchMut(MagicPhysX.PxContactStreamIterator@)">
            <summary>Advances iterator to next contact patch.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.HasNextContact(MagicPhysX.PxContactStreamIterator@)">
            <summary>Returns if the current patch has more contacts.  If there are more contacts in the current patch.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.NextContactMut(MagicPhysX.PxContactStreamIterator@)">
            <summary>Advances to the next contact in the patch.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetContactNormal(MagicPhysX.PxContactStreamIterator@)">
            <summary>Gets the current contact's normal  The current contact's normal.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetInvMassScale0(MagicPhysX.PxContactStreamIterator@)">
            <summary>Gets the inverse mass scale for body 0.  The inverse mass scale for body 0.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetInvMassScale1(MagicPhysX.PxContactStreamIterator@)">
            <summary>Gets the inverse mass scale for body 1.  The inverse mass scale for body 1.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetInvInertiaScale0(MagicPhysX.PxContactStreamIterator@)">
            <summary>Gets the inverse inertia scale for body 0.  The inverse inertia scale for body 0.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetInvInertiaScale1(MagicPhysX.PxContactStreamIterator@)">
            <summary>Gets the inverse inertia scale for body 1.  The inverse inertia scale for body 1.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetMaxImpulse(MagicPhysX.PxContactStreamIterator@)">
            <summary>Gets the contact's max impulse.  The contact's max impulse.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetTargetVel(MagicPhysX.PxContactStreamIterator@)">
            <summary>Gets the contact's target velocity.  The contact's target velocity.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetContactPoint(MagicPhysX.PxContactStreamIterator@)">
            <summary>Gets the contact's contact point.  The contact's contact point.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSeparation(MagicPhysX.PxContactStreamIterator@)">
            <summary>Gets the contact's separation.  The contact's separation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetFaceIndex0(MagicPhysX.PxContactStreamIterator@)">
            <summary>Gets the contact's face index for shape 0.  The contact's face index for shape 0.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetFaceIndex1(MagicPhysX.PxContactStreamIterator@)">
            <summary>Gets the contact's face index for shape 1.  The contact's face index for shape 1.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetStaticFriction(MagicPhysX.PxContactStreamIterator@)">
            <summary>Gets the contact's static friction coefficient.  The contact's static friction coefficient.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetDynamicFriction(MagicPhysX.PxContactStreamIterator@)">
            <summary>Gets the contact's dynamic friction coefficient.  The contact's dynamic friction coefficient.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetRestitution(MagicPhysX.PxContactStreamIterator@)">
            <summary>Gets the contact's restitution coefficient.  The contact's restitution coefficient.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetDamping(MagicPhysX.PxContactStreamIterator@)">
            <summary>Gets the contact's damping value.  The contact's damping value.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetMaterialFlags(MagicPhysX.PxContactStreamIterator@)">
            <summary>Gets the contact's material flags.  The contact's material flags.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetMaterialIndex0(MagicPhysX.PxContactStreamIterator@)">
            <summary>Gets the contact's material index for shape 0.  The contact's material index for shape 0.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetMaterialIndex1(MagicPhysX.PxContactStreamIterator@)">
            <summary>Gets the contact's material index for shape 1.  The contact's material index for shape 1.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AdvanceToIndexMut(MagicPhysX.PxContactStreamIterator@,System.UInt32)">
            <summary>Advances the contact stream iterator to a specific contact index.  True if advancing was possible</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetPoint(MagicPhysX.PxContactSet@,System.UInt32)">
            <summary>Get the position of a specific contact point in the set.  Position to the requested point in world space</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetPointMut(MagicPhysX.PxContactSet@,System.UInt32,MagicPhysX.PxVec3*)">
            <summary>Alter the position of a specific contact point in the set.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNormal(MagicPhysX.PxContactSet@,System.UInt32)">
            <summary>Get the contact normal of a specific contact point in the set.  The requested normal in world space</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetNormalMut(MagicPhysX.PxContactSet@,System.UInt32,MagicPhysX.PxVec3*)">
            <summary>Alter the contact normal of a specific contact point in the set.  Changing the normal can cause contact points to be ignored.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSeparation(MagicPhysX.PxContactSet@,System.UInt32)">
            <summary>Get the separation distance of a specific contact point in the set.  The separation. Negative implies penetration.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetSeparationMut(MagicPhysX.PxContactSet@,System.UInt32,System.Single)">
            <summary>Alter the separation of a specific contact point in the set.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetTargetVelocity(MagicPhysX.PxContactSet@,System.UInt32)">
            <summary>Get the target velocity of a specific contact point in the set.  The target velocity in world frame</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetTargetVelocityMut(MagicPhysX.PxContactSet@,System.UInt32,MagicPhysX.PxVec3*)">
            <summary>Alter the target velocity of a specific contact point in the set.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetInternalFaceIndex0(MagicPhysX.PxContactSet@,System.UInt32)">
            <summary>Get the face index with respect to the first shape of the pair for a specific contact point in the set.  The face index of the first shape  At the moment, the first shape is never a tri-mesh, therefore this function always returns PXC_CONTACT_NO_FACE_INDEX</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetInternalFaceIndex1(MagicPhysX.PxContactSet@,System.UInt32)">
            <summary>Get the face index with respect to the second shape of the pair for a specific contact point in the set.  The face index of the second shape</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetMaxImpulse(MagicPhysX.PxContactSet@,System.UInt32)">
            <summary>Get the maximum impulse for a specific contact point in the set.  The maximum impulse</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetMaxImpulseMut(MagicPhysX.PxContactSet@,System.UInt32,System.Single)">
            <summary>Alter the maximum impulse for a specific contact point in the set.  Must be nonnegative. If set to zero, the contact point will be ignored</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetRestitution(MagicPhysX.PxContactSet@,System.UInt32)">
            <summary>Get the restitution coefficient for a specific contact point in the set.  The restitution coefficient</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetRestitutionMut(MagicPhysX.PxContactSet@,System.UInt32,System.Single)">
            <summary>Alter the restitution coefficient for a specific contact point in the set.  Valid ranges [0,1]</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetStaticFriction(MagicPhysX.PxContactSet@,System.UInt32)">
            <summary>Get the static friction coefficient for a specific contact point in the set.  The friction coefficient (dimensionless)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetStaticFrictionMut(MagicPhysX.PxContactSet@,System.UInt32,System.Single)">
            <summary>Alter the static friction coefficient for a specific contact point in the set.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetDynamicFriction(MagicPhysX.PxContactSet@,System.UInt32)">
            <summary>Get the static friction coefficient for a specific contact point in the set.  The friction coefficient</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetDynamicFrictionMut(MagicPhysX.PxContactSet@,System.UInt32,System.Single)">
            <summary>Alter the static dynamic coefficient for a specific contact point in the set.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IgnoreMut(MagicPhysX.PxContactSet@,System.UInt32)">
            <summary>Ignore the contact point.  If a contact point is ignored then no force will get applied at this point. This can be used to disable collision in certain areas of a shape, for example.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Size(MagicPhysX.PxContactSet@)">
            <summary>The number of contact points in the set.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetInvMassScale0(MagicPhysX.PxContactSet@)">
            <summary>Returns the invMassScale of body 0  A value &lt; 1.0 makes this contact treat the body as if it had larger mass. A value of 0.f makes this contact treat the body as if it had infinite mass. Any value &gt; 1.f makes this contact treat the body as if it had smaller mass.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetInvMassScale1(MagicPhysX.PxContactSet@)">
            <summary>Returns the invMassScale of body 1  A value &lt; 1.0 makes this contact treat the body as if it had larger mass. A value of 0.f makes this contact treat the body as if it had infinite mass. Any value &gt; 1.f makes this contact treat the body as if it had smaller mass.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetInvInertiaScale0(MagicPhysX.PxContactSet@)">
            <summary>Returns the invInertiaScale of body 0  A value &lt; 1.0 makes this contact treat the body as if it had larger inertia. A value of 0.f makes this contact treat the body as if it had infinite inertia. Any value &gt; 1.f makes this contact treat the body as if it had smaller inertia.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetInvInertiaScale1(MagicPhysX.PxContactSet@)">
            <summary>Returns the invInertiaScale of body 1  A value &lt; 1.0 makes this contact treat the body as if it had larger inertia. A value of 0.f makes this contact treat the body as if it had infinite inertia. Any value &gt; 1.f makes this contact treat the body as if it had smaller inertia.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetInvMassScale0Mut(MagicPhysX.PxContactSet@,System.Single)">
            <summary>Sets the invMassScale of body 0  This can be set to any value in the range [0, PX_MAX_F32). A value &lt; 1.0 makes this contact treat the body as if it had larger mass. A value of 0.f makes this contact treat the body as if it had infinite mass. Any value &gt; 1.f makes this contact treat the body as if it had smaller mass.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetInvMassScale1Mut(MagicPhysX.PxContactSet@,System.Single)">
            <summary>Sets the invMassScale of body 1  This can be set to any value in the range [0, PX_MAX_F32). A value &lt; 1.0 makes this contact treat the body as if it had larger mass. A value of 0.f makes this contact treat the body as if it had infinite mass. Any value &gt; 1.f makes this contact treat the body as if it had smaller mass.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetInvInertiaScale0Mut(MagicPhysX.PxContactSet@,System.Single)">
            <summary>Sets the invInertiaScale of body 0  This can be set to any value in the range [0, PX_MAX_F32). A value &lt; 1.0 makes this contact treat the body as if it had larger inertia. A value of 0.f makes this contact treat the body as if it had infinite inertia. Any value &gt; 1.f makes this contact treat the body as if it had smaller inertia.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetInvInertiaScale1Mut(MagicPhysX.PxContactSet@,System.Single)">
            <summary>Sets the invInertiaScale of body 1  This can be set to any value in the range [0, PX_MAX_F32). A value &lt; 1.0 makes this contact treat the body as if it had larger inertia. A value of 0.f makes this contact treat the body as if it had infinite inertia. Any value &gt; 1.f makes this contact treat the body as if it had smaller inertia.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.OnContactModifyMut(MagicPhysX.PxContactModifyCallback@,MagicPhysX.PxContactModifyPair*,System.UInt32)">
            <summary>Passes modifiable arrays of contacts to the application.  The initial contacts are regenerated from scratch each frame by collision detection.  The number of contacts can not be changed, so you cannot add your own contacts.  You may however disable contacts using PxContactSet::ignore().</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.OnCCDContactModifyMut(MagicPhysX.PxCCDContactModifyCallback@,MagicPhysX.PxContactModifyPair*,System.UInt32)">
            <summary>Passes modifiable arrays of contacts to the application.  The initial contacts are regenerated from scratch each frame by collision detection.  The number of contacts can not be changed, so you cannot add your own contacts.  You may however disable contacts using PxContactSet::ignore().</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.OnReleaseMut(MagicPhysX.PxDeletionListener@,MagicPhysX.PxBase*,System.Void*,MagicPhysX.PxDeletionEventFlag)">
            <summary>Notification if an object or its memory gets released  If release() gets called on a PxBase object, an eUSER_RELEASE event will get fired immediately. The object state can be queried in the callback but it is not allowed to change the state. Furthermore, when reading from the object it is the user's responsibility to make sure that no other thread is writing at the same time to the object (this includes the simulation itself, i.e., [`PxScene::fetchResults`]() must not get called at the same time).  Calling release() on a PxBase object does not necessarily trigger its destructor immediately. For example, the object can be shared and might still be referenced by other objects or the simulation might still be running and accessing the object state. In such cases the destructor will be called as soon as it is safe to do so. After the destruction of the object and its memory, an eMEMORY_RELEASE event will get fired. In this case it is not allowed to dereference the object pointer in the callback.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetYoungsModulusMut(MagicPhysX.PxFEMMaterial@,System.Single)">
            <summary>Sets young's modulus which defines the body's stiffness</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetYoungsModulus(MagicPhysX.PxFEMMaterial@)">
            <summary>Retrieves the young's modulus value.  The young's modulus value.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetPoissonsMut(MagicPhysX.PxFEMMaterial@,System.Single)">
            <summary>Sets the Poisson's ratio which defines the body's volume preservation. Completely incompressible materials have a poisson ratio of 0.5. Its value should not be set to exactly 0.5 because this leads to numerical problems.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetPoissons(MagicPhysX.PxFEMMaterial@)">
            <summary>Retrieves the Poisson's ratio.  The Poisson's ratio.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetDynamicFrictionMut(MagicPhysX.PxFEMMaterial@,System.Single)">
            <summary>Sets the dynamic friction value which defines the strength of resistance when two objects slide relative to each other while in contact.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetDynamicFriction(MagicPhysX.PxFEMMaterial@)">
            <summary>Retrieves the dynamic friction value  The dynamic friction value</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetToDefaultMut(MagicPhysX.PxFilterData@)">
            <summary>(re)sets the structure to the default.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.QueryFilterDataNew1(MagicPhysX.PxFilterData@,MagicPhysX.PxQueryFlags)">
            <summary>constructor to set both filter data and filter flags</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PairFoundMut(MagicPhysX.PxSimulationFilterCallback@,System.UInt32,System.UInt32,MagicPhysX.PxFilterData,MagicPhysX.PxActor*,MagicPhysX.PxShape*,System.UInt32,MagicPhysX.PxFilterData,MagicPhysX.PxActor*,MagicPhysX.PxShape*,MagicPhysX.PxPairFlags*)">
            <summary>Filter method to specify how a pair of potentially colliding objects should be processed.  This method gets called when the filter flags returned by the filter shader (see [`PxSimulationFilterShader`]) indicate that the filter callback should be invoked ([`PxFilterFlag::eCALLBACK`] or #PxFilterFlag::eNOTIFY set). Return the PxFilterFlag flags and set the PxPairFlag flags to define what the simulation should do with the given collision pair.  Filter flags defining whether the pair should be discarded, temporarily ignored or processed and whether the pair should be tracked and send a report on pair deletion through the filter callback</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PairLostMut(MagicPhysX.PxSimulationFilterCallback@,System.UInt32,System.UInt32,MagicPhysX.PxFilterData,System.UInt32,MagicPhysX.PxFilterData,System.Boolean)">
            <summary>Callback to inform that a tracked collision pair is gone.  This method gets called when a collision pair disappears or gets re-filtered. Only applies to collision pairs which have been marked as filter callback pairs ([`PxFilterFlag::eNOTIFY`] set in #pairFound()).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.StatusChangeMut(MagicPhysX.PxSimulationFilterCallback@,System.UInt32*,MagicPhysX.PxPairFlags*,MagicPhysX.PxFilterFlags*)">
            <summary>Callback to give the opportunity to change the filter state of a tracked collision pair.  This method gets called once per simulation step to let the application change the filter and pair flags of a collision pair that has been reported in [`pairFound`]() and requested callbacks by setting [`PxFilterFlag::eNOTIFY`]. To request a change of filter status, the target pair has to be specified by its ID, the new filter and pair flags have to be provided and the method should return true.  If this method changes the filter status of a collision pair and the pair should keep being tracked by the filter callbacks then [`PxFilterFlag::eNOTIFY`] has to be set.  The application is responsible to ensure that this method does not get called for pairs that have been reported as lost, see [`pairLost`]().  True if the changes should be applied. In this case the method will get called again. False if no more status changes should be done in the current simulation step. In that case the provided flags will be discarded.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetDataAccessFlagsMut(MagicPhysX.PxLockedData@)">
            <summary>Any combination of PxDataAccessFlag::eREADABLE and PxDataAccessFlag::eWRITABLE</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.UnlockMut(MagicPhysX.PxLockedData@)">
            <summary>Unlocks the bulk data.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Delete(MagicPhysX.PxLockedData@)">
            <summary>virtual destructor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetDynamicFrictionMut(MagicPhysX.PxMaterial@,System.Single)">
            <summary>Sets the coefficient of dynamic friction.  The coefficient of dynamic friction should be in [0, PX_MAX_F32). If set to greater than staticFriction, the effective value of staticFriction will be increased to match.  Sleeping: Does NOT wake any actors which may be affected.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetDynamicFriction(MagicPhysX.PxMaterial@)">
            <summary>Retrieves the DynamicFriction value.  The coefficient of dynamic friction.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetStaticFrictionMut(MagicPhysX.PxMaterial@,System.Single)">
            <summary>Sets the coefficient of static friction  The coefficient of static friction should be in the range [0, PX_MAX_F32)  Sleeping: Does NOT wake any actors which may be affected.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetStaticFriction(MagicPhysX.PxMaterial@)">
            <summary>Retrieves the coefficient of static friction.  The coefficient of static friction.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetRestitutionMut(MagicPhysX.PxMaterial@,System.Single)">
            <summary>Sets the coefficient of restitution  A coefficient of 0 makes the object bounce as little as possible, higher values up to 1.0 result in more bounce.  This property is overloaded when PxMaterialFlag::eCOMPLIANT_CONTACT flag is enabled. This permits negative values for restitution to be provided. The negative values are converted into spring stiffness terms for an implicit spring simulated at the contact site, with the spring positional error defined by the contact separation value. Higher stiffness terms produce stiffer springs that behave more like a rigid contact.  Sleeping: Does NOT wake any actors which may be affected.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetRestitution(MagicPhysX.PxMaterial@)">
            <summary>Retrieves the coefficient of restitution.  See [`setRestitution`].  The coefficient of restitution.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetDampingMut(MagicPhysX.PxMaterial@,System.Single)">
            <summary>Sets the coefficient of damping  This property only affects the simulation if PxMaterialFlag::eCOMPLIANT_CONTACT is raised. Damping works together with spring stiffness (set through a negative restitution value). Spring stiffness corrects positional error while damping resists relative velocity. Setting a high damping coefficient can produce spongy contacts.  Sleeping: Does NOT wake any actors which may be affected.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetDamping(MagicPhysX.PxMaterial@)">
            <summary>Retrieves the coefficient of damping.  See [`setDamping`].  The coefficient of damping.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetFlagMut(MagicPhysX.PxMaterial@,MagicPhysX.PxMaterialFlag,System.Boolean)">
            <summary>Raises or clears a particular material flag.  See the list of flags [`PxMaterialFlag`]  Default: eIMPROVED_PATCH_FRICTION  Sleeping: Does NOT wake any actors which may be affected.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetFlagsMut(MagicPhysX.PxMaterial@,MagicPhysX.PxMaterialFlags)">
            <summary>sets all the material flags.  See the list of flags [`PxMaterialFlag`]  Default: eIMPROVED_PATCH_FRICTION  Sleeping: Does NOT wake any actors which may be affected.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetFlags(MagicPhysX.PxMaterial@)">
            <summary>Retrieves the flags. See [`PxMaterialFlag`].  The material flags.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetFrictionCombineModeMut(MagicPhysX.PxMaterial@,MagicPhysX.PxCombineMode)">
            <summary>Sets the friction combine mode.  See the enum ::PxCombineMode .  Default: PxCombineMode::eAVERAGE  Sleeping: Does NOT wake any actors which may be affected.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetFrictionCombineMode(MagicPhysX.PxMaterial@)">
            <summary>Retrieves the friction combine mode.  See [`setFrictionCombineMode`].  The friction combine mode for this material.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetRestitutionCombineModeMut(MagicPhysX.PxMaterial@,MagicPhysX.PxCombineMode)">
            <summary>Sets the restitution combine mode.  See the enum ::PxCombineMode .  Default: PxCombineMode::eAVERAGE  Sleeping: Does NOT wake any actors which may be affected.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetRestitutionCombineMode(MagicPhysX.PxMaterial@)">
            <summary>Retrieves the restitution combine mode.  See [`setRestitutionCombineMode`].  The coefficient of restitution combine mode for this material.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetToDefaultMut(MagicPhysX.PxDiffuseParticleParams@)">
            <summary>(re)sets the structure to the default.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetFrictionMut(MagicPhysX.PxParticleMaterial@,System.Single)">
            <summary>Sets friction</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetFriction(MagicPhysX.PxParticleMaterial@)">
            <summary>Retrieves the friction value.  The friction value.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetDampingMut(MagicPhysX.PxParticleMaterial@,System.Single)">
            <summary>Sets velocity damping term</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetDamping(MagicPhysX.PxParticleMaterial@)">
            <summary>Retrieves the velocity damping term  The velocity damping term.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetAdhesionMut(MagicPhysX.PxParticleMaterial@,System.Single)">
            <summary>Sets adhesion term</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetAdhesion(MagicPhysX.PxParticleMaterial@)">
            <summary>Retrieves the adhesion term  The adhesion term.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetGravityScaleMut(MagicPhysX.PxParticleMaterial@,System.Single)">
            <summary>Sets gravity scale term</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetGravityScale(MagicPhysX.PxParticleMaterial@)">
            <summary>Retrieves the gravity scale term  The gravity scale term.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetAdhesionRadiusScaleMut(MagicPhysX.PxParticleMaterial@,System.Single)">
            <summary>Sets material adhesion radius scale. This is multiplied by the particle rest offset to compute the fall-off distance at which point adhesion ceases to operate.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetAdhesionRadiusScale(MagicPhysX.PxParticleMaterial@)">
            <summary>Retrieves the adhesion radius scale.  The adhesion radius scale.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxPhysics@)">
            <summary>Destroys the instance it is called on.  Use this release method to destroy an instance of this class. Be sure to not keep a reference to this object after calling release. Avoid release calls while a scene is simulating (in between simulate() and fetchResults() calls).  Note that this must be called once for each prior call to PxCreatePhysics, as there is a reference counter. Also note that you mustn't destroy the PxFoundation instance (holding the allocator, error callback etc.) until after the reference count reaches 0 and the SDK is actually removed.  Releasing an SDK will also release any objects created through it (scenes, triangle meshes, convex meshes, heightfields, shapes etc.), provided the user hasn't already done so.  Releasing the PxPhysics instance is a prerequisite to releasing the PxFoundation instance.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetFoundationMut(MagicPhysX.PxPhysics@)">
            <summary>Retrieves the Foundation instance.  A reference to the Foundation object.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CreateAggregateMut(MagicPhysX.PxPhysics@,System.UInt32,System.UInt32,System.UInt32)">
            <summary>Creates an aggregate with the specified maximum size and filtering hint.  The previous API used \"bool enableSelfCollision\" which should now silently evaluates to a PxAggregateType::eGENERIC aggregate with its self-collision bit.  Use PxAggregateType::eSTATIC or PxAggregateType::eKINEMATIC for aggregates that will only contain static or kinematic actors. This provides faster filtering when used in combination with PxPairFilteringMode.  The new aggregate.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetTolerancesScale(MagicPhysX.PxPhysics@)">
            <summary>Returns the simulation tolerance parameters.  The current simulation tolerance parameters.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CreateTriangleMeshMut(MagicPhysX.PxPhysics@,MagicPhysX.PxInputStream*)">
            <summary>Creates a triangle mesh object.  This can then be instanced into [`PxShape`] objects.  The new triangle mesh.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbTriangleMeshes(MagicPhysX.PxPhysics@)">
            <summary>Return the number of triangle meshes that currently exist.  Number of triangle meshes.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetTriangleMeshes(MagicPhysX.PxPhysics@,MagicPhysX.PxTriangleMesh**,System.UInt32,System.UInt32)">
            <summary>Writes the array of triangle mesh pointers to a user buffer.  Returns the number of pointers written.  The ordering of the triangle meshes in the array is not specified.  The number of triangle mesh pointers written to userBuffer, this should be less or equal to bufferSize.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CreateTetrahedronMeshMut(MagicPhysX.PxPhysics@,MagicPhysX.PxInputStream*)">
            <summary>Creates a tetrahedron mesh object.  This can then be instanced into [`PxShape`] objects.  The new tetrahedron mesh.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CreateSoftBodyMeshMut(MagicPhysX.PxPhysics@,MagicPhysX.PxInputStream*)">
            <summary>Creates a softbody mesh object.  The new softbody mesh.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbTetrahedronMeshes(MagicPhysX.PxPhysics@)">
            <summary>Return the number of tetrahedron meshes that currently exist.  Number of tetrahedron meshes.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetTetrahedronMeshes(MagicPhysX.PxPhysics@,MagicPhysX.PxTetrahedronMesh**,System.UInt32,System.UInt32)">
            <summary>Writes the array of tetrahedron mesh pointers to a user buffer.  Returns the number of pointers written.  The ordering of the tetrahedron meshes in the array is not specified.  The number of tetrahedron mesh pointers written to userBuffer, this should be less or equal to bufferSize.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CreateHeightFieldMut(MagicPhysX.PxPhysics@,MagicPhysX.PxInputStream*)">
            <summary>Creates a heightfield object from previously cooked stream.  This can then be instanced into [`PxShape`] objects.  The new heightfield.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbHeightFields(MagicPhysX.PxPhysics@)">
            <summary>Return the number of heightfields that currently exist.  Number of heightfields.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetHeightFields(MagicPhysX.PxPhysics@,MagicPhysX.PxHeightField**,System.UInt32,System.UInt32)">
            <summary>Writes the array of heightfield pointers to a user buffer.  Returns the number of pointers written.  The ordering of the heightfields in the array is not specified.  The number of heightfield pointers written to userBuffer, this should be less or equal to bufferSize.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CreateConvexMeshMut(MagicPhysX.PxPhysics@,MagicPhysX.PxInputStream*)">
            <summary>Creates a convex mesh object.  This can then be instanced into [`PxShape`] objects.  The new convex mesh.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbConvexMeshes(MagicPhysX.PxPhysics@)">
            <summary>Return the number of convex meshes that currently exist.  Number of convex meshes.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetConvexMeshes(MagicPhysX.PxPhysics@,MagicPhysX.PxConvexMesh**,System.UInt32,System.UInt32)">
            <summary>Writes the array of convex mesh pointers to a user buffer.  Returns the number of pointers written.  The ordering of the convex meshes in the array is not specified.  The number of convex mesh pointers written to userBuffer, this should be less or equal to bufferSize.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CreateBVHMut(MagicPhysX.PxPhysics@,MagicPhysX.PxInputStream*)">
            <summary>Creates a bounding volume hierarchy.  The new BVH.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbBVHs(MagicPhysX.PxPhysics@)">
            <summary>Return the number of bounding volume hierarchies that currently exist.  Number of bounding volume hierarchies.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetBVHs(MagicPhysX.PxPhysics@,MagicPhysX.PxBVH**,System.UInt32,System.UInt32)">
            <summary>Writes the array of bounding volume hierarchy pointers to a user buffer.  Returns the number of pointers written.  The ordering of the BVHs in the array is not specified.  The number of BVH pointers written to userBuffer, this should be less or equal to bufferSize.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CreateSceneMut(MagicPhysX.PxPhysics@,MagicPhysX.PxSceneDesc*)">
            <summary>Creates a scene.  Every scene uses a Thread Local Storage slot. This imposes a platform specific limit on the number of scenes that can be created.  The new scene object.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbScenes(MagicPhysX.PxPhysics@)">
            <summary>Gets number of created scenes.  The number of scenes created.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetScenes(MagicPhysX.PxPhysics@,MagicPhysX.PxScene**,System.UInt32,System.UInt32)">
            <summary>Writes the array of scene pointers to a user buffer.  Returns the number of pointers written.  The ordering of the scene pointers in the array is not specified.  The number of scene pointers written to userBuffer, this should be less or equal to bufferSize.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CreateRigidStaticMut(MagicPhysX.PxPhysics@,MagicPhysX.PxTransform*)">
            <summary>Creates a static rigid actor with the specified pose and all other fields initialized to their default values.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CreateRigidDynamicMut(MagicPhysX.PxPhysics@,MagicPhysX.PxTransform*)">
            <summary>Creates a dynamic rigid actor with the specified pose and all other fields initialized to their default values.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CreatePruningStructureMut(MagicPhysX.PxPhysics@,MagicPhysX.PxRigidActor**,System.UInt32)">
            <summary>Creates a pruning structure from actors.  Every provided actor needs at least one shape with the eSCENE_QUERY_SHAPE flag set.  Both static and dynamic actors can be provided.  It is not allowed to pass in actors which are already part of a scene.  Articulation links cannot be provided.  Pruning structure created from given actors, or NULL if any of the actors did not comply with the above requirements.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CreateShapeMut(MagicPhysX.PxPhysics@,MagicPhysX.PxGeometry*,MagicPhysX.PxMaterial*,System.Boolean,MagicPhysX.PxShapeFlags)">
            <summary>Creates a shape which may be attached to multiple actors  The shape will be created with a reference count of 1.  The shape  Shared shapes are not mutable when they are attached to an actor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CreateShapeMut1(MagicPhysX.PxPhysics@,MagicPhysX.PxGeometry*,MagicPhysX.PxMaterial**,System.UInt16,System.Boolean,MagicPhysX.PxShapeFlags)">
            <summary>Creates a shape which may be attached to multiple actors  The shape will be created with a reference count of 1.  The shape  Shared shapes are not mutable when they are attached to an actor  Shapes created from *SDF* triangle-mesh geometries do not support more than one material.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbShapes(MagicPhysX.PxPhysics@)">
            <summary>Return the number of shapes that currently exist.  Number of shapes.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetShapes(MagicPhysX.PxPhysics@,MagicPhysX.PxShape**,System.UInt32,System.UInt32)">
            <summary>Writes the array of shape pointers to a user buffer.  Returns the number of pointers written.  The ordering of the shapes in the array is not specified.  The number of shape pointers written to userBuffer, this should be less or equal to bufferSize.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CreateConstraintMut(MagicPhysX.PxPhysics@,MagicPhysX.PxRigidActor*,MagicPhysX.PxRigidActor*,MagicPhysX.PxConstraintConnector*,MagicPhysX.PxConstraintShaderTable*,System.UInt32)">
            <summary>Creates a constraint shader.  A constraint shader will get added automatically to the scene the two linked actors belong to. Either, but not both, of actor0 and actor1 may be NULL to denote attachment to the world.  The new constraint shader.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CreateArticulationReducedCoordinateMut(MagicPhysX.PxPhysics@)">
            <summary>Creates a reduced-coordinate articulation with all fields initialized to their default values.  the new articulation</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CreateMaterialMut(MagicPhysX.PxPhysics@,System.Single,System.Single,System.Single)">
            <summary>Creates a new rigid body material with certain default properties.  The new rigid body material.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbMaterials(MagicPhysX.PxPhysics@)">
            <summary>Return the number of rigid body materials that currently exist.  Number of rigid body materials.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetMaterials(MagicPhysX.PxPhysics@,MagicPhysX.PxMaterial**,System.UInt32,System.UInt32)">
            <summary>Writes the array of rigid body material pointers to a user buffer.  Returns the number of pointers written.  The ordering of the materials in the array is not specified.  The number of material pointers written to userBuffer, this should be less or equal to bufferSize.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.RegisterDeletionListenerMut(MagicPhysX.PxPhysics@,MagicPhysX.PxDeletionListener*,MagicPhysX.PxDeletionEventFlags*,System.Boolean)">
            <summary>Register a deletion listener. Listeners will be called whenever an object is deleted.  It is illegal to register or unregister a deletion listener while deletions are being processed.  By default a registered listener will receive events from all objects. Set the restrictedObjectSet parameter to true on registration and use [`registerDeletionListenerObjects`] to restrict the received events to specific objects.  The deletion events are only supported on core PhysX objects. In general, objects in extension modules do not provide this functionality, however, in the case of PxJoint objects, the underlying PxConstraint will send the events.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.UnregisterDeletionListenerMut(MagicPhysX.PxPhysics@,MagicPhysX.PxDeletionListener*)">
            <summary>Unregister a deletion listener.  It is illegal to register or unregister a deletion listener while deletions are being processed.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.RegisterDeletionListenerObjectsMut(MagicPhysX.PxPhysics@,MagicPhysX.PxDeletionListener*,MagicPhysX.PxBase**,System.UInt32)">
            <summary>Register specific objects for deletion events.  This method allows for a deletion listener to limit deletion events to specific objects only.  It is illegal to register or unregister objects while deletions are being processed.  The deletion listener has to be registered through [`registerDeletionListener`]() and configured to support restricted object sets prior to this method being used.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.UnregisterDeletionListenerObjectsMut(MagicPhysX.PxPhysics@,MagicPhysX.PxDeletionListener*,MagicPhysX.PxBase**,System.UInt32)">
            <summary>Unregister specific objects for deletion events.  This method allows to clear previously registered objects for a deletion listener (see [`registerDeletionListenerObjects`]()).  It is illegal to register or unregister objects while deletions are being processed.  The deletion listener has to be registered through [`registerDeletionListener`]() and configured to support restricted object sets prior to this method being used.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetPhysicsInsertionCallbackMut(MagicPhysX.PxPhysics@)">
            <summary>Gets PxPhysics object insertion interface.  The insertion interface is needed for PxCreateTriangleMesh, PxCooking::createTriangleMesh etc., this allows runtime mesh creation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxDistanceJointCreate(MagicPhysX.PxPhysics@,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*)">
            <summary>Create a distance Joint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxContactJointCreate(MagicPhysX.PxPhysics@,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*)">
            <summary>Create a distance Joint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxFixedJointCreate(MagicPhysX.PxPhysics@,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*)">
            <summary>Create a fixed joint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxPrismaticJointCreate(MagicPhysX.PxPhysics@,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*)">
            <summary>Create a prismatic joint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxRevoluteJointCreate(MagicPhysX.PxPhysics@,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*)">
            <summary>Create a revolute joint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxSphericalJointCreate(MagicPhysX.PxPhysics@,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*)">
            <summary>Create a spherical joint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxD6JointCreate(MagicPhysX.PxPhysics@,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*)">
            <summary>Create a D6 joint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxGearJointCreate(MagicPhysX.PxPhysics@,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*)">
            <summary>Create a gear Joint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxRackAndPinionJointCreate(MagicPhysX.PxPhysics@,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*,MagicPhysX.PxRigidActor*,MagicPhysX.PxTransform*)">
            <summary>Create a rack &amp; pinion Joint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.RigidActorExtCreateBVHFromActor(MagicPhysX.PxPhysics@,MagicPhysX.PxRigidActor*)">
            <summary>Convenience function to create a PxBVH object from a PxRigidActor.  The computed PxBVH can then be used in PxScene::addActor() or PxAggregate::addActor(). After adding the actor &amp; BVH to the scene/aggregate, release the PxBVH object by calling PxBVH::release().  The PxBVH for this actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SerializationCreateSerializationRegistry(MagicPhysX.PxPhysics@)">
            <summary>Creates an application managed registry for serialization.  PxSerializationRegistry instance.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxCreateDynamic(MagicPhysX.PxPhysics@,MagicPhysX.PxTransform*,MagicPhysX.PxGeometry*,MagicPhysX.PxMaterial*,System.Single,MagicPhysX.PxTransform*)">
            <summary>simple method to create a PxRigidDynamic actor with a single PxShape.  a new dynamic actor with the PxRigidBodyFlag, or NULL if it could not be constructed</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxCreateDynamic1(MagicPhysX.PxPhysics@,MagicPhysX.PxTransform*,MagicPhysX.PxShape*,System.Single)">
            <summary>simple method to create a PxRigidDynamic actor with a single PxShape.  a new dynamic actor with the PxRigidBodyFlag, or NULL if it could not be constructed</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxCreateKinematic(MagicPhysX.PxPhysics@,MagicPhysX.PxTransform*,MagicPhysX.PxGeometry*,MagicPhysX.PxMaterial*,System.Single,MagicPhysX.PxTransform*)">
            <summary>simple method to create a kinematic PxRigidDynamic actor with a single PxShape.  unlike PxCreateDynamic, the geometry is not restricted to box, capsule, sphere or convex. However, kinematics of other geometry types may not participate in simulation collision and may be used only for triggers or scene queries of moving objects under animation control. In this case the density parameter will be ignored and the created shape will be set up as a scene query only shape (see [`PxShapeFlag::eSCENE_QUERY_SHAPE`])  a new dynamic actor with the PxRigidBodyFlag::eKINEMATIC set, or NULL if it could not be constructed</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxCreateKinematic1(MagicPhysX.PxPhysics@,MagicPhysX.PxTransform*,MagicPhysX.PxShape*,System.Single)">
            <summary>simple method to create a kinematic PxRigidDynamic actor with a single PxShape.  unlike PxCreateDynamic, the geometry is not restricted to box, capsule, sphere or convex. However, kinematics of other geometry types may not participate in simulation collision and may be used only for triggers or scene queries of moving objects under animation control. In this case the density parameter will be ignored and the created shape will be set up as a scene query only shape (see [`PxShapeFlag::eSCENE_QUERY_SHAPE`])  a new dynamic actor with the PxRigidBodyFlag::eKINEMATIC set, or NULL if it could not be constructed</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxCreateStatic(MagicPhysX.PxPhysics@,MagicPhysX.PxTransform*,MagicPhysX.PxGeometry*,MagicPhysX.PxMaterial*,MagicPhysX.PxTransform*)">
            <summary>simple method to create a PxRigidStatic actor with a single PxShape.  a new static actor, or NULL if it could not be constructed</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxCreateStatic1(MagicPhysX.PxPhysics@,MagicPhysX.PxTransform*,MagicPhysX.PxShape*)">
            <summary>simple method to create a PxRigidStatic actor with a single PxShape.  a new static actor, or NULL if it could not be constructed</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxCloneShape(MagicPhysX.PxPhysics@,MagicPhysX.PxShape*,System.Boolean)">
            <summary>create a shape by copying attributes from another shape  The function clones a PxShape. The following properties are copied: - geometry - flags - materials - actor-local pose - contact offset - rest offset - simulation filter data - query filter data - torsional patch radius - minimum torsional patch radius  The following are not copied and retain their default values: - name - user data  the newly-created rigid static</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxCloneStatic(MagicPhysX.PxPhysics@,MagicPhysX.PxTransform*,MagicPhysX.PxRigidActor*)">
            <summary>create a static body by copying attributes from another rigid actor  The function clones a PxRigidDynamic or PxRigidStatic as a PxRigidStatic. A uniform scale is applied. The following properties are copied: - shapes - actor flags - owner client and client behavior bits - dominance group  The following are not copied and retain their default values: - name - joints or observers - aggregate or scene membership - user data  Transforms are not copied with bit-exact accuracy.  the newly-created rigid static</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxCloneDynamic(MagicPhysX.PxPhysics@,MagicPhysX.PxTransform*,MagicPhysX.PxRigidDynamic*)">
            <summary>create a dynamic body by copying attributes from an existing body  The following properties are copied: - shapes - actor flags, rigidDynamic flags and rigidDynamic lock flags - mass, moment of inertia, and center of mass frame - linear and angular velocity - linear and angular damping - maximum linear velocity - maximum angular velocity - position and velocity solver iterations - maximum depenetration velocity - sleep threshold - contact report threshold - dominance group - owner client and client behavior bits - name pointer - kinematic target  The following are not copied and retain their default values: - name - joints or observers - aggregate or scene membership - sleep timer - user data  Transforms are not copied with bit-exact accuracy.  the newly-created rigid static</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxCreatePlane(MagicPhysX.PxPhysics@,MagicPhysX.PxPlane*,MagicPhysX.PxMaterial*)">
            <summary>create a plane actor. The plane equation is n.x + d = 0  a new static actor, or NULL if it could not be constructed</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxInitExtensions(MagicPhysX.PxPhysics@,MagicPhysX.PxPvd*)">
            <summary>Initialize the PhysXExtensions library.  This should be called before calling any functions or methods in extensions which may require allocation.  This function does not need to be called before creating a PxDefaultAllocator object.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PreFilterMut(MagicPhysX.PxQueryFilterCallback@,MagicPhysX.PxFilterData*,MagicPhysX.PxShape*,MagicPhysX.PxRigidActor*,MagicPhysX.PxHitFlags*)">
            <summary>This filter callback is executed before the exact intersection test if PxQueryFlag::ePREFILTER flag was set.  the updated type for this hit  (see [`PxQueryHitType`])</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PostFilterMut(MagicPhysX.PxQueryFilterCallback@,MagicPhysX.PxFilterData*,MagicPhysX.PxQueryHit*,MagicPhysX.PxShape*,MagicPhysX.PxRigidActor*)">
            <summary>This filter callback is executed if the exact intersection test returned true and PxQueryFlag::ePOSTFILTER flag was set.  the updated hit type for this hit  (see [`PxQueryHitType`])</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Delete(MagicPhysX.PxQueryFilterCallback@)">
            <summary>virtual destructor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetKinematicTargetMut(MagicPhysX.PxRigidDynamic@,MagicPhysX.PxTransform*)">
            <summary>Moves kinematically controlled dynamic actors through the game world.  You set a dynamic actor to be kinematic using the PxRigidBodyFlag::eKINEMATIC flag with setRigidBodyFlag().  The move command will result in a velocity that will move the body into the desired pose. After the move is carried out during a single time step, the velocity is returned to zero. Thus, you must continuously call this in every time step for kinematic actors so that they move along a path.  This function simply stores the move destination until the next simulation step is processed, so consecutive calls will simply overwrite the stored target variable.  The motion is always fully carried out.  It is invalid to use this method if the actor has not been added to a scene already or if PxActorFlag::eDISABLE_SIMULATION is set.  Sleeping: This call wakes the actor if it is sleeping and will set the wake counter to [`PxSceneDesc::wakeCounterResetValue`].</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetKinematicTarget(MagicPhysX.PxRigidDynamic@,MagicPhysX.PxTransform*)">
            <summary>Get target pose of a kinematically controlled dynamic actor.  True if the actor is a kinematically controlled dynamic and the target has been set, else False.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsSleeping(MagicPhysX.PxRigidDynamic@)">
            <summary>Returns true if this body is sleeping.  When an actor does not move for a period of time, it is no longer simulated in order to save time. This state is called sleeping. However, because the object automatically wakes up when it is either touched by an awake object, or one of its properties is changed by the user, the entire sleep mechanism should be transparent to the user.  In general, a dynamic rigid actor is guaranteed to be awake if at least one of the following holds:  The wake counter is positive (see [`setWakeCounter`]()).  The linear or angular velocity is non-zero.  A non-zero force or torque has been applied.  If a dynamic rigid actor is sleeping, the following state is guaranteed:  The wake counter is zero.  The linear and angular velocity is zero.  There is no force update pending.  When an actor gets inserted into a scene, it will be considered asleep if all the points above hold, else it will be treated as awake.  If an actor is asleep after the call to PxScene::fetchResults() returns, it is guaranteed that the pose of the actor was not changed. You can use this information to avoid updating the transforms of associated objects.  A kinematic actor is asleep unless a target pose has been set (in which case it will stay awake until two consecutive simulation steps without a target pose being set have passed). The wake counter will get set to zero or to the reset value [`PxSceneDesc::wakeCounterResetValue`] in the case where a target pose has been set to be consistent with the definitions above.  It is invalid to use this method if the actor has not been added to a scene already.  It is not allowed to use this method while the simulation is running.  True if the actor is sleeping.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetSleepThresholdMut(MagicPhysX.PxRigidDynamic@,System.Single)">
            <summary>Sets the mass-normalized kinetic energy threshold below which an actor may go to sleep.  Actors whose kinetic energy divided by their mass is below this threshold will be candidates for sleeping.  Default: 5e-5f * PxTolerancesScale::speed * PxTolerancesScale::speed</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSleepThreshold(MagicPhysX.PxRigidDynamic@)">
            <summary>Returns the mass-normalized kinetic energy below which an actor may go to sleep.  The energy threshold for sleeping.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetStabilizationThresholdMut(MagicPhysX.PxRigidDynamic@,System.Single)">
            <summary>Sets the mass-normalized kinetic energy threshold below which an actor may participate in stabilization.  Actors whose kinetic energy divided by their mass is above this threshold will not participate in stabilization.  This value has no effect if PxSceneFlag::eENABLE_STABILIZATION was not enabled on the PxSceneDesc.  Default: 1e-5f * PxTolerancesScale::speed * PxTolerancesScale::speed</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetStabilizationThreshold(MagicPhysX.PxRigidDynamic@)">
            <summary>Returns the mass-normalized kinetic energy below which an actor may participate in stabilization.  Actors whose kinetic energy divided by their mass is above this threshold will not participate in stabilization.  The energy threshold for participating in stabilization.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetRigidDynamicLockFlags(MagicPhysX.PxRigidDynamic@)">
            <summary>Reads the PxRigidDynamic lock flags.  See the list of flags [`PxRigidDynamicLockFlag`]  The values of the PxRigidDynamicLock flags.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetRigidDynamicLockFlagMut(MagicPhysX.PxRigidDynamic@,MagicPhysX.PxRigidDynamicLockFlag,System.Boolean)">
            <summary>Raises or clears a particular rigid dynamic lock flag.  See the list of flags [`PxRigidDynamicLockFlag`]  Default: no flags are set</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetLinearVelocity(MagicPhysX.PxRigidDynamic@)">
            <summary>Retrieves the linear velocity of an actor.  It is not allowed to use this method while the simulation is running (except during PxScene::collide(), in PxContactModifyCallback or in contact report callbacks).  The linear velocity of the actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetLinearVelocityMut(MagicPhysX.PxRigidDynamic@,MagicPhysX.PxVec3*,System.Boolean)">
            <summary>Sets the linear velocity of the actor.  Note that if you continuously set the velocity of an actor yourself, forces such as gravity or friction will not be able to manifest themselves, because forces directly influence only the velocity/momentum of an actor.  Default: (0.0, 0.0, 0.0)  Sleeping: This call wakes the actor if it is sleeping, and the autowake parameter is true (default) or the new velocity is non-zero.  It is invalid to use this method if PxActorFlag::eDISABLE_SIMULATION is set.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetAngularVelocity(MagicPhysX.PxRigidDynamic@)">
            <summary>Retrieves the angular velocity of the actor.  It is not allowed to use this method while the simulation is running (except during PxScene::collide(), in PxContactModifyCallback or in contact report callbacks).  The angular velocity of the actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetAngularVelocityMut(MagicPhysX.PxRigidDynamic@,MagicPhysX.PxVec3*,System.Boolean)">
            <summary>Sets the angular velocity of the actor.  Note that if you continuously set the angular velocity of an actor yourself, forces such as friction will not be able to rotate the actor, because forces directly influence only the velocity/momentum.  Default: (0.0, 0.0, 0.0)  Sleeping: This call wakes the actor if it is sleeping, and the autowake parameter is true (default) or the new velocity is non-zero.  It is invalid to use this method if PxActorFlag::eDISABLE_SIMULATION is set.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetWakeCounterMut(MagicPhysX.PxRigidDynamic@,System.Single)">
            <summary>Sets the wake counter for the actor.  The wake counter value determines the minimum amount of time until the body can be put to sleep. Please note that a body will not be put to sleep if the energy is above the specified threshold (see [`setSleepThreshold`]()) or if other awake bodies are touching it.  Passing in a positive value will wake the actor up automatically.  It is invalid to use this method for kinematic actors since the wake counter for kinematics is defined based on whether a target pose has been set (see the comment in [`isSleeping`]()).  It is invalid to use this method if PxActorFlag::eDISABLE_SIMULATION is set.  Default: 0.4 (which corresponds to 20 frames for a time step of 0.02)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetWakeCounter(MagicPhysX.PxRigidDynamic@)">
            <summary>Returns the wake counter of the actor.  It is not allowed to use this method while the simulation is running.  The wake counter of the actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.WakeUpMut(MagicPhysX.PxRigidDynamic@)">
            <summary>Wakes up the actor if it is sleeping.  The actor will get woken up and might cause other touching actors to wake up as well during the next simulation step.  This will set the wake counter of the actor to the value specified in [`PxSceneDesc::wakeCounterResetValue`].  It is invalid to use this method if the actor has not been added to a scene already or if PxActorFlag::eDISABLE_SIMULATION is set.  It is invalid to use this method for kinematic actors since the sleep state for kinematics is defined based on whether a target pose has been set (see the comment in [`isSleeping`]()).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PutToSleepMut(MagicPhysX.PxRigidDynamic@)">
            <summary>Forces the actor to sleep.  The actor will stay asleep during the next simulation step if not touched by another non-sleeping actor.  Any applied force will be cleared and the velocity and the wake counter of the actor will be set to 0.  It is invalid to use this method if the actor has not been added to a scene already or if PxActorFlag::eDISABLE_SIMULATION is set.  It is invalid to use this method for kinematic actors since the sleep state for kinematics is defined based on whether a target pose has been set (see the comment in [`isSleeping`]()).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetSolverIterationCountsMut(MagicPhysX.PxRigidDynamic@,System.UInt32,System.UInt32)">
            <summary>Sets the solver iteration counts for the body.  The solver iteration count determines how accurately joints and contacts are resolved. If you are having trouble with jointed bodies oscillating and behaving erratically, then setting a higher position iteration count may improve their stability.  If intersecting bodies are being depenetrated too violently, increase the number of velocity iterations. More velocity iterations will drive the relative exit velocity of the intersecting objects closer to the correct value given the restitution.  Default: 4 position iterations, 1 velocity iteration</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSolverIterationCounts(MagicPhysX.PxRigidDynamic@,System.UInt32*,System.UInt32*)">
            <summary>Retrieves the solver iteration counts.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetContactReportThreshold(MagicPhysX.PxRigidDynamic@)">
            <summary>Retrieves the force threshold for contact reports.  The contact report threshold is a force threshold. If the force between two actors exceeds this threshold for either of the two actors, a contact report will be generated according to the contact report threshold flags provided by the filter shader/callback. See [`PxPairFlag`].  The threshold used for a collision between a dynamic actor and the static environment is the threshold of the dynamic actor, and all contacts with static actors are summed to find the total normal force.  Default: PX_MAX_F32  Force threshold for contact reports.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetContactReportThresholdMut(MagicPhysX.PxRigidDynamic@,System.Single)">
            <summary>Sets the force threshold for contact reports.  See [`getContactReportThreshold`]().</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetToDefaultMut(MagicPhysX.PxSceneQueryDesc@)">
            <summary>(re)sets the structure to the default.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxSceneQueryDesc@)">
            <summary>Returns true if the descriptor is valid.  true if the current settings are valid.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxCreateExternalSceneQuerySystem(MagicPhysX.PxSceneQueryDesc@,System.UInt64)">
            <summary>Creates an external scene query system.  An external SQ system is the part of a PxScene that deals with scene queries (SQ). This is usually taken care of by an internal implementation inside PxScene, but it is also possible to re-route all SQ calls to an external implementation, potentially opening the door to some customizations in behavior and features for advanced users.  The following external SQ system is an example of how an implementation would look like. It re-uses much of the same code as the internal version, but it could be re-implemented in a completely different way to match users' specific needs.  An external SQ system instance</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetDynamicTreeRebuildRateHintMut(MagicPhysX.PxSceneQuerySystemBase@,System.UInt32)">
            <summary>Sets the rebuild rate of the dynamic tree pruning structures.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetDynamicTreeRebuildRateHint(MagicPhysX.PxSceneQuerySystemBase@)">
            <summary>Retrieves the rebuild rate of the dynamic tree pruning structures.  The rebuild rate of the dynamic tree pruning structures.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ForceRebuildDynamicTreeMut(MagicPhysX.PxSceneQuerySystemBase@,System.UInt32)">
            <summary>Forces dynamic trees to be immediately rebuilt.  PxScene will call this function with the PX_SCENE_PRUNER_STATIC or PX_SCENE_PRUNER_DYNAMIC value.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetUpdateModeMut(MagicPhysX.PxSceneQuerySystemBase@,MagicPhysX.PxSceneQueryUpdateMode)">
            <summary>Sets scene query update mode</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetUpdateMode(MagicPhysX.PxSceneQuerySystemBase@)">
            <summary>Gets scene query update mode  Current scene query update mode.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetStaticTimestamp(MagicPhysX.PxSceneQuerySystemBase@)">
            <summary>Retrieves the system's internal scene query timestamp, increased each time a change to the static scene query structure is performed.  scene query static timestamp</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.FlushUpdatesMut(MagicPhysX.PxSceneQuerySystemBase@)">
            <summary>Flushes any changes to the scene query representation.  This method updates the state of the scene query representation to match changes in the scene state.  By default, these changes are buffered until the next query is submitted. Calling this function will not change the results from scene queries, but can be used to ensure that a query will not perform update work in the course of its execution.  A thread performing updates will hold a write lock on the query structure, and thus stall other querying threads. In multithread scenarios it can be useful to explicitly schedule the period where this lock may be held for a significant period, so that subsequent queries issued from multiple threads will not block.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Raycast(MagicPhysX.PxSceneQuerySystemBase@,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxRaycastCallback*,MagicPhysX.PxHitFlags,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryFilterCallback*,MagicPhysX.PxQueryCache*,MagicPhysX.PxGeometryQueryFlags)">
            <summary>Performs a raycast against objects in the scene, returns results in a PxRaycastBuffer object or via a custom user callback implementation inheriting from PxRaycastCallback.  Touching hits are not ordered.  Shooting a ray from within an object leads to different results depending on the shape type. Please check the details in user guide article SceneQuery. User can ignore such objects by employing one of the provided filter mechanisms.  True if any touching or blocking hits were found or any hit was found in case PxQueryFlag::eANY_HIT was specified.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Sweep(MagicPhysX.PxSceneQuerySystemBase@,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxSweepCallback*,MagicPhysX.PxHitFlags,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryFilterCallback*,MagicPhysX.PxQueryCache*,System.Single,MagicPhysX.PxGeometryQueryFlags)">
            <summary>Performs a sweep test against objects in the scene, returns results in a PxSweepBuffer object or via a custom user callback implementation inheriting from PxSweepCallback.  Touching hits are not ordered.  If a shape from the scene is already overlapping with the query shape in its starting position, the hit is returned unless eASSUME_NO_INITIAL_OVERLAP was specified.  True if any touching or blocking hits were found or any hit was found in case PxQueryFlag::eANY_HIT was specified.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Overlap(MagicPhysX.PxSceneQuerySystemBase@,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxOverlapCallback*,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryFilterCallback*,MagicPhysX.PxQueryCache*,MagicPhysX.PxGeometryQueryFlags)">
            <summary>Performs an overlap test of a given geometry against objects in the scene, returns results in a PxOverlapBuffer object or via a custom user callback implementation inheriting from PxOverlapCallback.  Filtering: returning eBLOCK from user filter for overlap queries will cause a warning (see [`PxQueryHitType`]).  True if any touching or blocking hits were found or any hit was found in case PxQueryFlag::eANY_HIT was specified.  eBLOCK should not be returned from user filters for overlap(). Doing so will result in undefined behavior, and a warning will be issued.  If the PxQueryFlag::eNO_BLOCK flag is set, the eBLOCK will instead be automatically converted to an eTOUCH and the warning suppressed.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetSceneQueryUpdateModeMut(MagicPhysX.PxSceneSQSystem@,MagicPhysX.PxSceneQueryUpdateMode)">
            <summary>Sets scene query update mode</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSceneQueryUpdateMode(MagicPhysX.PxSceneSQSystem@)">
            <summary>Gets scene query update mode  Current scene query update mode.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSceneQueryStaticTimestamp(MagicPhysX.PxSceneSQSystem@)">
            <summary>Retrieves the scene's internal scene query timestamp, increased each time a change to the static scene query structure is performed.  scene query static timestamp</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.FlushQueryUpdatesMut(MagicPhysX.PxSceneSQSystem@)">
            <summary>Flushes any changes to the scene query representation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ForceDynamicTreeRebuildMut(MagicPhysX.PxSceneSQSystem@,System.Boolean,System.Boolean)">
            <summary>Forces dynamic trees to be immediately rebuilt.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetStaticStructure(MagicPhysX.PxSceneSQSystem@)">
            <summary>Return the value of PxSceneQueryDesc::staticStructure that was set when creating the scene with PxPhysics::createScene</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetDynamicStructure(MagicPhysX.PxSceneSQSystem@)">
            <summary>Return the value of PxSceneQueryDesc::dynamicStructure that was set when creating the scene with PxPhysics::createScene</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SceneQueriesUpdateMut(MagicPhysX.PxSceneSQSystem@,MagicPhysX.PxBaseTask*,System.Boolean)">
            <summary>Executes scene queries update tasks.  This function will refit dirty shapes within the pruner and will execute a task to build a new AABB tree, which is build on a different thread. The new AABB tree is built based on the dynamic tree rebuild hint rate. Once the new tree is ready it will be commited in next fetchQueries call, which must be called after.  This function is equivalent to the following PxSceneQuerySystem calls: Synchronous calls: - PxSceneQuerySystemBase::flushUpdates() - handle0 = PxSceneQuerySystem::prepareSceneQueryBuildStep(PX_SCENE_PRUNER_STATIC) - handle1 = PxSceneQuerySystem::prepareSceneQueryBuildStep(PX_SCENE_PRUNER_DYNAMIC) Asynchronous calls: - PxSceneQuerySystem::sceneQueryBuildStep(handle0); - PxSceneQuerySystem::sceneQueryBuildStep(handle1);  This function is part of the PxSceneSQSystem interface because it uses the PxScene task system under the hood. But it calls PxSceneQuerySystem functions, which are independent from this system and could be called in a similar fashion by a separate, possibly user-defined task manager.  If PxSceneQueryUpdateMode::eBUILD_DISABLED_COMMIT_DISABLED is used, it is required to update the scene queries using this function.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CheckQueriesMut(MagicPhysX.PxSceneSQSystem@,System.Boolean)">
            <summary>This checks to see if the scene queries update has completed.  This does not cause the data available for reading to be updated with the results of the scene queries update, it is simply a status check. The bool will allow it to either return immediately or block waiting for the condition to be met so that it can return true  True if the results are available.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.FetchQueriesMut(MagicPhysX.PxSceneSQSystem@,System.Boolean)">
            <summary>This method must be called after sceneQueriesUpdate. It will wait for the scene queries update to finish. If the user makes an illegal scene queries update call, the SDK will issue an error message.  If a new AABB tree build finished, then during fetchQueries the current tree within the pruning structure is swapped with the new tree.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxSceneQuerySystem@)">
            <summary>Decrements the reference count of the object and releases it if the new reference count is zero.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AcquireReferenceMut(MagicPhysX.PxSceneQuerySystem@)">
            <summary>Acquires a counted reference to this object.  This method increases the reference count of the object by 1. Decrement the reference count by calling release()</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PreallocateMut(MagicPhysX.PxSceneQuerySystem@,System.UInt32,System.UInt32)">
            <summary>Preallocates internal arrays to minimize the amount of reallocations.  The system does not prevent more allocations than given numbers. It is legal to not call this function at all, or to add more shapes to the system than the preallocated amounts.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.FlushMemoryMut(MagicPhysX.PxSceneQuerySystem@)">
            <summary>Frees internal memory that may not be in-use anymore.  This is an entry point for reclaiming transient memory allocated at some point by the SQ system, but which wasn't been immediately freed for performance reason. Calling this function might free some memory, but it might also produce a new set of allocations in the next frame.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AddSQShapeMut(MagicPhysX.PxSceneQuerySystem@,MagicPhysX.PxRigidActor*,MagicPhysX.PxShape*,MagicPhysX.PxBounds3*,MagicPhysX.PxTransform*,System.UInt32*,System.Boolean)">
            <summary>Adds a shape to the SQ system.  The same function is used to add either a regular shape, or a SQ compound shape.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.RemoveSQShapeMut(MagicPhysX.PxSceneQuerySystem@,MagicPhysX.PxRigidActor*,MagicPhysX.PxShape*)">
            <summary>Removes a shape from the SQ system.  The same function is used to remove either a regular shape, or a SQ compound shape.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.UpdateSQShapeMut(MagicPhysX.PxSceneQuerySystem@,MagicPhysX.PxRigidActor*,MagicPhysX.PxShape*,MagicPhysX.PxTransform*)">
            <summary>Updates a shape in the SQ system.  The same function is used to update either a regular shape, or a SQ compound shape.  The transforms are eager-evaluated, but the bounds are lazy-evaluated. This means that the updated transform has to be passed to the update function, while the bounds are automatically recomputed by the system whenever needed.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AddSQCompoundMut(MagicPhysX.PxSceneQuerySystem@,MagicPhysX.PxRigidActor*,MagicPhysX.PxShape**,MagicPhysX.PxBVH*,MagicPhysX.PxTransform*)">
            <summary>Adds a compound to the SQ system.  SQ compound handle</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.RemoveSQCompoundMut(MagicPhysX.PxSceneQuerySystem@,System.UInt32)">
            <summary>Removes a compound from the SQ system.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.UpdateSQCompoundMut(MagicPhysX.PxSceneQuerySystem@,System.UInt32,MagicPhysX.PxTransform*)">
            <summary>Updates a compound in the SQ system.  The compound structures are immediately updated when the call occurs.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ShiftOriginMut(MagicPhysX.PxSceneQuerySystem@,MagicPhysX.PxVec3*)">
            <summary>Shift the data structures' origin by the specified vector.  Please refer to the notes of the similar function in PxScene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.MergeMut(MagicPhysX.PxSceneQuerySystem@,MagicPhysX.PxPruningStructure*)">
            <summary>Merges a pruning structure with the SQ system's internal pruners.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetHandle(MagicPhysX.PxSceneQuerySystem@,MagicPhysX.PxRigidActor*,MagicPhysX.PxShape*,System.UInt32*)">
            <summary>Shape to SQ-pruner-handle mapping function.  This function finds and returns the SQ pruner handle associated with a given (actor/shape) couple that was previously added to the system. This is needed for the sync function.  Associated SQ pruner handle.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SyncMut(MagicPhysX.PxSceneQuerySystem@,System.UInt32,System.UInt32*,System.UInt32*,MagicPhysX.PxBounds3*,MagicPhysX.PxTransformPadded*,System.UInt32,MagicPhysX.PxBitMap*)">
            <summary>Synchronizes the scene-query system with another system that references the same objects.  This function is used when the scene-query objects also exist in another system that can also update them. For example the scene-query objects (used for raycast, overlap or sweep queries) might be driven by equivalent objects in an external rigid-body simulation engine. In this case the rigid-body simulation engine computes the new poses and transforms, and passes them to the scene-query system using this function. It is more efficient than calling updateSQShape on each object individually, since updateSQShape would end up recomputing the bounds already available in the rigid-body engine.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.FinalizeUpdatesMut(MagicPhysX.PxSceneQuerySystem@)">
            <summary>Finalizes updates made to the SQ system.  This function should be called after updates have been made to the SQ system, to fully reflect the changes inside the internal pruners. In particular it should be called: - after calls to updateSQShape - after calls to sync  This function: - recomputes bounds of manually updated shapes (i.e. either regular or SQ compound shapes modified by updateSQShape) - updates dynamic pruners (refit operations) - incrementally rebuilds AABB-trees  The amount of work performed in this function depends on PxSceneQueryUpdateMode.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PrepareSceneQueryBuildStepMut(MagicPhysX.PxSceneQuerySystem@,System.UInt32)">
            <summary>Prepares asynchronous build step.  This is directly called (synchronously) by PxSceneSQSystem::sceneQueriesUpdate(). See the comments there.  This function is called to let the system execute any necessary synchronous operation before the asynchronous sceneQueryBuildStep() function is called.  If there is any work to do for the specific pruner, the function returns a pruner-specific handle that will be passed to the corresponding, asynchronous sceneQueryBuildStep function.  A pruner-specific handle that will be sent to sceneQueryBuildStep if there is any work to do, i.e. to execute the corresponding sceneQueryBuildStep() call.  Null if there is no work to do, otherwise a pruner-specific handle.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SceneQueryBuildStepMut(MagicPhysX.PxSceneQuerySystem@,System.Void*)">
            <summary>Executes asynchronous build step.  This is directly called (asynchronously) by PxSceneSQSystem::sceneQueriesUpdate(). See the comments there.  This function incrementally builds the internal trees/pruners. It is called asynchronously, i.e. this can be called from different threads for building multiple trees at the same time.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxCreateBroadPhase(MagicPhysX.PxBroadPhaseDesc@)">
            <summary>Broadphase factory function.  Use this function to create a new standalone broadphase.  Newly created broadphase, or NULL</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbRegions(MagicPhysX.PxBroadPhaseRegions@)">
            <summary>Returns number of regions currently registered in the broad-phase.  Number of regions</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetRegions(MagicPhysX.PxBroadPhaseRegions@,MagicPhysX.PxBroadPhaseRegionInfo*,System.UInt32,System.UInt32)">
            <summary>Gets broad-phase regions.  Number of written out regions.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AddRegionMut(MagicPhysX.PxBroadPhaseRegions@,MagicPhysX.PxBroadPhaseRegion*,System.Boolean,MagicPhysX.PxBounds3*,System.Single*)">
            <summary>Adds a new broad-phase region.  The total number of regions is limited to PxBroadPhaseCaps::mMaxNbRegions. If that number is exceeded, the call is ignored.  The newly added region will be automatically populated with already existing objects that touch it, if the 'populateRegion' parameter is set to true. Otherwise the newly added region will be empty, and it will only be populated with objects when those objects are added to the simulation, or updated if they already exist.  Using 'populateRegion=true' has a cost, so it is best to avoid it if possible. In particular it is more efficient to create the empty regions first (with populateRegion=false) and then add the objects afterwards (rather than the opposite).  Objects automatically move from one region to another during their lifetime. The system keeps tracks of what regions a given object is in. It is legal for an object to be in an arbitrary number of regions. However if an object leaves all regions, or is created outside of all regions, several things happen: - collisions get disabled for this object - the object appears in the getOutOfBoundsObjects() array  If an out-of-bounds object, whose collisions are disabled, re-enters a valid broadphase region, then collisions are re-enabled for that object.  Handle for newly created region, or 0xffffffff in case of failure.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.RemoveRegionMut(MagicPhysX.PxBroadPhaseRegions@,System.UInt32)">
            <summary>Removes a broad-phase region.  If the region still contains objects, and if those objects do not overlap any region any more, they are not automatically removed from the simulation. Instead, the PxBroadPhaseCallback::onObjectOutOfBounds notification is used for each object. Users are responsible for removing the objects from the simulation if this is the desired behavior.  If the handle is invalid, or if a valid handle is removed twice, an error message is sent to the error stream.  True if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetType(MagicPhysX.PxBroadPhase@)">
            <summary>Gets the broadphase type.  Broadphase type.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetCaps(MagicPhysX.PxBroadPhase@,MagicPhysX.PxBroadPhaseCaps*)">
            <summary>Gets broad-phase caps.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetRegionsMut(MagicPhysX.PxBroadPhase@)">
            <summary>Retrieves the regions API if applicable.  For broadphases that do not use explicit user-defined regions, this call returns NULL.  Region API, or NULL.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetAllocatorMut(MagicPhysX.PxBroadPhase@)">
            <summary>Retrieves the broadphase allocator.  User-provided buffers should ideally be allocated with this allocator, for best performance. This is especially true for the GPU broadphases, whose buffers need to be allocated in CUDA host memory.  The broadphase allocator.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetContextID(MagicPhysX.PxBroadPhase@)">
            <summary>Retrieves the profiler's context ID.  The context ID.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetScratchBlockMut(MagicPhysX.PxBroadPhase@,System.Void*,System.UInt32)">
            <summary>Sets a scratch buffer  Some broadphases might take advantage of a scratch buffer to limit runtime allocations.  All broadphases still work without providing a scratch buffer, this is an optional function that can potentially reduce runtime allocations.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.UpdateMut(MagicPhysX.PxBroadPhase@,MagicPhysX.PxBroadPhaseUpdateData*,MagicPhysX.PxBaseTask*)">
            <summary>Updates the broadphase and computes the lists of created/deleted pairs.  The provided update data describes changes to objects since the last broadphase update.  To benefit from potentially multithreaded implementations, it is necessary to provide a continuation task to the function. It is legal to pass NULL there, but the underlying (CPU) implementations will then run single-threaded.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.FetchResultsMut(MagicPhysX.PxBroadPhase@,MagicPhysX.PxBroadPhaseResults*)">
            <summary>Retrieves the broadphase results after an update.  This should be called once after each update call to retrieve the results of the broadphase. The results are incremental, i.e. the system only returns new and lost pairs, not all current pairs.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.UpdateMut1(MagicPhysX.PxBroadPhase@,MagicPhysX.PxBroadPhaseResults*,MagicPhysX.PxBroadPhaseUpdateData*)">
            <summary>Helper for single-threaded updates.  This short helper function performs a single-theaded update and reports the results in a single call.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxCreateAABBManager(MagicPhysX.PxBroadPhase@)">
            <summary>AABB manager factory function.  Use this function to create a new standalone high-level broadphase.  Newly created AABB manager, or NULL</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetBroadPhaseMut(MagicPhysX.PxAABBManager@)">
            <summary>Retrieves the underlying broadphase.  The managed broadphase.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetBounds(MagicPhysX.PxAABBManager@)">
            <summary>Retrieves the managed bounds.  This is needed as input parameters to functions like PxBroadPhaseRegions::addRegion.  The managed object bounds.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetDistances(MagicPhysX.PxAABBManager@)">
            <summary>Retrieves the managed distances.  This is needed as input parameters to functions like PxBroadPhaseRegions::addRegion.  The managed object distances.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetGroups(MagicPhysX.PxAABBManager@)">
            <summary>Retrieves the managed filter groups.  The managed object groups.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetCapacity(MagicPhysX.PxAABBManager@)">
            <summary>Retrieves the managed buffers' capacity.  Bounds, distances and groups buffers have the same capacity.  The managed buffers' capacity.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AddObjectMut(MagicPhysX.PxAABBManager@,System.UInt32,MagicPhysX.PxBounds3*,System.UInt32,System.Single)">
            <summary>Adds an object to the manager.  Objects' indices are externally managed, i.e. they must be provided by users (as opposed to handles that could be returned by this manager). The design allows users to identify an object by a single ID, and use the same ID in multiple sub-systems.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.RemoveObjectMut(MagicPhysX.PxAABBManager@,System.UInt32)">
            <summary>Removes an object from the manager.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.UpdateObjectMut(MagicPhysX.PxAABBManager@,System.UInt32,MagicPhysX.PxBounds3*,System.Single*)">
            <summary>Updates an object in the manager.  This call can update an object's bounds, distance, or both. It is not possible to update an object's filter group.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.UpdateMut(MagicPhysX.PxAABBManager@,MagicPhysX.PxBaseTask*)">
            <summary>Updates the broadphase and computes the lists of created/deleted pairs.  The data necessary for updating the broadphase is internally computed by the AABB manager.  To benefit from potentially multithreaded implementations, it is necessary to provide a continuation task to the function. It is legal to pass NULL there, but the underlying (CPU) implementations will then run single-threaded.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.FetchResultsMut(MagicPhysX.PxAABBManager@,MagicPhysX.PxBroadPhaseResults*)">
            <summary>Retrieves the broadphase results after an update.  This should be called once after each update call to retrieve the results of the broadphase. The results are incremental, i.e. the system only returns new and lost pairs, not all current pairs.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.UpdateMut1(MagicPhysX.PxAABBManager@,MagicPhysX.PxBroadPhaseResults*)">
            <summary>Helper for single-threaded updates.  This short helper function performs a single-theaded update and reports the results in a single call.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetToDefaultMut(MagicPhysX.PxSceneLimits@)">
            <summary>(re)sets the structure to the default</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxSceneLimits@)">
            <summary>Returns true if the descriptor is valid.  true if the current settings are valid.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbBroadPhaseAdds(MagicPhysX.PxSimulationStatistics@)">
            <summary>Get number of broadphase volumes added for the current simulation step.  Number of broadphase volumes added.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbBroadPhaseRemoves(MagicPhysX.PxSimulationStatistics@)">
            <summary>Get number of broadphase volumes removed for the current simulation step.  Number of broadphase volumes removed.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetRbPairStats(MagicPhysX.PxSimulationStatistics@,MagicPhysX.RbPairStatsType,MagicPhysX.PxGeometryType,MagicPhysX.PxGeometryType)">
            <summary>Get number of shape collision pairs of a certain type processed for the current simulation step.  There is an entry for each geometry pair type.  entry[i][j] = entry[j][i], hence, if you want the sum of all pair types, you need to discard the symmetric entries  Number of processed pairs of the specified geometry types.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetScenePvdFlagMut(MagicPhysX.PxPvdSceneClient@,MagicPhysX.PxPvdSceneFlag,System.Boolean)">
            <summary>Sets the PVD flag. See PxPvdSceneFlag.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetScenePvdFlagsMut(MagicPhysX.PxPvdSceneClient@,MagicPhysX.PxPvdSceneFlags)">
            <summary>Sets the PVD flags. See PxPvdSceneFlags.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetScenePvdFlags(MagicPhysX.PxPvdSceneClient@)">
            <summary>Retrieves the PVD flags. See PxPvdSceneFlags.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.UpdateCameraMut(MagicPhysX.PxPvdSceneClient@,System.Byte*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>update camera on PVD application's render window</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.DrawPointsMut(MagicPhysX.PxPvdSceneClient@,MagicPhysX.PxDebugPoint*,System.UInt32)">
            <summary>draw points on PVD application's render window</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.DrawLinesMut(MagicPhysX.PxPvdSceneClient@,MagicPhysX.PxDebugLine*,System.UInt32)">
            <summary>draw lines on PVD application's render window</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.DrawTrianglesMut(MagicPhysX.PxPvdSceneClient@,MagicPhysX.PxDebugTriangle*,System.UInt32)">
            <summary>draw triangles on PVD application's render window</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.DrawTextMut(MagicPhysX.PxPvdSceneClient@,MagicPhysX.PxDebugText*)">
            <summary>draw text on PVD application's render window</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.OnObjectOutOfBoundsMut(MagicPhysX.PxBroadPhaseCallback@,MagicPhysX.PxShape*,MagicPhysX.PxActor*)">
            <summary>Out-of-bounds notification.  This function is called when an object leaves the broad-phase.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.OnObjectOutOfBoundsMut1(MagicPhysX.PxBroadPhaseCallback@,MagicPhysX.PxAggregate*)">
            <summary>Out-of-bounds notification.  This function is called when an aggregate leaves the broad-phase.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxScene@)">
            <summary>Deletes the scene.  Removes any actors and constraint shaders from this scene (if the user hasn't already done so).  Be sure to not keep a reference to this object after calling release. Avoid release calls while the scene is simulating (in between simulate() and fetchResults() calls).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetFlagMut(MagicPhysX.PxScene@,MagicPhysX.PxSceneFlag,System.Boolean)">
            <summary>Sets a scene flag. You can only set one flag at a time.  Not all flags are mutable and changing some will result in an error. Please check [`PxSceneFlag`] to see which flags can be changed.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetFlags(MagicPhysX.PxScene@)">
            <summary>Get the scene flags.  The scene flags. See [`PxSceneFlag`]</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetLimitsMut(MagicPhysX.PxScene@,MagicPhysX.PxSceneLimits*)">
            <summary>Set new scene limits.  Increase the maximum capacity of various data structures in the scene. The new capacities will be at least as large as required to deal with the objects currently in the scene. Further, these values are for preallocation and do not represent hard limits.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetLimits(MagicPhysX.PxScene@)">
            <summary>Get current scene limits.  Current scene limits.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetPhysicsMut(MagicPhysX.PxScene@)">
            <summary>Call this method to retrieve the Physics SDK.  The physics SDK this scene is associated with.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetTimestamp(MagicPhysX.PxScene@)">
            <summary>Retrieves the scene's internal timestamp, increased each time a simulation step is completed.  scene timestamp</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AddArticulationMut(MagicPhysX.PxScene@,MagicPhysX.PxArticulationReducedCoordinate*)">
            <summary>Adds an articulation to this scene.  If the articulation is already assigned to a scene (see [`PxArticulationReducedCoordinate::getScene`]), the call is ignored and an error is issued.  True if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.RemoveArticulationMut(MagicPhysX.PxScene@,MagicPhysX.PxArticulationReducedCoordinate*,System.Boolean)">
            <summary>Removes an articulation from this scene.  If the articulation is not part of this scene (see [`PxArticulationReducedCoordinate::getScene`]), the call is ignored and an error is issued.  If the articulation is in an aggregate it will be removed from the aggregate.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AddActorMut(MagicPhysX.PxScene@,MagicPhysX.PxActor*,MagicPhysX.PxBVH*)">
            <summary>Adds an actor to this scene.  If the actor is already assigned to a scene (see [`PxActor::getScene`]), the call is ignored and an error is issued.  If the actor has an invalid constraint, in checked builds the call is ignored and an error is issued.  You can not add individual articulation links (see [`PxArticulationLink`]) to the scene. Use #addArticulation() instead.  If the actor is a PxRigidActor then each assigned PxConstraint object will get added to the scene automatically if it connects to another actor that is part of the scene already.  When a BVH is provided the actor shapes are grouped together. The scene query pruning structure inside PhysX SDK will store/update one bound per actor. The scene queries against such an actor will query actor bounds and then make a local space query against the provided BVH, which is in actor's local space.  True if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AddActorsMut(MagicPhysX.PxScene@,MagicPhysX.PxActor**,System.UInt32)">
            <summary>Adds actors to this scene. Only supports actors of type PxRigidStatic and PxRigidDynamic.  This method only supports actors of type PxRigidStatic and PxRigidDynamic. For other actors, use addActor() instead. For articulation links, use addArticulation().  If one of the actors is already assigned to a scene (see [`PxActor::getScene`]), the call is ignored and an error is issued.  If an actor in the array contains an invalid constraint, in checked builds the call is ignored and an error is issued.  If an actor in the array is a PxRigidActor then each assigned PxConstraint object will get added to the scene automatically if it connects to another actor that is part of the scene already.  this method is optimized for high performance.  True if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AddActorsMut1(MagicPhysX.PxScene@,MagicPhysX.PxPruningStructure*)">
            <summary>Adds a pruning structure together with its actors to this scene. Only supports actors of type PxRigidStatic and PxRigidDynamic.  This method only supports actors of type PxRigidStatic and PxRigidDynamic. For other actors, use addActor() instead. For articulation links, use addArticulation().  If an actor in the pruning structure contains an invalid constraint, in checked builds the call is ignored and an error is issued.  For all actors in the pruning structure each assigned PxConstraint object will get added to the scene automatically if it connects to another actor that is part of the scene already.  This method is optimized for high performance.  Merging a PxPruningStructure into an active scene query optimization AABB tree might unbalance the tree. A typical use case for PxPruningStructure is a large world scenario where blocks of closely positioned actors get streamed in. The merge process finds the best node in the active scene query optimization AABB tree and inserts the PxPruningStructure. Therefore using PxPruningStructure for actors scattered throughout the world will result in an unbalanced tree.  True if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.RemoveActorMut(MagicPhysX.PxScene@,MagicPhysX.PxActor*,System.Boolean)">
            <summary>Removes an actor from this scene.  If the actor is not part of this scene (see [`PxActor::getScene`]), the call is ignored and an error is issued.  You can not remove individual articulation links (see [`PxArticulationLink`]) from the scene. Use #removeArticulation() instead.  If the actor is a PxRigidActor then all assigned PxConstraint objects will get removed from the scene automatically.  If the actor is in an aggregate it will be removed from the aggregate.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.RemoveActorsMut(MagicPhysX.PxScene@,MagicPhysX.PxActor**,System.UInt32,System.Boolean)">
            <summary>Removes actors from this scene. Only supports actors of type PxRigidStatic and PxRigidDynamic.  This method only supports actors of type PxRigidStatic and PxRigidDynamic. For other actors, use removeActor() instead. For articulation links, use removeArticulation().  If some actor is not part of this scene (see [`PxActor::getScene`]), the actor remove is ignored and an error is issued.  You can not remove individual articulation links (see [`PxArticulationLink`]) from the scene. Use #removeArticulation() instead.  If the actor is a PxRigidActor then all assigned PxConstraint objects will get removed from the scene automatically.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AddAggregateMut(MagicPhysX.PxScene@,MagicPhysX.PxAggregate*)">
            <summary>Adds an aggregate to this scene.  If the aggregate is already assigned to a scene (see [`PxAggregate::getScene`]), the call is ignored and an error is issued.  If the aggregate contains an actor with an invalid constraint, in checked builds the call is ignored and an error is issued.  If the aggregate already contains actors, those actors are added to the scene as well.  True if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.RemoveAggregateMut(MagicPhysX.PxScene@,MagicPhysX.PxAggregate*,System.Boolean)">
            <summary>Removes an aggregate from this scene.  If the aggregate is not part of this scene (see [`PxAggregate::getScene`]), the call is ignored and an error is issued.  If the aggregate contains actors, those actors are removed from the scene as well.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AddCollectionMut(MagicPhysX.PxScene@,MagicPhysX.PxCollection*)">
            <summary>Adds objects in the collection to this scene.  This function adds the following types of objects to this scene: PxRigidActor (except PxArticulationLink), PxAggregate, PxArticulationReducedCoordinate. This method is typically used after deserializing the collection in order to populate the scene with deserialized objects.  If the collection contains an actor with an invalid constraint, in checked builds the call is ignored and an error is issued.  True if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbActors(MagicPhysX.PxScene@,MagicPhysX.PxActorTypeFlags)">
            <summary>Retrieve the number of actors of certain types in the scene. For supported types, see PxActorTypeFlags.  the number of actors.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetActors(MagicPhysX.PxScene@,MagicPhysX.PxActorTypeFlags,MagicPhysX.PxActor**,System.UInt32,System.UInt32)">
            <summary>Retrieve an array of all the actors of certain types in the scene. For supported types, see PxActorTypeFlags.  Number of actors written to the buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetActiveActorsMut(MagicPhysX.PxScene@,System.UInt32*)">
            <summary>Queries the PxScene for a list of the PxActors whose transforms have been updated during the previous simulation step. Only includes actors of type PxRigidDynamic and PxArticulationLink.  PxSceneFlag::eENABLE_ACTIVE_ACTORS must be set.  Do not use this method while the simulation is running. Calls to this method while the simulation is running will be ignored and NULL will be returned.  A pointer to the list of active PxActors generated during the last call to fetchResults().</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbArticulations(MagicPhysX.PxScene@)">
            <summary>Returns the number of articulations in the scene.  the number of articulations in this scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetArticulations(MagicPhysX.PxScene@,MagicPhysX.PxArticulationReducedCoordinate**,System.UInt32,System.UInt32)">
            <summary>Retrieve all the articulations in the scene.  Number of articulations written to the buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbConstraints(MagicPhysX.PxScene@)">
            <summary>Returns the number of constraint shaders in the scene.  the number of constraint shaders in this scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetConstraints(MagicPhysX.PxScene@,MagicPhysX.PxConstraint**,System.UInt32,System.UInt32)">
            <summary>Retrieve all the constraint shaders in the scene.  Number of constraint shaders written to the buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbAggregates(MagicPhysX.PxScene@)">
            <summary>Returns the number of aggregates in the scene.  the number of aggregates in this scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetAggregates(MagicPhysX.PxScene@,MagicPhysX.PxAggregate**,System.UInt32,System.UInt32)">
            <summary>Retrieve all the aggregates in the scene.  Number of aggregates written to the buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetDominanceGroupPairMut(MagicPhysX.PxScene@,System.Byte,System.Byte,MagicPhysX.PxDominanceGroupPair*)">
            <summary>Specifies the dominance behavior of contacts between two actors with two certain dominance groups.  It is possible to assign each actor to a dominance groups using [`PxActor::setDominanceGroup`]().  With dominance groups one can have all contacts created between actors act in one direction only. This is useful, for example, if you want an object to push debris out of its way and be unaffected,while still responding physically to forces and collisions with non-debris objects.  Whenever a contact between two actors (a0, a1) needs to be solved, the groups (g0, g1) of both actors are retrieved. Then the PxDominanceGroupPair setting for this group pair is retrieved with getDominanceGroupPair(g0, g1).  In the contact, PxDominanceGroupPair::dominance0 becomes the dominance setting for a0, and PxDominanceGroupPair::dominance1 becomes the dominance setting for a1. A dominanceN setting of 1.0f, the default, will permit aN to be pushed or pulled by a(1-N) through the contact. A dominanceN setting of 0.0f, will however prevent aN to be pushed by a(1-N) via the contact. Thus, a PxDominanceGroupPair of (1.0f, 0.0f) makes the interaction one-way.  The matrix sampled by getDominanceGroupPair(g1, g2) is initialised by default such that:  if g1 == g2, then (1.0f, 1.0f) is returned if g1 &lt; g2, then (0.0f, 1.0f) is returned if g1 &gt;  g2, then (1.0f, 0.0f) is returned  In other words, we permit actors in higher groups to be pushed around by actors in lower groups by default.  These settings should cover most applications, and in fact not overriding these settings may likely result in higher performance.  It is not possible to make the matrix asymetric, or to change the diagonal. In other words:  it is not possible to change (g1, g2) if (g1==g2) if you set  (g1, g2) to X, then (g2, g1) will implicitly and automatically be set to ~X, where:  ~(1.0f, 1.0f) is (1.0f, 1.0f) ~(0.0f, 1.0f) is (1.0f, 0.0f) ~(1.0f, 0.0f) is (0.0f, 1.0f)  These two restrictions are to make sure that contacts between two actors will always evaluate to the same dominance setting, regardless of the order of the actors.  Dominance settings are currently specified as floats 0.0f or 1.0f because in the future we may permit arbitrary fractional settings to express 'partly-one-way' interactions.  Sleeping: Does NOT wake actors up automatically.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetDominanceGroupPair(MagicPhysX.PxScene@,System.Byte,System.Byte)">
            <summary>Samples the dominance matrix.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetCpuDispatcher(MagicPhysX.PxScene@)">
            <summary>Return the cpu dispatcher that was set in PxSceneDesc::cpuDispatcher when creating the scene with PxPhysics::createScene</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CreateClientMut(MagicPhysX.PxScene@)">
            <summary>Reserves a new client ID.  PX_DEFAULT_CLIENT is always available as the default clientID. Additional clients are returned by this function. Clients cannot be released once created. An error is reported when more than a supported number of clients (currently 128) are created.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetSimulationEventCallbackMut(MagicPhysX.PxScene@,MagicPhysX.PxSimulationEventCallback*)">
            <summary>Sets a user notify object which receives special simulation events when they occur.  Do not set the callback while the simulation is running. Calls to this method while the simulation is running will be ignored.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSimulationEventCallback(MagicPhysX.PxScene@)">
            <summary>Retrieves the simulationEventCallback pointer set with setSimulationEventCallback().  The current user notify pointer. See [`PxSimulationEventCallback`].</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetContactModifyCallbackMut(MagicPhysX.PxScene@,MagicPhysX.PxContactModifyCallback*)">
            <summary>Sets a user callback object, which receives callbacks on all contacts generated for specified actors.  Do not set the callback while the simulation is running. Calls to this method while the simulation is running will be ignored.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetCCDContactModifyCallbackMut(MagicPhysX.PxScene@,MagicPhysX.PxCCDContactModifyCallback*)">
            <summary>Sets a user callback object, which receives callbacks on all CCD contacts generated for specified actors.  Do not set the callback while the simulation is running. Calls to this method while the simulation is running will be ignored.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetContactModifyCallback(MagicPhysX.PxScene@)">
            <summary>Retrieves the PxContactModifyCallback pointer set with setContactModifyCallback().  The current user contact modify callback pointer. See [`PxContactModifyCallback`].</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetCCDContactModifyCallback(MagicPhysX.PxScene@)">
            <summary>Retrieves the PxCCDContactModifyCallback pointer set with setContactModifyCallback().  The current user contact modify callback pointer. See [`PxContactModifyCallback`].</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetBroadPhaseCallbackMut(MagicPhysX.PxScene@,MagicPhysX.PxBroadPhaseCallback*)">
            <summary>Sets a broad-phase user callback object.  Do not set the callback while the simulation is running. Calls to this method while the simulation is running will be ignored.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetBroadPhaseCallback(MagicPhysX.PxScene@)">
            <summary>Retrieves the PxBroadPhaseCallback pointer set with setBroadPhaseCallback().  The current broad-phase callback pointer. See [`PxBroadPhaseCallback`].</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetFilterShaderDataMut(MagicPhysX.PxScene@,System.Void*,System.UInt32)">
            <summary>Sets the shared global filter data which will get passed into the filter shader.  It is the user's responsibility to ensure that changing the shared global filter data does not change the filter output value for existing pairs. If the filter output for existing pairs does change nonetheless then such a change will not take effect until the pair gets refiltered. resetFiltering() can be used to explicitly refilter the pairs of specific objects.  The provided data will get copied to internal buffers and this copy will be used for filtering calls.  Do not use this method while the simulation is running. Calls to this method while the simulation is running will be ignored.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetFilterShaderData(MagicPhysX.PxScene@)">
            <summary>Gets the shared global filter data in use for this scene.  The reference points to a copy of the original filter data specified in [`PxSceneDesc`].filterShaderData or provided by #setFilterShaderData().  Shared filter data for filter shader.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetFilterShaderDataSize(MagicPhysX.PxScene@)">
            <summary>Gets the size of the shared global filter data ([`PxSceneDesc`].filterShaderData)  Size of shared filter data [bytes].</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ResetFilteringMut(MagicPhysX.PxScene@,MagicPhysX.PxActor*)">
            <summary>Marks the object to reset interactions and re-run collision filters in the next simulation step.  This call forces the object to remove all existing collision interactions, to search anew for existing contact pairs and to run the collision filters again for found collision pairs.  The operation is supported for PxRigidActor objects only.  All persistent state of existing interactions will be lost and can not be retrieved even if the same collison pair is found again in the next step. This will mean, for example, that you will not get notified about persistent contact for such an interaction (see [`PxPairFlag::eNOTIFY_TOUCH_PERSISTS`]), the contact pair will be interpreted as newly found instead.  Lost touch contact reports will be sent for every collision pair which includes this shape, if they have been requested through [`PxPairFlag::eNOTIFY_TOUCH_LOST`] or #PxPairFlag::eNOTIFY_THRESHOLD_FORCE_LOST.  This is an expensive operation, don't use it if you don't have to.  Can be used to retrieve collision pairs that were killed by the collision filters (see [`PxFilterFlag::eKILL`])  It is invalid to use this method if the actor has not been added to a scene already.  It is invalid to use this method if PxActorFlag::eDISABLE_SIMULATION is set.  Do not use this method while the simulation is running.  Sleeping: Does wake up the actor.  True if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ResetFilteringMut1(MagicPhysX.PxScene@,MagicPhysX.PxRigidActor*,MagicPhysX.PxShape**,System.UInt32)">
            <summary>Marks the object to reset interactions and re-run collision filters for specified shapes in the next simulation step.  This is a specialization of the resetFiltering(PxActor &amp; actor) method and allows to reset interactions for specific shapes of a PxRigidActor.  Do not use this method while the simulation is running.  Sleeping: Does wake up the actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetKinematicKinematicFilteringMode(MagicPhysX.PxScene@)">
            <summary>Gets the pair filtering mode for kinematic-kinematic pairs.  Filtering mode for kinematic-kinematic pairs.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetStaticKinematicFilteringMode(MagicPhysX.PxScene@)">
            <summary>Gets the pair filtering mode for static-kinematic pairs.  Filtering mode for static-kinematic pairs.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SimulateMut(MagicPhysX.PxScene@,System.Single,MagicPhysX.PxBaseTask*,System.Void*,System.UInt32,System.Boolean)">
            <summary>Advances the simulation by an elapsedTime time.  Large elapsedTime values can lead to instabilities. In such cases elapsedTime should be subdivided into smaller time intervals and simulate() should be called multiple times for each interval.  Calls to simulate() should pair with calls to fetchResults(): Each fetchResults() invocation corresponds to exactly one simulate() invocation; calling simulate() twice without an intervening fetchResults() or fetchResults() twice without an intervening simulate() causes an error condition.  scene-&gt;simulate(); ...do some processing until physics is computed... scene-&gt;fetchResults(); ...now results of run may be retrieved.  True if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AdvanceMut(MagicPhysX.PxScene@,MagicPhysX.PxBaseTask*)">
            <summary>Performs dynamics phase of the simulation pipeline.  Calls to advance() should follow calls to fetchCollision(). An error message will be issued if this sequence is not followed.  True if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CollideMut(MagicPhysX.PxScene@,System.Single,MagicPhysX.PxBaseTask*,System.Void*,System.UInt32,System.Boolean)">
            <summary>Performs collision detection for the scene over elapsedTime  Calls to collide() should be the first method called to simulate a frame.  True if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CheckResultsMut(MagicPhysX.PxScene@,System.Boolean)">
            <summary>This checks to see if the simulation run has completed.  This does not cause the data available for reading to be updated with the results of the simulation, it is simply a status check. The bool will allow it to either return immediately or block waiting for the condition to be met so that it can return true  True if the results are available.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.FetchCollisionMut(MagicPhysX.PxScene@,System.Boolean)">
            <summary>This method must be called after collide() and before advance(). It will wait for the collision phase to finish. If the user makes an illegal simulation call, the SDK will issue an error message.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.FetchResultsMut(MagicPhysX.PxScene@,System.Boolean,System.UInt32*)">
            <summary>This is the big brother to checkResults() it basically does the following:  True if the results have been fetched.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.FetchResultsStartMut(MagicPhysX.PxScene@,MagicPhysX.PxContactPairHeader**,System.UInt32*,System.Boolean)">
            <summary>This call performs the first section of fetchResults, and returns a pointer to the contact streams output by the simulation. It can be used to process contact pairs in parallel, which is often a limiting factor for fetchResults() performance.  After calling this function and processing the contact streams, call fetchResultsFinish(). Note that writes to the simulation are not permitted between the start of fetchResultsStart() and the end of fetchResultsFinish().  True if the results have been fetched.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ProcessCallbacksMut(MagicPhysX.PxScene@,MagicPhysX.PxBaseTask*)">
            <summary>This call processes all event callbacks in parallel. It takes a continuation task, which will be executed once all callbacks have been processed.  This is a utility function to make it easier to process callbacks in parallel using the PhysX task system. It can only be used in conjunction with fetchResultsStart(...) and fetchResultsFinish(...)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.FetchResultsFinishMut(MagicPhysX.PxScene@,System.UInt32*)">
            <summary>This call performs the second section of fetchResults.  It must be called after fetchResultsStart() returns and contact reports have been processed.  Note that once fetchResultsFinish() has been called, the contact streams returned in fetchResultsStart() will be invalid.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.FetchResultsParticleSystemMut(MagicPhysX.PxScene@)">
            <summary>This call performs the synchronization of particle system data copies.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.FlushSimulationMut(MagicPhysX.PxScene@,System.Boolean)">
            <summary>Clear internal buffers and free memory.  This method can be used to clear buffers and free internal memory without having to destroy the scene. Can be useful if the physics data gets streamed in and a checkpoint with a clean state should be created.  It is not allowed to call this method while the simulation is running. The call will fail.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetGravityMut(MagicPhysX.PxScene@,MagicPhysX.PxVec3*)">
            <summary>Sets a constant gravity for the entire scene.  Do not use this method while the simulation is running.  Sleeping: Does NOT wake the actor up automatically.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetGravity(MagicPhysX.PxScene@)">
            <summary>Retrieves the current gravity setting.  The current gravity for the scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetBounceThresholdVelocityMut(MagicPhysX.PxScene@,System.Single)">
            <summary>Set the bounce threshold velocity.  Collision speeds below this threshold will not cause a bounce.  Do not use this method while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetBounceThresholdVelocity(MagicPhysX.PxScene@)">
            <summary>Return the bounce threshold velocity.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetCCDMaxPassesMut(MagicPhysX.PxScene@,System.UInt32)">
            <summary>Sets the maximum number of CCD passes  Do not use this method while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetCCDMaxPasses(MagicPhysX.PxScene@)">
            <summary>Gets the maximum number of CCD passes.  The maximum number of CCD passes.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetCCDMaxSeparationMut(MagicPhysX.PxScene@,System.Single)">
            <summary>Set the maximum CCD separation.  Do not use this method while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetCCDMaxSeparation(MagicPhysX.PxScene@)">
            <summary>Gets the maximum CCD separation.  The maximum CCD separation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetCCDThresholdMut(MagicPhysX.PxScene@,System.Single)">
            <summary>Set the CCD threshold.  Do not use this method while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetCCDThreshold(MagicPhysX.PxScene@)">
            <summary>Gets the CCD threshold.  The CCD threshold.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetMaxBiasCoefficientMut(MagicPhysX.PxScene@,System.Single)">
            <summary>Set the max bias coefficient.  Do not use this method while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetMaxBiasCoefficient(MagicPhysX.PxScene@)">
            <summary>Gets the max bias coefficient.  The max bias coefficient.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetFrictionOffsetThresholdMut(MagicPhysX.PxScene@,System.Single)">
            <summary>Set the friction offset threshold.  Do not use this method while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetFrictionOffsetThreshold(MagicPhysX.PxScene@)">
            <summary>Gets the friction offset threshold.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetFrictionCorrelationDistanceMut(MagicPhysX.PxScene@,System.Single)">
            <summary>Set the friction correlation distance.  Do not use this method while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetFrictionCorrelationDistance(MagicPhysX.PxScene@)">
            <summary>Gets the friction correlation distance.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetFrictionType(MagicPhysX.PxScene@)">
            <summary>Return the friction model.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSolverType(MagicPhysX.PxScene@)">
            <summary>Return the solver model.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetVisualizationParameterMut(MagicPhysX.PxScene@,MagicPhysX.PxVisualizationParameter,System.Single)">
            <summary>Function that lets you set debug visualization parameters.  Returns false if the value passed is out of range for usage specified by the enum.  Do not use this method while the simulation is running.  False if the parameter is out of range.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetVisualizationParameter(MagicPhysX.PxScene@,MagicPhysX.PxVisualizationParameter)">
            <summary>Function that lets you query debug visualization parameters.  The value of the parameter.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetVisualizationCullingBoxMut(MagicPhysX.PxScene@,MagicPhysX.PxBounds3*)">
            <summary>Defines a box in world space to which visualization geometry will be (conservatively) culled. Use a non-empty culling box to enable the feature, and an empty culling box to disable it.  Do not use this method while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetVisualizationCullingBox(MagicPhysX.PxScene@)">
            <summary>Retrieves the visualization culling box.  the box to which the geometry will be culled.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetRenderBufferMut(MagicPhysX.PxScene@)">
            <summary>Retrieves the render buffer.  This will contain the results of any active visualization for this scene.  Do not use this method while the simulation is running. Calls to this method while the simulation is running will result in undefined behaviour.  The render buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSimulationStatistics(MagicPhysX.PxScene@,MagicPhysX.PxSimulationStatistics*)">
            <summary>Call this method to retrieve statistics for the current simulation step.  Do not use this method while the simulation is running. Calls to this method while the simulation is running will be ignored.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetBroadPhaseType(MagicPhysX.PxScene@)">
            <summary>Returns broad-phase type.  Broad-phase type</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetBroadPhaseCaps(MagicPhysX.PxScene@,MagicPhysX.PxBroadPhaseCaps*)">
            <summary>Gets broad-phase caps.  True if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbBroadPhaseRegions(MagicPhysX.PxScene@)">
            <summary>Returns number of regions currently registered in the broad-phase.  Number of regions</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetBroadPhaseRegions(MagicPhysX.PxScene@,MagicPhysX.PxBroadPhaseRegionInfo*,System.UInt32,System.UInt32)">
            <summary>Gets broad-phase regions.  Number of written out regions</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AddBroadPhaseRegionMut(MagicPhysX.PxScene@,MagicPhysX.PxBroadPhaseRegion*,System.Boolean)">
            <summary>Adds a new broad-phase region.  The bounds for the new region must be non-empty, otherwise an error occurs and the call is ignored.  Note that by default, objects already existing in the SDK that might touch this region will not be automatically added to the region. In other words the newly created region will be empty, and will only be populated with new objects when they are added to the simulation, or with already existing objects when they are updated.  It is nonetheless possible to override this default behavior and let the SDK populate the new region automatically with already existing objects overlapping the incoming region. This has a cost though, and it should only be used when the game can not guarantee that all objects within the new region will be added to the simulation after the region itself.  Objects automatically move from one region to another during their lifetime. The system keeps tracks of what regions a given object is in. It is legal for an object to be in an arbitrary number of regions. However if an object leaves all regions, or is created outside of all regions, several things happen: - collisions get disabled for this object - if a PxBroadPhaseCallback object is provided, an \"out-of-bounds\" event is generated via that callback - if a PxBroadPhaseCallback object is not provided, a warning/error message is sent to the error stream  If an object goes out-of-bounds and user deletes it during the same frame, neither the out-of-bounds event nor the error message is generated.  Handle for newly created region, or 0xffffffff in case of failure.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.RemoveBroadPhaseRegionMut(MagicPhysX.PxScene@,System.UInt32)">
            <summary>Removes a new broad-phase region.  If the region still contains objects, and if those objects do not overlap any region any more, they are not automatically removed from the simulation. Instead, the PxBroadPhaseCallback::onObjectOutOfBounds notification is used for each object. Users are responsible for removing the objects from the simulation if this is the desired behavior.  If the handle is invalid, or if a valid handle is removed twice, an error message is sent to the error stream.  True if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetTaskManager(MagicPhysX.PxScene@)">
            <summary>Get the task manager associated with this scene  the task manager associated with the scene</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.LockReadMut(MagicPhysX.PxScene@,System.Byte*,System.UInt32)">
            <summary>Lock the scene for reading from the calling thread.  When the PxSceneFlag::eREQUIRE_RW_LOCK flag is enabled lockRead() must be called before any read calls are made on the scene.  Multiple threads may read at the same time, no threads may read while a thread is writing. If a call to lockRead() is made while another thread is holding a write lock then the calling thread will be blocked until the writing thread calls unlockWrite().  Lock upgrading is *not* supported, that means it is an error to call lockRead() followed by lockWrite().  Recursive locking is supported but each lockRead() call must be paired with an unlockRead().</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.UnlockReadMut(MagicPhysX.PxScene@)">
            <summary>Unlock the scene from reading.  Each unlockRead() must be paired with a lockRead() from the same thread.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.LockWriteMut(MagicPhysX.PxScene@,System.Byte*,System.UInt32)">
            <summary>Lock the scene for writing from this thread.  When the PxSceneFlag::eREQUIRE_RW_LOCK flag is enabled lockWrite() must be called before any write calls are made on the scene.  Only one thread may write at a time and no threads may read while a thread is writing. If a call to lockWrite() is made and there are other threads reading then the calling thread will be blocked until the readers complete.  Writers have priority. If a thread is blocked waiting to write then subsequent calls to lockRead() from other threads will be blocked until the writer completes.  If multiple threads are waiting to write then the thread that is first granted access depends on OS scheduling.  Recursive locking is supported but each lockWrite() call must be paired with an unlockWrite().  If a thread has already locked the scene for writing then it may call lockRead().</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.UnlockWriteMut(MagicPhysX.PxScene@)">
            <summary>Unlock the scene from writing.  Each unlockWrite() must be paired with a lockWrite() from the same thread.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetNbContactDataBlocksMut(MagicPhysX.PxScene@,System.UInt32)">
            <summary>set the cache blocks that can be used during simulate().  Each frame the simulation requires memory to store contact, friction, and contact cache data. This memory is used in blocks of 16K. Each frame the blocks used by the previous frame are freed, and may be retrieved by the application using PxScene::flushSimulation()  This call will force allocation of cache blocks if the numBlocks parameter is greater than the currently allocated number of blocks, and less than the max16KContactDataBlocks parameter specified at scene creation time.  Do not use this method while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbContactDataBlocksUsed(MagicPhysX.PxScene@)">
            <summary>get the number of cache blocks currently used by the scene  This function may not be called while the scene is simulating  the number of cache blocks currently used by the scene</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetMaxNbContactDataBlocksUsed(MagicPhysX.PxScene@)">
            <summary>get the maximum number of cache blocks used by the scene  This function may not be called while the scene is simulating  the maximum number of cache blocks everused by the scene</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetContactReportStreamBufferSize(MagicPhysX.PxScene@)">
            <summary>Return the value of PxSceneDesc::contactReportStreamBufferSize that was set when creating the scene with PxPhysics::createScene</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetSolverBatchSizeMut(MagicPhysX.PxScene@,System.UInt32)">
            <summary>Sets the number of actors required to spawn a separate rigid body solver thread.  Do not use this method while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSolverBatchSize(MagicPhysX.PxScene@)">
            <summary>Retrieves the number of actors required to spawn a separate rigid body solver thread.  Current number of actors required to spawn a separate rigid body solver thread.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetSolverArticulationBatchSizeMut(MagicPhysX.PxScene@,System.UInt32)">
            <summary>Sets the number of articulations required to spawn a separate rigid body solver thread.  Do not use this method while the simulation is running.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSolverArticulationBatchSize(MagicPhysX.PxScene@)">
            <summary>Retrieves the number of articulations required to spawn a separate rigid body solver thread.  Current number of articulations required to spawn a separate rigid body solver thread.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetWakeCounterResetValue(MagicPhysX.PxScene@)">
            <summary>Returns the wake counter reset value.  Wake counter reset value</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ShiftOriginMut(MagicPhysX.PxScene@,MagicPhysX.PxVec3*)">
            <summary>Shift the scene origin by the specified vector.  The poses of all objects in the scene and the corresponding data structures will get adjusted to reflect the new origin location (the shift vector will get subtracted from all object positions).  It is the user's responsibility to keep track of the summed total origin shift and adjust all input/output to/from PhysX accordingly.  Do not use this method while the simulation is running. Calls to this method while the simulation is running will be ignored.  Make sure to propagate the origin shift to other dependent modules (for example, the character controller module etc.).  This is an expensive operation and we recommend to use it only in the case where distance related precision issues may arise in areas far from the origin.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetScenePvdClientMut(MagicPhysX.PxScene@)">
            <summary>Returns the Pvd client associated with the scene.  the client, NULL if no PVD supported.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CopyArticulationDataMut(MagicPhysX.PxScene@,System.Void*,System.Void*,MagicPhysX.PxArticulationGpuDataType,System.UInt32,System.Void*)">
            <summary>Copy GPU articulation data from the internal GPU buffer to a user-provided device buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ApplyArticulationDataMut(MagicPhysX.PxScene@,System.Void*,System.Void*,MagicPhysX.PxArticulationGpuDataType,System.UInt32,System.Void*,System.Void*)">
            <summary>Apply GPU articulation data from a user-provided device buffer to the internal GPU buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CopySoftBodyDataMut(MagicPhysX.PxScene@,System.Void**,System.Void*,System.Void*,MagicPhysX.PxSoftBodyDataFlag,System.UInt32,System.UInt32,System.Void*)">
            <summary>Copy GPU softbody data from the internal GPU buffer to a user-provided device buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ApplySoftBodyDataMut(MagicPhysX.PxScene@,System.Void**,System.Void*,System.Void*,MagicPhysX.PxSoftBodyDataFlag,System.UInt32,System.UInt32,System.Void*)">
            <summary>Apply user-provided data to the internal softbody system.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CopyContactDataMut(MagicPhysX.PxScene@,System.Void*,System.UInt32,System.Void*,System.Void*)">
            <summary>Copy contact data from the internal GPU buffer to a user-provided device buffer.  The contact data contains pointers to internal state and is only valid until the next call to simulate().</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CopyBodyDataMut(MagicPhysX.PxScene@,MagicPhysX.PxGpuBodyData*,MagicPhysX.PxGpuActorPair*,System.UInt32,System.Void*)">
            <summary>Copy GPU rigid body data from the internal GPU buffer to a user-provided device buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ApplyActorDataMut(MagicPhysX.PxScene@,System.Void*,MagicPhysX.PxGpuActorPair*,MagicPhysX.PxActorCacheFlag,System.UInt32,System.Void*,System.Void*)">
            <summary>Apply user-provided data to rigid body.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ComputeDenseJacobiansMut(MagicPhysX.PxScene@,MagicPhysX.PxIndexDataPair*,System.UInt32,System.Void*)">
            <summary>Compute dense Jacobian matrices for specified articulations on the GPU.  The size of Jacobians can vary by articulation, since it depends on the number of links, degrees-of-freedom, and whether the base is fixed.  The size is determined using these formulas: nCols = (fixedBase ? 0 : 6) + dofCount nRows = (fixedBase ? 0 : 6) + (linkCount - 1) * 6;  The user must ensure that adequate space is provided for each Jacobian matrix.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ComputeGeneralizedMassMatricesMut(MagicPhysX.PxScene@,MagicPhysX.PxIndexDataPair*,System.UInt32,System.Void*)">
            <summary>Compute the joint-space inertia matrices that maps joint accelerations to joint forces: forces = M * accelerations on the GPU.  The size of matrices can vary by articulation, since it depends on the number of links and degrees-of-freedom.  The size is determined using this formula: sizeof(float) * dofCount * dofCount  The user must ensure that adequate space is provided for each mass matrix.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ComputeGeneralizedGravityForcesMut(MagicPhysX.PxScene@,MagicPhysX.PxIndexDataPair*,System.UInt32,System.Void*)">
            <summary>Computes the joint DOF forces required to counteract gravitational forces for the given articulation pose.  The size of the result can vary by articulation, since it depends on the number of links and degrees-of-freedom.  The size is determined using this formula: sizeof(float) * dofCount  The user must ensure that adequate space is provided for each articulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ComputeCoriolisAndCentrifugalForcesMut(MagicPhysX.PxScene@,MagicPhysX.PxIndexDataPair*,System.UInt32,System.Void*)">
            <summary>Computes the joint DOF forces required to counteract coriolis and centrifugal forces for the given articulation pose.  The size of the result can vary by articulation, since it depends on the number of links and degrees-of-freedom.  The size is determined using this formula: sizeof(float) * dofCount  The user must ensure that adequate space is provided for each articulation.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ApplyParticleBufferDataMut(MagicPhysX.PxScene@,System.UInt32*,MagicPhysX.PxGpuParticleBufferIndexPair*,MagicPhysX.PxParticleBufferFlags*,System.UInt32,System.Void*,System.Void*)">
            <summary>Apply user-provided data to particle buffers.  This function should be used if the particle buffer flags are already on the device. Otherwise, use PxParticleBuffer::raiseFlags() from the CPU.  This assumes the data has been changed directly in the PxParticleBuffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReadLockNewAlloc(MagicPhysX.PxScene@,System.Byte*,System.UInt32)">
            <summary>Constructor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.WriteLockNewAlloc(MagicPhysX.PxScene@,System.Byte*,System.UInt32)">
            <summary>Constructor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxCreateControllerManager(MagicPhysX.PxScene@,System.Boolean)">
            <summary>Creates the controller manager.  The character controller is informed by [`PxDeletionListener::onRelease`]() when actors or shapes are released, and updates its internal caches accordingly. If character controller movement or a call to [`PxControllerManager::shiftOrigin`]() may overlap with actor/shape releases, internal data structures must be guarded against concurrent access.  Locking guarantees thread safety in such scenarios.  locking may result in significant slowdown for release of actors or shapes.  By default, locking is disabled.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.QueryExtRaycastAny(MagicPhysX.PxScene@,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxQueryHit*,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryFilterCallback*,MagicPhysX.PxQueryCache*)">
            <summary>Raycast returning any blocking hit, not necessarily the closest.  Returns whether any rigid actor is hit along the ray.  Shooting a ray from within an object leads to different results depending on the shape type. Please check the details in article SceneQuery. User can ignore such objects by using one of the provided filter mechanisms.  True if a blocking hit was found.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.QueryExtRaycastSingle(MagicPhysX.PxScene@,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxHitFlags,MagicPhysX.PxRaycastHit*,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryFilterCallback*,MagicPhysX.PxQueryCache*)">
            <summary>Raycast returning a single result.  Returns the first rigid actor that is hit along the ray. Data for a blocking hit will be returned as specified by the outputFlags field. Touching hits will be ignored.  Shooting a ray from within an object leads to different results depending on the shape type. Please check the details in article SceneQuery. User can ignore such objects by using one of the provided filter mechanisms.  True if a blocking hit was found.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.QueryExtRaycastMultiple(MagicPhysX.PxScene@,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxHitFlags,MagicPhysX.PxRaycastHit*,System.UInt32,System.Boolean*,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryFilterCallback*,MagicPhysX.PxQueryCache*)">
            <summary>Raycast returning multiple results.  Find all rigid actors that get hit along the ray. Each result contains data as specified by the outputFlags field.  Touching hits are not ordered.  Shooting a ray from within an object leads to different results depending on the shape type. Please check the details in article SceneQuery. User can ignore such objects by using one of the provided filter mechanisms.  Number of hits in the buffer, or -1 if the buffer overflowed.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.QueryExtSweepAny(MagicPhysX.PxScene@,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxHitFlags,MagicPhysX.PxQueryHit*,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryFilterCallback*,MagicPhysX.PxQueryCache*,System.Single)">
            <summary>Sweep returning any blocking hit, not necessarily the closest.  Returns whether any rigid actor is hit along the sweep path.  If a shape from the scene is already overlapping with the query shape in its starting position, behavior is controlled by the PxSceneQueryFlag::eINITIAL_OVERLAP flag.  True if a blocking hit was found.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.QueryExtSweepSingle(MagicPhysX.PxScene@,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxHitFlags,MagicPhysX.PxSweepHit*,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryFilterCallback*,MagicPhysX.PxQueryCache*,System.Single)">
            <summary>Sweep returning a single result.  Returns the first rigid actor that is hit along the ray. Data for a blocking hit will be returned as specified by the outputFlags field. Touching hits will be ignored.  If a shape from the scene is already overlapping with the query shape in its starting position, behavior is controlled by the PxSceneQueryFlag::eINITIAL_OVERLAP flag.  True if a blocking hit was found.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.QueryExtSweepMultiple(MagicPhysX.PxScene@,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxVec3*,System.Single,MagicPhysX.PxHitFlags,MagicPhysX.PxSweepHit*,System.UInt32,System.Boolean*,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryFilterCallback*,MagicPhysX.PxQueryCache*,System.Single)">
            <summary>Sweep returning multiple results.  Find all rigid actors that get hit along the sweep. Each result contains data as specified by the outputFlags field.  Touching hits are not ordered.  If a shape from the scene is already overlapping with the query shape in its starting position, behavior is controlled by the PxSceneQueryFlag::eINITIAL_OVERLAP flag.  Number of hits in the buffer, or -1 if the buffer overflowed.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.QueryExtOverlapMultiple(MagicPhysX.PxScene@,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxOverlapHit*,System.UInt32,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryFilterCallback*)">
            <summary>Test overlap between a geometry and objects in the scene.  Filtering: Overlap tests do not distinguish between touching and blocking hit types. Both get written to the hit buffer.  PxHitFlag::eMESH_MULTIPLE and PxHitFlag::eMESH_BOTH_SIDES have no effect in this case  Number of hits in the buffer, or -1 if the buffer overflowed.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.QueryExtOverlapAny(MagicPhysX.PxScene@,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxOverlapHit*,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryFilterCallback*)">
            <summary>Test returning, for a given geometry, any overlapping object in the scene.  Filtering: Overlap tests do not distinguish between touching and blocking hit types. Both trigger a hit.  PxHitFlag::eMESH_MULTIPLE and PxHitFlag::eMESH_BOTH_SIDES have no effect in this case  True if an overlap was found.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxCreateBatchQueryExt(MagicPhysX.PxScene@,MagicPhysX.PxQueryFilterCallback*,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>Create a PxBatchQueryExt without the need for pre-allocated result or touch buffers.  Returns a PxBatchQueryExt instance. A NULL pointer will be returned if the subsequent allocations fail or if any of the arguments are illegal. In the event that a NULL pointer is returned a corresponding error will be issued to the error stream.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxCreateBatchQueryExt1(MagicPhysX.PxScene@,MagicPhysX.PxQueryFilterCallback*,MagicPhysX.PxRaycastBuffer*,System.UInt32,MagicPhysX.PxRaycastHit*,System.UInt32,MagicPhysX.PxSweepBuffer*,System.UInt32,MagicPhysX.PxSweepHit*,System.UInt32,MagicPhysX.PxOverlapBuffer*,System.UInt32,MagicPhysX.PxOverlapHit*,System.UInt32)">
            <summary>Create a PxBatchQueryExt with user-supplied result and touch buffers.  Returns a PxBatchQueryExt instance. A NULL pointer will be returned if the subsequent allocations fail or if any of the arguments are illegal. In the event that a NULL pointer is returned a corresponding error will be issued to the error stream.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.NextItemSetMut(MagicPhysX.PxContactPairExtraDataIterator@)">
            <summary>Advances the iterator to next set of extra data items.  The contact pair extra data stream contains sets of items as requested by the corresponding [`PxPairFlag`] flags [`PxPairFlag::ePRE_SOLVER_VELOCITY`], #PxPairFlag::ePOST_SOLVER_VELOCITY, #PxPairFlag::eCONTACT_EVENT_POSE. A set can contain one item of each plus the PxContactPairIndex item. This method parses the stream and points the iterator member variables to the corresponding items of the current set, if they are available. If CCD is not enabled, you should only get one set of items. If CCD with multiple passes is enabled, you might get more than one item set.  Even though contact pair extra data is requested per shape pair, you will not get an item set per shape pair but one per actor pair. If, for example, an actor has two shapes and both collide with another actor, then there will only be one item set (since it applies to both shape pairs).  True if there was another set of extra data items in the stream, else false.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ExtractContacts(MagicPhysX.PxContactPair@,MagicPhysX.PxContactPairPoint*,System.UInt32)">
            <summary>Extracts the contact points from the stream and stores them in a convenient format.  Number of contact points written to the buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.BufferContacts(MagicPhysX.PxContactPair@,MagicPhysX.PxContactPair*,System.Byte*)">
            <summary>Helper method to clone the contact pair and copy the contact data stream into a user buffer.  The contact data stream is only accessible during the contact report callback. This helper function provides copy functionality to buffer the contact stream information such that it can get accessed at a later stage.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxPruningStructure@)">
            <summary>Release this object.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetRigidActors(MagicPhysX.PxPruningStructure@,MagicPhysX.PxRigidActor**,System.UInt32,System.UInt32)">
            <summary>Retrieve rigid actors in the pruning structure.  You can retrieve the number of rigid actor pointers by calling [`getNbRigidActors`]()  Number of rigid actor pointers written to the buffer.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbRigidActors(MagicPhysX.PxPruningStructure@)">
            <summary>Returns the number of rigid actors in the pruning structure.  You can use [`getRigidActors`]() to retrieve the rigid actor pointers.  Number of rigid actors in the pruning structure.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetStaticMergeData(MagicPhysX.PxPruningStructure@)">
            <summary>Gets the merge data for static actors  This is mainly called by the PxSceneQuerySystem::merge() function to merge a PxPruningStructure with the internal data-structures of the scene-query system.  Implementation-dependent merge data for static actors.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetDynamicMergeData(MagicPhysX.PxPruningStructure@)">
            <summary>Gets the merge data for dynamic actors  This is mainly called by the PxSceneQuerySystem::merge() function to merge a PxPruningStructure with the internal data-structures of the scene-query system.  Implementation-dependent merge data for dynamic actors.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxObstacleContext@)">
            <summary>Releases the context.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetControllerManager(MagicPhysX.PxObstacleContext@)">
            <summary>Retrieves the controller manager associated with this context.  The associated controller manager</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AddObstacleMut(MagicPhysX.PxObstacleContext@,MagicPhysX.PxObstacle*)">
            <summary>Adds an obstacle to the context.  Handle for newly-added obstacle</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.RemoveObstacleMut(MagicPhysX.PxObstacleContext@,System.UInt32)">
            <summary>Removes an obstacle from the context.  True if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.UpdateObstacleMut(MagicPhysX.PxObstacleContext@,System.UInt32,MagicPhysX.PxObstacle*)">
            <summary>Updates data for an existing obstacle.  True if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbObstacles(MagicPhysX.PxObstacleContext@)">
            <summary>Retrieves number of obstacles in the context.  Number of obstacles in the context</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetObstacle(MagicPhysX.PxObstacleContext@,System.UInt32)">
            <summary>Retrieves desired obstacle.  Desired obstacle</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetObstacleByHandle(MagicPhysX.PxObstacleContext@,System.UInt32)">
            <summary>Retrieves desired obstacle by given handle.  Desired obstacle</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.OnShapeHitMut(MagicPhysX.PxUserControllerHitReport@,MagicPhysX.PxControllerShapeHit*)">
            <summary>Called when current controller hits a shape.  This is called when the CCT moves and hits a shape. This will not be called when a moving shape hits a non-moving CCT.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.OnControllerHitMut(MagicPhysX.PxUserControllerHitReport@,MagicPhysX.PxControllersHit*)">
            <summary>Called when current controller hits another controller.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.OnObstacleHitMut(MagicPhysX.PxUserControllerHitReport@,MagicPhysX.PxControllerObstacleHit*)">
            <summary>Called when current controller hits a user-defined obstacle.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.FilterMut(MagicPhysX.PxControllerFilterCallback@,MagicPhysX.PxController*,MagicPhysX.PxController*)">
            <summary>Filtering method for CCT-vs-CCT.  true to keep the pair, false to filter it out</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxControllerDesc@)">
            <summary>returns true if the current settings are valid  True if the descriptor is valid.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetType(MagicPhysX.PxControllerDesc@)">
            <summary>Returns the character controller type  The controllers type.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetType(MagicPhysX.PxController@)">
            <summary>Return the type of controller</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxController@)">
            <summary>Releases the controller.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.MoveMut(MagicPhysX.PxController@,MagicPhysX.PxVec3*,System.Single,System.Single,MagicPhysX.PxControllerFilters*,MagicPhysX.PxObstacleContext*)">
            <summary>Moves the character using a \"collide-and-slide\" algorithm.  Collision flags, collection of ::PxControllerCollisionFlags</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetPositionMut(MagicPhysX.PxController@,MagicPhysX.PxExtendedVec3*)">
            <summary>Sets controller's position.  The position controlled by this function is the center of the collision shape.  This is a 'teleport' function, it doesn't check for collisions.  The character's position must be such that it does not overlap the static geometry.  To move the character under normal conditions use the [`move`]() function.  Currently always returns true.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetPosition(MagicPhysX.PxController@)">
            <summary>Retrieve the raw position of the controller.  The position retrieved by this function is the center of the collision shape. To retrieve the bottom position of the shape, a.k.a. the foot position, use the getFootPosition() function.  The position is updated by calls to move(). Calling this method without calling move() will return the last position or the initial position of the controller.  The controller's center position</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetFootPositionMut(MagicPhysX.PxController@,MagicPhysX.PxExtendedVec3*)">
            <summary>Set controller's foot position.  The position controlled by this function is the bottom of the collision shape, a.k.a. the foot position.  The foot position takes the contact offset into account  This is a 'teleport' function, it doesn't check for collisions.  To move the character under normal conditions use the [`move`]() function.  Currently always returns true.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetFootPosition(MagicPhysX.PxController@)">
            <summary>Retrieve the \"foot\" position of the controller, i.e. the position of the bottom of the CCT's shape.  The foot position takes the contact offset into account  The controller's foot position</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetActor(MagicPhysX.PxController@)">
            <summary>Get the rigid body actor associated with this controller (see PhysX documentation). The behavior upon manually altering this actor is undefined, you should primarily use it for reading const properties.  the actor associated with the controller.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetStepOffsetMut(MagicPhysX.PxController@,System.Single)">
            <summary>The step height.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetStepOffset(MagicPhysX.PxController@)">
            <summary>Retrieve the step height.  The step offset for the controller.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetNonWalkableModeMut(MagicPhysX.PxController@,MagicPhysX.PxControllerNonWalkableMode)">
            <summary>Sets the non-walkable mode for the CCT.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNonWalkableMode(MagicPhysX.PxController@)">
            <summary>Retrieves the non-walkable mode for the CCT.  The current non-walkable mode.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetContactOffset(MagicPhysX.PxController@)">
            <summary>Retrieve the contact offset.  The contact offset for the controller.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetContactOffsetMut(MagicPhysX.PxController@,System.Single)">
            <summary>Sets the contact offset.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetUpDirection(MagicPhysX.PxController@)">
            <summary>Retrieve the 'up' direction.  The up direction for the controller.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetUpDirectionMut(MagicPhysX.PxController@,MagicPhysX.PxVec3*)">
            <summary>Sets the 'up' direction.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSlopeLimit(MagicPhysX.PxController@)">
            <summary>Retrieve the slope limit.  The slope limit for the controller.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetSlopeLimitMut(MagicPhysX.PxController@,System.Single)">
            <summary>Sets the slope limit.  This feature can not be enabled at runtime, i.e. if the slope limit is zero when creating the CCT (which disables the feature) then changing the slope limit at runtime will not have any effect, and the call will be ignored.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.InvalidateCacheMut(MagicPhysX.PxController@)">
            <summary>Flushes internal geometry cache.  The character controller uses caching in order to speed up collision testing. The cache is automatically flushed when a change to static objects is detected in the scene. For example when a static shape is added, updated, or removed from the scene, the cache is automatically invalidated.  However there may be situations that cannot be automatically detected, and those require manual invalidation of the cache. Currently the user must call this when the filtering behavior changes (the PxControllerFilters parameter of the PxController::move call).  While the controller in principle could detect a change in these parameters, it cannot detect a change in the behavior of the filtering function.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSceneMut(MagicPhysX.PxController@)">
            <summary>Retrieve the scene associated with the controller.  The physics scene</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetUserData(MagicPhysX.PxController@)">
            <summary>Returns the user data associated with this controller.  The user pointer associated with the controller.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetUserDataMut(MagicPhysX.PxController@,System.Void*)">
            <summary>Sets the user data associated with this controller.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetState(MagicPhysX.PxController@,MagicPhysX.PxControllerState*)">
            <summary>Returns information about the controller's internal state.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetStats(MagicPhysX.PxController@,MagicPhysX.PxControllerStats*)">
            <summary>Returns the controller's internal statistics.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ResizeMut(MagicPhysX.PxController@,System.Single)">
            <summary>Resizes the controller.  This function attempts to resize the controller to a given size, while making sure the bottom position of the controller remains constant. In other words the function modifies both the height and the (center) position of the controller. This is a helper function that can be used to implement a 'crouch' functionality for example.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetToDefaultMut(MagicPhysX.PxBoxControllerDesc@)">
            <summary>(re)sets the structure to the default.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxBoxControllerDesc@)">
            <summary>returns true if the current settings are valid  True if the descriptor is valid.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetHalfHeight(MagicPhysX.PxBoxController@)">
            <summary>Gets controller's half height.  The half height of the controller.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetHalfSideExtent(MagicPhysX.PxBoxController@)">
            <summary>Gets controller's half side extent.  The half side extent of the controller.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetHalfForwardExtent(MagicPhysX.PxBoxController@)">
            <summary>Gets controller's half forward extent.  The half forward extent of the controller.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetHalfHeightMut(MagicPhysX.PxBoxController@,System.Single)">
            <summary>Sets controller's half height.  this doesn't check for collisions.  Currently always true.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetHalfSideExtentMut(MagicPhysX.PxBoxController@,System.Single)">
            <summary>Sets controller's half side extent.  this doesn't check for collisions.  Currently always true.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetHalfForwardExtentMut(MagicPhysX.PxBoxController@,System.Single)">
            <summary>Sets controller's half forward extent.  this doesn't check for collisions.  Currently always true.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetToDefaultMut(MagicPhysX.PxCapsuleControllerDesc@)">
            <summary>(re)sets the structure to the default.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxCapsuleControllerDesc@)">
            <summary>returns true if the current settings are valid  True if the descriptor is valid.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetRadius(MagicPhysX.PxCapsuleController@)">
            <summary>Gets controller's radius.  The radius of the controller.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetRadiusMut(MagicPhysX.PxCapsuleController@,System.Single)">
            <summary>Sets controller's radius.  this doesn't check for collisions.  Currently always true.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetHeight(MagicPhysX.PxCapsuleController@)">
            <summary>Gets controller's height.  The height of the capsule controller.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetHeightMut(MagicPhysX.PxCapsuleController@,System.Single)">
            <summary>Resets controller's height.  this doesn't check for collisions.  Currently always true.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetClimbingMode(MagicPhysX.PxCapsuleController@)">
            <summary>Gets controller's climbing mode.  The capsule controller's climbing mode.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetClimbingModeMut(MagicPhysX.PxCapsuleController@,MagicPhysX.PxCapsuleClimbingMode)">
            <summary>Sets controller's climbing mode.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetBehaviorFlagsMut(MagicPhysX.PxControllerBehaviorCallback@,MagicPhysX.PxShape*,MagicPhysX.PxActor*)">
            <summary>Retrieve behavior flags for a shape.  When the CCT touches a shape, the CCT's behavior w.r.t. this shape can be customized by users. This function retrieves the desired PxControllerBehaviorFlag flags capturing the desired behavior.  See comments about deprecated functions at the start of this class  Desired behavior flags for the given shape</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetBehaviorFlagsMut1(MagicPhysX.PxControllerBehaviorCallback@,MagicPhysX.PxController*)">
            <summary>Retrieve behavior flags for a controller.  When the CCT touches a controller, the CCT's behavior w.r.t. this controller can be customized by users. This function retrieves the desired PxControllerBehaviorFlag flags capturing the desired behavior.  The flag PxControllerBehaviorFlag::eCCT_CAN_RIDE_ON_OBJECT is not supported.  See comments about deprecated functions at the start of this class  Desired behavior flags for the given controller</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetBehaviorFlagsMut2(MagicPhysX.PxControllerBehaviorCallback@,MagicPhysX.PxObstacle*)">
            <summary>Retrieve behavior flags for an obstacle.  When the CCT touches an obstacle, the CCT's behavior w.r.t. this obstacle can be customized by users. This function retrieves the desired PxControllerBehaviorFlag flags capturing the desired behavior.  See comments about deprecated functions at the start of this class  Desired behavior flags for the given obstacle</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxControllerManager@)">
            <summary>Releases the controller manager.  This will release all associated controllers and obstacle contexts.  This function is required to be called to release foundation usage.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetScene(MagicPhysX.PxControllerManager@)">
            <summary>Returns the scene the manager is adding the controllers to.  The associated physics scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbControllers(MagicPhysX.PxControllerManager@)">
            <summary>Returns the number of controllers that are being managed.  The number of controllers.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetControllerMut(MagicPhysX.PxControllerManager@,System.UInt32)">
            <summary>Retrieve one of the controllers in the manager.  The controller with the specified index.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CreateControllerMut(MagicPhysX.PxControllerManager@,MagicPhysX.PxControllerDesc*)">
            <summary>Creates a new character controller.  The new controller</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PurgeControllersMut(MagicPhysX.PxControllerManager@)">
            <summary>Releases all the controllers that are being managed.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetRenderBufferMut(MagicPhysX.PxControllerManager@)">
            <summary>Retrieves debug data.  The render buffer filled with debug-render data</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetDebugRenderingFlagsMut(MagicPhysX.PxControllerManager@,MagicPhysX.PxControllerDebugRenderFlags)">
            <summary>Sets debug rendering flags</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbObstacleContexts(MagicPhysX.PxControllerManager@)">
            <summary>Returns the number of obstacle contexts that are being managed.  The number of obstacle contexts.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetObstacleContextMut(MagicPhysX.PxControllerManager@,System.UInt32)">
            <summary>Retrieve one of the obstacle contexts in the manager.  The obstacle context with the specified index.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CreateObstacleContextMut(MagicPhysX.PxControllerManager@)">
            <summary>Creates an obstacle context.  New obstacle context</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ComputeInteractionsMut(MagicPhysX.PxControllerManager@,System.Single,MagicPhysX.PxControllerFilterCallback*)">
            <summary>Computes character-character interactions.  This function is an optional helper to properly resolve interactions between characters, in case they overlap (which can happen for gameplay reasons, etc).  You should call this once per frame, before your PxController::move() calls. The function will not move the characters directly, but it will compute overlap information for each character that will be used in the next move() call.  You need to provide a proper time value here so that interactions are resolved in a way that do not depend on the framerate.  If you only have one character in the scene, or if you can guarantee your characters will never overlap, then you do not need to call this function.  Releasing the manager will automatically release all the associated obstacle contexts.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetTessellationMut(MagicPhysX.PxControllerManager@,System.Boolean,System.Single)">
            <summary>Enables or disables runtime tessellation.  Large triangles can create accuracy issues in the sweep code, which in turn can lead to characters not sliding smoothly against geometries, or even penetrating them. This feature allows one to reduce those issues by tessellating large triangles at runtime, before performing sweeps against them. The amount of tessellation is controlled by the 'maxEdgeLength' parameter. Any triangle with at least one edge length greater than the maxEdgeLength will get recursively tessellated, until resulting triangles are small enough.  This features only applies to triangle meshes, convex meshes, heightfields and boxes.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetOverlapRecoveryModuleMut(MagicPhysX.PxControllerManager@,System.Boolean)">
            <summary>Enables or disables the overlap recovery module.  The overlap recovery module can be used to depenetrate CCTs from static objects when an overlap is detected. This can happen in three main cases: - when the CCT is directly spawned or teleported in another object - when the CCT algorithm fails due to limited FPU accuracy - when the \"up vector\" is modified, making the rotated CCT shape overlap surrounding objects  When activated, the CCT module will automatically try to resolve the penetration, and move the CCT to a safe place where it does not overlap other objects anymore. This only concerns static objects, dynamic objects are ignored by the recovery module.  When the recovery module is not activated, it is possible for the CCTs to go through static objects. By default, the recovery module is enabled.  The recovery module currently works with all geometries except heightfields.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetPreciseSweepsMut(MagicPhysX.PxControllerManager@,System.Boolean)">
            <summary>Enables or disables the precise sweeps.  Precise sweeps are more accurate, but also potentially slower than regular sweeps.  By default, precise sweeps are enabled.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetPreventVerticalSlidingAgainstCeilingMut(MagicPhysX.PxControllerManager@,System.Boolean)">
            <summary>Enables or disables vertical sliding against ceilings.  Geometry is seen as \"ceilings\" when the following condition is met:  dot product(contact normal, up direction) &lt; 0.0f  This flag controls whether characters should slide vertically along the geometry in that case.  By default, sliding is allowed.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ShiftOriginMut(MagicPhysX.PxControllerManager@,MagicPhysX.PxVec3*)">
            <summary>Shift the origin of the character controllers and obstacle objects by the specified vector.  The positions of all character controllers, obstacle objects and the corresponding data structures will get adjusted to reflect the shifted origin location (the shift vector will get subtracted from all character controller and obstacle object positions).  It is the user's responsibility to keep track of the summed total origin shift and adjust all input/output to/from PhysXCharacterKinematic accordingly.  This call will not automatically shift the PhysX scene and its objects. You need to call PxScene::shiftOrigin() seperately to keep the systems in sync.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxSDFDesc@)">
            <summary>Returns true if the descriptor is valid.  true if the current settings are valid</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetToDefaultMut(MagicPhysX.PxConvexMeshDesc@)">
            <summary>(re)sets the structure to the default.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxConvexMeshDesc@)">
            <summary>Returns true if the descriptor is valid.  True if the current settings are valid</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetToDefaultMut(MagicPhysX.PxTriangleMeshDesc@)">
            <summary>(re)sets the structure to the default.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxTriangleMeshDesc@)">
            <summary>Returns true if the descriptor is valid.  true if the current settings are valid</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetToDefaultMut(MagicPhysX.PxBVH34MidphaseDesc@)">
            <summary>Desc initialization to default value.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxBVH34MidphaseDesc@)">
            <summary>Returns true if the descriptor is valid.  true if the current settings are valid.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetType(MagicPhysX.PxMidphaseDesc@)">
            <summary>Returns type of midphase mesh structure.  PxMeshMidPhase::Enum</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetToDefaultMut(MagicPhysX.PxMidphaseDesc@,MagicPhysX.PxMeshMidPhase)">
            <summary>Initialize the midphase mesh structure descriptor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxMidphaseDesc@)">
            <summary>Returns true if the descriptor is valid.  true if the current settings are valid.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetToDefaultMut(MagicPhysX.PxBVHDesc@)">
            <summary>Initialize the BVH descriptor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxBVHDesc@)">
            <summary>Returns true if the descriptor is valid.  true if the current settings are valid.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxCookBVH(MagicPhysX.PxBVHDesc@,MagicPhysX.PxOutputStream*)">
            <summary>Cooks a bounding volume hierarchy. The results are written to the stream.  PxCookBVH() allows a BVH description to be cooked into a binary stream suitable for loading and performing BVH detection at runtime.  true on success.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxCreateBVH(MagicPhysX.PxBVHDesc@,MagicPhysX.PxInsertionCallback*)">
            <summary>Cooks and creates a bounding volume hierarchy without going through a stream.  This method does the same as cookBVH, but the produced BVH is not stored into a stream but is either directly inserted in PxPhysics, or created as a standalone object. Use this method if you are unable to cook offline.  PxInsertionCallback can be obtained through PxPhysics::getPhysicsInsertionCallback() or PxCooking::getStandaloneInsertionCallback().  PxBVH pointer on success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxCookConvexMesh(MagicPhysX.PxCookingParams@,MagicPhysX.PxConvexMeshDesc*,MagicPhysX.PxOutputStream*,MagicPhysX.PxConvexMeshCookingResult*)">
            <summary>Cooks a convex mesh. The results are written to the stream.  To create a triangle mesh object it is necessary to first 'cook' the mesh data into a form which allows the SDK to perform efficient collision detection.  cookConvexMesh() allows a mesh description to be cooked into a binary stream suitable for loading and performing collision detection at runtime.  The number of vertices and the number of convex polygons in a cooked convex mesh is limited to 255.  If those limits are exceeded in either the user-provided data or the final cooked mesh, an error is reported.  true on success.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxCreateConvexMesh(MagicPhysX.PxCookingParams@,MagicPhysX.PxConvexMeshDesc*,MagicPhysX.PxInsertionCallback*,MagicPhysX.PxConvexMeshCookingResult*)">
            <summary>Cooks and creates a convex mesh without going through a stream.  This method does the same as cookConvexMesh, but the produced mesh is not stored into a stream but is either directly inserted in PxPhysics, or created as a standalone object. Use this method if you are unable to cook offline.  PxInsertionCallback can be obtained through PxPhysics::getPhysicsInsertionCallback() or PxCooking::getStandaloneInsertionCallback().  PxConvexMesh pointer on success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxValidateConvexMesh(MagicPhysX.PxCookingParams@,MagicPhysX.PxConvexMeshDesc*)">
            <summary>Verifies if the convex mesh is valid. Prints an error message for each inconsistency found.  The convex mesh descriptor must contain an already created convex mesh - the vertices, indices and polygons must be provided.  This function should be used if PxConvexFlag::eDISABLE_MESH_VALIDATION is planned to be used in release builds.  true if all the validity conditions hold, false otherwise.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxComputeHullPolygons(MagicPhysX.PxCookingParams@,MagicPhysX.PxSimpleTriangleMesh*,MagicPhysX.PxAllocatorCallback*,System.UInt32*,MagicPhysX.PxVec3**,System.UInt32*,System.UInt32**,System.UInt32*,MagicPhysX.PxHullPolygon**)">
            <summary>Computed hull polygons from given vertices and triangles. Polygons are needed for PxConvexMeshDesc rather than triangles.  Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. The output vertices, indices and polygons must be used to construct a hull.  The provided PxAllocatorCallback does allocate the out array's. It is the user responsibility to deallocated those array's.  true on success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxValidateTriangleMesh(MagicPhysX.PxCookingParams@,MagicPhysX.PxTriangleMeshDesc*)">
            <summary>Verifies if the triangle mesh is valid. Prints an error message for each inconsistency found.  The following conditions are true for a valid triangle mesh: 1. There are no duplicate vertices (within specified vertexWeldTolerance. See PxCookingParams::meshWeldTolerance) 2. There are no large triangles (within specified PxTolerancesScale.)  true if all the validity conditions hold, false otherwise.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxCreateTriangleMesh(MagicPhysX.PxCookingParams@,MagicPhysX.PxTriangleMeshDesc*,MagicPhysX.PxInsertionCallback*,MagicPhysX.PxTriangleMeshCookingResult*)">
            <summary>Cooks and creates a triangle mesh without going through a stream.  This method does the same as cookTriangleMesh, but the produced mesh is not stored into a stream but is either directly inserted in PxPhysics, or created as a standalone object. Use this method if you are unable to cook offline.  PxInsertionCallback can be obtained through PxPhysics::getPhysicsInsertionCallback() or PxCooking::getStandaloneInsertionCallback().  PxTriangleMesh pointer on success.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxCookTriangleMesh(MagicPhysX.PxCookingParams@,MagicPhysX.PxTriangleMeshDesc*,MagicPhysX.PxOutputStream*,MagicPhysX.PxTriangleMeshCookingResult*)">
            <summary>Cooks a triangle mesh. The results are written to the stream.  To create a triangle mesh object it is necessary to first 'cook' the mesh data into a form which allows the SDK to perform efficient collision detection.  PxCookTriangleMesh() allows a mesh description to be cooked into a binary stream suitable for loading and performing collision detection at runtime.  true on success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetActorsMut(MagicPhysX.PxJoint@,MagicPhysX.PxRigidActor*,MagicPhysX.PxRigidActor*)">
            <summary>Set the actors for this joint.  An actor may be NULL to indicate the world frame. At most one of the actors may be NULL.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetActors(MagicPhysX.PxJoint@,MagicPhysX.PxRigidActor**,MagicPhysX.PxRigidActor**)">
            <summary>Get the actors for this joint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetLocalPoseMut(MagicPhysX.PxJoint@,MagicPhysX.PxJointActorIndex,MagicPhysX.PxTransform*)">
            <summary>Set the joint local pose for an actor.  This is the relative pose which locates the joint frame relative to the actor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetLocalPose(MagicPhysX.PxJoint@,MagicPhysX.PxJointActorIndex)">
            <summary>get the joint local pose for an actor.  return the local pose for this joint</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetRelativeTransform(MagicPhysX.PxJoint@)">
            <summary>get the relative pose for this joint  This function returns the pose of the joint frame of actor1 relative to actor0</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetRelativeLinearVelocity(MagicPhysX.PxJoint@)">
            <summary>get the relative linear velocity of the joint  This function returns the linear velocity of the origin of the constraint frame of actor1, relative to the origin of the constraint frame of actor0. The value is returned in the constraint frame of actor0</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetRelativeAngularVelocity(MagicPhysX.PxJoint@)">
            <summary>get the relative angular velocity of the joint  This function returns the angular velocity of  actor1 relative to actor0. The value is returned in the constraint frame of actor0</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetBreakForceMut(MagicPhysX.PxJoint@,System.Single,System.Single)">
            <summary>set the break force for this joint.  if the constraint force or torque on the joint exceeds the specified values, the joint will break, at which point it will not constrain the two actors and the flag PxConstraintFlag::eBROKEN will be set. The force and torque are measured in the joint frame of the first actor</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetBreakForce(MagicPhysX.PxJoint@,System.Single*,System.Single*)">
            <summary>get the break force for this joint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetConstraintFlagsMut(MagicPhysX.PxJoint@,MagicPhysX.PxConstraintFlags)">
            <summary>set the constraint flags for this joint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetConstraintFlagMut(MagicPhysX.PxJoint@,MagicPhysX.PxConstraintFlag,System.Boolean)">
            <summary>set a constraint flags for this joint to a specified value.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetConstraintFlags(MagicPhysX.PxJoint@)">
            <summary>get the constraint flags for this joint.  the constraint flags</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetInvMassScale0Mut(MagicPhysX.PxJoint@,System.Single)">
            <summary>set the inverse mass scale for actor0.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetInvMassScale0(MagicPhysX.PxJoint@)">
            <summary>get the inverse mass scale for actor0.  inverse mass scale for actor0</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetInvInertiaScale0Mut(MagicPhysX.PxJoint@,System.Single)">
            <summary>set the inverse inertia scale for actor0.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetInvInertiaScale0(MagicPhysX.PxJoint@)">
            <summary>get the inverse inertia scale for actor0.  inverse inertia scale for actor0</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetInvMassScale1Mut(MagicPhysX.PxJoint@,System.Single)">
            <summary>set the inverse mass scale for actor1.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetInvMassScale1(MagicPhysX.PxJoint@)">
            <summary>get the inverse mass scale for actor1.  inverse mass scale for actor1</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetInvInertiaScale1Mut(MagicPhysX.PxJoint@,System.Single)">
            <summary>set the inverse inertia scale for actor1.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetInvInertiaScale1(MagicPhysX.PxJoint@)">
            <summary>get the inverse inertia scale for actor1.  inverse inertia scale for actor1</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetConstraint(MagicPhysX.PxJoint@)">
            <summary>Retrieves the PxConstraint corresponding to this joint.  This can be used to determine, among other things, the force applied at the joint.  the constraint</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetNameMut(MagicPhysX.PxJoint@,System.Byte*)">
            <summary>Sets a name string for the object that can be retrieved with getName().  This is for debugging and is not used by the SDK. The string is not copied by the SDK, only the pointer is stored.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetName(MagicPhysX.PxJoint@)">
            <summary>Retrieves the name string set with setName().  Name string associated with object.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxJoint@)">
            <summary>Deletes the joint.  This call does not wake up the connected rigid bodies.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetScene(MagicPhysX.PxJoint@)">
            <summary>Retrieves the scene which this joint belongs to.  Owner Scene. NULL if not part of a scene.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxSetJointGlobalFrame(MagicPhysX.PxJoint@,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>Helper function to setup a joint's global frame  This replaces the following functions from previous SDK versions:  void NxJointDesc::setGlobalAnchor(const NxVec3 &amp; wsAnchor); void NxJointDesc::setGlobalAxis(const NxVec3 &amp; wsAxis);  The function sets the joint's localPose using world-space input parameters.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetDistance(MagicPhysX.PxDistanceJoint@)">
            <summary>Return the current distance of the joint</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetMinDistanceMut(MagicPhysX.PxDistanceJoint@,System.Single)">
            <summary>Set the allowed minimum distance for the joint.  The minimum distance must be no more than the maximum distance  Default 0.0f Range [0, PX_MAX_F32)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetMinDistance(MagicPhysX.PxDistanceJoint@)">
            <summary>Get the allowed minimum distance for the joint.  the allowed minimum distance</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetMaxDistanceMut(MagicPhysX.PxDistanceJoint@,System.Single)">
            <summary>Set the allowed maximum distance for the joint.  The maximum distance must be no less than the minimum distance.  Default 0.0f Range [0, PX_MAX_F32)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetMaxDistance(MagicPhysX.PxDistanceJoint@)">
            <summary>Get the allowed maximum distance for the joint.  the allowed maximum distance</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetToleranceMut(MagicPhysX.PxDistanceJoint@,System.Single)">
            <summary>Set the error tolerance of the joint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetTolerance(MagicPhysX.PxDistanceJoint@)">
            <summary>Get the error tolerance of the joint.  the distance beyond the joint's [min, max] range before the joint becomes active.  Default 0.25f * PxTolerancesScale::length Range (0, PX_MAX_F32)  This value should be used to ensure that if the minimum distance is zero and the spring function is in use, the rest length of the spring is non-zero.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetStiffnessMut(MagicPhysX.PxDistanceJoint@,System.Single)">
            <summary>Set the strength of the joint spring.  The spring is used if enabled, and the distance exceeds the range [min-error, max+error].  Default 0.0f Range [0, PX_MAX_F32)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetStiffness(MagicPhysX.PxDistanceJoint@)">
            <summary>Get the strength of the joint spring.  stiffness the spring strength of the joint</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetDampingMut(MagicPhysX.PxDistanceJoint@,System.Single)">
            <summary>Set the damping of the joint spring.  The spring is used if enabled, and the distance exceeds the range [min-error, max+error].  Default 0.0f Range [0, PX_MAX_F32)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetDamping(MagicPhysX.PxDistanceJoint@)">
            <summary>Get the damping of the joint spring.  the degree of damping of the joint spring of the joint</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetContactDistanceMut(MagicPhysX.PxDistanceJoint@,System.Single)">
            <summary>Set the contact distance for the min &amp; max distance limits.  This is similar to the PxJointLimitParameters::contactDistance parameter for regular limits.  The two most common values are 0 and infinite. Infinite means the internal constraints are always created, resulting in the best simulation quality but slower performance. Zero means the internal constraints are only created when the limits are violated, resulting in best performance but worse simulation quality.  Default 0.0f Range [0, PX_MAX_F32)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetContactDistance(MagicPhysX.PxDistanceJoint@)">
            <summary>Get the contact distance.  the contact distance</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetDistanceJointFlagsMut(MagicPhysX.PxDistanceJoint@,MagicPhysX.PxDistanceJointFlags)">
            <summary>Set the flags specific to the Distance Joint.  Default PxDistanceJointFlag::eMAX_DISTANCE_ENABLED</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetDistanceJointFlagMut(MagicPhysX.PxDistanceJoint@,MagicPhysX.PxDistanceJointFlag,System.Boolean)">
            <summary>Set a single flag specific to a Distance Joint to true or false.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetDistanceJointFlags(MagicPhysX.PxDistanceJoint@)">
            <summary>Get the flags specific to the Distance Joint.  the joint flags</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetConcreteTypeName(MagicPhysX.PxDistanceJoint@)">
            <summary>Returns string name of PxDistanceJoint, used for serialization</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetContactMut(MagicPhysX.PxContactJoint@,MagicPhysX.PxVec3*)">
            <summary>Set the current contact of the joint</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetContactNormalMut(MagicPhysX.PxContactJoint@,MagicPhysX.PxVec3*)">
            <summary>Set the current contact normal of the joint</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetPenetrationMut(MagicPhysX.PxContactJoint@,System.Single)">
            <summary>Set the current penetration of the joint</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetContact(MagicPhysX.PxContactJoint@)">
            <summary>Return the current contact of the joint</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetContactNormal(MagicPhysX.PxContactJoint@)">
            <summary>Return the current contact normal of the joint</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetPenetration(MagicPhysX.PxContactJoint@)">
            <summary>Return the current penetration value of the joint</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetConcreteTypeName(MagicPhysX.PxContactJoint@)">
            <summary>Returns string name of PxContactJoint, used for serialization</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetConcreteTypeName(MagicPhysX.PxFixedJoint@)">
            <summary>Returns string name of PxFixedJoint, used for serialization</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxJointLimitParameters@)">
            <summary>Returns true if the current settings are valid.  true if the current settings are valid</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxJointLinearLimit@)">
            <summary>Returns true if the limit is valid  true if the current settings are valid</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxJointLinearLimitPair@)">
            <summary>Returns true if the limit is valid.  true if the current settings are valid</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxJointAngularLimitPair@)">
            <summary>Returns true if the limit is valid.  true if the current settings are valid</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxJointLimitCone@)">
            <summary>Returns true if the limit is valid.  true if the current settings are valid</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxJointLimitPyramid@)">
            <summary>Returns true if the limit is valid.  true if the current settings are valid</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetPosition(MagicPhysX.PxPrismaticJoint@)">
            <summary>returns the displacement of the joint along its axis.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetVelocity(MagicPhysX.PxPrismaticJoint@)">
            <summary>returns the velocity of the joint along its axis</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetLimitMut(MagicPhysX.PxPrismaticJoint@,MagicPhysX.PxJointLinearLimitPair*)">
            <summary>sets the joint limit  parameters.  The limit range is [-PX_MAX_F32, PX_MAX_F32], but note that the width of the limit (upper-lower) must also be a valid float.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetLimit(MagicPhysX.PxPrismaticJoint@)">
            <summary>gets the joint limit  parameters.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetPrismaticJointFlagsMut(MagicPhysX.PxPrismaticJoint@,MagicPhysX.PxPrismaticJointFlags)">
            <summary>Set the flags specific to the Prismatic Joint.  Default PxPrismaticJointFlags(0)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetPrismaticJointFlagMut(MagicPhysX.PxPrismaticJoint@,MagicPhysX.PxPrismaticJointFlag,System.Boolean)">
            <summary>Set a single flag specific to a Prismatic Joint to true or false.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetPrismaticJointFlags(MagicPhysX.PxPrismaticJoint@)">
            <summary>Get the flags specific to the Prismatic Joint.  the joint flags</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetConcreteTypeName(MagicPhysX.PxPrismaticJoint@)">
            <summary>Returns string name of PxPrismaticJoint, used for serialization</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetAngle(MagicPhysX.PxRevoluteJoint@)">
            <summary>return the angle of the joint, in the range (-2*Pi, 2*Pi]</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetVelocity(MagicPhysX.PxRevoluteJoint@)">
            <summary>return the velocity of the joint</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetLimitMut(MagicPhysX.PxRevoluteJoint@,MagicPhysX.PxJointAngularLimitPair*)">
            <summary>set the joint limit parameters.  The limit is activated using the flag PxRevoluteJointFlag::eLIMIT_ENABLED  The limit angle range is (-2*Pi, 2*Pi).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetLimit(MagicPhysX.PxRevoluteJoint@)">
            <summary>get the joint limit parameters.  the joint limit parameters</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetDriveVelocityMut(MagicPhysX.PxRevoluteJoint@,System.Single,System.Boolean)">
            <summary>set the target velocity for the drive model.  The motor will only be able to reach this velocity if the maxForce is sufficiently large. If the joint is spinning faster than this velocity, the motor will actually try to brake (see PxRevoluteJointFlag::eDRIVE_FREESPIN.)  The sign of this variable determines the rotation direction, with positive values going the same way as positive joint angles. Setting a very large target velocity may cause undesirable results.  Range: (-PX_MAX_F32, PX_MAX_F32) Default: 0.0</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetDriveVelocity(MagicPhysX.PxRevoluteJoint@)">
            <summary>gets the target velocity for the drive model.  the drive target velocity</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetDriveForceLimitMut(MagicPhysX.PxRevoluteJoint@,System.Single)">
            <summary>sets the maximum torque the drive can exert.  The value set here may be used either as an impulse limit or a force limit, depending on the flag PxConstraintFlag::eDRIVE_LIMITS_ARE_FORCES  Range: [0, PX_MAX_F32) Default: PX_MAX_F32</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetDriveForceLimit(MagicPhysX.PxRevoluteJoint@)">
            <summary>gets the maximum torque the drive can exert.  the torque limit</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetDriveGearRatioMut(MagicPhysX.PxRevoluteJoint@,System.Single)">
            <summary>sets the gear ratio for the drive.  When setting up the drive constraint, the velocity of the first actor is scaled by this value, and its response to drive torque is scaled down. So if the drive target velocity is zero, the second actor will be driven to the velocity of the first scaled by the gear ratio  Range: [0, PX_MAX_F32) Default: 1.0</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetDriveGearRatio(MagicPhysX.PxRevoluteJoint@)">
            <summary>gets the gear ratio.  the drive gear ratio</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetRevoluteJointFlagsMut(MagicPhysX.PxRevoluteJoint@,MagicPhysX.PxRevoluteJointFlags)">
            <summary>sets the flags specific to the Revolute Joint.  Default PxRevoluteJointFlags(0)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetRevoluteJointFlagMut(MagicPhysX.PxRevoluteJoint@,MagicPhysX.PxRevoluteJointFlag,System.Boolean)">
            <summary>sets a single flag specific to a Revolute Joint.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetRevoluteJointFlags(MagicPhysX.PxRevoluteJoint@)">
            <summary>gets the flags specific to the Revolute Joint.  the joint flags</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetConcreteTypeName(MagicPhysX.PxRevoluteJoint@)">
            <summary>Returns string name of PxRevoluteJoint, used for serialization</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetLimitCone(MagicPhysX.PxSphericalJoint@)">
            <summary>Set the limit cone.  If enabled, the limit cone will constrain the angular movement of the joint to lie within an elliptical cone.  the limit cone</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetLimitConeMut(MagicPhysX.PxSphericalJoint@,MagicPhysX.PxJointLimitCone*)">
            <summary>Get the limit cone.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSwingYAngle(MagicPhysX.PxSphericalJoint@)">
            <summary>get the swing angle of the joint from the Y axis</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSwingZAngle(MagicPhysX.PxSphericalJoint@)">
            <summary>get the swing angle of the joint from the Z axis</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetSphericalJointFlagsMut(MagicPhysX.PxSphericalJoint@,MagicPhysX.PxSphericalJointFlags)">
            <summary>Set the flags specific to the Spherical Joint.  Default PxSphericalJointFlags(0)</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetSphericalJointFlagMut(MagicPhysX.PxSphericalJoint@,MagicPhysX.PxSphericalJointFlag,System.Boolean)">
            <summary>Set a single flag specific to a Spherical Joint to true or false.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSphericalJointFlags(MagicPhysX.PxSphericalJoint@)">
            <summary>Get the flags specific to the Spherical Joint.  the joint flags</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetConcreteTypeName(MagicPhysX.PxSphericalJoint@)">
            <summary>Returns string name of PxSphericalJoint, used for serialization</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsValid(MagicPhysX.PxD6JointDrive@)">
            <summary>returns true if the drive is valid</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetMotionMut(MagicPhysX.PxD6Joint@,MagicPhysX.PxD6Axis,MagicPhysX.PxD6Motion)">
            <summary>Set the motion type around the specified axis.  Each axis may independently specify that the degree of freedom is locked (blocking relative movement along or around this axis), limited by the corresponding limit, or free.  Default: all degrees of freedom are locked</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetMotion(MagicPhysX.PxD6Joint@,MagicPhysX.PxD6Axis)">
            <summary>Get the motion type around the specified axis.  the motion type around the specified axis</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetTwistAngle(MagicPhysX.PxD6Joint@)">
            <summary>get the twist angle of the joint, in the range (-2*Pi, 2*Pi]</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSwingYAngle(MagicPhysX.PxD6Joint@)">
            <summary>get the swing angle of the joint from the Y axis</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSwingZAngle(MagicPhysX.PxD6Joint@)">
            <summary>get the swing angle of the joint from the Z axis</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetDistanceLimitMut(MagicPhysX.PxD6Joint@,MagicPhysX.PxJointLinearLimit*)">
            <summary>Set the distance limit for the joint.  A single limit constraints all linear limited degrees of freedom, forming a linear, circular or spherical constraint on motion depending on the number of limited degrees. This is similar to a distance limit.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetDistanceLimit(MagicPhysX.PxD6Joint@)">
            <summary>Get the distance limit for the joint.  the distance limit structure</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetLinearLimitMut(MagicPhysX.PxD6Joint@,MagicPhysX.PxD6Axis,MagicPhysX.PxJointLinearLimitPair*)">
            <summary>Set the linear limit for a given linear axis.  This function extends the previous setDistanceLimit call with the following features: - there can be a different limit for each linear axis - each limit is defined by two values, i.e. it can now be asymmetric  This can be used to create prismatic joints similar to PxPrismaticJoint, or point-in-quad joints, or point-in-box joints.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetLinearLimit(MagicPhysX.PxD6Joint@,MagicPhysX.PxD6Axis)">
            <summary>Get the linear limit for a given linear axis.  the linear limit pair structure from desired axis</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetTwistLimitMut(MagicPhysX.PxD6Joint@,MagicPhysX.PxJointAngularLimitPair*)">
            <summary>Set the twist limit for the joint.  The twist limit controls the range of motion around the twist axis.  The limit angle range is (-2*Pi, 2*Pi).</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetTwistLimit(MagicPhysX.PxD6Joint@)">
            <summary>Get the twist limit for the joint.  the twist limit structure</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetSwingLimitMut(MagicPhysX.PxD6Joint@,MagicPhysX.PxJointLimitCone*)">
            <summary>Set the swing cone limit for the joint.  The cone limit is used if either or both swing axes are limited. The extents are symmetrical and measured in the frame of the parent. If only one swing degree of freedom is limited, the corresponding value from the cone limit defines the limit range.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetSwingLimit(MagicPhysX.PxD6Joint@)">
            <summary>Get the cone limit for the joint.  the swing limit structure</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetPyramidSwingLimitMut(MagicPhysX.PxD6Joint@,MagicPhysX.PxJointLimitPyramid*)">
            <summary>Set a pyramidal swing limit for the joint.  The pyramid limits will only be used in the following cases: - both swing Y and Z are limited. The limit shape is then a pyramid. - Y is limited and Z is locked, or vice versa. The limit shape is an asymmetric angular section, similar to what is supported for the twist axis. The remaining cases (Y limited and Z is free, or vice versa) are not supported.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetPyramidSwingLimit(MagicPhysX.PxD6Joint@)">
            <summary>Get the pyramidal swing limit for the joint.  the swing limit structure</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetDriveMut(MagicPhysX.PxD6Joint@,MagicPhysX.PxD6Drive,MagicPhysX.PxD6JointDrive*)">
            <summary>Set the drive parameters for the specified drive type.  Default The default drive spring and damping values are zero, the force limit is zero, and no flags are set.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetDrive(MagicPhysX.PxD6Joint@,MagicPhysX.PxD6Drive)">
            <summary>Get the drive parameters for the specified drive type.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetDrivePositionMut(MagicPhysX.PxD6Joint@,MagicPhysX.PxTransform*,System.Boolean)">
            <summary>Set the drive goal pose  The goal is relative to the constraint frame of actor[0]  Default the identity transform</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetDrivePosition(MagicPhysX.PxD6Joint@)">
            <summary>Get the drive goal pose.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetDriveVelocityMut(MagicPhysX.PxD6Joint@,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,System.Boolean)">
            <summary>Set the target goal velocity for drive.  The velocity is measured in the constraint frame of actor[0]</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetDriveVelocity(MagicPhysX.PxD6Joint@,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*)">
            <summary>Get the target goal velocity for joint drive.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetProjectionLinearToleranceMut(MagicPhysX.PxD6Joint@,System.Single)">
            <summary>Set the linear tolerance threshold for projection. Projection is enabled if PxConstraintFlag::ePROJECTION is set for the joint.  If the joint separates by more than this distance along its locked degrees of freedom, the solver will move the bodies to close the distance.  Setting a very small tolerance may result in simulation jitter or other artifacts.  Sometimes it is not possible to project (for example when the joints form a cycle).  Range: [0, PX_MAX_F32) Default: 1e10f</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetProjectionLinearTolerance(MagicPhysX.PxD6Joint@)">
            <summary>Get the linear tolerance threshold for projection.  the linear tolerance threshold</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetProjectionAngularToleranceMut(MagicPhysX.PxD6Joint@,System.Single)">
            <summary>Set the angular tolerance threshold for projection. Projection is enabled if PxConstraintFlag::ePROJECTION is set for the joint.  If the joint deviates by more than this angle around its locked angular degrees of freedom, the solver will move the bodies to close the angle.  Setting a very small tolerance may result in simulation jitter or other artifacts.  Sometimes it is not possible to project (for example when the joints form a cycle).  Range: [0,Pi] Default: Pi  Angular projection is implemented only for the case of two or three locked angular degrees of freedom.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetProjectionAngularTolerance(MagicPhysX.PxD6Joint@)">
            <summary>Get the angular tolerance threshold for projection.  tolerance the angular tolerance threshold in radians</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetConcreteTypeName(MagicPhysX.PxD6Joint@)">
            <summary>Returns string name of PxD6Joint, used for serialization</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetHingesMut(MagicPhysX.PxGearJoint@,MagicPhysX.PxBase*,MagicPhysX.PxBase*)">
            <summary>Set the hinge/revolute joints connected by the gear joint.  The passed joints can be either PxRevoluteJoint, PxD6Joint or PxArticulationJointReducedCoordinate. The joints must define degrees of freedom around the twist axis. They cannot be null.  Note that these joints are only used to compute the positional error correction term, used to adjust potential drift between jointed actors. The gear joint can run without calling this function, but in that case some visible overlap may develop over time between the teeth of the gear meshes.  Calling this function resets the internal positional error correction term.  true if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetGearRatioMut(MagicPhysX.PxGearJoint@,System.Single)">
            <summary>Set the desired gear ratio.  For two gears with n0 and n1 teeth respectively, the gear ratio is n0/n1.  You may need to use a negative gear ratio if the joint frames of involved actors are not oriented in the same direction.  Calling this function resets the internal positional error correction term.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetGearRatio(MagicPhysX.PxGearJoint@)">
            <summary>Get the gear ratio.  Current ratio</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetJointsMut(MagicPhysX.PxRackAndPinionJoint@,MagicPhysX.PxBase*,MagicPhysX.PxBase*)">
            <summary>Set the hinge &amp; prismatic joints connected by the rack &amp; pinion joint.  The passed hinge joint can be either PxRevoluteJoint, PxD6Joint or PxArticulationJointReducedCoordinate. It cannot be null. The passed prismatic joint can be either PxPrismaticJoint or PxD6Joint. It cannot be null.  Note that these joints are only used to compute the positional error correction term, used to adjust potential drift between jointed actors. The rack &amp; pinion joint can run without calling this function, but in that case some visible overlap may develop over time between the teeth of the rack &amp; pinion meshes.  Calling this function resets the internal positional error correction term.  true if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetRatioMut(MagicPhysX.PxRackAndPinionJoint@,System.Single)">
            <summary>Set the desired ratio directly.  You may need to use a negative gear ratio if the joint frames of involved actors are not oriented in the same direction.  Calling this function resets the internal positional error correction term.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetRatio(MagicPhysX.PxRackAndPinionJoint@)">
            <summary>Get the ratio.  Current ratio</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetDataMut(MagicPhysX.PxRackAndPinionJoint@,System.UInt32,System.UInt32,System.Single)">
            <summary>Set the desired ratio indirectly.  This is a simple helper function that computes the ratio from passed data:  ratio = (PI*2*nbRackTeeth)/(rackLength*nbPinionTeeth)  Calling this function resets the internal positional error correction term.  true if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxGetFilterConstants(MagicPhysX.PxGroupsMask@,MagicPhysX.PxGroupsMask*)">
            <summary>Gets filtering constant K0 and K1. See comments for PxGroupsMask</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxSetFilterConstants(MagicPhysX.PxGroupsMask@,MagicPhysX.PxGroupsMask*)">
            <summary>Setups filtering's K0 and K1 value. See comments for PxGroupsMask</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxGetFilterOps(MagicPhysX.PxFilterOp@,MagicPhysX.PxFilterOp*,MagicPhysX.PxFilterOp*)">
            <summary>Retrieves filtering operation. See comments for PxGroupsMask</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.PhysPxSetFilterOps(MagicPhysX.PxFilterOp@,MagicPhysX.PxFilterOp*,MagicPhysX.PxFilterOp*)">
            <summary>Setups filtering operations. See comments for PxGroupsMask</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.TranslateMut(MagicPhysX.PxMassProperties@,MagicPhysX.PxVec3*)">
            <summary>Translate the center of mass by a given vector and adjust the inertia tensor accordingly.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.Sum(MagicPhysX.PxMassProperties@,MagicPhysX.PxTransform*,System.UInt32)">
            <summary>Sum up individual mass properties.  The summed up mass properties.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.FindOverlapMut(MagicPhysX.PxMeshOverlapUtil@,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxTriangleMeshGeometry*,MagicPhysX.PxTransform*)">
            <summary>Find the mesh triangles which touch the specified geometry object.  Number of overlaps found. Triangle indices can then be accessed through the [`getResults`]() function.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.FindOverlapMut1(MagicPhysX.PxMeshOverlapUtil@,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxHeightFieldGeometry*,MagicPhysX.PxTransform*)">
            <summary>Find the height field triangles which touch the specified geometry object.  Number of overlaps found. Triangle indices can then be accessed through the [`getResults`]() function.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetResults(MagicPhysX.PxMeshOverlapUtil@)">
            <summary>Retrieves array of triangle indices after a findOverlap call.  Indices of touched triangles</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetNbResults(MagicPhysX.PxMeshOverlapUtil@)">
            <summary>Retrieves number of triangle indices after a findOverlap call.  Number of touched triangles</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxDefaultCpuDispatcher@)">
            <summary>Deletes the dispatcher.  Do not keep a reference to the deleted instance.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetRunProfiledMut(MagicPhysX.PxDefaultCpuDispatcher@,System.Boolean)">
            <summary>Enables profiling at task level.  By default enabled only in profiling builds.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetRunProfiled(MagicPhysX.PxDefaultCpuDispatcher@)">
            <summary>Checks if profiling is enabled at task level.  True if tasks should be profiled.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.RaycastMut(MagicPhysX.PxBatchQueryExt@,MagicPhysX.PxVec3*,MagicPhysX.PxVec3*,System.Single,System.UInt16,MagicPhysX.PxHitFlags,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryCache*)">
            <summary>Performs a raycast against objects in the scene.  Touching hits are not ordered.  Shooting a ray from within an object leads to different results depending on the shape type. Please check the details in article SceneQuery. User can ignore such objects by using one of the provided filter mechanisms.  This query call writes to a list associated with the query object and is NOT thread safe (for performance reasons there is no lock and overlapping writes from different threads may result in undefined behavior).  Returns a PxRaycastBuffer pointer that will store the result of the query after execute() is completed. This will point either to an element of the buffer allocated on construction or to a user buffer passed to the constructor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SweepMut(MagicPhysX.PxBatchQueryExt@,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,MagicPhysX.PxVec3*,System.Single,System.UInt16,MagicPhysX.PxHitFlags,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryCache*,System.Single)">
            <summary>Performs a sweep test against objects in the scene.  Touching hits are not ordered.  If a shape from the scene is already overlapping with the query shape in its starting position, the hit is returned unless eASSUME_NO_INITIAL_OVERLAP was specified.  This query call writes to a list associated with the query object and is NOT thread safe (for performance reasons there is no lock and overlapping writes from different threads may result in undefined behavior).  Returns a PxSweepBuffer pointer that will store the result of the query after execute() is completed. This will point either to an element of the buffer allocated on construction or to a user buffer passed to the constructor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.OverlapMut(MagicPhysX.PxBatchQueryExt@,MagicPhysX.PxGeometry*,MagicPhysX.PxTransform*,System.UInt16,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryCache*)">
            <summary>Performs an overlap test of a given geometry against objects in the scene.  Filtering: returning eBLOCK from user filter for overlap queries will cause a warning (see [`PxQueryHitType`]).  eBLOCK should not be returned from user filters for overlap(). Doing so will result in undefined behavior, and a warning will be issued.  If the PxQueryFlag::eNO_BLOCK flag is set, the eBLOCK will instead be automatically converted to an eTOUCH and the warning suppressed.  This query call writes to a list associated with the query object and is NOT thread safe (for performance reasons there is no lock and overlapping writes from different threads may result in undefined behavior).  Returns a PxOverlapBuffer pointer that will store the result of the query after execute() is completed. This will point either to an element of the buffer allocated on construction or to a user buffer passed to the constructor.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AddPrunerMut(MagicPhysX.PxCustomSceneQuerySystem@,MagicPhysX.PxPruningStructureType,MagicPhysX.PxDynamicTreeSecondaryPruner,System.UInt32)">
            <summary>Adds a pruner to the system.  The internal PhysX scene-query system uses two regular pruners (one for static shapes, one for dynamic shapes) and an optional compound pruner. Our custom scene query system supports an arbitrary number of regular pruners.  This can be useful to reduce the load on each pruner, in particular during updates, when internal trees are rebuilt in the background. On the other hand this implementation simply iterates over all created pruners to perform queries, so their cost might increase if a large number of pruners is used.  In any case this serves as an example of how the PxSceneQuerySystem API can be used to customize scene queries.  A pruner index</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.StartCustomBuildstepMut(MagicPhysX.PxCustomSceneQuerySystem@)">
            <summary>Start custom build-steps for all pruners  This function is used in combination with customBuildstep() and finishCustomBuildstep() to let users take control of the pruners' build-step &amp; commit calls - basically the pruners' update functions. These functions should be used with the PxSceneQueryUpdateMode::eBUILD_DISABLED_COMMIT_DISABLED update mode, otherwise the build-steps will happen automatically in fetchResults. For N pruners it can be more efficient to use these custom build-step functions to perform the updates in parallel:  - call startCustomBuildstep() first (one synchronous call) - for each pruner, call customBuildstep() (asynchronous calls from multiple threads) - once it is done, call finishCustomBuildstep() to finish the update (synchronous call)  The multi-threaded update is more efficient here than what it is in PxScene, because the \"flushShapes()\" call is also multi-threaded (while it is not in PxScene).  Note that users are responsible for locks here, and these calls should not overlap with other SQ calls. In particular one should not add new objects to the SQ system or perform queries while these calls are happening.  The number of pruners in the system.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.CustomBuildstepMut(MagicPhysX.PxCustomSceneQuerySystem@,System.UInt32)">
            <summary>Perform a custom build-step for a given pruner.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.FinishCustomBuildstepMut(MagicPhysX.PxCustomSceneQuerySystem@)">
            <summary>Finish custom build-steps  Call this function once after all the customBuildstep() calls are done.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetPrunerIndex(MagicPhysX.PxCustomSceneQuerySystemAdapter@,MagicPhysX.PxRigidActor*,MagicPhysX.PxShape*)">
            <summary>Gets a pruner index for an actor/shape.  This user-defined function tells the system in which pruner a given actor/shape should go.  The returned index must be valid, i.e. it must have been previously returned to users by PxCustomSceneQuerySystem::addPruner.  A pruner index for this actor/shape.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ProcessPruner(MagicPhysX.PxCustomSceneQuerySystemAdapter@,System.UInt32,MagicPhysX.PxQueryThreadContext*,MagicPhysX.PxQueryFilterData*,MagicPhysX.PxQueryFilterCallback*)">
            <summary>Pruner filtering callback.  This will be called for each query to validate whether it should process a given pruner.  True to process the pruner, false to skip it entirely</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.SetSamplingRadiusMut(MagicPhysX.PxPoissonSampler@,System.Single)">
            <summary>Sets the sampling radius  Returns true if the sampling was successful and false if there was a problem. Usually an internal overflow is the problem for very big meshes or very small sampling radii.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AddSamplesInSphereMut(MagicPhysX.PxPoissonSampler@,MagicPhysX.PxVec3*,System.Single,System.Boolean)">
            <summary>Adds new Poisson Samples inside the sphere specified</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.AddSamplesInBoxMut(MagicPhysX.PxPoissonSampler@,MagicPhysX.PxBounds3*,MagicPhysX.PxQuat*,System.Boolean)">
            <summary>Adds new Poisson Samples inside the box specified</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsPointInTriangleMeshMut(MagicPhysX.PxTriangleMeshPoissonSampler@,MagicPhysX.PxVec3*)">
            <summary>Checks whether a point is inside the triangle mesh  Returns true if the point is inside the triangle mesh</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetTypeNameMut(MagicPhysX.PxRepXSerializer@)">
            <summary>The type this Serializer is meant to operate on.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ObjectToFileMut(MagicPhysX.PxRepXSerializer@,MagicPhysX.PxRepXObject*,MagicPhysX.PxCollection*,MagicPhysX.XmlWriter*,MagicPhysX.MemoryBuffer*,MagicPhysX.PxRepXInstantiationArgs*)">
            <summary>Convert from a RepX object to a key-value pair hierarchy</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.FileToObjectMut(MagicPhysX.PxRepXSerializer@,MagicPhysX.XmlReader*,MagicPhysX.XmlMemoryAllocator*,MagicPhysX.PxRepXInstantiationArgs*,MagicPhysX.PxCollection*)">
            <summary>Convert from a descriptor to a live object.  Must be an object of this Serializer type.  The new live object.  It can be an invalid object if the instantiation cannot take place.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ConnectMut(MagicPhysX.PxPvd@,MagicPhysX.PxPvdTransport*,MagicPhysX.PxPvdInstrumentationFlags)">
            <summary>Connects the SDK to the PhysX Visual Debugger application.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.DisconnectMut(MagicPhysX.PxPvd@)">
            <summary>Disconnects the SDK from the PhysX Visual Debugger application. If we are still connected, this will kill the entire debugger connection.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsConnectedMut(MagicPhysX.PxPvd@,System.Boolean)">
            <summary>Return if connection to PVD is created.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetTransportMut(MagicPhysX.PxPvd@)">
            <summary>returns the PVD data transport returns NULL if no transport is present.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetInstrumentationFlagsMut(MagicPhysX.PxPvd@)">
            <summary>Retrieves the PVD flags. See PxPvdInstrumentationFlags.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ReleaseMut(MagicPhysX.PxPvd@)">
            <summary>Releases the pvd instance.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.ConnectMut(MagicPhysX.PxPvdTransport@)">
            <summary>Connects to the Visual Debugger application. return True if success</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.DisconnectMut(MagicPhysX.PxPvdTransport@)">
            <summary>Disconnects from the Visual Debugger application. If we are still connected, this will kill the entire debugger connection.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.IsConnectedMut(MagicPhysX.PxPvdTransport@)">
            <summary>Return if connection to PVD is created.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.WriteMut(MagicPhysX.PxPvdTransport@,System.Byte*,System.UInt32)">
            <summary>write bytes to the other endpoint of the connection. should lock before witre. If an error occurs this connection will assume to be dead.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.FlushMut(MagicPhysX.PxPvdTransport@)">
            <summary>send any data and block until we know it is at least on the wire.</summary>
        </member>
        <member name="M:MagicPhysX.NativeMethodsGroupingExtensions.GetWrittenDataSizeMut(MagicPhysX.PxPvdTransport@)">
            <summary>Return size of written data.</summary>
        </member>
    </members>
</doc>
