#version 450

// Debug visualization: Render surfels as colored circles on scene geometry
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(binding = 0) uniform sampler2D gDepth;
layout(binding = 1) uniform sampler2D gNormal;
layout(binding = 2) uniform sampler2D gAlbedo;
layout(binding = 3) uniform usampler2D gTransformId;
layout(binding = 4) uniform sampler2D gHDRScene;
layout(binding = 0, rgba8) writeonly uniform image2D gOutput;

// GPU indirect: per-draw command data (float[48]) indexed by TransformId.
layout(std430, binding = 5) buffer CulledCommandsBuffer { float culled[]; };

uniform bool hasCulledCommands;
uniform uint culledFloatCount;
uniform uint culledCommandFloats;

uniform ivec2 resolution;
uniform mat4 invProjMatrix;
uniform mat4 cameraToWorldMatrix;
uniform vec3 gridOrigin;
uniform float cellSize;
uniform uvec3 gridDim;
uniform uint maxPerCell;
uniform uint maxSurfels;

struct Surfel
{
    vec4 posRadius; // xyz=localPos, w=worldRadius
    vec4 normal;    // xyz=localNormal
    vec4 albedo;
    uvec4 meta;     // x=lastUsedFrame, y=active, z=transformId
};

layout(std430, binding = 0) buffer SurfelBuffer
{
    Surfel surfels[];
};

layout(std430, binding = 1) buffer CounterBuffer
{
    int stackTop;
    int pad0;
    int pad1;
    int pad2;
};

layout(std430, binding = 3) buffer GridCounts
{
    uint counts[];
};

layout(std430, binding = 4) buffer GridIndices
{
    uint indices[];
};

vec3 HashColor(uint id)
{
    // Cheap integer hash -> RGB in [0,1]
    uint x = id;
    x ^= x >> 16;
    x *= 0x7feb352du;
    x ^= x >> 15;
    x *= 0x846ca68bu;
    x ^= x >> 16;

    return vec3(
        float((x >> 0) & 255u),
        float((x >> 8) & 255u),
        float((x >> 16) & 255u)) / 255.0;
}

vec3 ReconstructWorldPosition(vec2 uv, float depth)
{
    vec4 clip = vec4(uv * 2.0 - 1.0, depth * 2.0 - 1.0, 1.0);
    vec4 view = invProjMatrix * clip;
    view /= max(view.w, 1e-6);
    vec4 world = cameraToWorldMatrix * view;
    return world.xyz;
}

uint CellIndex(uvec3 c)
{
    return c.x + gridDim.x * (c.y + gridDim.y * c.z);
}

bool WorldToCell(vec3 p, out uint cell)
{
    vec3 rel = (p - gridOrigin) / max(cellSize, 1e-6);
    ivec3 ci = ivec3(floor(rel));
    if (any(lessThan(ci, ivec3(0))) || any(greaterThanEqual(ci, ivec3(gridDim))))
        return false;

    cell = CellIndex(uvec3(ci));
    return true;
}

bool TryLoadWorldMatrix(uint commandIndex, out mat4 M)
{
    if (!hasCulledCommands)
        return false;

    uint stride = max(culledCommandFloats, 48u);
    uint base = commandIndex * stride;
    if (base + 15u >= culledFloatCount)
        return false;

    // GPU command buffer stores matrices in row-major order (matching System.Numerics.Matrix4x4).
    // GLSL mat4 constructor takes columns, so we read rows and construct columns.
    vec4 r0 = vec4(culled[base+0],  culled[base+1],  culled[base+2],  culled[base+3]);
    vec4 r1 = vec4(culled[base+4],  culled[base+5],  culled[base+6],  culled[base+7]);
    vec4 r2 = vec4(culled[base+8],  culled[base+9],  culled[base+10], culled[base+11]);
    vec4 r3 = vec4(culled[base+12], culled[base+13], culled[base+14], culled[base+15]);
    // Transpose: mat4 takes columns, so column i = (r0[i], r1[i], r2[i], r3[i])
    M = mat4(
        vec4(r0.x, r1.x, r2.x, r3.x),
        vec4(r0.y, r1.y, r2.y, r3.y),
        vec4(r0.z, r1.z, r2.z, r3.z),
        vec4(r0.w, r1.w, r2.w, r3.w)
    );
    return true;
}

void main()
{
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    if (pix.x >= resolution.x || pix.y >= resolution.y)
        return;

    vec2 uv = (vec2(pix) + 0.5) / vec2(resolution);
    
    // Get base scene color with simple tonemapping
    vec3 sceneColor = texture(gHDRScene, uv).rgb;
    sceneColor = sceneColor / (sceneColor + 1.0);
    
    float depth = texture(gDepth, uv).r;
    if (depth <= 0.0 || depth >= 1.0)
    {
        imageStore(gOutput, pix, vec4(sceneColor, 1.0));
        return;
    }

    vec3 worldPos = ReconstructWorldPosition(uv, depth);

    // Find the cell this pixel is in
    uint cell;
    if (!WorldToCell(worldPos, cell))
    {
        imageStore(gOutput, pix, vec4(sceneColor, 1.0));
        return;
    }

    uint count = counts[cell];
    if (count == 0u)
    {
        imageStore(gOutput, pix, vec4(sceneColor, 1.0));
        return;
    }

    // Check if we're inside any surfel's radius
    uint n = min(count, maxPerCell);
    float minDist = 1e10;
    float minRadius = 1.0;
    vec3 nearestColor = vec3(0.0);
    bool foundSurfel = false;

    for (uint i = 0u; i < n; ++i)
    {
        uint idx = indices[cell * maxPerCell + i];
        if (idx >= maxSurfels)
            continue;
        if (surfels[idx].meta.y == 0u)
            continue;

        // Reconstruct world position from local space using transform matrix
        vec3 sPos = surfels[idx].posRadius.xyz;
        float sRadius = max(surfels[idx].posRadius.w, 0.1);

        uint transformId = surfels[idx].meta.z;
        mat4 model;
        if (TryLoadWorldMatrix(transformId, model))
        {
            sPos = (model * vec4(sPos, 1.0)).xyz;
        }

        float dist = length(worldPos - sPos);
        
        // Check if within surfel radius
        if (dist < sRadius * 1.5) // Slightly expanded for visibility
        {
            if (dist < minDist)
            {
                minDist = dist;
                minRadius = sRadius;
                // Color by surfel index for unique identification
                nearestColor = HashColor(idx);
                foundSurfel = true;
            }
        }
    }

    if (foundSurfel)
    {
        // Draw surfel as colored circle with edge highlight
        float edgeFactor = clamp(minDist / minRadius, 0.0, 1.0);
        float edgeHighlight = smoothstep(0.7, 1.0, edgeFactor);
        float centerDarkening = smoothstep(0.0, 0.3, edgeFactor);
        
        vec3 finalColor = nearestColor;
        // Add white edge ring
        finalColor = mix(finalColor, vec3(1.0), edgeHighlight * 0.5);
        // Slightly darken center for depth perception
        finalColor *= 0.8 + 0.2 * centerDarkening;
        
        // Blend with scene
        float alpha = 0.8 * (1.0 - edgeFactor * 0.3);
        vec3 result = mix(sceneColor, finalColor, alpha);
        imageStore(gOutput, pix, vec4(result, 1.0));
    }
    else
    {
        imageStore(gOutput, pix, vec4(sceneColor, 1.0));
    }
}
