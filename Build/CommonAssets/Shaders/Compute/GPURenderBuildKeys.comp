#version 460 core

layout(local_size_x = 256) in;

const uint COMMAND_FLOATS = 48u;
const uint KEY_UINTS = 4u;

layout(std430, binding = 0) readonly buffer CulledCommands { float culled[]; };
layout(std430, binding = 1) readonly buffer CulledCountBuffer
{
    uint CulledCount;
    uint CulledInstanceCount;
    uint CulledOverflow;
};
layout(std430, binding = 2) writeonly buffer SortKeyBuffer { uint sortKeys[]; };

uniform int CurrentRenderPass;
uniform int MaxSortKeys;
uniform uint StateBitMask;

void main()
{
    uint logicalIdx = gl_GlobalInvocationID.x;
    uint total = CulledCount;

    if (logicalIdx >= total || logicalIdx >= uint(MaxSortKeys))
        return;

    uint base = logicalIdx * COMMAND_FLOATS;
    if (base + COMMAND_FLOATS > uint(culled.length()))
        return;

    uint renderPass = floatBitsToUint(culled[base + 40u]);
    if (CurrentRenderPass >= 0 &&
        renderPass != uint(CurrentRenderPass) &&
        renderPass != 0xFFFFFFFFu)
    {
        return;
    }

    uint materialID = floatBitsToUint(culled[base + 38u]);
    uint meshID = floatBitsToUint(culled[base + 36u]);
    uint shaderProgramID = floatBitsToUint(culled[base + 41u]);
    uint flags = floatBitsToUint(culled[base + 45u]);

    uint stateBits = flags & StateBitMask;
    uint packedPassPipelineState =
        ((renderPass & 0xFFu) << 24u) |
        ((shaderProgramID & 0x0FFFu) << 12u) |
        (stateBits & 0x0FFFu);

    uint outBase = logicalIdx * KEY_UINTS;
    sortKeys[outBase + 0u] = packedPassPipelineState;
    sortKeys[outBase + 1u] = materialID;
    sortKeys[outBase + 2u] = meshID;
    sortKeys[outBase + 3u] = logicalIdx;
}
