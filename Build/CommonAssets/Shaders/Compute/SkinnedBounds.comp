#version 450

layout(local_size_x = 256) in;

layout(std430, binding = 0) buffer BoneMatricesBuffer
{
    mat4 BoneMatrices[];
};

layout(std430, binding = 1) buffer BoneInvBindMatricesBuffer
{
    mat4 BoneInvBindMatrices[];
};

layout(std430, binding = 2) buffer BoneIndicesBuffer
{
    ivec4 BoneIndices[];
};

layout(std430, binding = 3) buffer BoneWeightsBuffer
{
    vec4 BoneWeights[];
};

layout(std430, binding = 4) buffer PositionBuffer
{
    vec4 Positions[];
};

layout(std430, binding = 5) buffer OutputPositionBuffer
{
    vec4 OutputPositions[];
};

layout(std430, binding = 6) buffer BoundsBuffer
{
    uvec4 MinBoundsBits;
    uvec4 MaxBoundsBits;
};

uniform uint vertexCount;
uniform int hasSkinning;
uniform mat4 fallbackMatrix;

const float FLT_MAX = 3.402823466e+38;

shared vec4 sharedMin[gl_WorkGroupSize.x];
shared vec4 sharedMax[gl_WorkGroupSize.x];

// Keep the atomic compare-swap inline so drivers retain the original storage qualifiers.
void atomicMinVec(inout uvec4 target, vec4 value)
{
    {
        uint oldValue = target.x;
        uint assumed;
        uint encoded = floatBitsToUint(value.x);
        do
        {
            assumed = oldValue;
            if (value.x >= uintBitsToFloat(assumed))
                break;
            oldValue = atomicCompSwap(target.x, assumed, encoded);
        } while (assumed != oldValue);
    }

    {
        uint oldValue = target.y;
        uint assumed;
        uint encoded = floatBitsToUint(value.y);
        do
        {
            assumed = oldValue;
            if (value.y >= uintBitsToFloat(assumed))
                break;
            oldValue = atomicCompSwap(target.y, assumed, encoded);
        } while (assumed != oldValue);
    }

    {
        uint oldValue = target.z;
        uint assumed;
        uint encoded = floatBitsToUint(value.z);
        do
        {
            assumed = oldValue;
            if (value.z >= uintBitsToFloat(assumed))
                break;
            oldValue = atomicCompSwap(target.z, assumed, encoded);
        } while (assumed != oldValue);
    }
}

void atomicMaxVec(inout uvec4 target, vec4 value)
{
    {
        uint oldValue = target.x;
        uint assumed;
        uint encoded = floatBitsToUint(value.x);
        do
        {
            assumed = oldValue;
            if (value.x <= uintBitsToFloat(assumed))
                break;
            oldValue = atomicCompSwap(target.x, assumed, encoded);
        } while (assumed != oldValue);
    }

    {
        uint oldValue = target.y;
        uint assumed;
        uint encoded = floatBitsToUint(value.y);
        do
        {
            assumed = oldValue;
            if (value.y <= uintBitsToFloat(assumed))
                break;
            oldValue = atomicCompSwap(target.y, assumed, encoded);
        } while (assumed != oldValue);
    }

    {
        uint oldValue = target.z;
        uint assumed;
        uint encoded = floatBitsToUint(value.z);
        do
        {
            assumed = oldValue;
            if (value.z <= uintBitsToFloat(assumed))
                break;
            oldValue = atomicCompSwap(target.z, assumed, encoded);
        } while (assumed != oldValue);
    }
}

void main()
{
    uint index = gl_GlobalInvocationID.x;
    uint localIndex = gl_LocalInvocationIndex;

    vec4 minValue = vec4(FLT_MAX);
    vec4 maxValue = vec4(-FLT_MAX);

    bool isValid = index < vertexCount;
    if (isValid)
    {
        vec4 basePosition = Positions[index];
        vec4 skinnedPosition = vec4(0.0);

        if (hasSkinning != 0)
        {
            ivec4 indices = BoneIndices[index];
            vec4 weights = BoneWeights[index];
            float accumulatedWeight = 0.0;

            for (int i = 0; i < 4; ++i)
            {
                int boneIndex = indices[i];
                float weight = weights[i];
                accumulatedWeight += weight;

                if (boneIndex <= 0 || weight <= 0.0)
                    continue;

                mat4 boneMatrix = BoneInvBindMatrices[boneIndex] * BoneMatrices[boneIndex];
                skinnedPosition += (boneMatrix * basePosition) * weight;
            }

            if (accumulatedWeight <= 0.00001)
                skinnedPosition = fallbackMatrix * basePosition;
        }
        else
        {
            skinnedPosition = fallbackMatrix * basePosition;
        }

        OutputPositions[index] = skinnedPosition;
        minValue = skinnedPosition;
        maxValue = skinnedPosition;
    }

    sharedMin[localIndex] = minValue;
    sharedMax[localIndex] = maxValue;
    barrier();

    for (uint stride = gl_WorkGroupSize.x >> 1u; stride > 0u; stride >>= 1u)
    {
        if (localIndex < stride)
        {
            sharedMin[localIndex] = min(sharedMin[localIndex], sharedMin[localIndex + stride]);
            sharedMax[localIndex] = max(sharedMax[localIndex], sharedMax[localIndex + stride]);
        }
        barrier();
    }

    if (localIndex == 0u && sharedMin[0].x < FLT_MAX)
    {
        atomicMinVec(MinBoundsBits, sharedMin[0]);
        atomicMaxVec(MaxBoundsBits, sharedMax[0]);
    }
}
