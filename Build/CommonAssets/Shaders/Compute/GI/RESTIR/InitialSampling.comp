#version 460 core
#extension GL_NV_ray_tracing : require

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0) uniform accelerationStructureNV topLevelAS;
layout(binding = 1) uniform sampler2D gDepth;
layout(binding = 2) uniform sampler2D gNormal;

struct Reservoir 
{
    vec3 Li; 
    float pdf; 
    vec3 sampleDir; 
    float W; 
    int M; 
    int pad[3];
};
layout(std430, binding = 3) buffer InitialReservoir { Reservoir R[]; };

layout(location = 0) rayPayloadNV vec3 payloadRadiance;

uniform ivec2 resolution;
uniform mat4 invProjMatrix;
uniform mat4 cameraToWorldMatrix;
uniform vec3 cameraPosition;
uniform vec2 invRes;
uniform uint frameIndex;

uint wangHash(uint seed)
{
    seed = (seed ^ 61u) ^ (seed >> 16);
    seed *= 9u;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2du;
    seed = seed ^ (seed >> 15);
    return seed;
}

float rand(inout uint state)
{
    state = wangHash(state);
    return float(state) * 2.3283064365386963e-10;
}

float luminance(vec3 v)
{
    return dot(v, vec3(0.2126, 0.7152, 0.0722));
}

vec3 reconstructWorldPosition(ivec2 pix, float depth)
{
    vec2 uv = (vec2(pix) + 0.5) * invRes;
    float z = depth * 2.0 - 1.0;
    vec4 clip = vec4(uv * 2.0 - 1.0, z, 1.0);
    vec4 view = invProjMatrix * clip;
    view /= max(view.w, 1e-6);
    vec4 world = cameraToWorldMatrix * view;
    return world.xyz;
}

vec3 sampleHemisphere(vec3 N, inout uint state)
{
    float u1 = rand(state);
    float u2 = rand(state);
    float r = sqrt(u1);
    float theta = 2.0 * 3.14159265359 * u2;
    vec3 H = vec3(r * cos(theta), r * sin(theta), sqrt(max(0.0, 1.0 - u1)));
    vec3 T = normalize(cross(abs(N.z) < 0.999 ? vec3(0,0,1) : vec3(0,1,0), N));
    vec3 B = cross(N, T);
    return normalize(H.x * T + H.y * B + H.z * N);
}

void main()
{
    uvec2 pix = gl_GlobalInvocationID.xy;
    if (pix.x >= uint(resolution.x) || pix.y >= uint(resolution.y))
    {
        return;
    }
    uint idx = pix.y * uint(resolution.x) + pix.x;

    ivec2 ipix = ivec2(pix);
    float depth = texelFetch(gDepth, ipix, 0).r;
    if (depth >= 1.0)
    {
        Reservoir emptyRes;
        emptyRes.Li = vec3(0.0);
        emptyRes.pdf = 1.0;
        emptyRes.sampleDir = vec3(0.0);
        emptyRes.W = 0.0;
        emptyRes.M = 0;
        emptyRes.pad[0] = emptyRes.pad[1] = emptyRes.pad[2] = 0;
        R[idx] = emptyRes;
        return;
    }

    vec3 pos = reconstructWorldPosition(ipix, depth);
    vec3 nor = normalize(texelFetch(gNormal, ipix, 0).xyz);
    if (all(lessThan(abs(nor), vec3(1e-5))))
    {
        nor = vec3(0.0, 1.0, 0.0);
    }

    uint state = idx + frameIndex * 9781u;
    vec3 wi = sampleHemisphere(nor, state);
    float cosTheta = max(dot(nor, wi), 0.0);
    float pdf = cosTheta / 3.14159265359;
    pdf = max(pdf, 1e-6);

    // Trace ray with payload
    payloadRadiance = vec3(0.0);
    traceNV(topLevelAS, 0, 0xFF, 0, 0, 0, pos, 0.001, wi, 1e30, payloadRadiance);

    Reservoir res;
    res.Li    = payloadRadiance;
    res.pdf   = pdf;
    res.sampleDir = wi;
    float energy = max(luminance(res.Li), 0.0);
    res.W     = energy * cosTheta / pdf;
    res.M     = 1;
    res.pad[0] = res.pad[1] = res.pad[2] = 0;
    R[idx]    = res;
}