#version 450

// Debug visualization: Render surfel grid cell occupancy as heatmap
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(binding = 0) uniform sampler2D gDepth;
layout(binding = 1) uniform sampler2D gNormal;
layout(binding = 2) uniform sampler2D gAlbedo;
layout(binding = 3) uniform usampler2D gTransformId;
layout(binding = 4) uniform sampler2D gHDRScene;
layout(binding = 0, rgba8) writeonly uniform image2D gOutput;

uniform ivec2 resolution;
uniform mat4 invProjMatrix;
uniform mat4 cameraToWorldMatrix;
uniform vec3 gridOrigin;
uniform float cellSize;
uniform uvec3 gridDim;
uniform uint maxPerCell;
uniform uint maxSurfels;

layout(std430, binding = 3) buffer GridCounts
{
    uint counts[];
};

vec3 HeatmapColor(float t)
{
    // Blue -> Cyan -> Green -> Yellow -> Red
    t = clamp(t, 0.0, 1.0);
    vec3 c;
    if (t < 0.25)
    {
        float s = t / 0.25;
        c = mix(vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 1.0), s);
    }
    else if (t < 0.5)
    {
        float s = (t - 0.25) / 0.25;
        c = mix(vec3(0.0, 1.0, 1.0), vec3(0.0, 1.0, 0.0), s);
    }
    else if (t < 0.75)
    {
        float s = (t - 0.5) / 0.25;
        c = mix(vec3(0.0, 1.0, 0.0), vec3(1.0, 1.0, 0.0), s);
    }
    else
    {
        float s = (t - 0.75) / 0.25;
        c = mix(vec3(1.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), s);
    }
    return c;
}

vec3 ReconstructWorldPosition(vec2 uv, float depth)
{
    vec4 clip = vec4(uv * 2.0 - 1.0, depth * 2.0 - 1.0, 1.0);
    vec4 view = invProjMatrix * clip;
    view /= max(view.w, 1e-6);
    vec4 world = cameraToWorldMatrix * view;
    return world.xyz;
}

uint CellIndex(uvec3 c)
{
    return c.x + gridDim.x * (c.y + gridDim.y * c.z);
}

bool WorldToCell(vec3 p, out uint cell, out vec3 cellLocalPos)
{
    vec3 rel = (p - gridOrigin) / max(cellSize, 1e-6);
    ivec3 ci = ivec3(floor(rel));
    if (any(lessThan(ci, ivec3(0))) || any(greaterThanEqual(ci, ivec3(gridDim))))
        return false;

    cell = CellIndex(uvec3(ci));
    cellLocalPos = fract(rel); // Position within cell [0,1]
    return true;
}

void main()
{
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    if (pix.x >= resolution.x || pix.y >= resolution.y)
        return;

    vec2 uv = (vec2(pix) + 0.5) / vec2(resolution);
    
    // Get base scene color with simple tonemapping
    vec3 sceneColor = texture(gHDRScene, uv).rgb;
    sceneColor = sceneColor / (sceneColor + 1.0);
    
    float depth = texture(gDepth, uv).r;
    if (depth <= 0.0 || depth >= 1.0)
    {
        imageStore(gOutput, pix, vec4(sceneColor, 1.0));
        return;
    }

    vec3 worldPos = ReconstructWorldPosition(uv, depth);

    // Find the cell this pixel is in
    uint cell;
    vec3 cellLocalPos;
    if (!WorldToCell(worldPos, cell, cellLocalPos))
    {
        imageStore(gOutput, pix, vec4(sceneColor, 1.0));
        return;
    }

    uint count = counts[cell];
    
    // Color by occupancy - normalize to maxPerCell
    float occupancy = float(count) / float(maxPerCell);
    vec3 heatColor = HeatmapColor(occupancy);
    
    // Draw cell boundaries as darker lines
    float edgeWidth = 0.05;
    bool onEdge = any(lessThan(cellLocalPos, vec3(edgeWidth))) || 
                  any(greaterThan(cellLocalPos, vec3(1.0 - edgeWidth)));
    
    if (onEdge)
    {
        heatColor *= 0.5; // Darken edges
    }
    
    // Show empty cells as semi-transparent gray
    if (count == 0u)
    {
        heatColor = vec3(0.3, 0.3, 0.3);
    }
    
    // Blend with scene - more opaque for filled cells
    float alpha = (count > 0u) ? 0.7 : 0.3;
    vec3 result = mix(sceneColor, heatColor, alpha);
    imageStore(gOutput, pix, vec4(result, 1.0));
}
