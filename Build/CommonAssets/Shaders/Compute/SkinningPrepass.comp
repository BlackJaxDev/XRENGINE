#version 450

layout(local_size_x = 256) in;

layout(row_major, std430, binding = 0) buffer BoneMatricesBuffer
{
    mat4 BoneMatrices[];
};

layout(row_major, std430, binding = 1) buffer BoneInvBindMatricesBuffer
{
    mat4 BoneInvBindMatrices[];
};

layout(std430, binding = 2) buffer BoneIndicesOrOffsetsBuffer
{
    // When optimized4=1: stores 4 bone indices per vertex (stride 16 bytes)
    // When optimized4=0: stores 1 offset per vertex (stride 4 bytes)
    uint BoneIndicesOrOffsetsRaw[];
};

layout(std430, binding = 3) buffer BoneWeightsOrCountsBuffer
{
    // When optimized4=1: stores 4 bone weights per vertex (stride 16 bytes)  
    // When optimized4=0: stores 1 count per vertex (stride 4 bytes)
    uint BoneWeightsOrCountsRaw[];
};

layout(std430, binding = 4) buffer BlendshapeCountsBuffer
{
    uvec2 BlendshapeCounts[];
};

layout(std430, binding = 5) buffer BlendshapeIndicesBuffer
{
    uvec4 BlendshapeIndices[];
};

layout(std430, binding = 6) buffer BlendshapeDeltasBuffer
{
    vec4 BlendshapeDeltas[];
};

layout(std430, binding = 7) buffer BlendshapeWeightsBuffer
{
    float BlendshapeWeights[];
};

// Input buffers (read-only, original mesh data)
layout(std430, binding = 8) readonly buffer PositionsInBuffer
{
    // Source positions are tightly packed vec3 (12 byte stride), so read as floats to avoid std430 vec4 padding.
    float PositionsIn[];
};

layout(std430, binding = 9) readonly buffer NormalsInBuffer
{
    // Normals are stored as vec3 per vertex (12 byte stride).
    float NormalsIn[];
};

layout(std430, binding = 10) readonly buffer TangentsInBuffer
{
    // Tangents are stored as vec3 per vertex (12 byte stride).
    float TangentsIn[];
};

// Output buffers (write-only, skinned results)
// These reuse bindings 11-13 which don't conflict with bone index/weight lists
// since those are only used for variable weight skinning path
layout(std430, binding = 11) writeonly buffer PositionsOutBuffer
{
    vec4 PositionsOut[];
};

layout(std430, binding = 12) writeonly buffer NormalsOutBuffer
{
    vec4 NormalsOut[];
};

layout(std430, binding = 15) writeonly buffer TangentsOutBuffer
{
    vec4 TangentsOut[];
};

// Variable weight skinning buffers (only used when optimized4 == 0)
layout(std430, binding = 13) buffer BoneIndexListBuffer
{
    uint BoneIndexList[];
};

layout(std430, binding = 14) buffer BoneWeightListBuffer
{
    float BoneWeightList[];
};

// Note: Interleaved vertex buffer support has been removed to stay within 
// the 16 SSBO binding limit. Compute skinning only works with non-interleaved meshes.

uniform uint vertexCount;
uniform int hasSkinning;
uniform int hasNormals;
uniform int hasTangents;
uniform int hasBlendshapes;
uniform int allowBlendshapes;
uniform int absoluteBlendshapePositions;
uniform int maxBlendshapeAccumulation;
uniform int useIntegerUniforms;
uniform int optimized4;
uniform uint boneMatrixBase;
uniform uint boneMatrixCount;
uniform uint blendshapeWeightBase;

const float MIN_BLEND_WEIGHT = 0.0001f;

uint decodeIndex(uint raw)
{
    return useIntegerUniforms != 0 ? raw : uint(round(uintBitsToFloat(raw)));
}

uint decodeCount(uvec2 raw)
{
    return useIntegerUniforms != 0 ? raw.y : uint(round(uintBitsToFloat(raw.y)));
}

uint decodeStart(uvec2 raw)
{
    return useIntegerUniforms != 0 ? raw.x : uint(round(uintBitsToFloat(raw.x)));
}

ivec4 decodeBlendshapeIndices(uvec4 raw)
{
    if (useIntegerUniforms != 0)
        return ivec4(raw);
    return ivec4(
        round(uintBitsToFloat(raw.x)),
        round(uintBitsToFloat(raw.y)),
        round(uintBitsToFloat(raw.z)),
        round(uintBitsToFloat(raw.w)));
}

vec3 loadPosition(uint vertexIndex)
{
    uint base = vertexIndex * 3u;
    return vec3(PositionsIn[base + 0u], PositionsIn[base + 1u], PositionsIn[base + 2u]);
}

vec3 loadNormal(uint vertexIndex)
{
    uint base = vertexIndex * 3u;
    return vec3(NormalsIn[base + 0u], NormalsIn[base + 1u], NormalsIn[base + 2u]);
}

vec3 loadTangent(uint vertexIndex)
{
    uint base = vertexIndex * 3u;
    return vec3(TangentsIn[base + 0u], TangentsIn[base + 1u], TangentsIn[base + 2u]);
}

void applyBlendshapes(inout vec3 position, inout vec3 normal, inout vec3 tangent, uint vertexIndex)
{
    if (hasBlendshapes == 0 || allowBlendshapes == 0)
        return;

    uvec2 countData = BlendshapeCounts[vertexIndex];
    uint start = decodeStart(countData);
    uint count = decodeCount(countData);
    if (count == 0u)
        return;

    if (maxBlendshapeAccumulation != 0)
    {
        vec3 maxPos = vec3(0.0);
        vec3 maxNrm = vec3(0.0);
        vec3 maxTan = vec3(0.0);
        for (uint i = 0u; i < count; ++i)
        {
            ivec4 bs = decodeBlendshapeIndices(BlendshapeIndices[start + i]);
            int blendIndex = bs.x;
            if (blendIndex < 0)
                continue;
            float weight = BlendshapeWeights[blendshapeWeightBase + uint(blendIndex)];
            if (weight <= MIN_BLEND_WEIGHT)
                continue;

            int posIndex = bs.y;
            int nrmIndex = bs.z;
            int tanIndex = bs.w;

            maxPos = max(maxPos, BlendshapeDeltas[posIndex].xyz * weight);
            maxNrm = max(maxNrm, BlendshapeDeltas[nrmIndex].xyz * weight);
            maxTan = max(maxTan, BlendshapeDeltas[tanIndex].xyz * weight);
        }

        position += maxPos;
        if (hasNormals != 0)
            normal += maxNrm;
        if (hasTangents != 0)
            tangent += maxTan;
    }
    else
    {
        for (uint i = 0u; i < count; ++i)
        {
            ivec4 bs = decodeBlendshapeIndices(BlendshapeIndices[start + i]);
            int blendIndex = bs.x;
            if (blendIndex < 0)
                continue;
            float weight = BlendshapeWeights[blendshapeWeightBase + uint(blendIndex)];
            if (weight <= MIN_BLEND_WEIGHT)
                continue;

            int posIndex = bs.y;
            int nrmIndex = bs.z;
            int tanIndex = bs.w;

            position += BlendshapeDeltas[posIndex].xyz * weight;
            if (hasNormals != 0)
                normal += BlendshapeDeltas[nrmIndex].xyz * weight;
            if (hasTangents != 0)
                tangent += BlendshapeDeltas[tanIndex].xyz * weight;
        }
    }
}

uint loadIndexValue(uint raw)
{
    return useIntegerUniforms != 0 ? raw : uint(round(uintBitsToFloat(raw)));
}

// Matches vertex shader adjoint() - computes cofactor matrix for normal transformation
mat3 adjoint(mat4 m)
{
    return mat3(
        cross(m[1].xyz, m[2].xyz),
        cross(m[2].xyz, m[0].xyz),
        cross(m[0].xyz, m[1].xyz)
    );
}

void applySkinningOptimized4(inout vec3 position, inout vec3 normal, inout vec3 tangent, uint vertexIndex)
{
    // When optimized4=1, data is laid out as ivec4/vec4 per vertex (16 bytes stride each)
    // Note: The C# PopulateOptWeightsParallel always writes bone indices as int,
    // so we read them directly as int without useIntegerUniforms decoding.
    uint base = vertexIndex * 4u;
    ivec4 indices = ivec4(
        int(BoneIndicesOrOffsetsRaw[base + 0u]),
        int(BoneIndicesOrOffsetsRaw[base + 1u]),
        int(BoneIndicesOrOffsetsRaw[base + 2u]),
        int(BoneIndicesOrOffsetsRaw[base + 3u]));
    vec4 weightsRaw = vec4(
        uintBitsToFloat(BoneWeightsOrCountsRaw[base + 0u]),
        uintBitsToFloat(BoneWeightsOrCountsRaw[base + 1u]),
        uintBitsToFloat(BoneWeightsOrCountsRaw[base + 2u]),
        uintBitsToFloat(BoneWeightsOrCountsRaw[base + 3u]));

    // Preserve the source vertex attributes for each bone contribution
    vec3 basePosition = position;
    vec3 baseNormal = normal;
    vec3 baseTangent = tangent;

    vec3 skinnedPos = vec3(0.0);
    vec3 skinnedNormal = vec3(0.0);
    vec3 skinnedTangent = vec3(0.0);
    float totalWeight = 0.0f;

    uint boneCount = boneMatrixCount;

    for (int i = 0; i < 4; ++i)
    {
        int boneIndex = indices[i];
        float weight = weightsRaw[i];
        if (boneIndex < 0 || weight <= 0.0f)
            continue;

        // Drop invalid indices instead of indexing past the buffer and crashing
        if (uint(boneIndex) >= boneCount)
            continue;

        // With row_major buffers, use row-vector multiplication to match CPU/System.Numerics conventions.
        // (This keeps results consistent with the vertex-skinning path without changing it.)
        uint idx = boneMatrixBase + uint(boneIndex);
        mat4 boneMatrix = BoneInvBindMatrices[idx] * BoneMatrices[idx];
        vec4 p = vec4(basePosition, 1.0f) * boneMatrix;
        skinnedPos += p.xyz * weight;
        totalWeight += weight;

        // Use adjoint for normal transformation - matches vertex shader and is much faster
        mat3 boneMatrix3 = adjoint(boneMatrix);
        if (hasNormals != 0)
            skinnedNormal += (baseNormal * boneMatrix3) * weight;
        if (hasTangents != 0)
            skinnedTangent += (baseTangent * boneMatrix3) * weight;
    }

    // If no bones contributed, preserve original position (vertex has no skinning)
    if (totalWeight <= 0.0001f)
        return;

    position = skinnedPos;
    if (hasNormals != 0)
        normal = skinnedNormal;
    if (hasTangents != 0)
        tangent = skinnedTangent;
}

void applySkinningVariable(inout vec3 position, inout vec3 normal, inout vec3 tangent, uint vertexIndex)
{
    // When optimized4=0, offset and count are single values per vertex (4 bytes stride)
    uint offset = loadIndexValue(BoneIndicesOrOffsetsRaw[vertexIndex]);
    uint count = loadIndexValue(BoneWeightsOrCountsRaw[vertexIndex]);
    if (count == 0u)
        return;

    vec3 basePosition = position;
    vec3 baseNormal = normal;
    vec3 baseTangent = tangent;

    vec3 skinnedPos = vec3(0.0);
    vec3 skinnedNormal = vec3(0.0);
    vec3 skinnedTangent = vec3(0.0);
    float totalWeight = 0.0f;

    uint boneCount = boneMatrixCount;

    uint indexListSize = BoneIndexList.length();
    uint weightListSize = BoneWeightList.length();
    if (offset >= indexListSize || offset >= weightListSize)
        return;

    uint maxAvailable = min(indexListSize - offset, weightListSize - offset);
    uint safeCount = min(count, maxAvailable);

    for (uint i = 0u; i < safeCount; ++i)
    {
        uint listIndex = offset + i;
        uint rawIndex = BoneIndexList[listIndex];
        float weight = BoneWeightList[listIndex];
        int boneIndex = int(loadIndexValue(rawIndex));
        if (boneIndex < 0 || weight <= 0.0f)
            continue;

        if (uint(boneIndex) >= boneCount)
            continue;

        // With row_major buffers, use row-vector multiplication to match CPU/System.Numerics conventions.
        uint idx = boneMatrixBase + uint(boneIndex);
        mat4 boneMatrix = BoneInvBindMatrices[idx] * BoneMatrices[idx];
        vec4 p = vec4(basePosition, 1.0f) * boneMatrix;
        skinnedPos += p.xyz * weight;
        totalWeight += weight;

        // Use adjoint for normal transformation - matches vertex shader and is much faster
        mat3 boneMatrix3 = adjoint(boneMatrix);
        if (hasNormals != 0)
            skinnedNormal += (baseNormal * boneMatrix3) * weight;
        if (hasTangents != 0)
            skinnedTangent += (baseTangent * boneMatrix3) * weight;
    }

    // If no bones contributed, preserve original position (vertex has no skinning)
    if (totalWeight <= 0.0001f)
        return;

    position = skinnedPos;
    if (hasNormals != 0)
        normal = skinnedNormal;
    if (hasTangents != 0)
        tangent = skinnedTangent;
}

void applySkinning(inout vec3 position, inout vec3 normal, inout vec3 tangent, uint vertexIndex)
{
    if (hasSkinning == 0)
        return;

    if (optimized4 != 0)
        applySkinningOptimized4(position, normal, tangent, vertexIndex);
    else
        applySkinningVariable(position, normal, tangent, vertexIndex);
}

void main()
{
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= vertexCount)
        return;

    // Note: Interleaved vertex buffer support has been removed to stay within
    // the 16 SSBO binding limit. Compute skinning only works with non-interleaved meshes.
    // If interleaved mode is requested, this shader will not produce correct results.

    vec3 basePosition = loadPosition(idx);
    vec3 baseNormal = (hasNormals != 0) ? loadNormal(idx) : vec3(0.0);
    vec3 baseTangent = (hasTangents != 0) ? loadTangent(idx) : vec3(0.0);

    applyBlendshapes(basePosition, baseNormal, baseTangent, idx);
    applySkinning(basePosition, baseNormal, baseTangent, idx);

    PositionsOut[idx].xyz = basePosition;
    if (hasNormals != 0)
        NormalsOut[idx].xyz = normalize(baseNormal);
    if (hasTangents != 0)
        TangentsOut[idx].xyz = normalize(baseTangent);
}
