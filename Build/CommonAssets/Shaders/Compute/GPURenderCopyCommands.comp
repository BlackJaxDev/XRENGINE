#version 460

// Copy render commands from input SSBO to output SSBO (passthrough culling path)
// One thread copies one command (32 floats / 128 bytes).

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

uniform uint CopyCount;
uniform int TargetPass;
uniform int DebugEnabled;
uniform int DebugMaxSamples;
uniform int DebugInstanceStride;

// Number of commands is equal to the number of dispatched invocations.
// No explicit CopyCount uniform is required.

// Input command buffer: tightly packed float[32] per command
layout(std430, binding = 0) readonly buffer InCommands
{
    float InData[];
};

// Output command buffer: tightly packed float[32] per command
layout(std430, binding = 1) writeonly buffer OutCommands
{
    float OutData[];
};

// Optional count buffer to mirror visible count on GPU
layout(std430, binding = 2) writeonly buffer VisibleCount
{
    uint OutCount[];
};

layout(std430, binding = 3) writeonly buffer DebugSamples
{
    uint DebugData[];
};

const uint CommandStride = 32u;
const uint RenderPassIndex = 24u;

void main()
{
    // Flatten the global invocation ID to a 1D linear index so this also
    // works if the CPU dispatches work across Y/Z dimensions.
    const uvec3 localSize = gl_WorkGroupSize;             // compile-time constant
    uvec3 globalSize = gl_NumWorkGroups * localSize;      // total grid size across all dims

    uint cmdIndex = gl_GlobalInvocationID.x
                  + gl_GlobalInvocationID.y * globalSize.x
                  + gl_GlobalInvocationID.z * (globalSize.x * globalSize.y);

    if (cmdIndex >= CopyCount)
        return;

    uint inBase  = cmdIndex * CommandStride;
    uint commandPass = floatBitsToUint(InData[inBase + RenderPassIndex]);
    uint expectedPass = TargetPass >= 0 ? uint(TargetPass) : 0xFFFFFFFFu;

    bool passMatches = true;

    if (TargetPass >= 0)
    {
        if (commandPass != expectedPass && commandPass != 0xFFFFFFFFu)
            passMatches = false;
    }

    if (DebugEnabled == 1)
    {
        uint maxSamples = uint(DebugMaxSamples);
        if (maxSamples > 0u)
        {
            uint stride = DebugInstanceStride > 0 ? uint(DebugInstanceStride) : CommandStride;
            uint debugIndex = cmdIndex;
            if (debugIndex < maxSamples)
            {
                uint baseIndex = debugIndex * stride;
                DebugData[baseIndex + 0u] = cmdIndex;
                DebugData[baseIndex + 1u] = commandPass;
                DebugData[baseIndex + 2u] = passMatches ? 1u : 0u;
                DebugData[baseIndex + 3u] = expectedPass;
            }
        }
    }

    if (!passMatches)
        return;

    uint outIndex = atomicAdd(OutCount[0], 1u);
    uint outBase = outIndex * CommandStride;

    // Unrolled copy for better performance on some drivers
    // But keep a simple loop for clarity and flexibility
    for (uint i = 0u; i < CommandStride; ++i)
        OutData[outBase + i] = InData[inBase + i];
}
