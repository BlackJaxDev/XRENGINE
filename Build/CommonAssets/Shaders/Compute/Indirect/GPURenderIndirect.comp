// Minimum working-set indirect draw build shader for 48-float command struct
#version 460 core

layout(local_size_x = 256) in;

// Constants
const int COMMAND_FLOATS = 48;      // 192 bytes per command
const int DRAW_COMMAND_UINTS = 5;   // count, instanceCount, firstIndex, baseVertex, baseInstance

/* Command layout (float[48]):
 00-15 WorldMatrix, 16-31 PrevWorldMatrix, 32-35 BoundingSphere, 36 MeshID, 37 SubmeshID, 38 MaterialID,
 39 InstanceCount, 40 RenderPass, 41 ShaderProgramID, 42 RenderDistance,
 43 LayerMask, 44 LODLevel, 45 Flags, 46 Reserved0, 47 Reserved1 */

// === Buffers ===
layout(std430, binding = 0) buffer CulledCommandsBuffer { float culled[]; };
layout(std430, binding = 1) buffer IndirectDrawBuffer { uint indirectDraws[]; };
layout(std430, binding = 2) buffer SubmeshDataBuffer { uint submeshData[]; }; // uint4 per submesh: indexCount, firstIndex, baseVertex, baseInstance
layout(std430, binding = 3) buffer CulledCountBuffer
{
    uint CulledCount;
    uint CulledInstanceCount;
    uint CulledOverflow;
};
layout(std430, binding = 4) buffer DrawCountBuffer { uint DrawCount; };

// Overflow flag specific to indirect build (distinct from culling overflow)
layout(std430, binding = 5) buffer IndirectOverflowFlagBuffer { uint IndirectOverflowFlag; };

// Optional sorted key-index list: pairs [key, originalIndex]
//layout(std430, binding = 6) buffer KeyIndexBuffer { uint keyIndexPairs[]; };

// Truncation flag (optional) set if draw list exceeds capacity
layout(std430, binding = 7) buffer TruncationFlagBuffer { uint TruncationFlag; };

// Optional shared stats buffer (must match culling shader binding if used)
layout(std430, binding = 8) buffer StatsBuffer
{
    uint StatsInputCount;
    uint StatsCulledCount;
    uint StatsDrawCount;
    uint StatsRejectedFrustum;
    uint StatsRejectedDistance;
    uint StatsBvhBuildCount;
    uint StatsBvhRefitCount;
    uint StatsBvhCullCount;
    uint StatsBvhRayCount;
    uint StatsBvhBuildTimeLo;
    uint StatsBvhBuildTimeHi;
    uint StatsBvhRefitTimeLo;
    uint StatsBvhRefitTimeHi;
    uint StatsBvhCullTimeLo;
    uint StatsBvhCullTimeHi;
    uint StatsBvhRayTimeLo;
    uint StatsBvhRayTimeHi;
};

layout(std430, binding = 9) readonly buffer CulledHotCommandsBuffer { uint culledHot[]; };

struct GPUViewDescriptor
{
    uint ViewId;
    uint ParentViewId;
    uint Flags;
    uint RenderPassMaskLo;
    uint RenderPassMaskHi;
    uint OutputLayer;
    uint ViewRectX;
    uint ViewRectY;
    uint ViewRectW;
    uint ViewRectH;
    uint VisibleOffset;
    uint VisibleCapacity;
    vec4 FoveationA;
    vec4 FoveationB;
};

struct GPUViewConstants
{
    mat4 View;
    mat4 Projection;
    mat4 ViewProjection;
    mat4 PrevViewProjection;
    vec4 CameraPositionAndNear;
    vec4 CameraForwardAndFar;
};

layout(std430, binding = 11) readonly buffer ViewDescriptorBuffer { GPUViewDescriptor ViewDescriptors[]; };
layout(std430, binding = 12) readonly buffer ViewConstantsBuffer { GPUViewConstants ViewConstants[]; };
layout(std430, binding = 13) readonly buffer CommandViewMaskBuffer { uvec2 CommandViewMasks[]; };
layout(std430, binding = 14) readonly buffer PerViewVisibleIndicesBuffer { uint PerViewVisibleIndices[]; };
layout(std430, binding = 15) readonly buffer PerViewDrawCountBuffer { uint PerViewDrawCount[]; };

// === Uniforms ===
uniform int CurrentRenderPass;     // -1 accepts all
uniform int MaxIndirectDraws;      // capacity in draws
uniform uint StatsEnabled;         // 0 when stats buffer is unbound
uniform int ActiveViewCount;
uniform int SourceViewId;
uniform int UseHotCommands;
//uniform int UseSorted;             // 1 = use keyIndexPairs for ordering

void main()
{
    uint logicalIdx = gl_GlobalInvocationID.x;
    uint total = CulledCount; // snapshot
    uint sourceViewId = SourceViewId < 0 ? 0u : uint(SourceViewId);

    if (ActiveViewCount > 0 && sourceViewId < uint(PerViewDrawCount.length()))
        total = min(total, PerViewDrawCount[sourceViewId]);

    if (logicalIdx >= total)
        return;

    uint idx = logicalIdx;
    if (ActiveViewCount > 0 &&
        sourceViewId < uint(ViewDescriptors.length()) &&
        sourceViewId < uint(PerViewDrawCount.length()))
    {
        GPUViewDescriptor sourceView = ViewDescriptors[sourceViewId];
        if (logicalIdx < sourceView.VisibleCapacity)
        {
            uint sourceOffset = sourceView.VisibleOffset + logicalIdx;
            if (sourceOffset < uint(PerViewVisibleIndices.length()))
                idx = PerViewVisibleIndices[sourceOffset];
        }
    }

    if (idx >= CulledCount)
        return;
    //if (UseSorted != 0)
    //{
    //    // keyIndexPairs stores [key, originalIndex] sequentially
    //    uint pairBase = logicalIdx * 2u;
    //    if (pairBase + 1u < keyIndexPairs.length())
    //        idx = keyIndexPairs[pairBase + 1u];
    //}

    int base = int(idx) * COMMAND_FLOATS;
    int hotBase = int(idx) * 16;

    uint renderPass;
    uint instanceCount;
    uint meshID;

    if (UseHotCommands != 0)
    {
        renderPass = culledHot[hotBase + 8];
        instanceCount = culledHot[hotBase + 7];
        meshID = culledHot[hotBase + 4];
    }
    else
    {
        renderPass = floatBitsToUint(culled[base + 40]);
        instanceCount = floatBitsToUint(culled[base + 39]);
        meshID = floatBitsToUint(culled[base + 36]);
    }

    // Defensive pass filter (culling shader should already filter by pass, but keep this to avoid
    // drawing mixed-pass command buffers if that assumption ever changes).
    if (CurrentRenderPass >= 0 && renderPass != uint(CurrentRenderPass) && renderPass != 0xFFFFFFFFu)
        return;

    // Deterministic output layout: one indirect slot per visible command.
    // This keeps batching offsets consistent with the culled command buffer order.
    uint outIndex = logicalIdx;
    if (logicalIdx == 0u)
    {
        uint capped = min(total, uint(MaxIndirectDraws));
        DrawCount = capped;
        if (total > uint(MaxIndirectDraws))
        {
            atomicExchange(IndirectOverflowFlag, 1u);
            atomicExchange(TruncationFlag, 1u);
        }
    }

    if (outIndex >= uint(MaxIndirectDraws))
        return;

    uint drawBase = outIndex * DRAW_COMMAND_UINTS;

    // Default to a no-op draw to avoid consuming stale commands.
    indirectDraws[drawBase + 0u] = 0u;
    indirectDraws[drawBase + 1u] = 0u;
    indirectDraws[drawBase + 2u] = 0u;
    indirectDraws[drawBase + 3u] = 0u;
    indirectDraws[drawBase + 4u] = 0u;

    if (instanceCount == 0u)
        return;

    // MeshDataBuffer is indexed by MeshID (uint4 per mesh): [IndexCount, FirstIndex, BaseVertex, BaseInstance]
    uint submeshOffset = meshID * 4u;
    if (submeshOffset + 3u >= submeshData.length())
        return;

    uint indexCount = submeshData[submeshOffset + 0u];
    if (indexCount == 0u)
        return; // defensive skip
    
    uint firstIndex = submeshData[submeshOffset + 1u];
    uint baseVertex = submeshData[submeshOffset + 2u];
    // Encode the culled-command index into baseInstance so the graphics vertex shader can
    // fetch per-draw data (world matrix, etc.) via gl_BaseInstance.
    uint baseInstance = idx;

    indirectDraws[drawBase + 0u] = indexCount;
    indirectDraws[drawBase + 1u] = instanceCount;
    indirectDraws[drawBase + 2u] = firstIndex;
    indirectDraws[drawBase + 3u] = baseVertex;
    indirectDraws[drawBase + 4u] = baseInstance;
    if (StatsEnabled != 0u)
        atomicAdd(StatsDrawCount, 1u);
}
