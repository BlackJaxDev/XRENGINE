#version 460

// Copy render commands from input SSBO to output SSBO (passthrough culling path)
// One thread copies one command (32 floats / 128 bytes).

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

uniform uint CopyCount;
uniform int TargetPass;
uniform int DebugEnabled;
uniform int DebugMaxSamples;
uniform int DebugInstanceStride;
uniform uint OutputCapacity;
uniform int BoundsCheckEnabled;
uniform int ActiveViewCount;

// Input command buffer: tightly packed float[48] per command (GPUIndirectRenderCommand)
layout(std430, binding = 0) readonly buffer InCommands
{
    float InData[];
};

// Output command buffer: tightly packed float[48] per command
layout(std430, binding = 1) writeonly buffer OutCommands
{
    float OutData[];
};

// Optional count buffer to mirror visible draw + instance counts on GPU
layout(std430, binding = 2) buffer VisibleCount
{
    uint VisibleDrawCount;
    uint VisibleInstanceCount;
    uint VisibleOverflow;
};

layout(std430, binding = 3) writeonly buffer DebugSamples
{
    uint DebugData[];
};

layout(std430, binding = 4) buffer OverflowFlag
{
    uint OverflowData[];
};

struct GPUViewDescriptor
{
    uint ViewId;
    uint ParentViewId;
    uint Flags;
    uint RenderPassMaskLo;
    uint RenderPassMaskHi;
    uint OutputLayer;
    uint ViewRectX;
    uint ViewRectY;
    uint ViewRectW;
    uint ViewRectH;
    uint VisibleOffset;
    uint VisibleCapacity;
    vec4 FoveationA;
    vec4 FoveationB;
};

struct GPUViewConstants
{
    mat4 View;
    mat4 Projection;
    mat4 ViewProjection;
    mat4 PrevViewProjection;
    vec4 CameraPositionAndNear;
    vec4 CameraForwardAndFar;
};

layout(std430, binding = 11) readonly buffer ViewDescriptorBuffer { GPUViewDescriptor ViewDescriptors[]; };
layout(std430, binding = 12) readonly buffer ViewConstantsBuffer { GPUViewConstants ViewConstants[]; };
layout(std430, binding = 13) readonly buffer CommandViewMaskBuffer { uvec2 CommandViewMasks[]; };
layout(std430, binding = 14) buffer PerViewVisibleIndicesBuffer { uint PerViewVisibleIndices[]; };
layout(std430, binding = 15) buffer PerViewDrawCountBuffer { uint PerViewDrawCounts[]; };

#define FLAG_TRANSPARENT    (1u<<0)

const uint CommandStride = 48u;
const uint RenderPassIndex = 40u;
const uint InstanceCountIndex = 39u;

bool ViewMaskContains(uvec2 mask, uint viewId)
{
    if (viewId < 32u)
        return (mask.x & (1u << viewId)) != 0u;

    uint hi = viewId - 32u;
    if (hi >= 32u)
        return false;

    return (mask.y & (1u << hi)) != 0u;
}

void AppendPerView(uint sourceCommandIndex, uint culledCommandIndex, vec3 commandCenter, uint commandFlags)
{
    if (ActiveViewCount <= 0)
        return;

    if (sourceCommandIndex >= CommandViewMasks.length())
        return;

    uvec2 mask = CommandViewMasks[sourceCommandIndex];
    uint maxViews = min(uint(ActiveViewCount), min(uint(64), uint(PerViewDrawCounts.length())));
    for (uint viewId = 0u; viewId < maxViews; ++viewId)
    {
        if (!ViewMaskContains(mask, viewId))
            continue;

        GPUViewDescriptor vd = ViewDescriptors[viewId];
        bool foveated = (vd.Flags & (1u << 3u)) != 0u;
        if (foveated)
        {
            vec3 cameraPosition = ViewConstants[viewId].CameraPositionAndNear.xyz;
            vec3 toCenter = commandCenter - cameraPosition;
            float perViewDistanceSq = dot(toCenter, toCenter);
            float fullResNearDistance = vd.FoveationB.w;
            if (fullResNearDistance > 0.0 && perViewDistanceSq <= (fullResNearDistance * fullResNearDistance))
                continue;

            if ((commandFlags & FLAG_TRANSPARENT) != 0u)
                continue;
        }

        uint local = atomicAdd(PerViewDrawCounts[viewId], 1u);
        if (local < vd.VisibleCapacity)
        {
            uint dst = vd.VisibleOffset + local;
            if (dst < PerViewVisibleIndices.length())
                PerViewVisibleIndices[dst] = culledCommandIndex;
        }
    }
}

void main()
{
    // Flatten the global invocation ID to a 1D linear index so this also
    // works if the CPU dispatches work across Y/Z dimensions.
    const uvec3 localSize = gl_WorkGroupSize;             // compile-time constant
    uvec3 globalSize = gl_NumWorkGroups * localSize;      // total grid size across all dims

    uint cmdIndex = gl_GlobalInvocationID.x
                  + gl_GlobalInvocationID.y * globalSize.x
                  + gl_GlobalInvocationID.z * (globalSize.x * globalSize.y);

    if (cmdIndex >= CopyCount)
        return;

    uint inBase  = cmdIndex * CommandStride;
    uint commandPass = floatBitsToUint(InData[inBase + RenderPassIndex]);
    uint expectedPass = TargetPass >= 0 ? uint(TargetPass) : 0xFFFFFFFFu;

    bool passMatches = true;

    if (TargetPass >= 0)
    {
        if (commandPass != expectedPass && commandPass != 0xFFFFFFFFu)
            passMatches = false;
    }

    if (DebugEnabled == 1)
    {
        uint maxSamples = uint(DebugMaxSamples);
        if (maxSamples > 0u)
        {
            uint stride = DebugInstanceStride > 0 ? uint(DebugInstanceStride) : CommandStride;
            uint debugIndex = cmdIndex;
            if (debugIndex < maxSamples)
            {
                uint baseIndex = debugIndex * stride;
                DebugData[baseIndex + 0u] = cmdIndex;
                DebugData[baseIndex + 1u] = commandPass;
                DebugData[baseIndex + 2u] = passMatches ? 1u : 0u;
                DebugData[baseIndex + 3u] = expectedPass;
            }
        }
    }

    if (!passMatches)
        return;

    uint instanceCount = floatBitsToUint(InData[inBase + InstanceCountIndex]);
    uint outIndex = atomicAdd(VisibleDrawCount, 1u);

    if (BoundsCheckEnabled == 1)
    {
        if (outIndex >= OutputCapacity)
        {
            atomicMin(VisibleDrawCount, OutputCapacity);
            atomicCompSwap(OverflowData[0], 0u, cmdIndex + 1u);
            atomicCompSwap(VisibleOverflow, 0u, cmdIndex + 1u);
            return;
        }
    }

    atomicAdd(VisibleInstanceCount, instanceCount);
    uint outBase = outIndex * CommandStride;

    // Unrolled copy for better performance on some drivers
    // But keep a simple loop for clarity and flexibility
    for (uint i = 0u; i < CommandStride; ++i)
        OutData[outBase + i] = InData[inBase + i];

    uint flags = floatBitsToUint(InData[inBase + 45u]);
    vec3 center = vec3(InData[inBase + 32u], InData[inBase + 33u], InData[inBase + 34u]);
    AppendPerView(cmdIndex, outIndex, center, flags);
}
