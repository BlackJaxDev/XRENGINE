// Minimum working-set culling shader (no octree) using a 48-float command struct
#version 460 core

layout(local_size_x = 256) in;

/*
 GPUIndirectRenderCommand (float[48], 192 bytes):
  00-15 : WorldMatrix (mat4, column-major)
  16-31 : PrevWorldMatrix (mat4, column-major) - for motion vectors
  32-35 : BoundingSphere (vec4: xyz center, w radius)
  36 : MeshID (uint as float)
  37 : SubmeshID (uint as float)  (optional / may mirror meshID if not flattened)
  38 : MaterialID (uint)
  39 : InstanceCount (uint)
  40 : RenderPass (uint)
  41 : ShaderProgramID (uint)
  42 : RenderDistance (float)  (camera-space depth or squared distance)
  43 : LayerMask (uint)
  44 : LODLevel (uint)
  45 : Flags (uint)
  46 : Reserved0
  47 : Reserved1
*/

// === Buffers ===
layout(std430, binding = 0) buffer InputCommandsBuffer { float inCommands[]; };
layout(std430, binding = 1) buffer CulledCommandsBuffer { float outCommands[]; };
layout(std430, binding = 2) buffer CulledCountBuffer
{
    uint CulledCount;
    uint CulledInstanceCount;
    uint CulledOverflow;
};
layout(std430, binding = 3) buffer OverflowFlagBuffer { uint CullingOverflowFlag; };
layout(std430, binding = 8) buffer StatsBuffer {
    uint StatsInputCount;
    uint StatsCulledCount;
    uint StatsDrawCount;
    uint StatsRejectedFrustum;
    uint StatsRejectedDistance;
    uint StatsBvhBuildCount;
    uint StatsBvhRefitCount;
    uint StatsBvhCullCount;
    uint StatsBvhRayCount;
    uint StatsBvhBuildTimeLo;
    uint StatsBvhBuildTimeHi;
    uint StatsBvhRefitTimeLo;
    uint StatsBvhRefitTimeHi;
    uint StatsBvhCullTimeLo;
    uint StatsBvhCullTimeHi;
    uint StatsBvhRayTimeLo;
    uint StatsBvhRayTimeHi;
};

struct GPUViewDescriptor
{
    uint ViewId;
    uint ParentViewId;
    uint Flags;
    uint RenderPassMaskLo;
    uint RenderPassMaskHi;
    uint OutputLayer;
    uint ViewRectX;
    uint ViewRectY;
    uint ViewRectW;
    uint ViewRectH;
    uint VisibleOffset;
    uint VisibleCapacity;
    vec4 FoveationA;
    vec4 FoveationB;
};

struct GPUViewConstants
{
    mat4 View;
    mat4 Projection;
    mat4 ViewProjection;
    mat4 PrevViewProjection;
    vec4 CameraPositionAndNear;
    vec4 CameraForwardAndFar;
};

layout(std430, binding = 11) readonly buffer ViewDescriptorBuffer { GPUViewDescriptor ViewDescriptors[]; };
layout(std430, binding = 12) readonly buffer ViewConstantsBuffer { GPUViewConstants ViewConstants[]; };
layout(std430, binding = 13) readonly buffer CommandViewMaskBuffer { uvec2 CommandViewMasks[]; };
layout(std430, binding = 14) buffer PerViewVisibleIndicesBuffer { uint PerViewVisibleIndices[]; };
layout(std430, binding = 15) buffer PerViewDrawCountBuffer { uint PerViewDrawCounts[]; };

// === Uniforms ===
uniform vec4 FrustumPlanes[6];
uniform float MaxRenderDistance;
uniform uint CameraLayerMask;
uniform int  CurrentRenderPass;
uniform int  InputCommandCount;
uniform int  MaxCulledCommands;
uniform uint DisabledFlagsMask;
uniform vec3 CameraPosition;
uniform int ActiveViewCount;

#define FLAG_TRANSPARENT    (1u<<0)
#define FLAG_CAST_SHADOW    (1u<<1)
#define FLAG_SKINNED        (1u<<2)
#define FLAG_DYNAMIC        (1u<<3)
#define FLAG_DOUBLE_SIDED   (1u<<4)

const int COMMAND_FLOATS = 48;

bool FrustumSphereVisible(vec3 center, float radius)
{
    for (int i = 0; i < 6; ++i)
    {
        vec4 p = FrustumPlanes[i];
        float dist = dot(p.xyz, center) + p.w;
        if (dist < -radius)
            return false;
    }
    return true;
}

bool ViewMaskContains(uvec2 mask, uint viewId)
{
    if (viewId < 32u)
        return (mask.x & (1u << viewId)) != 0u;

    uint hi = viewId - 32u;
    if (hi >= 32u)
        return false;

    return (mask.y & (1u << hi)) != 0u;
}

bool ViewPassMatches(uint viewId)
{
    if (viewId >= uint(ActiveViewCount) || viewId >= ViewDescriptors.length())
        return false;

    GPUViewDescriptor vd = ViewDescriptors[viewId];
    if (CurrentRenderPass < 0)
        return true;

    if (CurrentRenderPass < 32)
        return (vd.RenderPassMaskLo & (1u << uint(CurrentRenderPass))) != 0u;

    uint hi = uint(CurrentRenderPass - 32);
    if (hi >= 32u)
        return true;

    return (vd.RenderPassMaskHi & (1u << hi)) != 0u;
}

void AppendPerView(uint sourceCommandIndex, uint culledCommandIndex, vec3 commandCenter, uint commandFlags)
{
    if (ActiveViewCount <= 0)
        return;

    if (sourceCommandIndex >= CommandViewMasks.length())
        return;

    uvec2 mask = CommandViewMasks[sourceCommandIndex];
    uint maxViews = min(uint(ActiveViewCount), min(uint(64), uint(PerViewDrawCounts.length())));
    for (uint viewId = 0u; viewId < maxViews; ++viewId)
    {
        if (!ViewMaskContains(mask, viewId))
            continue;
        if (!ViewPassMatches(viewId))
            continue;

        GPUViewDescriptor vd = ViewDescriptors[viewId];
        bool foveated = (vd.Flags & (1u << 3u)) != 0u;
        if (foveated)
        {
            vec3 cameraPosition = ViewConstants[viewId].CameraPositionAndNear.xyz;
            vec3 toCenter = commandCenter - cameraPosition;
            float perViewDistanceSq = dot(toCenter, toCenter);
            float fullResNearDistance = vd.FoveationB.w;
            if (fullResNearDistance > 0.0 && perViewDistanceSq <= (fullResNearDistance * fullResNearDistance))
                continue;

            if ((commandFlags & FLAG_TRANSPARENT) != 0u)
                continue;
        }

        uint local = atomicAdd(PerViewDrawCounts[viewId], 1u);
        if (local < vd.VisibleCapacity)
        {
            uint dst = vd.VisibleOffset + local;
            if (dst < PerViewVisibleIndices.length())
                PerViewVisibleIndices[dst] = culledCommandIndex;
        }
    }
}

void main()
{
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= uint(InputCommandCount))
        return;

    if (idx == 0u)
        StatsInputCount = uint(InputCommandCount);

    int base = int(idx) * COMMAND_FLOATS;
    if (base + COMMAND_FLOATS > inCommands.length())
        return;

    vec4 bs = vec4(inCommands[base+32], inCommands[base+33], inCommands[base+34], inCommands[base+35]);
    vec3 center = bs.xyz;
    float radius = bs.w;
    uint layerMask = floatBitsToUint(inCommands[base+43]);
    uint renderPass = floatBitsToUint(inCommands[base+40]);
    uint instanceCount = floatBitsToUint(inCommands[base+39]);
    vec3 toCenter = center - CameraPosition;
    float renderDistance = dot(toCenter, toCenter);
    uint flags = floatBitsToUint(inCommands[base+45]);

    if (instanceCount == 0u) return;
    if ((layerMask & CameraLayerMask) == 0u) return;
    if (DisabledFlagsMask != 0u && (flags & DisabledFlagsMask) != 0u) return;
    if (CurrentRenderPass >= 0 && renderPass != uint(CurrentRenderPass) && renderPass != 0xFFFFFFFFu) return;
    if (renderDistance > MaxRenderDistance) {
        atomicAdd(StatsRejectedDistance, 1u);
        return;
    }
    if (!FrustumSphereVisible(center, radius)) {
        atomicAdd(StatsRejectedFrustum, 1u);
        return;
    }

    uint outIndex = atomicAdd(CulledCount, 1u);
    if (outIndex >= uint(MaxCulledCommands))
    {
        atomicAdd(CullingOverflowFlag, 1u);
        if (MaxCulledCommands > 0)
        {
            uint sentinelIndex = uint(MaxCulledCommands - 1);
            int sentinelBase = int(sentinelIndex) * COMMAND_FLOATS;
            outCommands[sentinelBase + 36] = uintBitsToFloat(0xFFFFFFFFu);
            outCommands[sentinelBase + 38] = uintBitsToFloat(0xFFFFFFFFu);
            outCommands[sentinelBase + 39] = uintBitsToFloat(0u);
        }
        return;
    }

    int outBase = int(outIndex) * COMMAND_FLOATS;
    for (int i = 0; i < COMMAND_FLOATS; ++i)
        outCommands[outBase + i] = inCommands[base + i];
    outCommands[outBase + 42] = renderDistance;

    AppendPerView(idx, outIndex, center, flags);

    atomicAdd(CulledInstanceCount, instanceCount);
    atomicAdd(StatsCulledCount, 1u);
}
