// Minimum working-set indirect draw build shader for 48-float command struct
#version 460 core

layout(local_size_x = 256) in;

// Constants
const int COMMAND_FLOATS = 48;      // 192 bytes per command
const int DRAW_COMMAND_UINTS = 5;   // count, instanceCount, firstIndex, baseVertex, baseInstance

/* Command layout (float[48]):
 00-15 WorldMatrix, 16-31 PrevWorldMatrix, 32-35 BoundingSphere, 36 MeshID, 37 SubmeshID, 38 MaterialID,
 39 InstanceCount, 40 RenderPass, 41 ShaderProgramID, 42 RenderDistance,
 43 LayerMask, 44 LODLevel, 45 Flags, 46 Reserved0, 47 Reserved1 */

// === Buffers ===
layout(std430, binding = 0) buffer CulledCommandsBuffer { float culled[]; };
layout(std430, binding = 1) buffer IndirectDrawBuffer { uint indirectDraws[]; };
layout(std430, binding = 2) buffer SubmeshDataBuffer { uint submeshData[]; }; // uint4 per submesh: indexCount, firstIndex, baseVertex, baseInstance
layout(std430, binding = 3) buffer CulledCountBuffer
{
    uint CulledCount;
    uint CulledInstanceCount;
    uint CulledOverflow;
};
layout(std430, binding = 4) buffer DrawCountBuffer { uint DrawCount; };

// Overflow flag specific to indirect build (distinct from culling overflow)
layout(std430, binding = 5) buffer IndirectOverflowFlagBuffer { uint IndirectOverflowFlag; };

// Optional sorted key-index list: pairs [key, originalIndex]
//layout(std430, binding = 6) buffer KeyIndexBuffer { uint keyIndexPairs[]; };

// Truncation flag (optional) set if draw list exceeds capacity
layout(std430, binding = 7) buffer TruncationFlagBuffer { uint TruncationFlag; };

// Optional shared stats buffer (must match culling shader binding if used)
layout(std430, binding = 8) buffer StatsBuffer
{
    uint StatsInputCount;
    uint StatsCulledCount;
    uint StatsDrawCount;
    uint StatsRejectedFrustum;
    uint StatsRejectedDistance;
};

// === Uniforms ===
uniform int CurrentRenderPass;     // -1 accepts all
uniform int MaxIndirectDraws;      // capacity in draws
uniform uint StatsEnabled;         // 0 when stats buffer is unbound
//uniform int UseSorted;             // 1 = use keyIndexPairs for ordering

void main()
{
    uint logicalIdx = gl_GlobalInvocationID.x;
    uint total = CulledCount; // snapshot

    if (logicalIdx >= total)
        return;

    uint idx = logicalIdx;
    //if (UseSorted != 0)
    //{
    //    // keyIndexPairs stores [key, originalIndex] sequentially
    //    uint pairBase = logicalIdx * 2u;
    //    if (pairBase + 1u < keyIndexPairs.length())
    //        idx = keyIndexPairs[pairBase + 1u];
    //}

    int base = int(idx) * COMMAND_FLOATS;
    uint renderPass = floatBitsToUint(culled[base + 40]);
    uint instanceCount = floatBitsToUint(culled[base + 39]);

    // Defensive pass filter (culling shader should already filter by pass, but keep this to avoid
    // drawing mixed-pass command buffers if that assumption ever changes).
    if (CurrentRenderPass >= 0 && renderPass != uint(CurrentRenderPass))
        return;

    // Deterministic output layout: one indirect slot per visible command.
    // This keeps batching offsets consistent with the culled command buffer order.
    uint outIndex = logicalIdx;
    if (logicalIdx == 0u)
    {
        uint capped = min(total, uint(MaxIndirectDraws));
        DrawCount = capped;
        if (total > uint(MaxIndirectDraws))
        {
            atomicExchange(IndirectOverflowFlag, 1u);
            atomicExchange(TruncationFlag, 1u);
        }
    }

    if (outIndex >= uint(MaxIndirectDraws))
        return;

    uint drawBase = outIndex * DRAW_COMMAND_UINTS;

    // Default to a no-op draw to avoid consuming stale commands.
    indirectDraws[drawBase + 0u] = 0u;
    indirectDraws[drawBase + 1u] = 0u;
    indirectDraws[drawBase + 2u] = 0u;
    indirectDraws[drawBase + 3u] = 0u;
    indirectDraws[drawBase + 4u] = 0u;

    if (instanceCount == 0u)
        return;

    // MeshDataBuffer is indexed by MeshID (uint4 per mesh): [IndexCount, FirstIndex, BaseVertex, BaseInstance]
    uint meshID = floatBitsToUint(culled[base + 36]);
    uint submeshOffset = meshID * 4u;
    if (submeshOffset + 3u >= submeshData.length())
        return;

    uint indexCount = submeshData[submeshOffset + 0u];
    if (indexCount == 0u)
        return; // defensive skip
    
    uint firstIndex = submeshData[submeshOffset + 1u];
    uint baseVertex = submeshData[submeshOffset + 2u];
    // Encode the culled-command index into baseInstance so the graphics vertex shader can
    // fetch per-draw data (world matrix, etc.) via gl_BaseInstance.
    uint baseInstance = idx;

    indirectDraws[drawBase + 0u] = indexCount;
    indirectDraws[drawBase + 1u] = instanceCount;
    indirectDraws[drawBase + 2u] = firstIndex;
    indirectDraws[drawBase + 3u] = baseVertex;
    indirectDraws[drawBase + 4u] = baseInstance;
    if (StatsEnabled != 0u)
        atomicAdd(StatsDrawCount, 1u);
}
