#version 460

// Bottom-up BVH refit. Recomputes leaf bounds from updated primitive AABBs
// then propagates bounds to internal nodes.

layout (constant_id = 0) const uint MAX_LEAF_PRIMITIVES = 1u;
layout (constant_id = 1) const uint BVH_MODE = 0u;

#include "bvh_nodes.glslinc"

struct MortonObject
{
    uint mortonCode;
    uint objectId;
};

struct Aabb
{
    vec4 minBounds;
    vec4 maxBounds;
};

layout(std430, binding = 0) buffer AABBs
{
    Aabb aabbs[];
};

layout(std430, binding = 1) buffer MortonCodes
{
    MortonObject mortonObjects[];
};

layout(std430, binding = 2) buffer BvhNodes
{
    uint nodeCount;
    uint rootIndex;
    uint nodeStrideScalars;
    uint maxLeafPrimitives;
    BvhNode nodes[];
};

layout(std430, binding = 3) buffer PrimitiveRanges
{
    uvec2 ranges[];
};

uniform uint debugValidation;

vec3 combineMin(vec3 a, vec3 b) { return min(a, b); }
vec3 combineMax(vec3 a, vec3 b) { return max(a, b); }

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

void main()
{
    uint nodeIndex = gl_GlobalInvocationID.x;
    if (nodeIndex >= nodeCount)
        return;

    BvhNode node = nodes[nodeIndex];
    uvec2 range = ranges[nodeIndex];

    if (debugValidation != 0u)
    {
        if (range.x + range.y > mortonObjects.length())
            return;
        if ((node.flags & BVH_FLAG_LEAF) != 0u)
        {
            if (range.y == 0u)
                return;
        }
        else
        {
            if ((node.leftChild != uint(-1) && node.leftChild >= nodeCount) || (node.rightChild != uint(-1) && node.rightChild >= nodeCount))
                return;
        }
    }

    if ((node.flags & BVH_FLAG_LEAF) != 0u)
    {
        // Leaf: recompute bounds from primitives in the range.
        if (range.y == 0u)
            return;

        vec3 minB = vec3(1e30);
        vec3 maxB = vec3(-1e30);
        for (uint i = 0u; i < range.y; ++i)
        {
            uint primIndex = mortonObjects[range.x + i].objectId;
            minB = combineMin(minB, aabbs[primIndex].minBounds.xyz);
            maxB = combineMax(maxB, aabbs[primIndex].maxBounds.xyz);
        }
        nodes[nodeIndex].minBounds = minB;
        nodes[nodeIndex].maxBounds = maxB;
    }
    else
    {
        // Internal: merge children.
        uint left = node.leftChild;
        uint right = node.rightChild;

        vec3 minB = vec3(1e30);
        vec3 maxB = vec3(-1e30);

        if (left != uint(-1))
        {
            minB = combineMin(minB, nodes[left].minBounds);
            maxB = combineMax(maxB, nodes[left].maxBounds);
        }
        if (right != uint(-1))
        {
            minB = combineMin(minB, nodes[right].minBounds);
            maxB = combineMax(maxB, nodes[right].maxBounds);
        }

        nodes[nodeIndex].minBounds = minB;
        nodes[nodeIndex].maxBounds = maxB;
    }
}
