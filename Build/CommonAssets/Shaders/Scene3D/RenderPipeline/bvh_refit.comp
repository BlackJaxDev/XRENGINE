#version 460

// Bottom-up BVH refit. Recomputes leaf bounds from updated primitive AABBs
// then propagates bounds to internal nodes.

layout (constant_id = 0) const uint MAX_LEAF_PRIMITIVES = 1u;
layout (constant_id = 1) const uint BVH_MODE = 0u;

#include "bvh_nodes.glslinc"

struct MortonObject
{
    uint mortonCode;
    uint objectId;
};

struct Aabb
{
    vec4 minBounds;
    vec4 maxBounds;
};

layout(std430, binding = 0) buffer AABBs
{
    Aabb aabbs[];
};

layout(std430, binding = 1) buffer MortonCodes
{
    MortonObject mortonObjects[];
};

layout(std430, binding = 2) buffer BvhNodes
{
    uint nodeCount;
    uint rootIndex;
    uint nodeStrideScalars;
    uint maxLeafPrimitives;
    BvhNode nodes[];
};

layout(std430, binding = 3) buffer PrimitiveRanges
{
    uvec2 ranges[];
};

uniform uint debugValidation;
layout(std430, binding = 4) buffer Transforms
{
    mat4 transforms[];
};

uniform uint refitStage; // 0 = update leaves, 1 = propagate internal nodes

vec3 combineMin(vec3 a, vec3 b) { return min(a, b); }
vec3 combineMax(vec3 a, vec3 b) { return max(a, b); }

vec3 transformPoint(mat4 m, vec3 p)
{
    return (m * vec4(p, 1.0)).xyz;
}

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

void refitLeaf(uint nodeIndex)
{
    BvhNode node = nodes[nodeIndex];
    uvec2 range = ranges[nodeIndex];

    if (debugValidation != 0u)
    {
        if (range.x + range.y > mortonObjects.length())
            return;
        if ((node.flags & BVH_FLAG_LEAF) != 0u)
        {
            if (range.y == 0u)
                return;
        }
        else
        {
            if ((node.leftChild != uint(-1) && node.leftChild >= nodeCount) || (node.rightChild != uint(-1) && node.rightChild >= nodeCount))
                return;
        }
    }

    if ((node.flags & BVH_FLAG_LEAF) != 0u)
    {
        // Leaf: recompute bounds from primitives in the range.
        if (range.y == 0u)
            return;

        vec3 minB = vec3(1e30);
        vec3 maxB = vec3(-1e30);
        for (uint i = 0u; i < range.y; ++i)
        {
            uint primIndex = mortonObjects[range.x + i].objectId;
            vec3 localMin = aabbs[primIndex].minBounds.xyz;
            vec3 localMax = aabbs[primIndex].maxBounds.xyz;
            mat4 transform = transforms[primIndex];

            vec3 corners[8];
            corners[0] = vec3(localMin.x, localMin.y, localMin.z);
            corners[1] = vec3(localMax.x, localMin.y, localMin.z);
            corners[2] = vec3(localMin.x, localMax.y, localMin.z);
            corners[3] = vec3(localMax.x, localMax.y, localMin.z);
            corners[4] = vec3(localMin.x, localMin.y, localMax.z);
            corners[5] = vec3(localMax.x, localMin.y, localMax.z);
            corners[6] = vec3(localMin.x, localMax.y, localMax.z);
            corners[7] = vec3(localMax.x, localMax.y, localMax.z);

            for (int c = 0; c < 8; ++c)
            {
                vec3 transformed = transformPoint(transform, corners[c]);
                minB = combineMin(minB, transformed);
                maxB = combineMax(maxB, transformed);
            }
        }
        nodes[nodeIndex].minBounds = minB;
        nodes[nodeIndex].maxBounds = maxB;
    }
}

void propagateInternal()
{
    if (nodeCount == 0u)
        return;

    uint leafCount = (nodeCount + 1u) >> 1u;
    for (uint nodeIndex = leafCount; nodeIndex < nodeCount; ++nodeIndex)
    {
        BvhNode node = nodes[nodeIndex];
        vec3 minB = vec3(1e30);
        vec3 maxB = vec3(-1e30);

        uint left = node.leftChild;
        uint right = node.rightChild;

        if (left != uint(-1))
        {
            minB = combineMin(minB, nodes[left].minBounds);
            maxB = combineMax(maxB, nodes[left].maxBounds);
        }
        if (right != uint(-1))
        {
            minB = combineMin(minB, nodes[right].minBounds);
            maxB = combineMax(maxB, nodes[right].maxBounds);
        }

        nodes[nodeIndex].minBounds = minB;
        nodes[nodeIndex].maxBounds = maxB;
    }
}

void main()
{
    if (refitStage == 0u)
    {
        uint nodeIndex = gl_GlobalInvocationID.x;
        if (nodeIndex < nodeCount)
            refitLeaf(nodeIndex);
        return;
    }

    if (gl_GlobalInvocationID.x == 0u)
        propagateInternal();
}
