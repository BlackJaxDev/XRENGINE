#version 460

// Bottom-up BVH refit. Recomputes leaf bounds from updated primitive AABBs
// then propagates bounds to internal nodes.

layout (constant_id = 0) const uint MAX_LEAF_PRIMITIVES = 1u;
layout (constant_id = 1) const uint BVH_MODE = 0u;

#include "bvh_nodes.glslinc"

struct MortonObject
{
    uint mortonCode;
    uint objectId;
};

struct Aabb
{
    vec4 minBounds;
    vec4 maxBounds;
};

layout(std430, binding = 0) buffer AABBs
{
    Aabb aabbs[];
};

layout(std430, binding = 1) buffer MortonCodes
{
    MortonObject mortonObjects[];
};

layout(std430, binding = 2) buffer BvhNodes
{
    uint nodeCount;
    uint rootIndex;
    uint nodeStrideScalars;
    uint maxLeafPrimitives;
    BvhNode nodes[];
};

layout(std430, binding = 3) buffer PrimitiveRanges
{
    uvec2 ranges[];
};

uniform uint debugValidation;
layout(std430, binding = 4) buffer Transforms
{
    mat4 transforms[];
};

uniform uint refitStage; // 0 = update leaves, 1 = propagate internal nodes

vec3 combineMin(vec3 a, vec3 b) { return min(a, b); }
vec3 combineMax(vec3 a, vec3 b) { return max(a, b); }

vec3 transformPoint(mat4 m, vec3 p)
{
    return (m * vec4(p, 1.0)).xyz;
}

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

void refitLeaf(uint nodeIndex)
{
    BvhNode node = nodes[nodeIndex];
    uvec2 range = ranges[nodeIndex];

    if (debugValidation != 0u)
    {
        if (range.x + range.y > mortonObjects.length())
            return;
        if ((node.flags & BVH_FLAG_LEAF) != 0u)
        {
            if (range.y == 0u)
                return;
        }
        else
        {
            if ((node.leftChild != uint(-1) && node.leftChild >= nodeCount) || (node.rightChild != uint(-1) && node.rightChild >= nodeCount))
                return;
        }
    }

    if ((node.flags & BVH_FLAG_LEAF) != 0u)
    {
        // Leaf: recompute bounds from primitives in the range.
        if (range.y == 0u)
            return;

        vec3 minB = vec3(1e30);
        vec3 maxB = vec3(-1e30);
        for (uint i = 0u; i < range.y; ++i)
        {
            uint primIndex = mortonObjects[range.x + i].objectId;
            vec3 localMin = aabbs[primIndex].minBounds.xyz;
            vec3 localMax = aabbs[primIndex].maxBounds.xyz;
            mat4 transform = transforms[primIndex];

            vec3 corners[8];
            corners[0] = vec3(localMin.x, localMin.y, localMin.z);
            corners[1] = vec3(localMax.x, localMin.y, localMin.z);
            corners[2] = vec3(localMin.x, localMax.y, localMin.z);
            corners[3] = vec3(localMax.x, localMax.y, localMin.z);
            corners[4] = vec3(localMin.x, localMin.y, localMax.z);
            corners[5] = vec3(localMax.x, localMin.y, localMax.z);
            corners[6] = vec3(localMin.x, localMax.y, localMax.z);
            corners[7] = vec3(localMax.x, localMax.y, localMax.z);

            for (int c = 0; c < 8; ++c)
            {
                vec3 transformed = transformPoint(transform, corners[c]);
                minB = combineMin(minB, transformed);
                maxB = combineMax(maxB, transformed);
            }
        }
        nodes[nodeIndex].minBounds = minB;
        nodes[nodeIndex].maxBounds = maxB;
    }
}

// Parallel bottom-up propagation using atomic counters
// Each internal node waits for both children to be processed before updating
shared uint processedCount[256];

void propagateInternalParallel(uint nodeIndex)
{
    if (nodeIndex >= nodeCount)
        return;

    BvhNode node = nodes[nodeIndex];
    
    // Skip leaf nodes - they were already processed in refitLeaf
    if ((node.flags & BVH_FLAG_LEAF) != 0u)
        return;

    vec3 minB = vec3(1e30);
    vec3 maxB = vec3(-1e30);

    uint left = node.leftChild;
    uint right = node.rightChild;

    if (left != uint(-1) && left < nodeCount)
    {
        minB = combineMin(minB, nodes[left].minBounds);
        maxB = combineMax(maxB, nodes[left].maxBounds);
    }
    if (right != uint(-1) && right < nodeCount)
    {
        minB = combineMin(minB, nodes[right].minBounds);
        maxB = combineMax(maxB, nodes[right].maxBounds);
    }

    nodes[nodeIndex].minBounds = minB;
    nodes[nodeIndex].maxBounds = maxB;
}

void main()
{
    if (refitStage == 0u)
    {
        uint nodeIndex = gl_GlobalInvocationID.x;
        if (nodeIndex < nodeCount)
            refitLeaf(nodeIndex);
        return;
    }

    // Stage 1: Propagate internal nodes in parallel
    // Process from leaves toward root - internal nodes are stored after leaves
    // Each thread processes one internal node
    uint leafCount = (nodeCount + 1u) >> 1u;
    uint internalCount = nodeCount > 0u ? nodeCount - leafCount : 0u;
    uint gid = gl_GlobalInvocationID.x;
    
    if (gid < internalCount)
    {
        // Internal nodes are at indices [leafCount, nodeCount)
        // Process in reverse order (bottom-up) to ensure children are processed first
        // This works because the BVH is built with parents having higher indices than children
        uint nodeIndex = leafCount + gid;
        propagateInternalParallel(nodeIndex);
    }
}
