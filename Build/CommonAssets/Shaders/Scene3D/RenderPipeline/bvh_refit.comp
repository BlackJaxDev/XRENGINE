#version 460

// Bottom-up BVH refit. Recomputes leaf bounds from updated primitive AABBs
// then propagates bounds to internal nodes.

layout (constant_id = 0) const uint MAX_LEAF_PRIMITIVES = 1u;
layout (constant_id = 1) const uint BVH_MODE = 0u;

#include "bvh_nodes.glslinc"

struct MortonObject
{
    uint mortonCode;
    uint objectId;
};

struct Aabb
{
    vec4 minBounds;
    vec4 maxBounds;
};

layout(std430, binding = 0) buffer AABBs
{
    Aabb aabbs[];
};

layout(std430, binding = 1) buffer MortonCodes
{
    MortonObject mortonObjects[];
};

layout(std430, binding = 2) buffer BvhNodes
{
    uint nodeCount;
    uint rootIndex;
    uint nodeStrideScalars;
    uint maxLeafPrimitives;
    BvhNode nodes[];
};

layout(std430, binding = 3) buffer PrimitiveRanges
{
    uvec2 ranges[];
};

// Scratch counters for bottom-up propagation. Must be zeroed before refit.
layout(std430, binding = 11) buffer RefitCounters
{
    uint counters[];
};

uniform uint debugValidation;
layout(std430, binding = 4) buffer Transforms
{
    mat4 transforms[];
};

uniform uint refitStage; // 0 = clear counters, 1 = update leaves + propagate to root

vec3 combineMin(vec3 a, vec3 b) { return min(a, b); }
vec3 combineMax(vec3 a, vec3 b) { return max(a, b); }

vec3 transformPoint(mat4 m, vec3 p)
{
    return (m * vec4(p, 1.0)).xyz;
}

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

void refitLeaf(uint nodeIndex)
{
    BvhNode node = nodes[nodeIndex];
    uvec2 range = ranges[nodeIndex];

    if (debugValidation != 0u)
    {
        if (range.x + range.y > mortonObjects.length())
            return;
        if ((node.flags & BVH_FLAG_LEAF) != 0u)
        {
            if (range.y == 0u)
                return;
        }
        else
        {
            if ((node.leftChild != uint(-1) && node.leftChild >= nodeCount) || (node.rightChild != uint(-1) && node.rightChild >= nodeCount))
                return;
        }
    }

    if ((node.flags & BVH_FLAG_LEAF) != 0u)
    {
        // Leaf: recompute bounds from primitives in the range.
        if (range.y == 0u)
            return;

        vec3 minB = vec3(1e30);
        vec3 maxB = vec3(-1e30);
        for (uint i = 0u; i < range.y; ++i)
        {
            uint primIndex = mortonObjects[range.x + i].objectId;
            vec3 localMin = aabbs[primIndex].minBounds.xyz;
            vec3 localMax = aabbs[primIndex].maxBounds.xyz;
            mat4 transform = transforms[primIndex];

            vec3 corners[8];
            corners[0] = vec3(localMin.x, localMin.y, localMin.z);
            corners[1] = vec3(localMax.x, localMin.y, localMin.z);
            corners[2] = vec3(localMin.x, localMax.y, localMin.z);
            corners[3] = vec3(localMax.x, localMax.y, localMin.z);
            corners[4] = vec3(localMin.x, localMin.y, localMax.z);
            corners[5] = vec3(localMax.x, localMin.y, localMax.z);
            corners[6] = vec3(localMin.x, localMax.y, localMax.z);
            corners[7] = vec3(localMax.x, localMax.y, localMax.z);

            for (int c = 0; c < 8; ++c)
            {
                vec3 transformed = transformPoint(transform, corners[c]);
                minB = combineMin(minB, transformed);
                maxB = combineMax(maxB, transformed);
            }
        }
        nodes[nodeIndex].minBounds = minB;
        nodes[nodeIndex].maxBounds = maxB;

        // Ensure leaf bounds are visible before propagating.
        memoryBarrierBuffer();

        // Bottom-up propagation using per-node counters.
        // Each internal node is processed exactly once, by the second child that arrives.
        uint parent = node.parentIndex;
        while (parent != uint(-1))
        {
            uint prior = atomicAdd(counters[parent], 1u);
            if (prior == 1u)
            {
                // Ensure we see the other child's bounds writes.
                memoryBarrierBuffer();

                uint left = nodes[parent].leftChild;
                uint right = nodes[parent].rightChild;

                // Defensive bounds checks when validation is enabled.
                if (debugValidation != 0u)
                {
                    if ((left != uint(-1) && left >= nodeCount) || (right != uint(-1) && right >= nodeCount))
                        return;
                }

                vec3 minP = vec3(1e30);
                vec3 maxP = vec3(-1e30);
                if (left != uint(-1))
                {
                    minP = combineMin(minP, nodes[left].minBounds);
                    maxP = combineMax(maxP, nodes[left].maxBounds);
                }
                if (right != uint(-1))
                {
                    minP = combineMin(minP, nodes[right].minBounds);
                    maxP = combineMax(maxP, nodes[right].maxBounds);
                }

                nodes[parent].minBounds = minP;
                nodes[parent].maxBounds = maxP;
                memoryBarrierBuffer();

                parent = nodes[parent].parentIndex;
                continue;
            }

            // First child to arrive stops here.
            break;
        }
    }
}

void main()
{
    if (refitStage == 0u)
    {
        uint gid = gl_GlobalInvocationID.x;
        if (gid < nodeCount)
            counters[gid] = 0u;
        return;
    }

    // Stage 1: Refit leaves and propagate to root.
    uint nodeIndex = gl_GlobalInvocationID.x;
    if (nodeIndex < nodeCount)
        refitLeaf(nodeIndex);
}
