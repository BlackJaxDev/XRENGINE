#version 460

// LBVH build from pre-sorted Morton keys.
// Emits leaves (up to MAX_LEAF_PRIMITIVES each), generates internal connectivity,
// and writes primitive ranges for downstream refinement/refit passes.
#define MAX_OBJECTS 1024u
#define OVERFLOW_MORTON 1u
#define OVERFLOW_NODE 2u
#define OVERFLOW_QUEUE 4u
#define OVERFLOW_BVH 8u

// Note: Using uniforms instead of Vulkan-specific specialization constants for OpenGL compatibility.
uniform uint MAX_LEAF_PRIMITIVES; // number of primitives per leaf (default 1)
uniform uint BVH_MODE;            // 0 = Morton-only, 1 = Morton + SAH refinement

#include "bvh_nodes.glslinc"

struct MortonObject
{
    uint mortonCode;
    uint objectId;
};

struct Aabb
{
    vec4 minBounds;
    vec4 maxBounds;
};

layout(std430, binding = 0) buffer AABBs
{
    Aabb aabbs[];
};

layout(std430, binding = 1) buffer MortonCodes
{
    MortonObject mortonObjects[];
};

layout(std430, binding = 2) buffer BvhNodes
{
    uint nodeCount;
    uint rootIndex;
    uint nodeStrideScalars; // for host alignment
    uint maxLeafPrimitives; // echoed constant for the host
    BvhNode nodes[];
};

layout(std430, binding = 3) buffer PrimitiveRanges
{
    uvec2 ranges[];
};

layout(std430, binding = 8) buffer OverflowFlags
{
    uint overflowFlags;
};

uniform uint numPrimitives;
uniform uint buildStage; // 0 = emit leaves + header, 1 = generate internal nodes, 2 = assign parent indices, 3 = compute root index
uniform uint nodeScalarCapacity;
uniform uint rangeScalarCapacity;
uniform uint mortonCapacity;

// --- Morton helpers over leaf blocks ---
uint leafFirstPrimitive(uint leafIndex)
{
    return min(numPrimitives - 1u, leafIndex * MAX_LEAF_PRIMITIVES);
}

uint mortonForLeaf(uint leafIndex)
{
    return mortonObjects[leafFirstPrimitive(leafIndex)].mortonCode;
}

int clz(uint x)
{
    if (x == 0u)
        return 32;

    int n = 0;
    if (x <= 0x0000FFFFu) { n += 16; x <<= 16; }
    if (x <= 0x00FFFFFFu) { n += 8;  x <<= 8;  }
    if (x <= 0x0FFFFFFFu) { n += 4;  x <<= 4;  }
    if (x <= 0x3FFFFFFFu) { n += 2;  x <<= 2;  }
    if (x <= 0x7FFFFFFFu) { n += 1; }
    return n;
}

int lcp_leaf(int i, int j, uint leafCount)
{
    if (j < 0 || j >= int(leafCount))
        return -1;
    uint a = mortonForLeaf(uint(i));
    uint b = mortonForLeaf(uint(j));
    if (a == b)
        return 32 + int(clz(uint(i) ^ uint(j)));
    return int(clz(a ^ b));
}

ivec2 determineRange(int i, uint leafCount)
{
    int lcpL = lcp_leaf(i, i - 1, leafCount);
    int lcpR = lcp_leaf(i, i + 1, leafCount);
    int d = ((lcpR - lcpL) >= 0) ? 1 : -1;

    // Baseline must be the LCP in the opposite direction (Karras LBVH).
    // Using lcp(i, i+d) here breaks endpoint ranges and can leave components disconnected.
    int deltaMin = lcp_leaf(i, i - d, leafCount);

    int lMax = 2;
    while (lcp_leaf(i, i + lMax * d, leafCount) > deltaMin)
        lMax *= 2;

    int l = 0;
    for (int t = lMax / 2; t >= 1; t /= 2)
    {
        if (lcp_leaf(i, i + (l + t) * d, leafCount) > deltaMin)
            l += t;
    }

    int j = i + l * d;
    return ivec2(min(i, j), max(i, j));
}

int findSplit(int first, int last, uint leafCount)
{
    int commonPrefix = lcp_leaf(first, last, leafCount);
    int split = first;
    int step = last - first;
    do
    {
        step = (step + 1) >> 1;
        int newSplit = split + step;
        if (newSplit < last)
        {
            int prefix = lcp_leaf(first, newSplit, leafCount);
            if (prefix > commonPrefix)
                split = newSplit;
        }
    } while (step > 1);
    return split;
}

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

void main()
{
    uint gid = gl_GlobalInvocationID.x;

    uint leafCount = (numPrimitives + MAX_LEAF_PRIMITIVES - 1u) / MAX_LEAF_PRIMITIVES;
    uint internalCount = (leafCount > 0u) ? (leafCount - 1u) : 0u;
    uint totalNodes = leafCount + internalCount;
    uint mortonCap = (mortonCapacity == 0u) ? MAX_OBJECTS : mortonCapacity;
    uint maxNodesByBuffer = (nodeScalarCapacity > BVH_NODE_STRIDE_SCALARS)
        ? (nodeScalarCapacity - 4u) / BVH_NODE_STRIDE_SCALARS
        : 0u;
    uint maxRangesByBuffer = (rangeScalarCapacity > 0u)
        ? (rangeScalarCapacity / BVH_RANGE_STRIDE_SCALARS)
        : 0u;

    if (gid == 0u && (numPrimitives > mortonCap || numPrimitives > MAX_OBJECTS || totalNodes > maxNodesByBuffer || totalNodes > maxRangesByBuffer))
        atomicOr(overflowFlags, OVERFLOW_BVH);

    if (numPrimitives > mortonCap || numPrimitives > MAX_OBJECTS || totalNodes > maxNodesByBuffer || totalNodes > maxRangesByBuffer)
        return;

    if (buildStage == 0u && gid == 0u)
    {
        nodeCount = totalNodes;
        // Root is computed after parent assignment (stage 3).
        rootIndex = (totalNodes > 0u) ? 0u : uint(-1);
        nodeStrideScalars = BVH_NODE_STRIDE_SCALARS;
        maxLeafPrimitives = MAX_LEAF_PRIMITIVES;
    }

    // Emit leaves with contiguous primitive ranges.
    if (buildStage == 0u && gid < leafCount)
    {
        uint start = gid * MAX_LEAF_PRIMITIVES;
        uint count = min(MAX_LEAF_PRIMITIVES, numPrimitives - start);

        vec3 minB = vec3(1e30);
        vec3 maxB = vec3(-1e30);
        for (uint i = 0u; i < count; ++i)
        {
            uint primIndex = mortonObjects[start + i].objectId;
            minB = min(minB, aabbs[primIndex].minBounds.xyz);
            maxB = max(maxB, aabbs[primIndex].maxBounds.xyz);
        }

        BvhNode leaf;
        leaf.minBounds = minB;
        leaf.maxBounds = maxB;
        leaf.leftChild = uint(-1);
        leaf.rightChild = uint(-1);
        leaf.primitiveRange = uvec2(start, count);
        leaf.parentIndex = uint(-1);
        leaf.flags = BVH_FLAG_LEAF;
        nodes[gid] = leaf;
        ranges[gid] = uvec2(start, count);
    }

    // Build internal connectivity (LBVH).
    // Note: parent indices are assigned in a separate stage to avoid data races
    // where an internal node write would overwrite a parentIndex written by another thread.
    if (buildStage == 1u && gid < internalCount)
    {
        int i = int(gid);
        ivec2 range = determineRange(i, leafCount);
        int first = range.x;
        int last  = range.y;
        int split = findSplit(first, last, leafCount);

        uint leftIndex  = (split == first)     ? uint(split)      : (leafCount + uint(split));
        uint rightIndex = (split + 1 == last)  ? uint(split + 1)  : (leafCount + uint(split + 1));
        uint nodeIndex = leafCount + gid;

        BvhNode n;
        n.minBounds = vec3(1e30);
        n.maxBounds = vec3(-1e30);
        n.leftChild = leftIndex;
        n.rightChild = rightIndex;

        uint startPrim = uint(first) * MAX_LEAF_PRIMITIVES;
        uint endPrim = min(numPrimitives, (uint(last) * MAX_LEAF_PRIMITIVES) + MAX_LEAF_PRIMITIVES);
        uvec2 combined = uvec2(startPrim, endPrim - startPrim);

        n.primitiveRange = combined;
        n.parentIndex = uint(-1);
        n.flags = 0u; // internal

        nodes[nodeIndex] = n;
        ranges[nodeIndex] = combined;
    }

    // Stage 2: assign parent indices (run after stage 1 has finished).
    if (buildStage == 2u && gid < internalCount)
    {
        uint nodeIndex = leafCount + gid;
        uint leftIndex = nodes[nodeIndex].leftChild;
        uint rightIndex = nodes[nodeIndex].rightChild;
        if (leftIndex != uint(-1))
            nodes[leftIndex].parentIndex = nodeIndex;
        if (rightIndex != uint(-1))
            nodes[rightIndex].parentIndex = nodeIndex;
    }

    // Stage 3: compute root index by following parent pointers from leaf 0.
    // This avoids relying on internal-node index ordering.
    if (buildStage == 3u && gid == 0u)
    {
        if (totalNodes == 0u)
        {
            rootIndex = uint(-1);
            return;
        }

        uint current = 0u;
        uint parent = nodes[current].parentIndex;
        while (parent != uint(-1))
        {
            current = parent;
            parent = nodes[current].parentIndex;
        }
        rootIndex = current;
    }
}
