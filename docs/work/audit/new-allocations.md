# C# `new` allocations report

Generated: 2026-02-26 12:19:56

Scan roots:
- XRENGINE
- XREngine.Animation
- XREngine.Audio
- XREngine.Data
- XREngine.Editor
- XREngine.Extensions
- XREngine.Input
- XREngine.Modeling
- XREngine.Profiler
- XREngine.Profiler.UI
- XREngine.Server
- XREngine.UnitTests
- XREngine.VRClient

Search patterns:
- \bnew\s+[A-Za-z_@][\w\.@]*
- \bnew\s*\(\)
- \bnew\s*\[\]

Excluded paths (regex):
- \\Submodules\\|\\Build\\Submodules\\|\\bin\\|\\obj\\

Notes:
- Comment-only lines (//, ///, /*, *, */) are skipped to reduce false positives.
- Matches inside string literals are skipped to reduce false positives (e.g., "Default ... new ...").


## XREngine.Animation/AnimationCurve.cs
- L17 C22: new() :: Linear = new();
- L18 C22: new() :: Smooth = new();
- L19 C20: new() :: Step = new();
- L20 C23: new() :: EaseOut = new();
- L21 C22: new() :: EaseIn = new();
- L24 C17: new FloatKeyframe :: new FloatKeyframe(0.0f, 0.0f, 0.0f, EVectorInterpType.Linear),
- L25 C17: new FloatKeyframe :: new FloatKeyframe(1.0f, 1.0f, 0.0f, EVectorInterpType.Linear));
- L27 C17: new FloatKeyframe :: new FloatKeyframe(0.0f, 0.0f, 0.0f, EVectorInterpType.Smooth),
- L28 C17: new FloatKeyframe :: new FloatKeyframe(1.0f, 1.0f, 0.0f, EVectorInterpType.Smooth));
- L30 C17: new FloatKeyframe :: new FloatKeyframe(0.0f, 0.0f, 0.0f, EVectorInterpType.Step),
- L31 C17: new FloatKeyframe :: new FloatKeyframe(1.0f, 1.0f, 0.0f, EVectorInterpType.Step));
- L33 C17: new FloatKeyframe :: new FloatKeyframe(0.0f, 0.0f, 0.0f, EVectorInterpType.Smooth),
- L34 C17: new FloatKeyframe :: new FloatKeyframe(1.0f, 1.0f, 0.0f, EVectorInterpType.Smooth));
- L36 C17: new FloatKeyframe :: new FloatKeyframe(0.0f, 0.0f, 0.0f, EVectorInterpType.Smooth),
- L37 C17: new FloatKeyframe :: new FloatKeyframe(1.0f, 1.0f, 0.0f, EVectorInterpType.Smooth));


## XREngine.Animation/Importers/UnityAnimImporter.cs
- L68 C32: new StreamReader :: using var reader = new StreamReader(filePath);
- L69 C24: new YamlStream :: var yaml = new YamlStream();
- L82 C26: new List :: var curves = new List<ScalarCurve>();
- L83 C29: new List :: var vecCurves = new List<VectorCurve>();
- L102 C24: new AnimationClip :: var clip = new AnimationClip
- L107 C30: new AnimationMember :: RootMember = new AnimationMember("Root", EAnimationMemberType.Group),
- L112 C27: new AnimMemberBuilder :: var builder = new AnimMemberBuilder(clip.RootMember);
- L115 C34: new Dictionary :: var scalarByTarget = new Dictionary<(string nodePath, string attribute), ScalarCurve>();
- L123 C35: new Dictionary :: var transformGroups = new Dictionary<(string nodePath, string kind), TransformCurveGroup>();
- L134 C29: new TransformCurveGroup :: group = new TransformCurveGroup(kind);
- L158 C35: new PropAnimVector3 :: var vecAnim = new PropAnimVector3
- L167 C33: new Vector3 :: var v = new Vector3(xAnim.GetValue(t), yAnim.GetValue(t), zAnim.GetValue(t));
- L168 C47: new Vector3Keyframe :: vecAnim.Keyframes.Add(new Vector3Keyframe(t, v, Vector3.Zero, EVectorInterpType.Smooth));
- L187 C36: new PropAnimQuaternion :: var quatAnim = new PropAnimQuaternion
- L196 C33: new Quaternion :: var q = new Quaternion(xAnim.GetValue(t), yAnim.GetValue(t), zAnim.GetValue(t), wAnim.GetValue(t));
- L202 C48: new QuaternionKeyframe :: quatAnim.Keyframes.Add(new QuaternionKeyframe(t, q, Quaternion.Identity, Quaternion.Identity, ERadialInterpType.Linear));
- L262 C52: new ScalarCurve :: var xAnim = BuildFloatAnim(new ScalarCurve(vc.Path, vc.Attribute + ".x", vc.ClassId, xKeys), length, looped, sampleRate, 1.0f);
- L263 C52: new ScalarCurve :: var yAnim = BuildFloatAnim(new ScalarCurve(vc.Path, vc.Attribute + ".y", vc.ClassId, yKeys), length, looped, sampleRate, 1.0f);
- L264 C52: new ScalarCurve :: var zAnim = BuildFloatAnim(new ScalarCurve(vc.Path, vc.Attribute + ".z", vc.ClassId, zKeys), length, looped, sampleRate, 1.0f);
- L266 C39: new PropAnimVector3 :: var vecAnim = new PropAnimVector3
- L274 C37: new Vector3 :: var v = new Vector3(xAnim.GetValue(t), yAnim.GetValue(t), zAnim.GetValue(t));
- L275 C51: new Vector3Keyframe :: vecAnim.Keyframes.Add(new Vector3Keyframe(t, v, Vector3.Zero, EVectorInterpType.Smooth));
- L288 C52: new ScalarCurve :: var xAnim = BuildFloatAnim(new ScalarCurve(vc.Path, vc.Attribute + ".x", vc.ClassId, xKeys), length, looped, sampleRate, 1.0f);
- L289 C52: new ScalarCurve :: var yAnim = BuildFloatAnim(new ScalarCurve(vc.Path, vc.Attribute + ".y", vc.ClassId, yKeys), length, looped, sampleRate, 1.0f);
- L290 C52: new ScalarCurve :: var zAnim = BuildFloatAnim(new ScalarCurve(vc.Path, vc.Attribute + ".z", vc.ClassId, zKeys), length, looped, sampleRate, 1.0f);
- L291 C52: new ScalarCurve :: var wAnim = BuildFloatAnim(new ScalarCurve(vc.Path, vc.Attribute + ".w", vc.ClassId, wKeys), length, looped, sampleRate, 1.0f);
- L293 C40: new PropAnimQuaternion :: var quatAnim = new PropAnimQuaternion
- L301 C37: new Quaternion :: var q = new Quaternion(xAnim.GetValue(t), yAnim.GetValue(t), zAnim.GetValue(t), wAnim.GetValue(t));
- L306 C52: new QuaternionKeyframe :: quatAnim.Keyframes.Add(new QuaternionKeyframe(t, q, Quaternion.Identity, Quaternion.Identity, ERadialInterpType.Linear));
- L319 C72: new() :: public Dictionary<char, ScalarCurve> Components { get; } = new();
- L393 C31: new AnimationMember :: var created = new AnimationMember(memberName, memberType);
- L425 C31: new AnimationMember :: var created = new AnimationMember(methodName, EAnimationMemberType.Method)
- L606 C42: new ScalarCurve :: scalarCurves.Add(new ScalarCurve(path, attribute!, classId, keys));
- L616 C38: new VectorCurve :: vectorCurves.Add(new VectorCurve(path, vecAttribute, classId, components));
- L634 C24: new List :: var list = new List<CurveKey>(keySeq.Children.Count);
- L644 C26: new CurveKey :: list.Add(new CurveKey(time, value, inSlope, outSlope, tangentMode));
- L657 C29: new Dictionary :: componentKeys = new Dictionary<char, IReadOnlyList<CurveKey>>();
- L667 C25: new Dictionary :: var comps = new Dictionary<char, IReadOnlyList<CurveKey>>();
- L668 C32: new[] :: foreach (char c in new[] { 'x', 'y', 'z', 'w' })
- L675 C28: new List :: var list = new List<CurveKey>(keySeq.Children.Count);
- L685 C30: new CurveKey :: list.Add(new CurveKey(time, value, inSlope, outSlope, tangentMode));
- L700 C24: new PropAnimFloat :: var anim = new PropAnimFloat
- L709 C36: new FloatKeyframe :: anim.Keyframes.Add(new FloatKeyframe
- L848 C23: new InvalidDataException :: throw new InvalidDataException("No YAML documents found.");
- L851 C23: new InvalidDataException :: throw new InvalidDataException("Unexpected YAML root node.");
- L862 C23: new InvalidDataException :: throw new InvalidDataException("Could not locate AnimationClip mapping.");
- L871 C43: new YamlScalarNode :: if (!map.Children.TryGetValue(new YamlScalarNode(key), out var node))
- L885 C43: new YamlScalarNode :: if (!map.Children.TryGetValue(new YamlScalarNode(key), out var node))
- L898 C43: new YamlScalarNode :: if (!map.Children.TryGetValue(new YamlScalarNode(key), out var node))


## XREngine.Animation/Interfaces/ICartesianKeyframe.cs
- L5 C9: new T :: new T InValue { get; set; }
- L6 C9: new T :: new T OutValue { get; set; }
- L7 C9: new T :: new T InTangent { get; set; }
- L8 C9: new T :: new T OutTangent { get; set; }


## XREngine.Animation/Interfaces/IPlanarKeyframeT.cs
- L5 C9: new T :: new T InValue { get; set; }
- L6 C9: new T :: new T OutValue { get; set; }
- L7 C9: new T :: new T InTangent { get; set; }
- L8 C9: new T :: new T OutTangent { get; set; }


## XREngine.Animation/Keyframes/Keyframe.cs
- L139 C27: new Exception :: throw new Exception();
- L161 C23: new Exception :: throw new Exception();


## XREngine.Animation/Keyframes/KeyframeTrack.cs
- L11 C108: new() :: public class KeyframeTrack<T> : BaseKeyframeTrack, IList, IList<T>, IEnumerable<T> where T : Keyframe, new()
- L57 C43: new object :: public object SyncRoot { get; } = new object();
- L76 C23: new IndexOutOfRangeException :: throw new IndexOutOfRangeException();
- L107 C23: new IndexOutOfRangeException :: throw new IndexOutOfRangeException();
- L267 C19: new System.NotImplementedException :: throw new System.NotImplementedException();
- L272 C19: new System.NotImplementedException :: throw new System.NotImplementedException();
- L277 C19: new System.NotImplementedException :: throw new System.NotImplementedException();
- L282 C19: new System.NotImplementedException :: throw new System.NotImplementedException();
- L287 C19: new System.NotImplementedException :: throw new System.NotImplementedException();
- L292 C19: new System.NotImplementedException :: throw new System.NotImplementedException();
- L297 C19: new System.NotImplementedException :: throw new System.NotImplementedException();
- L302 C19: new System.NotImplementedException :: throw new System.NotImplementedException();


## XREngine.Animation/Keyframes/VectorKeyframe.cs
- L17 C26: new T :: : this(0.0f, new T(), new T(), EVectorInterpType.Smooth) { }
- L17 C35: new T :: : this(0.0f, new T(), new T(), EVectorInterpType.Smooth) { }
- L42 C65: new() :: protected DelInterpolate _interpolateOut = (_, _, _) => new();
- L43 C73: new() :: protected DelInterpolate _interpolateVelocityOut = (_, _, _) => new();
- L44 C77: new() :: protected DelInterpolate _interpolateAccelerationOut = (_, _, _) => new();
- L46 C64: new() :: protected DelInterpolate _interpolateIn = (_, _, _) => new();
- L47 C72: new() :: protected DelInterpolate _interpolateVelocityIn = (_, _, _) => new();
- L48 C76: new() :: protected DelInterpolate _interpolateAccelerationIn = (_, _, _) => new();
- L175 C16: new VectorKeyframe :: public new VectorKeyframe<T>? Next
- L180 C16: new VectorKeyframe :: public new VectorKeyframe<T>? Prev
- L403 C79: new T :: return type == EVectorValueType.Position ? OutValue : new T();
- L431 C74: new T :: return type == EVectorValueType.Position ? InValue : new T();
- L469 C79: new T :: return type == EVectorValueType.Position ? OutValue : new T();
- L502 C74: new T :: return type == EVectorValueType.Position ? InValue : new T();
- L545 C36: new T :: velocity = new T();
- L546 C40: new T :: acceleration = new T();
- L600 C36: new T :: velocity = new T();
- L601 C40: new T :: acceleration = new T();
- L614 C69: new () :: => (diff / span) < 1.0f ? OutValue : (next?.OutValue ?? new ());
- L616 C16: new() :: => new();
- L618 C16: new() :: => new();
- L623 C16: new() :: => new();
- L630 C67: new() :: => (diff / span) < 1.0f ? InValue : (prev?.InValue ?? new());
- L632 C16: new() :: => new();
- L634 C16: new() :: => new();
- L639 C16: new() :: => new();


## XREngine.Animation/Property/BoolKeyframe.cs
- L17 C16: new BoolKeyframe :: public new BoolKeyframe? Next
- L22 C16: new BoolKeyframe :: public new BoolKeyframe? Prev


## XREngine.Animation/Property/Core/AnimationClip.cs
- L217 C35: new() :: VMDFile vmd = new();
- L293 C24: new Vector3 :: return new Vector3(q.X, q.Y, q.Z) * (angle / sinAngle);
- L295 C24: new Vector3 :: return new Vector3(q.X, q.Y, q.Z); // small-angle approximation
- L309 C26: new Quaternion :: result = new Quaternion(
- L317 C26: new Quaternion :: result = new Quaternion(v.X, v.Y, v.Z, 1.0f); // small-angle approximation
- L344 C38: new AnimationMember :: ikRoot = new AnimationMember("GetComponent", EAnimationMemberType.Method)
- L388 C39: new AnimationMember :: var getBone = new AnimationMember("FindDescendantByName", EAnimationMemberType.Method)
- L395 C41: new AnimationMember :: var transform = new AnimationMember("Transform", EAnimationMemberType.Property);
- L464 C37: new FloatKeyframe :: xAnim.Keyframes.Add(new FloatKeyframe((int)frame.Key, fps, data.Translation.X, xOutTan, xInTan, EVectorInterpType.Smooth));
- L480 C37: new FloatKeyframe :: yAnim.Keyframes.Add(new FloatKeyframe((int)frame.Key, fps, data.Translation.Y, yOutTan, yInTan, EVectorInterpType.Smooth));
- L496 C37: new FloatKeyframe :: zAnim.Keyframes.Add(new FloatKeyframe((int)frame.Key, fps, data.Translation.Z, zOutTan, zInTan, EVectorInterpType.Smooth));
- L512 C39: new QuaternionKeyframe :: rotAnim.Keyframes.Add(new QuaternionKeyframe((int)frame.Key, fps, data.Rotation, outRotTan, inRotTan, ERadialInterpType.Smooth));


## XREngine.Animation/Property/Core/AnimationMember.cs
- L39 C31: new AnimationMember :: _children.Add(new AnimationMember(remainingPath));
- L70 C35: new AnimationMember :: _children.Add(new AnimationMember(remainingPath));
- L285 C46: new object :: private object?[] _methodArguments = new object?[1];
- L457 C32: new Expression :: var callArgs = new Expression[parameters.Length];
- L568 C21: new AnimationMember :: new AnimationMember("FindDescendantByName", EAnimationMemberType.Method)
- L575 C29: new AnimationMember :: new AnimationMember("GetComponent", EAnimationMemberType.Method)


## XREngine.Animation/Property/Core/BlendTree2D.cs
- L84 C55: new Child :: private readonly Child?[] _boundingChildren = new Child?[4];
- L95 C56: new ChildWeight :: private readonly ChildWeight[] _childWeights = new ChildWeight[4];
- L158 C30: new Child :: _sortedByX = new Child[_children.Count];
- L159 C30: new Child :: _sortedByY = new Child[_children.Count];
- L292 C49: new ChildWeight :: _childWeights[_weightCount++] = new ChildWeight { Child = a, Weight = 1.0f };
- L303 C45: new ChildWeight :: _childWeights[_weightCount++] = new ChildWeight { Child = a, Weight = 1.0f - t };
- L304 C45: new ChildWeight :: _childWeights[_weightCount++] = new ChildWeight { Child = b, Weight = t };
- L324 C49: new ChildWeight :: _childWeights[_weightCount++] = new ChildWeight { Child = a, Weight = 1.0f };
- L329 C49: new ChildWeight :: _childWeights[_weightCount++] = new ChildWeight { Child = b, Weight = 1.0f };
- L342 C45: new ChildWeight :: _childWeights[_weightCount++] = new ChildWeight { Child = a, Weight = weightA };
- L343 C45: new ChildWeight :: _childWeights[_weightCount++] = new ChildWeight { Child = b, Weight = weightB };
- L358 C49: new ChildWeight :: _childWeights[_weightCount++] = new ChildWeight { Child = nearest, Weight = 1.0f };
- L367 C85: new() :: List<(Child child, float angleDist, float dotProduct)> childDistances = new();
- L399 C49: new ChildWeight :: _childWeights[_weightCount++] = new ChildWeight { Child = nearest, Weight = 1.0f };
- L408 C31: new float :: float[] weights = new float[count];
- L415 C49: new ChildWeight :: _childWeights[_weightCount++] = new ChildWeight
- L437 C53: new ChildWeight :: _childWeights[_weightCount++] = new ChildWeight
- L447 C49: new ChildWeight :: _childWeights[_weightCount++] = new ChildWeight
- L507 C58: new Child :: int leftIdx = Array.BinarySearch(_sortedByX, new Child { PositionX = x }, _xComp);
- L581 C53: new ChildWeight :: _childWeights[_weightCount++] = new ChildWeight { Child = _boundingChildren[0]!, Weight = 1.0f };
- L620 C33: new Child :: Child[] remaining = new Child[2];
- L656 C49: new ChildWeight :: _childWeights[_weightCount++] = new ChildWeight { Child = nearest, Weight = 1.0f };
- L667 C45: new ChildWeight :: _childWeights[_weightCount++] = new ChildWeight
- L672 C45: new ChildWeight :: _childWeights[_weightCount++] = new ChildWeight
- L677 C45: new ChildWeight :: _childWeights[_weightCount++] = new ChildWeight
- L682 C45: new ChildWeight :: _childWeights[_weightCount++] = new ChildWeight
- L726 C53: new ChildWeight :: _childWeights[_weightCount++] = new ChildWeight { Child = _boundingChildren[0]!, Weight = 1.0f };
- L769 C49: new ChildWeight :: _childWeights[_weightCount++] = new ChildWeight { Child = nearest, Weight = 1.0f };
- L790 C49: new ChildWeight :: _childWeights[_weightCount++] = new ChildWeight { Child = a, Weight = 1.0f };
- L805 C45: new ChildWeight :: _childWeights[_weightCount++] = new ChildWeight { Child = a, Weight = 1.0f - t };
- L806 C45: new ChildWeight :: _childWeights[_weightCount++] = new ChildWeight { Child = b, Weight = t };
- L839 C45: new ChildWeight :: _childWeights[_weightCount++] = new ChildWeight { Child = a, Weight = normalizedAlpha };
- L840 C45: new ChildWeight :: _childWeights[_weightCount++] = new ChildWeight { Child = b, Weight = normalizedBeta };
- L841 C45: new ChildWeight :: _childWeights[_weightCount++] = new ChildWeight { Child = c, Weight = normalizedGamma };


## XREngine.Animation/Property/Core/MotionBase.cs
- L30 C56: new() :: private readonly object _animationValuesLock = new();


## XREngine.Animation/Property/Core/PropAnimKeyframed.cs
- L6 C132: new() :: public abstract class PropAnimKeyframed<TKeyframe> : BasePropAnimKeyframed, IEnumerable<TKeyframe> where TKeyframe : Keyframe, new()


## XREngine.Animation/Property/Core/PropAnimLerpable.cs
- L8 C53: new() :: where TValueKey : LerpableKeyframe<TValue>, new()
- L32 C40: new() :: private TValue _defaultValue = new();
- L144 C19: new TValue :: : new TValue();
- L168 C55: new TValue :: => _baked is null || _baked.Length == 0 ? new TValue() :
- L272 C22: new TValue :: _baked = new TValue[BakedFrameCount];
- L281 C26: new T :: : this(0.0f, new T(), new T()) { }
- L281 C35: new T :: : this(0.0f, new T(), new T()) { }
- L324 C16: new LerpableKeyframe :: public new LerpableKeyframe<T>? Next
- L330 C16: new LerpableKeyframe :: public new LerpableKeyframe<T>? Prev


## XREngine.Animation/Property/Core/PropAnimVector.cs
- L11 C51: new() :: where TValueKey : VectorKeyframe<TValue>, new()
- L39 C40: new() :: private TValue _defaultValue = new();
- L138 C23: new InvalidOperationException :: throw new InvalidOperationException("Cannot get baked value when not baked.");
- L187 C23: new InvalidOperationException :: throw new InvalidOperationException("Cannot get baked value when not baked.");
- L190 C24: new TValue :: return new TValue();
- L216 C55: new TValue :: => _baked is null || _baked.Length == 0 ? new TValue() :
- L277 C35: new TValue :: CurrentVelocity = new TValue();
- L278 C39: new TValue :: CurrentAcceleration = new TValue();
- L287 C35: new TValue :: CurrentVelocity = new TValue();
- L288 C39: new TValue :: CurrentAcceleration = new TValue();
- L337 C23: new() :: vel = new(),
- L338 C23: new() :: acc = new();
- L373 C22: new TValue :: _baked = new TValue[BakedFrameCount];
- L387 C56: new TValue :: float[] inComps = GetComponents(velocity ? new TValue() : DefaultValue);
- L405 C32: new float :: float[] outComps = new float[compCount];
- L406 C34: new float :: float[] inTanComps = new float[compCount];
- L407 C35: new float :: float[] outTanComps = new float[compCount];
- L511 C32: new float :: float[] outComps = new float[compCount];


## XREngine.Animation/Property/ObjectKeyframe.cs
- L7 C16: new ObjectKeyframe :: public new ObjectKeyframe? Next
- L12 C16: new ObjectKeyframe :: public new ObjectKeyframe? Prev


## XREngine.Animation/Property/PropAnimBool.cs
- L44 C22: new bool :: _baked = new bool[BakedFrameCount];


## XREngine.Animation/Property/PropAnimMatrix.cs
- L39 C19: new NotImplementedException :: throw new NotImplementedException();
- L55 C22: new Matrix4x4 :: _baked = new Matrix4x4[BakedFrameCount];
- L62 C19: new NotImplementedException :: throw new NotImplementedException();
- L81 C16: new MatrixKeyframe :: public new MatrixKeyframe? Next
- L87 C16: new MatrixKeyframe :: public new MatrixKeyframe? Prev
- L119 C21: new Matrix4x4 :: Value = new Matrix4x4();
- L131 C20: new Matrix4x4 :: return new Matrix4x4(


## XREngine.Animation/Property/PropAnimMethod.cs
- L62 C22: new T :: _baked = new T[BakedFrameCount];


## XREngine.Animation/Property/PropAnimObject.cs
- L73 C22: new string :: _baked = new string[BakedFrameCount];


## XREngine.Animation/Property/PropAnimQuaternion.cs
- L84 C23: new InvalidOperationException :: throw new InvalidOperationException("Cannot get baked value when not baked.");
- L128 C23: new InvalidOperationException :: throw new InvalidOperationException("Cannot get baked value when not baked.");
- L178 C22: new Quaternion :: _baked = new Quaternion[BakedFrameCount];


## XREngine.Animation/Property/PropAnimString.cs
- L55 C22: new string :: _baked = new string[BakedFrameCount];


## XREngine.Animation/Property/PropAnimVector4.cs
- L35 C51: new() :: public static readonly Vector5 Zero = new();
- L116 C23: new Vector4 :: InValue = new Vector4(float.Parse(parts[1]), float.Parse(parts[2]), float.Parse(parts[3]), float.Parse(parts[4]));
- L117 C24: new Vector4 :: OutValue = new Vector4(float.Parse(parts[5]), float.Parse(parts[6]), float.Parse(parts[7]), float.Parse(parts[8]));
- L118 C25: new Vector4 :: InTangent = new Vector4(float.Parse(parts[9]), float.Parse(parts[10]), float.Parse(parts[11]), float.Parse(parts[12]));
- L119 C26: new Vector4 :: OutTangent = new Vector4(float.Parse(parts[13]), float.Parse(parts[14]), float.Parse(parts[15]), float.Parse(parts[16]));


## XREngine.Animation/Property/QuaternionKeyframe.cs
- L63 C16: new QuaternionKeyframe :: public new QuaternionKeyframe? Next
- L68 C16: new QuaternionKeyframe :: public new QuaternionKeyframe? Prev
- L236 C23: new Quaternion :: InValue = new Quaternion(float.Parse(parts[1]), float.Parse(parts[2]), float.Parse(parts[3]), float.Parse(parts[4]));
- L237 C24: new Quaternion :: OutValue = new Quaternion(float.Parse(parts[5]), float.Parse(parts[6]), float.Parse(parts[7]), float.Parse(parts[8]));
- L238 C25: new Quaternion :: InTangent = new Quaternion(float.Parse(parts[9]), float.Parse(parts[10]), float.Parse(parts[11]), float.Parse(parts[12]));
- L239 C26: new Quaternion :: OutTangent = new Quaternion(float.Parse(parts[13]), float.Parse(parts[14]), float.Parse(parts[15]), float.Parse(parts[16]));


## XREngine.Animation/Property/StringKeyframe.cs
- L7 C16: new StringKeyframe :: public new StringKeyframe? Next
- L12 C16: new StringKeyframe :: public new StringKeyframe? Prev


## XREngine.Animation/Property/Vector2Keyframe.cs
- L50 C23: new Vector2 :: InValue = new Vector2(float.Parse(parts[1]), float.Parse(parts[2]));
- L51 C24: new Vector2 :: OutValue = new Vector2(float.Parse(parts[3]), float.Parse(parts[4]));
- L52 C25: new Vector2 :: InTangent = new Vector2(float.Parse(parts[5]), float.Parse(parts[6]));
- L53 C26: new Vector2 :: OutTangent = new Vector2(float.Parse(parts[7]), float.Parse(parts[8]));


## XREngine.Animation/Property/Vector3Keyframe.cs
- L62 C23: new Vector3 :: InValue = new Vector3(float.Parse(parts[1]), float.Parse(parts[2]), float.Parse(parts[3]));
- L63 C24: new Vector3 :: OutValue = new Vector3(float.Parse(parts[4]), float.Parse(parts[5]), float.Parse(parts[6]));
- L64 C25: new Vector3 :: InTangent = new Vector3(float.Parse(parts[7]), float.Parse(parts[8]), float.Parse(parts[9]));
- L65 C26: new Vector3 :: OutTangent = new Vector3(float.Parse(parts[10]), float.Parse(parts[11]), float.Parse(parts[12]));


## XREngine.Animation/State Machine/AnimStateMachine.cs
- L63 C56: new() :: private readonly object _animationValuesLock = new();
- L392 C25: new List :: var names = new List<string>(Variables.Count);
- L433 C23: new Dictionary :: var map = new Dictionary<string, AnimVar>(StringComparer.Ordinal);
- L441 C26: new List :: var result = new List<AnimParameterSchemaEntry>(_orderedParameterNames.Length);
- L448 C32: new AnimParameterSchemaEntry :: result.Add(new AnimParameterSchemaEntry(name, AnimParameterType.Bool, b.Value, 0, 0f));
- L450 C32: new AnimParameterSchemaEntry :: result.Add(new AnimParameterSchemaEntry(name, AnimParameterType.Int, false, i.Value, 0f));
- L452 C32: new AnimParameterSchemaEntry :: result.Add(new AnimParameterSchemaEntry(name, AnimParameterType.Float, false, 0, f.Value));
- L461 C25: new List :: var names = new List<string>();
- L500 C51: new AnimBool :: AnimParameterType.Bool => new AnimBool(entry.Name, entry.BoolDefault),
- L501 C50: new AnimInt :: AnimParameterType.Int => new AnimInt(entry.Name, entry.IntDefault),
- L502 C52: new AnimFloat :: AnimParameterType.Float => new AnimFloat(entry.Name, entry.FloatDefault),
- L558 C25: new SortedSet :: names = new SortedSet<string>(StringComparer.Ordinal);
- L663 C37: new AnimFloat :: Variables.Add(name, new AnimFloat(name, defaultValue));
- L671 C37: new AnimInt :: Variables.Add(name, new AnimInt(name, defaultValue));
- L679 C37: new AnimBool :: Variables.Add(name, new AnimBool(name, defaultValue));


## XREngine.Animation/State Machine/Layers/AnimLayer.cs
- L28 C45: new AnyState :: public AnyState AnyState { get; } = new AnyState();
- L36 C57: new() :: internal readonly object _animationValuesLock = new();
- L39 C55: new() :: private readonly BlendManager _blendManager = new();


## XREngine.Animation/State Machine/Layers/States/AnimState.cs
- L27 C66: new() :: public T AddComponent<T>() where T : AnimStateComponent, new()
- L29 C24: new T :: var comp = new T();


## XREngine.Animation/State Machine/Layers/States/AnimStateBase.cs
- L83 C46: new() :: AnimStateTransition transition = new()


## XREngine.Animation/State Machine/Layers/States/BlendManager.cs
- L60 C31: new Dictionary :: _animatedCurves = new Dictionary<string, AnimationMember>(uniquePaths.Count());


## XREngine.Animation/TransformKeyCollection.cs
- L18 C54: new PropAnimFloat :: public PropAnimFloat TranslationX { get; } = new PropAnimFloat() { DefaultValue = 0.0f };
- L20 C54: new PropAnimFloat :: public PropAnimFloat TranslationY { get; } = new PropAnimFloat() { DefaultValue = 0.0f };
- L22 C54: new PropAnimFloat :: public PropAnimFloat TranslationZ { get; } = new PropAnimFloat() { DefaultValue = 0.0f };
- L24 C48: new PropAnimFloat :: public PropAnimFloat ScaleX { get; } = new PropAnimFloat() { DefaultValue = 0.0f };
- L26 C48: new PropAnimFloat :: public PropAnimFloat ScaleY { get; } = new PropAnimFloat() { DefaultValue = 0.0f };
- L28 C48: new PropAnimFloat :: public PropAnimFloat ScaleZ { get; } = new PropAnimFloat() { DefaultValue = 0.0f };
- L30 C55: new PropAnimQuaternion :: public PropAnimQuaternion Rotation { get; } = new PropAnimQuaternion() { DefaultValue = Quaternion.Identity };
- L114 C27: new Vector3 :: translation = new Vector3(
- L121 C21: new Vector3 :: scale = new Vector3(
- L128 C27: new Vector3 :: translation = new Vector3(
- L135 C21: new Vector3 :: scale = new Vector3(


## XREngine.Audio/AudioBuffer.cs
- L116 C63: new Complex :: Complex[] complexBuffer = [.. samples.Select(x => new Complex(x, 0.0))];


## XREngine.Audio/AudioDiagnostics.cs
- L87 C76: new() :: private static readonly ConcurrentQueue<DiagEvent> _recentEvents = new();
- L98 C23: new DiagEvent :: var evt = new DiagEvent(Stopwatch.GetTimestamp(), kind, detail);


## XREngine.Audio/AudioInputDevice.cs
- L22 C80: new AudioCapture :: public AudioCapture<BufferFormat> AudioCapture { get; private set; } = new AudioCapture<BufferFormat>(listener.Capture, deviceName, freq, format, bufferSize);
- L65 C39: new byte :: byte[] data = new byte[BufferSize];
- L80 C40: new short :: short[] data = new short[BufferSize];


## XREngine.Audio/AudioInputDeviceFloat.cs
- L21 C85: new AudioCapture :: public AudioCapture<FloatBufferFormat> AudioCapture { get; private set; } = new AudioCapture<FloatBufferFormat>(listener.Capture, deviceName, freq, format, bufferSize);
- L59 C28: new float :: float[] data = new float[BufferSize];


## XREngine.Audio/AudioManager.cs
- L102 C50: new OpenALTransport :: AudioTransportType.OpenAL => new OpenALTransport(),
- L109 C28: new ListenerContext :: listener = new ListenerContext(transport, effects) { Name = name };
- L113 C28: new() :: listener = new() { Name = name };
- L144 C89: new OpenALEfxProcessor :: AudioEffectsType.OpenAL_EFX when transport is OpenALTransport openAl => new OpenALEfxProcessor(openAl),
- L146 C49: new PassthroughProcessor :: AudioEffectsType.Passthrough => new PassthroughProcessor(),
- L155 C20: new PassthroughProcessor :: return new PassthroughProcessor();
- L162 C24: new Steam.SteamAudioProcessor :: return new Steam.SteamAudioProcessor();
- L167 C24: new PassthroughProcessor :: return new PassthroughProcessor();
- L174 C20: new OpenALTransport :: return new OpenALTransport();


## XREngine.Audio/AudioSource.cs
- L247 C28: new ArgumentOutOfRangeException :: _ => throw new ArgumentOutOfRangeException(nameof(state), state, null),
- L257 C28: new ArgumentOutOfRangeException :: _ => throw new ArgumentOutOfRangeException(nameof(state), state, null),
- L266 C28: new ArgumentOutOfRangeException :: _ => throw new ArgumentOutOfRangeException(nameof(type), type, null),
- L275 C28: new ArgumentOutOfRangeException :: _ => throw new ArgumentOutOfRangeException(nameof(type), type, null),
- L839 C20: new AuxSendFilter :: return new AuxSendFilter { AuxEffectSlotID = slotID, AuxSendNumber = sendNumber, FilterID = filterID };


## XREngine.Audio/Effects/AudioEffect.cs
- L40 C53: new Vector3 :: => Api.SetEffectProperty(Handle, param, new Vector3(x, y, z));
- L42 C53: new Vector3 :: => Api.SetEffectProperty(Handle, param, new Vector3(value));
- L44 C53: new Vector3 :: => Api.SetEffectProperty(Handle, param, new Vector3(x, y, 0));


## XREngine.Audio/Effects/EffectContext.cs
- L45 C39: new EAXReverbEffect :: EaxReverbPool = new(() => new EAXReverbEffect(this));
- L46 C36: new ReverbEffect :: ReverbPool = new(() => new ReverbEffect(this));
- L47 C36: new ChorusEffect :: ChorusPool = new(() => new ChorusEffect(this));
- L48 C40: new DistortionEffect :: DistortionPool = new(() => new DistortionEffect(this));
- L49 C34: new EchoEffect :: EchoPool = new(() => new EchoEffect(this));
- L50 C37: new FlangerEffect :: FlangerPool = new(() => new FlangerEffect(this));
- L51 C46: new FrequencyShifterEffect :: FrequencyShifterPool = new(() => new FrequencyShifterEffect(this));
- L52 C42: new VocalMorpherEffect :: VocalMorpherPool = new(() => new VocalMorpherEffect(this));
- L53 C42: new PitchShifterEffect :: PitchShifterPool = new(() => new PitchShifterEffect(this));
- L54 C43: new RingModulatorEffect :: RingModulatorPool = new(() => new RingModulatorEffect(this));
- L55 C37: new AutowahEffect :: AutowahPool = new(() => new AutowahEffect(this));
- L56 C40: new CompressorEffect :: CompressorPool = new(() => new CompressorEffect(this));
- L57 C39: new EqualizerEffect :: EqualizerPool = new(() => new EqualizerEffect(this));


## XREngine.Audio/ListenerContext.cs
- L71 C44: new ArgumentNullException :: Transport = transport ?? throw new ArgumentNullException(nameof(transport));
- L111 C26: new ResourcePool :: SourcePool = new ResourcePool<AudioSource>(() => new AudioSource(this));
- L111 C62: new AudioSource :: SourcePool = new ResourcePool<AudioSource>(() => new AudioSource(this));
- L112 C26: new ResourcePool :: BufferPool = new ResourcePool<AudioBuffer>(() => new AudioBuffer(this));
- L112 C62: new AudioBuffer :: BufferPool = new ResourcePool<AudioBuffer>(() => new AudioBuffer(this));
- L114 C42: new AudioEffectsSettings :: EffectsProcessor?.Initialize(new AudioEffectsSettings { SampleRate = Transport.SampleRate });
- L146 C27: new EffectContext :: Effects = new EffectContext(this, effectExtension);
- L159 C26: new ResourcePool :: SourcePool = new ResourcePool<AudioSource>(() => new AudioSource(this));
- L159 C62: new AudioSource :: SourcePool = new ResourcePool<AudioSource>(() => new AudioSource(this));
- L160 C26: new ResourcePool :: BufferPool = new ResourcePool<AudioBuffer>(() => new AudioBuffer(this));
- L160 C62: new AudioBuffer :: BufferPool = new ResourcePool<AudioBuffer>(() => new AudioBuffer(this));
- L465 C35: new float :: float[] orientation = new float[6];
- L469 C23: new Vector3 :: forward = new Vector3(orientation[0], orientation[1], orientation[2]);
- L470 C18: new Vector3 :: up = new Vector3(orientation[3], orientation[4], orientation[5]);


## XREngine.Audio/OpenALEfxProcessor.cs
- L32 C45: new ArgumentNullException :: _transport = transport ?? throw new ArgumentNullException(nameof(transport));
- L53 C33: new EffectContext :: EffectContext = new EffectContext(listener, _transport.EffectExtension);


## XREngine.Audio/OpenALTransport.cs
- L184 C35: new float :: float[] orientation = new float[6];
- L188 C23: new Vector3 :: forward = new Vector3(orientation[0], orientation[1], orientation[2]);
- L189 C18: new Vector3 :: up = new Vector3(orientation[3], orientation[4], orientation[5]);
- L207 C20: new AudioSourceHandle :: return new AudioSourceHandle(id);
- L227 C20: new AudioBufferHandle :: return new AudioBufferHandle(id);
- L326 C29: new AudioBufferHandle :: output[i] = new AudioBufferHandle(handles[i]);


## XREngine.Audio/PassthroughProcessor.cs
- L49 C20: new EffectsSourceHandle :: return new EffectsSourceHandle(_nextHandleId++);


## XREngine.Audio/Steam/OpaqueHandles.cs
- L16 C66: new() :: public static implicit operator IPLContext(IntPtr handle) => new() { Handle = handle };
- L42 C19: new Exception :: throw new Exception(error.ToString());
- L51 C19: new Exception :: throw new Exception(error.ToString());


## XREngine.Audio/Steam/SteamAudioProcessor.cs
- L57 C23: new DllNotFoundException :: throw new DllNotFoundException(
- L111 C35: new IPLContextSettings :: var contextSettings = new IPLContextSettings();
- L114 C23: new InvalidOperationException :: throw new InvalidOperationException($"Steam Audio: iplContextCreate failed with {error}. Is phonon.dll available?");
- L117 C30: new IPLAudioSettings :: _audioSettings = new IPLAudioSettings
- L124 C32: new IPLHRTFSettings :: var hrtfSettings = new IPLHRTFSettings
- L132 C23: new InvalidOperationException :: throw new InvalidOperationException($"Steam Audio: iplHRTFCreate failed with {error}.");
- L136 C31: new IPLSimulationSettings :: var simSettings = new IPLSimulationSettings
- L149 C23: new InvalidOperationException :: throw new InvalidOperationException($"Steam Audio: iplSimulatorCreate failed with {error}.");
- L152 C31: new IPLCoordinateSpace3 :: _listenerCoords = new IPLCoordinateSpace3
- L154 C25: new IPLVector3 :: ahead = new IPLVector3(0, 0, -1),
- L155 C22: new IPLVector3 :: up = new IPLVector3(0, 1, 0),
- L156 C25: new IPLVector3 :: right = new IPLVector3(1, 0, 0),
- L193 C32: new IPLSimulationSharedInputs :: var sharedInputs = new IPLSimulationSharedInputs
- L214 C31: new IPLCoordinateSpace3 :: _listenerCoords = new IPLCoordinateSpace3
- L231 C25: new SourceChain :: var chain = new SourceChain { Context = _context, Simulator = _simulator };
- L236 C38: new IPLSourceSettings :: var sourceSettings = new IPLSourceSettings
- L242 C27: new InvalidOperationException :: throw new InvalidOperationException($"iplSourceCreate failed: {error}");
- L247 C38: new IPLCoordinateSpace3 :: chain.SourceCoords = new IPLCoordinateSpace3
- L250 C26: new IPLVector3 :: up = new IPLVector3(0, 1, 0),
- L255 C30: new IPLSimulationInputs :: var inputs = new IPLSimulationInputs
- L267 C38: new IPLDirectEffectSettings :: var directSettings = new IPLDirectEffectSettings { numChannels = 1 };
- L270 C27: new InvalidOperationException :: throw new InvalidOperationException($"iplDirectEffectCreate failed: {error}");
- L273 C40: new IPLBinauralEffectSettings :: var binauralSettings = new IPLBinauralEffectSettings { hrtf = _hrtf };
- L276 C27: new InvalidOperationException :: throw new InvalidOperationException($"iplBinauralEffectCreate failed: {error}");
- L281 C27: new InvalidOperationException :: throw new InvalidOperationException($"iplAudioBufferAllocate (input) failed: {error}");
- L285 C27: new InvalidOperationException :: throw new InvalidOperationException($"iplAudioBufferAllocate (direct output) failed: {error}");
- L289 C27: new InvalidOperationException :: throw new InvalidOperationException($"iplAudioBufferAllocate (binaural output) failed: {error}");
- L298 C20: new EffectsSourceHandle :: return new EffectsSourceHandle(handleId);
- L324 C34: new IPLCoordinateSpace3 :: chain.SourceCoords = new IPLCoordinateSpace3
- L332 C26: new IPLSimulationInputs :: var inputs = new IPLSimulationInputs
- L374 C47: new Span :: input[..samplesToCopy].CopyTo(new Span<float>(inputData, samplesToCopy));
- L377 C21: new Span :: new Span<float>(inputData + samplesToCopy, frameSize - samplesToCopy).Clear();
- L381 C30: new IPLSimulationOutputs :: var simOutputs = new IPLSimulationOutputs();
- L403 C34: new IPLBinauralEffectParams :: var binauralParams = new IPLBinauralEffectParams


## XREngine.Audio/XRAudioUtil.cs
- L11 C30: new MMDeviceEnumerator :: var enumerator = new MMDeviceEnumerator();
- L18 C30: new MMDeviceEnumerator :: var enumerator = new MMDeviceEnumerator();
- L25 C30: new MMDeviceEnumerator :: var enumerator = new MMDeviceEnumerator();
- L32 C30: new MMDeviceEnumerator :: var enumerator = new MMDeviceEnumerator();
- L39 C30: new MMDeviceEnumerator :: var enumerator = new MMDeviceEnumerator();
- L46 C30: new MMDeviceEnumerator :: var enumerator = new MMDeviceEnumerator();


## XREngine.Data/ArchiveExtractor.cs
- L35 C26: new ArchiveExtractionProgress :: yield return new ArchiveExtractionProgress(0f, EArchiveExtractionPhase.Preparing, "Preparing extraction...");
- L44 C30: new ArchiveExtractionProgress :: yield return new ArchiveExtractionProgress(1f, EArchiveExtractionPhase.Completed, "Import complete.");
- L66 C36: new FileStream :: using var fileStream = new FileStream(packagePath, FileMode.Open, FileAccess.Read, FileShare.Read);
- L67 C36: new GZipInputStream :: using var gzipStream = new GZipInputStream(fileStream);
- L68 C35: new TarInputStream :: using var tarStream = new TarInputStream(gzipStream, Encoding.Default);
- L86 C40: new FileStream :: using var output = new FileStream(entryPath, FileMode.Create, FileAccess.Write, FileShare.None);
- L94 C30: new ArchiveExtractionProgress :: yield return new ArchiveExtractionProgress(
- L151 C30: new ArchiveExtractionProgress :: yield return new ArchiveExtractionProgress(


## XREngine.Data/AudioData.cs
- L43 C30: new float :: float[] result = new float[_data.Length / sizeof(float)];
- L55 C30: new short :: short[] result = new short[_data.Length / sizeof(short)];
- L67 C29: new byte :: byte[] result = new byte[_data.Length];
- L118 C24: new float :: var data = new float[reader.TotalSamples * reader.Channels];
- L142 C28: new byte :: byte[] bytes = new byte[totalBytes];
- L150 C21: new DataSource :: _data = new DataSource(bytes);
- L161 C28: new byte :: byte[] bytes = new byte[reader.Length];
- L166 C29: new DataSource :: _data = new DataSource(bytes);
- L170 C29: new DataSource :: _data = new DataSource(bytes);
- L174 C29: new DataSource :: _data = new DataSource(bytes);
- L194 C27: new EndOfStreamException :: throw new EndOfStreamException($"Stream ended early: expected {buffer.Length} bytes, got {totalRead} bytes.");
- L212 C29: new DataSource :: _data = new DataSource(ConvertStereoToMono(GetByteData()));
- L231 C29: new DataSource :: _data = new DataSource(GetOneChannelFromStereo(GetByteData(), true));
- L250 C29: new DataSource :: _data = new DataSource(GetOneChannelFromStereo(GetByteData(), false));
- L266 C30: new() :: AudioData mono = new()
- L281 C30: new() :: AudioData mono = new()
- L296 C30: new() :: AudioData mono = new()
- L310 C34: new byte :: byte[] monoSamples = new byte[monoLength];
- L329 C35: new short :: short[] monoSamples = new short[monoLength];
- L347 C35: new float :: float[] monoSamples = new float[monoLength];
- L366 C34: new byte :: byte[] monoSamples = new byte[monoLength];
- L376 C35: new short :: short[] monoSamples = new short[monoLength];
- L386 C35: new float :: float[] monoSamples = new float[monoLength];
- L398 C36: new float :: float[] floatSamples = new float[sampleCount];


## XREngine.Data/BSP/BSPCube.cs
- L20 C17: new Vector3 :: new Vector3(-halfSize, -halfSize, -halfSize),
- L21 C17: new Vector3 :: new Vector3(halfSize, -halfSize, -halfSize),
- L22 C17: new Vector3 :: new Vector3(halfSize, halfSize, -halfSize),
- L23 C17: new Vector3 :: new Vector3(-halfSize, halfSize, -halfSize),
- L24 C17: new Vector3 :: new Vector3(-halfSize, -halfSize, halfSize),
- L25 C17: new Vector3 :: new Vector3(halfSize, -halfSize, halfSize),
- L26 C17: new Vector3 :: new Vector3(halfSize, halfSize, halfSize),
- L27 C17: new Vector3 :: new Vector3(-halfSize, halfSize, halfSize),
- L45 C17: new Vector3 :: new Vector3(0, 0, -1),
- L46 C17: new Vector3 :: new Vector3(0, 0, 1),
- L47 C17: new Vector3 :: new Vector3(0, -1, 0),
- L48 C17: new Vector3 :: new Vector3(0, 1, 0),
- L49 C17: new Vector3 :: new Vector3(-1, 0, 0),
- L50 C17: new Vector3 :: new Vector3(1, 0, 0)


## XREngine.Data/BSP/BSPNode.cs
- L36 C27: new BSPNode :: Front ??= new BSPNode();
- L42 C26: new BSPNode :: Back ??= new BSPNode();
- L165 C28: new Triangle :: output.Add(new Triangle(p0, polygon[i], polygon[i + 1]));
- L184 C20: new System.Numerics.Plane :: return new System.Numerics.Plane(-plane.Value.Normal, -plane.Value.D);
- L200 C24: new List :: return new List<Triangle>(triangles);
- L230 C33: new() :: BSPNode cloneNode = new();
- L233 C35: new System.Numerics.Plane :: cloneNode.Plane = new System.Numerics.Plane(Plane.Value.Normal, Plane.Value.D);
- L242 C41: new Triangle :: cloneNode.Triangles.Add(new Triangle(triangle.A, triangle.B, triangle.C));


## XREngine.Data/BSP/BSPShapeExtensions.cs
- L16 C31: new Triangle :: triangles.Add(new Triangle(a, b, c));
- L19 C28: new() :: BSPNode node = new();


## XREngine.Data/ComputerInfo.cs
- L18 C49: new() :: public static ComputerInfo Analyze() => new()


## XREngine.Data/ConcurrentHashSet.cs
- L223 C25: new object :: var locks = new object[concurrencyLevel];
- L225 C28: new object :: locks[i] = new object();
- L227 C32: new int :: var countPerLock = new int[locks.Length];
- L228 C27: new Node :: var buckets = new Node[capacity];
- L229 C23: new Tables :: _tables = new Tables(buckets, locks, countPerLock);
- L257 C33: new Tables :: var newTables = new Tables(new Node[DefaultCapacity], _tables.Locks, new int[_tables.CountPerLock.Length]);
- L257 C44: new Node :: var newTables = new Tables(new Node[DefaultCapacity], _tables.Locks, new int[_tables.CountPerLock.Length]);
- L257 C86: new int :: var newTables = new Tables(new Node[DefaultCapacity], _tables.Locks, new int[_tables.CountPerLock.Length]);
- L392 C27: new ArgumentException :: throw new ArgumentException("The index is equal to or greater than the length of the array, or the number of elements in the set is greater than the available space from index to the end of the destination array.");
- L447 C66: new Node :: Volatile.Write(ref tables.Buckets[bucketNo], new Node(item, hashcode, tables.Buckets[bucketNo]));
- L579 C32: new object :: newLocks = new object[tables.Locks.Length * 2];
- L582 C39: new object :: newLocks[i] = new object();
- L585 C34: new Node :: var newBuckets = new Node[newLength];
- L586 C39: new int :: var newCountPerLock = new int[newLocks.Length];
- L597 C51: new Node :: newBuckets[newBucketNo] = new Node(current.Item, current.Hashcode, newBuckets[newBucketNo]);
- L612 C27: new Tables :: _tables = new Tables(newBuckets, newLocks, newCountPerLock);


## XREngine.Data/Core/Assets/OverrideableSettingsAssetBase.cs
- L14 C44: new OverrideableSettingsTracker :: _overrideableSettingsTracker = new OverrideableSettingsTracker(this, OnOverrideableSettingChanged);


## XREngine.Data/Core/Assets/XRAsset.cs
- L255 C23: new InvalidOperationException :: throw new InvalidOperationException("Cannot open a file for streaming without a file path.");
- L423 C32: new StreamWriter :: using var writer = new StreamWriter(filePath, append: false, Encoding.UTF8);


## XREngine.Data/Core/Assets/XRAssetGraphUtility.cs
- L27 C101: new() :: private static readonly ConcurrentDictionary<Type, List<Func<object, object?>>> AccessorCache = new();
- L28 C78: new() :: private static readonly ConcurrentDictionary<Type, bool> LeafTypeCache = new();
- L29 C87: new() :: private static readonly ConcurrentDictionary<Type, bool> InspectMemberTypeCache = new();
- L60 C30: new HashSet :: var visitedObjects = new HashSet<object>(ReferenceEqualityComparer.Instance);
- L61 C32: new HashSet :: var discoveredAssets = new HashSet<XRAsset>(AssetReferenceComparer.Instance);
- L285 C25: new List :: var accessors = new List<Func<object, object?>>();
- L420 C66: new() :: public static readonly AssetReferenceComparer Instance = new();


## XREngine.Data/Core/Colors/ColorF3.cs
- L141 C23: new ColorF3 :: => this = new ColorF3(str);


## XREngine.Data/Core/Colors/HSVPixel.cs
- L51 C28: new ARGBPixel :: newPixel = new ARGBPixel(255, v, v, v);
- L63 C26: new ARGBPixel :: 0 => new ARGBPixel(255, v, t, p),
- L64 C26: new ARGBPixel :: 1 => new ARGBPixel(255, q, v, p),
- L65 C26: new ARGBPixel :: 2 => new ARGBPixel(255, p, v, t),
- L66 C26: new ARGBPixel :: 3 => new ARGBPixel(255, p, q, v),
- L67 C26: new ARGBPixel :: 4 => new ARGBPixel(255, t, p, v),
- L68 C26: new ARGBPixel :: _ => new ARGBPixel(255, v, p, q),


## XREngine.Data/Core/Events/XRBoolEvent.cs
- L179 C19: new() :: e ??= new();


## XREngine.Data/Core/Events/XREvent.cs
- L92 C19: new() :: e ??= new();
- L159 C38: new object :: object?[] expanded = new object?[tuple.Length];
- L195 C19: new() :: e ??= new();


## XREngine.Data/Core/Events/XRPersistentCall.cs
- L85 C37: new Type :: desiredParamTypes = new Type[typeNames.Length];


## XREngine.Data/Core/Memory/Bin16.cs
- L13 C68: new Bin16 :: public static implicit operator Bin16(ushort val) { return new Bin16(val); }
- L84 C20: new Bin16 :: return new Bin16(b);


## XREngine.Data/Core/Memory/Bin24.cs
- L14 C66: new Bin24 :: public static implicit operator Bin24(uint val) { return new Bin24((UInt24)val); }
- L16 C68: new Bin24 :: public static implicit operator Bin24(UInt24 val) { return new Bin24(val); }
- L87 C20: new Bin24 :: return new Bin24((UInt24)b);


## XREngine.Data/Core/Memory/Bin32.cs
- L12 C66: new Bin32 :: public static implicit operator Bin32(uint val) { return new Bin32(val); }
- L84 C20: new Bin32 :: return new Bin32(b);


## XREngine.Data/Core/Memory/Bin64.cs
- L12 C67: new Bin64 :: public static implicit operator Bin64(ulong val) { return new Bin64(val); }
- L84 C20: new Bin64 :: return new Bin64(b);


## XREngine.Data/Core/Memory/Bin8.cs
- L12 C65: new Bin8 :: public static implicit operator Bin8(byte val) { return new Bin8(val); }
- L84 C20: new Bin8 :: return new Bin8(b);


## XREngine.Data/Core/Memory/Compression.cs
- L18 C47: new() :: public object SyncRoot { get; } = new();
- L44 C24: new GDeflateCodecContext :: return new GDeflateCodecContext(api, codec);
- L70 C31: new byte :: encoded = new byte[(int)bound];
- L125 C31: new byte :: decoded = new byte[expectedDecodedLength];
- L179 C26: new StringBuilder :: var sb = new StringBuilder(byteStr.Length);
- L254 C23: new FormatException :: throw new FormatException(
- L268 C23: new FormatException :: throw new FormatException("Compressed byte string contains invalid hexadecimal characters.", ex);
- L275 C57: new() :: SevenZip.Compression.LZMA.Encoder encoder = new();
- L277 C44: new() :: using MemoryStream outStream = new();
- L305 C25: new() :: encoder ??= new();
- L306 C32: new() :: inStreamObject ??= new();
- L307 C33: new() :: outStreamObject ??= new();
- L326 C57: new() :: SevenZip.Compression.LZMA.Decoder decoder = new();
- L331 C33: new byte :: byte[] properties = new byte[5];
- L333 C34: new byte :: byte[] lengthBytes = new byte[4];
- L353 C25: new() :: decoder ??= new();
- L354 C32: new() :: inStreamObject ??= new();
- L355 C33: new() :: outStreamObject ??= new();
- L368 C33: new byte :: byte[] properties = new byte[5];
- L370 C34: new byte :: byte[] lengthBytes = new byte[4];
- L389 C57: new() :: SevenZip.Compression.LZMA.Decoder decoder = new();
- L391 C44: new() :: using MemoryStream outStream = new();
- L394 C33: new byte :: byte[] properties = new byte[5];
- L398 C34: new byte :: byte[] lengthBytes = new byte[sizeByteCount];
- L436 C38: new UnmanagedMemoryStream :: using var inStream = new UnmanagedMemoryStream(ptr, span.Length);
- L438 C37: new byte :: byte[] properties = new byte[5];
- L449 C61: new() :: SevenZip.Compression.LZMA.Decoder decoder = new();
- L456 C43: new MemoryStream :: using var outStream = new MemoryStream(pooled, 0, (int)len, writable: true);
- L460 C37: new byte :: byte[] result = new byte[len];
- L518 C41: new byte :: byte[][] compressedChunks = new byte[chunkCount][];
- L519 C40: new int :: int[] chunkOriginalSizes = new int[chunkCount];
- L529 C32: new byte :: byte[] chunk = new byte[length];
- L548 C29: new byte :: byte[] result = new byte[headerSize + totalCompressed];
- L586 C23: new InvalidOperationException :: throw new InvalidOperationException("Not a chunked LZMA blob.");
- L594 C37: new int :: int[] compressedSizes = new int[chunkCount];
- L601 C35: new int :: int[] originalSizes = new int[chunkCount];
- L608 C29: new byte :: byte[] result = new byte[originalSize];
- L614 C42: new byte :: byte[] chunkCompressed = new byte[compressedSizes[i]];
- L642 C33: new byte :: byte[] header = new byte[sizeof(int)];
- L648 C29: new byte :: byte[] output = new byte[sizeof(int) + maxEncoded];
- L652 C23: new InvalidOperationException :: throw new InvalidOperationException("LZ4 compression failed.");
- L664 C23: new InvalidOperationException :: throw new InvalidOperationException("LZ4 blob too short.");
- L677 C27: new InvalidOperationException :: throw new InvalidOperationException($"LZ4 decode size mismatch: expected {originalSize}, got {decoded}.");
- L678 C33: new byte :: byte[] result = new byte[originalSize];
- L703 C36: new Compressor :: using var compressor = new Compressor(level);
- L714 C38: new Decompressor :: using var decompressor = new Decompressor();
- L725 C37: new byte :: byte[] result = new byte[written];
- L753 C23: new InvalidOperationException :: throw new InvalidOperationException("GDeflate compression is not available (DirectStorage codec not loaded).");
- L764 C23: new InvalidOperationException :: throw new InvalidOperationException("GDeflate decompression failed or is not available.");
- L847 C28: new NotSupportedException :: _ => throw new NotSupportedException($"Unknown compression codec: {codec}"),
- L865 C28: new NotSupportedException :: _ => throw new NotSupportedException($"Unknown compression codec: {codec}"),
- L900 C25: new float :: var qRest = new float[3];
- L911 C41: new int :: int[] quantizedComponents = new int[3];
- L933 C40: new float :: float[] scaledComponents = new float[3];
- L952 C28: new() :: Quaternion q = new();
- L987 C32: new byte :: byte[] byteArray = new byte[totalBytes];
- L1051 C41: new int :: int[] quantizedComponents = new int[3];
- L1082 C28: new byte :: byte[] bytes = new byte[(bits + 7) / 8];


## XREngine.Data/Core/Memory/DataSource.cs
- L18 C50: new DataSourceFormatter :: MemoryPackFormatterProvider.Register(new DataSourceFormatter());
- L137 C28: new byte :: byte[] bytes = new byte[Length];
- L144 C30: new short :: short[] shorts = new short[Length / 2];
- L151 C30: new float :: float[] floats = new float[Length / 4];
- L159 C24: new DataSource :: return new DataSource(Address, Length, false);
- L172 C28: new Span :: ReadExactly(s, new Span<byte>(ptr, (int)source.Length));
- L210 C27: new EndOfStreamException :: throw new EndOfStreamException($"Stream ended early: expected {buffer.Length} bytes, got {totalRead} bytes.");
- L255 C29: new DataSource :: value = new DataSource(0);
- L260 C25: new DataSource :: value = new DataSource(payload);


## XREngine.Data/Core/Memory/FileMap.cs
- L46 C30: new FileStream :: stream = new FileStream(path, FileMode.Open, (prot == FileMapProtect.ReadWrite) ? FileAccess.ReadWrite : FileAccess.Read, FileShare.Read, 8, options);
- L53 C26: new FileStream :: stream = new FileStream(tempPath, FileMode.Open, FileAccess.ReadWrite, FileShare.Read, 8, options | FileOptions.DeleteOnClose);
- L71 C33: new FileStream :: FileStream stream = new FileStream(path = Path.GetTempFileName(), FileMode.Open, FileAccess.ReadWrite, FileShare.Read, 8, FileOptions.RandomAccess | FileOptions.DeleteOnClose);
- L101 C39: new WFileMap :: PlatformID.Win32NT => new WFileMap(stream.SafeFileHandle.DangerousGetHandle(), prot, offset, length) { _path = stream.Name },
- L102 C22: new CFileMap :: _ => new CFileMap(stream, prot, offset, length) { _path = stream.Name },
- L117 C39: new WFileMap :: PlatformID.Win32NT => new WFileMap(stream.SafeFileHandle.DangerousGetHandle(), prot, offset, length) { _baseStream = stream, _path = stream.Name },
- L118 C22: new CFileMap :: _ => new CFileMap(stream, prot, offset, length) { _baseStream = stream, _path = stream.Name },


## XREngine.Data/Core/Memory/FloatQuantizeHeader.cs
- L37 C27: new InvalidOperationException :: throw new InvalidOperationException("Bit count must be between 1 and 32.");
- L52 C27: new InvalidOperationException :: throw new InvalidOperationException("Component count must be 1, 2, 3 or 4.");


## XREngine.Data/Core/Memory/FloatQuantizer.cs
- L96 C49: new float :: _pData = [.. values.SelectMany(x => new float[] { x.X, x.Y, x.Z, x.W })];
- L103 C49: new float :: _pData = [.. values.SelectMany(x => new float[] { x.X, x.Y, x.Z })];
- L110 C49: new float :: _pData = [.. values.SelectMany(x => new float[] { x.X, x.Y })];
- L122 C16: new() :: => new()
- L161 C20: new Vector4 :: _min = new Vector4(float.MaxValue);
- L162 C20: new Vector4 :: _max = new Vector4(float.MinValue);
- L284 C32: new Vector4 :: Vector4[] values = new Vector4[header.ElementCount];
- L294 C32: new Vector3 :: Vector3[] values = new Vector3[header.ElementCount];
- L304 C32: new Vector2 :: Vector2[] values = new Vector2[header.ElementCount];
- L314 C30: new float :: float[] values = new float[header.ElementCount];
- L335 C36: new() :: BoolVector4 included = new() { X = hasX, Y = hasY, Z = hasZ, W = hasW };


## XREngine.Data/Core/Memory/FloatQuantizer1.cs
- L14 C23: new ArgumentException :: throw new ArgumentException("maxError must be greater than zero.");
- L71 C23: new ArgumentException :: throw new ArgumentException("Input and output spans must have the same length.");
- L88 C23: new ArgumentException :: throw new ArgumentException("Input and output spans must have the same length.");
- L104 C23: new ArgumentException :: throw new ArgumentException("values span cannot be empty.");
- L134 C36: new byte :: Span<byte> byteArray = new byte[totalBytes];
- L157 C23: new ArgumentException :: throw new ArgumentException("The byteArray is too small to hold the quantized data.");
- L185 C23: new ArgumentException :: throw new ArgumentException("The byteArray does not contain enough data.");


## XREngine.Data/Core/Memory/NvCompInterop.cs
- L168 C23: new InvalidOperationException :: throw new InvalidOperationException($"CUDA error {err} during {context}.");
- L175 C23: new InvalidOperationException :: throw new InvalidOperationException($"nvCOMP error {status} during {context}.");
- L194 C23: new NotSupportedException :: throw new NotSupportedException("nvCOMP native library is not available.");
- L201 C24: new nvcompBatchedLZ4Opts_t :: var opts = new nvcompBatchedLZ4Opts_t { data_type = 0 };
- L262 C45: new byte :: byte[] result = new byte[4 + (int)compressedSize];
- L314 C23: new NotSupportedException :: throw new NotSupportedException("nvCOMP native library is not available.");
- L317 C23: new ArgumentException :: throw new ArgumentException("Compressed data too short — missing size header.", nameof(compressed));
- L383 C45: new byte :: byte[] result = new byte[uncompressedSize];


## XREngine.Data/Core/Memory/VoidPtr.cs
- L15 C47: new() :: public static readonly VoidPtr Zero = new() { _address = null };
- L146 C16: new() :: => new() { _address = ((byte*)p1._address + addr) };
- L148 C16: new() :: => new() { _address = ((byte*)p1._address - addr) };
- L151 C16: new() :: => new() { _address = ((byte*)p1._address + addr) };
- L153 C16: new() :: => new() { _address = ((byte*)p1._address - addr) };
- L156 C16: new() :: => new() { _address = ((byte*)p1._address + addr) };
- L158 C16: new() :: => new() { _address = ((byte*)p1._address - addr) };
- L161 C16: new() :: => new() { _address = ((byte*)p1._address + addr) };
- L163 C16: new() :: => new() { _address = ((byte*)p1._address - addr) };
- L186 C16: new() :: => new() { _address = ptr };
- L191 C16: new() :: => new() { _address = (void*)ptr };
- L195 C16: new() :: => new() { _address = (void*)ptr };
- L200 C16: new() :: => new() { _address = (void*)ptr };
- L204 C16: new() :: => new() { _address = (void*)ptr };
- L207 C16: new() :: => new() { _address = (void*)ptr };
- L408 C26: new byte :: byte[] arr = new byte[count];


## XREngine.Data/Core/Memory/Win32.cs
- L17 C81: new SafeHandle :: public static implicit operator SafeHandle(VoidPtr handle) { return new SafeHandle(handle); }
- L24 C24: new SafeHandle :: return new SafeHandle(hFile);


## XREngine.Data/Core/Objects/OverrideableSettingsOwnerBase.cs
- L12 C44: new OverrideableSettingsTracker :: _overrideableSettingsTracker = new OverrideableSettingsTracker(this, OnOverrideableSettingChanged);


## XREngine.Data/Core/Objects/OverrideableSettingsTracker.cs
- L14 C101: new() :: private readonly Dictionary<IOverrideableSetting, string> _overrideableSettingPropertyMap = new();


## XREngine.Data/Core/Objects/XRBase.cs
- L23 C88: new() :: private static readonly AsyncLocal<int> PropertyNotificationSuppressionDepth = new();
- L28 C16: new PropertyNotificationSuppressionScope :: => new PropertyNotificationSuppressionScope();
- L185 C46: new XRPropertyChangedEventArgs :: => PropertyChanged?.Invoke(this, new XRPropertyChangedEventArgs<T>(propName, prev, field));
- L193 C24: new XRPropertyChangingEventArgs :: var args = new XRPropertyChangingEventArgs<T>(propName, field, @new);


## XREngine.Data/Core/Objects/XRObjectBase.cs
- L55 C27: new Exception :: throw new Exception("Failed to generate a unique ID for an object."); //Highly unlikely
- L88 C83: new() :: private static readonly ConcurrentQueue<XRObjectBase> _objectsToDestroy = new();


## XREngine.Data/Core/OverrideableSetting.cs
- L161 C21: new OverrideableSetting :: value = new OverrideableSetting<T>(settingValue, hasOverride);


## XREngine.Data/Core/Type Converters/DataSourceYamlTypeConverter.cs
- L94 C34: new DataSource :: result = new DataSource(length ?? 0u, zeroMemory: true) { PreferCompressedYaml = false };
- L99 C34: new DataSource :: result = new DataSource(rawBytes) { PreferCompressedYaml = false };
- L104 C30: new DataSource :: result = new DataSource(Compression.DecompressFromString(length, byteStr)) { PreferCompressedYaml = true };
- L117 C24: new DataSource :: return new DataSource(fallbackLength, zeroMemory: true);
- L126 C26: new MappingStart :: emitter.Emit(new MappingStart(null, null, false, MappingStyle.Block));
- L128 C30: new Scalar :: emitter.Emit(new Scalar("Length"));
- L129 C30: new Scalar :: emitter.Emit(new Scalar(source.Length.ToString()));
- L133 C34: new Scalar :: emitter.Emit(new Scalar("Encoding"));
- L134 C34: new Scalar :: emitter.Emit(new Scalar("RawHex"));
- L136 C34: new Scalar :: emitter.Emit(new Scalar("Bytes"));
- L137 C34: new Scalar :: emitter.Emit(new Scalar(Convert.ToHexString(source.GetBytes())));
- L141 C34: new Scalar :: emitter.Emit(new Scalar("Bytes"));
- L142 C34: new Scalar :: emitter.Emit(new Scalar(Compression.CompressToString(source)));
- L145 C26: new MappingEnd :: emitter.Emit(new MappingEnd());
- L151 C23: new YamlException :: throw new YamlException(errorMessage);
- L183 C19: new YamlException :: throw new YamlException("Unsupported YAML node encountered while skipping a value.");
- L222 C22: new System.Text.StringBuilder :: var sb = new System.Text.StringBuilder(hex.Length);


## XREngine.Data/Core/Type Converters/Matrix4x4YamlTypeConverter.cs
- L16 C23: new YamlException :: throw new YamlException("Expected a scalar value to deserialize a Matrix4x4.");
- L19 C23: new YamlException :: throw new YamlException("Expected Matrix4x4 format 'M00 M01 M02 M03 M10 M11 M12 M13 M20 M21 M22 M23 M30 M31 M32 M33'.");
- L36 C20: new Matrix4x4 :: return new Matrix4x4(
- L45 C26: new Scalar :: emitter.Emit(new Scalar($"{m4x4.M11} {m4x4.M12} {m4x4.M13} {m4x4.M14} {m4x4.M21} {m4x4.M22} {m4x4.M23} {m4x4.M24} {m4x4.M31} {m4x4.M32} {m4x4.M33} {m4x4.M34} {m4x4.M41} {m4x4.M42} {m4x4.M43} {m4x4.M44}"));


## XREngine.Data/Core/Type Converters/OverrideableSettingYamlTypeConverter.cs
- L25 C23: new YamlException :: throw new YamlException("Expected a mapping to deserialize an OverrideableSetting.");
- L34 C27: new YamlException :: throw new YamlException("Expected a scalar key while deserializing OverrideableSetting.");
- L69 C26: new MappingStart :: emitter.Emit(new MappingStart(null, null, false, MappingStyle.Block));
- L73 C30: new Scalar :: emitter.Emit(new Scalar(nameof(OverrideableSetting<int>.HasOverride)));
- L76 C30: new Scalar :: emitter.Emit(new Scalar(nameof(OverrideableSetting<int>.Value)));
- L80 C26: new MappingEnd :: emitter.Emit(new MappingEnd());


## XREngine.Data/Core/Type Converters/QuaternionTypeConverter.cs
- L17 C28: new Quaternion :: return new Quaternion(float.Parse(parts[0]), float.Parse(parts[1]), float.Parse(parts[2]), float.Parse(parts[3]));


## XREngine.Data/Core/Type Converters/QuaternionYamlTypeConverter.cs
- L16 C23: new YamlException :: throw new YamlException("Expected a scalar value to deserialize a Vector4.");
- L19 C23: new YamlException :: throw new YamlException("Expected Vector4 format 'X Y Z W'.");
- L24 C20: new Quaternion :: return new Quaternion(x, y, z, w);
- L29 C26: new Scalar :: emitter.Emit(new Scalar($"{v4.X} {v4.Y} {v4.Z} {v4.W}"));


## XREngine.Data/Core/Type Converters/Vector2TypeConverter.cs
- L17 C28: new Vector2 :: return new Vector2(float.Parse(parts[0]), float.Parse(parts[1]));


## XREngine.Data/Core/Type Converters/Vector2YamlTypeConverter.cs
- L16 C23: new YamlException :: throw new YamlException("Expected a scalar value to deserialize a Vector2.");
- L19 C23: new YamlException :: throw new YamlException("Expected Vector2 format 'X Y'.");
- L22 C20: new Vector2 :: return new Vector2(x, y);
- L27 C26: new Scalar :: emitter.Emit(new Scalar($"{v2.X} {v2.Y}"));


## XREngine.Data/Core/Type Converters/Vector3TypeConverter.cs
- L17 C28: new Vector3 :: return new Vector3(float.Parse(parts[0]), float.Parse(parts[1]), float.Parse(parts[2]));


## XREngine.Data/Core/Type Converters/Vector3YamlTypeConverter.cs
- L17 C23: new YamlException :: throw new YamlException("Expected a scalar value to deserialize a Vector3.");
- L21 C23: new YamlException :: throw new YamlException("Expected Vector3 format 'X Y Z'.");
- L26 C20: new Vector3 :: return new Vector3(x, y, z);
- L32 C26: new Scalar :: emitter.Emit(new Scalar($"{v3.X} {v3.Y} {v3.Z}"));


## XREngine.Data/Core/Type Converters/Vector4TypeConverter.cs
- L17 C28: new Vector4 :: return new Vector4(float.Parse(parts[0]), float.Parse(parts[1]), float.Parse(parts[2]), float.Parse(parts[3]));


## XREngine.Data/Core/Type Converters/Vector4YamlTypeConverter.cs
- L16 C23: new YamlException :: throw new YamlException("Expected a scalar value to deserialize a Vector4.");
- L19 C23: new YamlException :: throw new YamlException("Expected Vector4 format 'X Y Z W'.");
- L24 C20: new Vector4 :: return new Vector4(x, y, z, w);
- L29 C26: new Scalar :: emitter.Emit(new Scalar($"{v4.X} {v4.Y} {v4.Z} {v4.W}"));


## XREngine.Data/Core/UserSettings.cs
- L160 C64: new() :: private OverrideableSetting<int> _jobWorkersOverride = new();
- L161 C66: new() :: private OverrideableSetting<int> _jobWorkerCapOverride = new();
- L162 C67: new() :: private OverrideableSetting<int> _jobQueueLimitOverride = new();
- L163 C78: new() :: private OverrideableSetting<int> _jobQueueWarningThresholdOverride = new();
- L164 C72: new() :: private OverrideableSetting<bool> _gpuRenderDispatchOverride = new();
- L165 C82: new() :: private OverrideableSetting<EOutputVerbosity> _outputVerbosityOverride = new();
- L166 C84: new() :: private OverrideableSetting<bool> _enableGpuIndirectDebugLoggingOverride = new();
- L167 C83: new() :: private OverrideableSetting<bool> _enableGpuIndirectCpuFallbackOverride = new();
- L168 C89: new() :: private OverrideableSetting<bool> _enableGpuIndirectValidationLoggingOverride = new();
- L171 C84: new() :: private OverrideableSetting<EAntiAliasingMode> _antiAliasingModeOverride = new();
- L172 C70: new() :: private OverrideableSetting<uint> _msaaSampleCountOverride = new();
- L173 C66: new() :: private OverrideableSetting<EVSyncMode> _vSyncOverride = new();
- L174 C96: new() :: private OverrideableSetting<EGlobalIlluminationMode> _globalIlluminationModeOverride = new();
- L175 C81: new() :: private OverrideableSetting<bool> _tickGroupedItemsInParallelOverride = new();
- L176 C71: new() :: private OverrideableSetting<bool> _enableNvidiaDlssOverride = new();
- L177 C78: new() :: private OverrideableSetting<EDlssQualityMode> _dlssQualityOverride = new();
- L178 C70: new() :: private OverrideableSetting<bool> _enableIntelXessOverride = new();
- L179 C78: new() :: private OverrideableSetting<EXessQualityMode> _xessQualityOverride = new();
- L182 C78: new() :: private OverrideableSetting<float> _targetUpdatesPerSecondOverride = new();
- L183 C76: new() :: private OverrideableSetting<float> _fixedFramesPerSecondOverride = new();
- L184 C77: new() :: private OverrideableSetting<float> _targetFramesPerSecondOverride = new();
- L185 C86: new() :: private OverrideableSetting<float> _unfocusedTargetFramesPerSecondOverride = new();
- L196 C63: new() :: set => SetField(ref _jobWorkersOverride, value ?? new());
- L208 C65: new() :: set => SetField(ref _jobWorkerCapOverride, value ?? new());
- L220 C66: new() :: set => SetField(ref _jobQueueLimitOverride, value ?? new());
- L232 C77: new() :: set => SetField(ref _jobQueueWarningThresholdOverride, value ?? new());
- L244 C70: new() :: set => SetField(ref _gpuRenderDispatchOverride, value ?? new());
- L256 C68: new() :: set => SetField(ref _outputVerbosityOverride, value ?? new());
- L268 C82: new() :: set => SetField(ref _enableGpuIndirectDebugLoggingOverride, value ?? new());
- L280 C81: new() :: set => SetField(ref _enableGpuIndirectCpuFallbackOverride, value ?? new());
- L292 C87: new() :: set => SetField(ref _enableGpuIndirectValidationLoggingOverride, value ?? new());
- L304 C69: new() :: set => SetField(ref _antiAliasingModeOverride, value ?? new());
- L316 C68: new() :: set => SetField(ref _msaaSampleCountOverride, value ?? new());
- L328 C58: new() :: set => SetField(ref _vSyncOverride, value ?? new());
- L340 C75: new() :: set => SetField(ref _globalIlluminationModeOverride, value ?? new());
- L352 C79: new() :: set => SetField(ref _tickGroupedItemsInParallelOverride, value ?? new());
- L364 C69: new() :: set => SetField(ref _enableNvidiaDlssOverride, value ?? new());
- L376 C64: new() :: set => SetField(ref _dlssQualityOverride, value ?? new());
- L388 C68: new() :: set => SetField(ref _enableIntelXessOverride, value ?? new());
- L400 C64: new() :: set => SetField(ref _xessQualityOverride, value ?? new());
- L412 C75: new() :: set => SetField(ref _targetUpdatesPerSecondOverride, value ?? new());
- L424 C73: new() :: set => SetField(ref _fixedFramesPerSecondOverride, value ?? new());
- L436 C74: new() :: set => SetField(ref _targetFramesPerSecondOverride, value ?? new());
- L448 C83: new() :: set => SetField(ref _unfocusedTargetFramesPerSecondOverride, value ?? new());


## XREngine.Data/Core/XRMath.cs
- L149 C20: new Vector2 :: return new Vector2(cos * radius, sin * radius);
- L154 C20: new Vector2 :: return new Vector2(cos * radius, sin * radius);
- L403 C26: new Complex :: x1 = new Complex(-b + mag, 0.0);
- L404 C26: new Complex :: x2 = new Complex(-b - mag, 0.0);
- L410 C26: new Complex :: x1 = new Complex(-b, mag);
- L411 C26: new Complex :: x2 = new Complex(-b, -mag);
- L762 C48: new Vector3 :: Vector3 result = Vector3.Transform(new Vector3(point, 0.0f),
- L763 C41: new Vector3 :: Matrix4x4.CreateTranslation(new Vector3(center, 0.0f)) *
- L764 C41: new Vector3 :: Matrix4x4.CreateTranslation(new Vector3(-center, 0.0f)) *
- L766 C20: new Vector2 :: return new Vector2(result.X, result.Y);
- L1029 C28: new int :: int[] values = new int[rowIndex + 1];
- L1161 C29: new() :: Vector3 euler = new();
- L1863 C20: new Vector3 :: return new Vector3(
- L1878 C24: new Vector3 :: return new Vector3(v.X, 0f, v.Z) * weight;
- L1889 C39: new Vector3 :: => normal == Globals.Up ? new Vector3(v.X, 0f, v.Z) : v - ProjectVector(v, normal);
- L2028 C24: new Vector3 :: return new Vector3(point.X, planePosition.Y, point.Z);


## XREngine.Data/Endian/bdouble.cs
- L17 C12: new() :: => new() { _data = Endian.SerializeBig ? val.Reverse() : val };


## XREngine.Data/Endian/bfloat.cs
- L17 C12: new() :: => new() { _data = Endian.SerializeBig ? val.Reverse() : val };


## XREngine.Data/Endian/bint.cs
- L17 C12: new() :: => new() { _data = Endian.SerializeBig ? val.Reverse() : val };


## XREngine.Data/Endian/blong.cs
- L17 C12: new() :: => new() { _data = Endian.SerializeBig ? val.Reverse() : val };


## XREngine.Data/Endian/BMatrix4.cs
- L30 C23: new() :: Matrix4x4 m = new();
- L40 C23: new() :: BMatrix4 bm = new();


## XREngine.Data/Endian/bshort.cs
- L17 C12: new() :: => new() { _data = Endian.SerializeBig ? val.Reverse() : val };


## XREngine.Data/Endian/buint.cs
- L17 C12: new() :: => new() { _data = Endian.SerializeBig ? val.Reverse() : val };


## XREngine.Data/Endian/BUInt24.cs
- L34 C64: new BUInt24 :: public static implicit operator BUInt24(uint val) { return new BUInt24(val); }
- L37 C63: new BUInt24 :: public static explicit operator BUInt24(int val) { return new BUInt24((uint)val); }
- L39 C66: new UInt24 :: public static implicit operator UInt24(BUInt24 val) { return new UInt24(val.Value); }
- L40 C66: new BUInt24 :: public static implicit operator BUInt24(UInt24 val) { return new BUInt24(val.Value); }


## XREngine.Data/Endian/bulong.cs
- L17 C12: new() :: => new() { _data = Endian.SerializeBig ? val.Reverse() : val };


## XREngine.Data/Endian/bushort.cs
- L17 C12: new() :: => new() { _data = Endian.SerializeBig ? val.Reverse() : val };


## XREngine.Data/Endian/SNormFloat4.cs
- L14 C23: new ArgumentOutOfRangeException :: throw new ArgumentOutOfRangeException(nameof(floatValue), "Value must be between -1.0 and 1.0");


## XREngine.Data/Endian/SNormFloat8.cs
- L14 C23: new ArgumentOutOfRangeException :: throw new ArgumentOutOfRangeException(nameof(floatValue), "Value must be between -1.0 and 1.0");


## XREngine.Data/Endian/UInt24.cs
- L26 C63: new UInt24 :: public static implicit operator UInt24(uint val) { return new UInt24(val); }


## XREngine.Data/Endian/UNormFloat4.cs
- L14 C23: new ArgumentOutOfRangeException :: throw new ArgumentOutOfRangeException(nameof(floatValue), "Value must be between 0.0 and 1.0");


## XREngine.Data/Endian/UNormFloat8.cs
- L14 C23: new ArgumentOutOfRangeException :: throw new ArgumentOutOfRangeException(nameof(floatValue), "Value must be between 0.0 and 1.0");


## XREngine.Data/EventDictionary.cs
- L44 C16: new TValue :: public new TValue this[TKey key]
- L63 C16: new void :: public new void Add(TKey key, TValue value)
- L70 C16: new void :: public new void Clear()
- L80 C16: new bool :: public new bool Remove(TKey key)


## XREngine.Data/Geometry/AABB.cs
- L26 C20: new AABB :: return new AABB(center - extents, center + extents);
- L159 C20: new AABB :: return new AABB(newMin, newMax);
- L222 C19: new Vector3 :: TBL = new Vector3(Left, Top, Back);
- L223 C19: new Vector3 :: TBR = new Vector3(Right, Top, Back);
- L225 C19: new Vector3 :: TFL = new Vector3(Left, Top, Front);
- L226 C19: new Vector3 :: TFR = new Vector3(Right, Top, Front);
- L228 C19: new Vector3 :: BBL = new Vector3(Left, Bottom, Back);
- L229 C19: new Vector3 :: BBR = new Vector3(Right, Bottom, Back);
- L231 C19: new Vector3 :: BFL = new Vector3(Left, Bottom, Front);
- L232 C19: new Vector3 :: BFR = new Vector3(Right, Bottom, Front);
- L279 C37: new Vector3 :: TBL = Vector3.Transform(new Vector3(Left, Top, Back), transform);
- L280 C37: new Vector3 :: TBR = Vector3.Transform(new Vector3(Right, Top, Back), transform);
- L282 C37: new Vector3 :: TFL = Vector3.Transform(new Vector3(Left, Top, Front), transform);
- L283 C37: new Vector3 :: TFR = Vector3.Transform(new Vector3(Right, Top, Front), transform);
- L285 C37: new Vector3 :: BBL = Vector3.Transform(new Vector3(Left, Bottom, Back), transform);
- L286 C37: new Vector3 :: BBR = Vector3.Transform(new Vector3(Right, Bottom, Back), transform);
- L288 C37: new Vector3 :: BFL = Vector3.Transform(new Vector3(Left, Bottom, Front), transform);
- L289 C37: new Vector3 :: BFR = Vector3.Transform(new Vector3(Right, Bottom, Front), transform);
- L314 C25: new Vector3 :: var array = new Vector3[]
- L364 C16: new() :: => new()
- L416 C19: new NotImplementedException :: throw new NotImplementedException();
- L466 C20: new AABB :: return new AABB(min, max);
- L472 C20: new AABB :: return new AABB(min, max);
- L476 C67: new Vector3 :: Vector3 min = Vector3.Min(bounds.Min, sphere.Center - new Vector3(sphere.Radius));
- L477 C67: new Vector3 :: Vector3 max = Vector3.Max(bounds.Max, sphere.Center + new Vector3(sphere.Radius));
- L478 C20: new AABB :: return new AABB(min, max);
- L484 C20: new AABB :: return new AABB(min, max);
- L536 C36: new Vector3 :: Vector3 min = center - new Vector3(radius);
- L537 C36: new Vector3 :: Vector3 max = center + new Vector3(radius);
- L538 C20: new AABB :: return new AABB(min, max);
- L545 C20: new AABB :: return new AABB(min, max);
- L552 C20: new AABB :: return new AABB(min, max);


## XREngine.Data/Geometry/BoundingRectangle.cs
- L17 C58: new() :: public static readonly BoundingRectangle Empty = new();
- L66 C20: new IVector2 :: : this(new IVector2(x, y), new IVector2(width, height), new Vector2(localOriginPercentageX, localOriginPercentageY)) { }
- L66 C40: new IVector2 :: : this(new IVector2(x, y), new IVector2(width, height), new Vector2(localOriginPercentageX, localOriginPercentageY)) { }
- L66 C69: new Vector2 :: : this(new IVector2(x, y), new IVector2(width, height), new Vector2(localOriginPercentageX, localOriginPercentageY)) { }
- L69 C20: new IVector2 :: : this(new IVector2(x, y), new IVector2(width, height)) { }
- L69 C40: new IVector2 :: : this(new IVector2(x, y), new IVector2(width, height)) { }
- L260 C20: new Rectangle :: return new Rectangle(pos.X, containerHeight - pos.Y, Width, Height);


## XREngine.Data/Geometry/BoundingRectangleF.cs
- L17 C59: new() :: public static readonly BoundingRectangleF Empty = new();
- L64 C20: new Vector2 :: : this(new Vector2(x, y), new Vector2(width, height), new Vector2(localOriginPercentageX, localOriginPercentageY)) { }
- L64 C39: new Vector2 :: : this(new Vector2(x, y), new Vector2(width, height), new Vector2(localOriginPercentageX, localOriginPercentageY)) { }
- L64 C67: new Vector2 :: : this(new Vector2(x, y), new Vector2(width, height), new Vector2(localOriginPercentageX, localOriginPercentageY)) { }
- L66 C20: new Vector2 :: : this(new Vector2(x, y), new Vector2(width, height)) { }
- L66 C39: new Vector2 :: : this(new Vector2(x, y), new Vector2(width, height)) { }
- L174 C44: new Vector2 :: readonly get => _translation + new Vector2(Width < 0 ? Width : 0, Height < 0 ? Height : 0);
- L187 C44: new Vector2 :: readonly get => _translation + new Vector2(Width > 0 ? Width : 0, Height > 0 ? Height : 0);
- L290 C20: new RectangleF :: return new RectangleF(pos.X, containerHeight - pos.Y, Width, Height);
- L357 C32: new Vector2 :: => _translation += new Vector2(x, y);
- L361 C35: new Vector2 :: => new(_translation + new Vector2(x, y), _bounds, _localOriginPercentage);


## XREngine.Data/Geometry/Box.cs
- L59 C17: new Vector3 :: new Vector3(min.X, min.Y, min.Z),
- L60 C17: new Vector3 :: new Vector3(max.X, min.Y, min.Z),
- L61 C17: new Vector3 :: new Vector3(min.X, max.Y, min.Z),
- L62 C17: new Vector3 :: new Vector3(max.X, max.Y, min.Z),
- L63 C17: new Vector3 :: new Vector3(min.X, min.Y, max.Z),
- L64 C17: new Vector3 :: new Vector3(max.X, min.Y, max.Z),
- L65 C17: new Vector3 :: new Vector3(min.X, max.Y, max.Z),
- L66 C17: new Vector3 :: new Vector3(max.X, max.Y, max.Z)
- L71 C17: new Plane :: new Plane(Vector3.UnitX, -min.X),
- L72 C17: new Plane :: new Plane(-Vector3.UnitX, max.X),
- L73 C17: new Plane :: new Plane(Vector3.UnitY, -min.Y),
- L74 C17: new Plane :: new Plane(-Vector3.UnitY, max.Y),
- L75 C17: new Plane :: new Plane(Vector3.UnitZ, -min.Z),
- L76 C17: new Plane :: new Plane(-Vector3.UnitZ, max.Z)
- L146 C26: new Vector3 :: _localSize = new Vector3(uniformSize);
- L151 C26: new Vector3 :: _localSize = new Vector3(sizeX, sizeY, sizeZ);
- L232 C19: new NotImplementedException :: throw new NotImplementedException();
- L237 C19: new NotImplementedException :: throw new NotImplementedException();
- L242 C19: new NotImplementedException :: throw new NotImplementedException();
- L247 C19: new NotImplementedException :: throw new NotImplementedException();
- L252 C19: new NotImplementedException :: throw new NotImplementedException();
- L257 C19: new NotImplementedException :: throw new NotImplementedException();


## XREngine.Data/Geometry/Capsule.cs
- L142 C28: new Exception :: _ => throw new Exception(),
- L189 C19: new NotImplementedException :: throw new NotImplementedException();
- L352 C19: new NotImplementedException :: throw new NotImplementedException();


## XREngine.Data/Geometry/CapsuleX.cs
- L37 C19: new NotImplementedException :: throw new NotImplementedException();
- L42 C19: new NotImplementedException :: throw new NotImplementedException();
- L47 C19: new NotImplementedException :: throw new NotImplementedException();
- L52 C19: new NotImplementedException :: throw new NotImplementedException();
- L57 C19: new NotImplementedException :: throw new NotImplementedException();
- L62 C19: new NotImplementedException :: throw new NotImplementedException();
- L67 C19: new NotImplementedException :: throw new NotImplementedException();
- L72 C19: new NotImplementedException :: throw new NotImplementedException();
- L77 C19: new NotImplementedException :: throw new NotImplementedException();
- L82 C19: new NotImplementedException :: throw new NotImplementedException();


## XREngine.Data/Geometry/CapsuleY.cs
- L37 C19: new NotImplementedException :: throw new NotImplementedException();
- L42 C19: new NotImplementedException :: throw new NotImplementedException();
- L47 C19: new NotImplementedException :: throw new NotImplementedException();
- L52 C19: new NotImplementedException :: throw new NotImplementedException();
- L57 C19: new NotImplementedException :: throw new NotImplementedException();
- L62 C19: new NotImplementedException :: throw new NotImplementedException();
- L67 C19: new NotImplementedException :: throw new NotImplementedException();
- L72 C19: new NotImplementedException :: throw new NotImplementedException();
- L77 C19: new NotImplementedException :: throw new NotImplementedException();
- L82 C19: new NotImplementedException :: throw new NotImplementedException();


## XREngine.Data/Geometry/CapsuleZ.cs
- L37 C19: new NotImplementedException :: throw new NotImplementedException();
- L42 C19: new NotImplementedException :: throw new NotImplementedException();
- L47 C19: new NotImplementedException :: throw new NotImplementedException();
- L52 C19: new NotImplementedException :: throw new NotImplementedException();
- L57 C19: new NotImplementedException :: throw new NotImplementedException();
- L62 C19: new NotImplementedException :: throw new NotImplementedException();
- L67 C19: new NotImplementedException :: throw new NotImplementedException();
- L72 C19: new NotImplementedException :: throw new NotImplementedException();
- L77 C19: new NotImplementedException :: throw new NotImplementedException();
- L82 C19: new NotImplementedException :: throw new NotImplementedException();


## XREngine.Data/Geometry/Circle3D.cs
- L16 C22: new Plane :: _plane = new Plane(Globals.Up, 0.0f);
- L21 C22: new Plane :: _plane = new Plane(normal, distance);
- L28 C22: new Plane :: _plane = new Plane(normal, distance);
- L34 C22: new Plane :: _plane = new Plane(normal, distance);


## XREngine.Data/Geometry/Cone.cs
- L64 C19: new NotImplementedException :: throw new NotImplementedException();
- L69 C19: new NotImplementedException :: throw new NotImplementedException();
- L74 C19: new NotImplementedException :: throw new NotImplementedException();
- L92 C19: new NotImplementedException :: throw new NotImplementedException();
- L97 C19: new NotImplementedException :: throw new NotImplementedException();
- L102 C19: new NotImplementedException :: throw new NotImplementedException();
- L107 C19: new NotImplementedException :: throw new NotImplementedException();


## XREngine.Data/Geometry/ConeX.cs
- L53 C19: new NotImplementedException :: throw new NotImplementedException();
- L58 C19: new NotImplementedException :: throw new NotImplementedException();
- L63 C19: new NotImplementedException :: throw new NotImplementedException();
- L68 C19: new NotImplementedException :: throw new NotImplementedException();
- L73 C19: new NotImplementedException :: throw new NotImplementedException();
- L78 C19: new NotImplementedException :: throw new NotImplementedException();
- L83 C19: new NotImplementedException :: throw new NotImplementedException();
- L88 C19: new NotImplementedException :: throw new NotImplementedException();
- L93 C19: new NotImplementedException :: throw new NotImplementedException();


## XREngine.Data/Geometry/ConeY.cs
- L53 C19: new NotImplementedException :: throw new NotImplementedException();
- L58 C19: new NotImplementedException :: throw new NotImplementedException();
- L63 C19: new NotImplementedException :: throw new NotImplementedException();
- L68 C19: new NotImplementedException :: throw new NotImplementedException();
- L73 C19: new NotImplementedException :: throw new NotImplementedException();
- L78 C19: new NotImplementedException :: throw new NotImplementedException();
- L83 C19: new NotImplementedException :: throw new NotImplementedException();
- L88 C19: new NotImplementedException :: throw new NotImplementedException();
- L93 C19: new NotImplementedException :: throw new NotImplementedException();


## XREngine.Data/Geometry/ConeZ.cs
- L53 C19: new NotImplementedException :: throw new NotImplementedException();
- L58 C19: new NotImplementedException :: throw new NotImplementedException();
- L63 C19: new NotImplementedException :: throw new NotImplementedException();
- L68 C19: new NotImplementedException :: throw new NotImplementedException();
- L73 C19: new NotImplementedException :: throw new NotImplementedException();
- L78 C19: new NotImplementedException :: throw new NotImplementedException();
- L83 C19: new NotImplementedException :: throw new NotImplementedException();
- L88 C19: new NotImplementedException :: throw new NotImplementedException();
- L93 C19: new NotImplementedException :: throw new NotImplementedException();


## XREngine.Data/Geometry/Frustum.cs
- L23 C47: new Vector3 :: private readonly Vector3[] _corners = new Vector3[8];
- L30 C23: new InvalidOperationException :: throw new InvalidOperationException("Cannot invert the MVP matrix.");
- L51 C31: new Vector3 :: _corners[i] = new Vector3(corner.X, corner.Y, corner.Z);
- L55 C44: new Plane :: private readonly Plane[] _planes = new Plane[6];
- L61 C20: new Plane :: Left = new Plane(
- L68 C21: new Plane :: Right = new Plane(
- L75 C22: new Plane :: Bottom = new Plane(
- L82 C19: new Plane :: Top = new Plane(
- L89 C20: new Plane :: Near = new Plane(
- L96 C19: new Plane :: Far = new Plane(
- L115 C34: new Plane :: _planes[0] = new Plane(-_planes[0].Normal, -_planes[0].D);
- L127 C34: new Plane :: _planes[1] = new Plane(-_planes[1].Normal, -_planes[1].D);
- L139 C34: new Plane :: _planes[2] = new Plane(-_planes[2].Normal, -_planes[2].D);
- L151 C34: new Plane :: _planes[3] = new Plane(-_planes[3].Normal, -_planes[3].D);
- L163 C34: new Plane :: _planes[4] = new Plane(-_planes[4].Normal, -_planes[4].D);
- L175 C34: new Plane :: _planes[5] = new Plane(-_planes[5].Normal, -_planes[5].D);
- L187 C39: new Vector3 :: DivideW(Vector4.Transform(new Vector3(-1.0f, -1.0f, 0.0f), invProj)),
- L188 C39: new Vector3 :: DivideW(Vector4.Transform(new Vector3(1.0f, -1.0f, 0.0f), invProj)),
- L189 C39: new Vector3 :: DivideW(Vector4.Transform(new Vector3(-1.0f, 1.0f, 0.0f), invProj)),
- L190 C39: new Vector3 :: DivideW(Vector4.Transform(new Vector3(1.0f, 1.0f, 0.0f), invProj)),
- L191 C39: new Vector3 :: DivideW(Vector4.Transform(new Vector3(-1.0f, -1.0f, 1.0f), invProj)),
- L192 C39: new Vector3 :: DivideW(Vector4.Transform(new Vector3(1.0f, -1.0f, 1.0f), invProj)),
- L193 C39: new Vector3 :: DivideW(Vector4.Transform(new Vector3(-1.0f, 1.0f, 1.0f), invProj)),
- L194 C39: new Vector3 :: DivideW(Vector4.Transform(new Vector3(1.0f, 1.0f, 1.0f), invProj))) { }
- L206 C17: new Vector3 :: new Vector3(-w, -h, -farPlane),
- L207 C17: new Vector3 :: new Vector3(w, h, -nearPlane),
- L445 C22: new Plane :: f.Near = new Plane(_planes[4].Normal, _planes[4].D - startDepth);
- L446 C21: new Plane :: f.Far = new Plane(_planes[5].Normal, _planes[5].D + endDepth);
- L517 C28: new NotImplementedException :: _ => throw new NotImplementedException(),
- L563 C19: new NotImplementedException :: throw new NotImplementedException();
- L576 C20: new AABB :: return new AABB(min, max);
- L581 C25: new() :: Frustum f = new();
- L594 C33: new List :: var intersections = new List<Vector3>();
- L738 C32: new Segment :: var frustumEdges = new Segment[]
- L772 C28: new Segment :: var boxEdges = new Segment[]


## XREngine.Data/Geometry/GeoUtil.cs
- L124 C39: new Plane :: PlaneIntersectsSphere(new Plane(Vector3.UnitX, XRMath.GetPlaneDistance(maximum, Vector3.UnitX)), sphere),
- L125 C39: new Plane :: PlaneIntersectsSphere(new Plane(-Vector3.UnitX, XRMath.GetPlaneDistance(minimum, -Vector3.UnitX)), sphere),
- L126 C39: new Plane :: PlaneIntersectsSphere(new Plane(Vector3.UnitY, XRMath.GetPlaneDistance(maximum, Vector3.UnitY)), sphere),
- L127 C39: new Plane :: PlaneIntersectsSphere(new Plane(-Vector3.UnitY, XRMath.GetPlaneDistance(minimum, -Vector3.UnitY)), sphere),
- L128 C39: new Plane :: PlaneIntersectsSphere(new Plane(Vector3.UnitZ, XRMath.GetPlaneDistance(maximum, Vector3.UnitZ)), sphere),
- L129 C39: new Plane :: PlaneIntersectsSphere(new Plane(-Vector3.UnitZ, XRMath.GetPlaneDistance(minimum, -Vector3.UnitZ)), sphere),
- L823 C24: new Ray :: line = new Ray();
- L830 C20: new Ray :: line = new Ray(point, point + Vector3.Normalize(direction));
- L1359 C19: new NotImplementedException :: throw new NotImplementedException();


## XREngine.Data/Geometry/Plane.cs
- L35 C20: new System.Numerics.Plane :: return new System.Numerics.Plane()
- L49 C20: new System.Numerics.Plane :: return new System.Numerics.Plane()
- L59 C16: new() :: => new()
- L134 C55: new Vector3 :: bottomLeft = position + Vector3.Transform(new Vector3(-0.5f * xExtent, -0.5f * yExtent, 0.0f), r);
- L135 C56: new Vector3 :: bottomRight = position + Vector3.Transform(new Vector3(0.5f * xExtent, -0.5f * yExtent, 0.0f), r);
- L136 C52: new Vector3 :: topLeft = position + Vector3.Transform(new Vector3(-0.5f * xExtent, 0.5f * yExtent, 0.0f), r);
- L137 C53: new Vector3 :: topRight = position + Vector3.Transform(new Vector3(0.5f * xExtent, 0.5f * yExtent, 0.0f), r);
- L174 C29: new int :: int[] indices = new int[3];
- L187 C30: new Triangle :: back.Add(new Triangle(vertices[i], vertices[j], vertices[k]));
- L192 C31: new Triangle :: front.Add(new Triangle(vertices[i], vertices[j], vertices[k]));


## XREngine.Data/Geometry/PreparedFrustum.cs
- L35 C23: new ArgumentException :: throw new ArgumentException("Frustum must have 6 planes.", nameof(planes));
- L37 C23: new ArgumentException :: throw new ArgumentException("Frustum must have 8 corners.", nameof(corners));
- L43 C18: new float :: Nx = new float[PlaneCount];
- L44 C18: new float :: Ny = new float[PlaneCount];
- L45 C18: new float :: Nz = new float[PlaneCount];
- L46 C17: new float :: D = new float[PlaneCount];
- L75 C30: new Plane :: Plane[] planes = new Plane[6];
- L76 C33: new Vector3 :: Vector3[] corners = new Vector3[8];
- L84 C20: new PreparedFrustum :: return new PreparedFrustum(planes, corners);


## XREngine.Data/Geometry/Ray.cs
- L25 C20: new Ray :: return new Ray(newStart, newEnd - newStart);
- L70 C22: new Vector3 :: result = new Vector3();
- L84 C26: new Vector3 :: result = new Vector3();


## XREngine.Data/Geometry/Sphere.cs
- L64 C19: new NotImplementedException :: throw new NotImplementedException();
- L69 C19: new NotImplementedException :: throw new NotImplementedException();
- L80 C29: new Vector3 :: => new(Center - new Vector3(Radius), Center + new Vector3(Radius));
- L80 C59: new Vector3 :: => new(Center - new Vector3(Radius), Center + new Vector3(Radius));


## XREngine.Data/Geometry/Triangle.cs
- L115 C27: new Vector3 :: barycentric = new Vector3(u, v, w);


## XREngine.Data/Half.cs
- L72 C23: new ArithmeticException :: throw new ArithmeticException("Half: Positive maximum value exceeded.");
- L75 C23: new ArithmeticException :: throw new ArithmeticException("Half: Negative minimum value exceeded.");
- L79 C23: new ArithmeticException :: throw new ArithmeticException("Half: Input is not a number (NaN).");
- L82 C23: new ArithmeticException :: throw new ArithmeticException("Half: Input is positive infinity.");
- L85 C23: new ArithmeticException :: throw new ArithmeticException("Half: Input is negative infinity.");
- L184 C27: new ArithmeticException :: throw new ArithmeticException("Half: Hardware floating-point overflow.");


## XREngine.Data/Interp.cs
- L70 C32: new Vector2 :: Vector2[] points = new Vector2[pointCount];
- L108 C23: new InvalidOperationException :: throw new InvalidOperationException();
- L110 C32: new Vector2 :: Vector2[] points = new Vector2[pointCount];
- L696 C20: new Point :: return new Point(
- L706 C20: new PointF :: return new PointF(
- L718 C31: new float :: float[] samples = new float[count];
- L729 C33: new Vector2 :: Vector2[] samples = new Vector2[count];
- L740 C33: new Vector3 :: Vector3[] samples = new Vector3[count];
- L751 C33: new Vector4 :: Vector4[] samples = new Vector4[count];


## XREngine.Data/Lists/ConsistentIndexList.cs
- L14 C54: new() :: private readonly ReaderWriterLockSlim _rwl = new();


## XREngine.Data/Lists/Deque/Deque.cs
- L85 C23: new ArgumentNullException :: throw new ArgumentNullException("col");
- L154 C28: new Node :: Node newNode = new Node(obj);
- L198 C28: new Node :: Node newNode = new Node(obj);
- L249 C23: new InvalidOperationException :: throw new InvalidOperationException("Deque is empty.");
- L302 C23: new InvalidOperationException :: throw new InvalidOperationException("Deque is empty.");
- L355 C23: new InvalidOperationException :: throw new InvalidOperationException("Deque is empty.");
- L378 C23: new InvalidOperationException :: throw new InvalidOperationException("Deque is empty.");
- L394 C31: new object :: object?[] array = new object[Count];
- L421 C23: new ArgumentNullException :: throw new ArgumentNullException("deque");
- L426 C20: new SynchronizedDeque :: return new SynchronizedDeque(deque);
- L549 C27: new InvalidOperationException :: throw new InvalidOperationException(
- L568 C31: new InvalidOperationException :: throw new InvalidOperationException(
- L585 C27: new InvalidOperationException :: throw new InvalidOperationException(
- L638 C27: new ArgumentNullException :: throw new ArgumentNullException("deque");
- L853 C23: new ArgumentNullException :: throw new ArgumentNullException("array");
- L857 C23: new ArgumentOutOfRangeException :: throw new ArgumentOutOfRangeException("index", index,
- L862 C23: new ArgumentException :: throw new ArgumentException("Array is multidimensional.");
- L866 C23: new ArgumentException :: throw new ArgumentException("Index is equal to or greater " +
- L871 C23: new ArgumentException :: throw new ArgumentException(
- L911 C20: new DequeEnumerator :: return new DequeEnumerator(this);
- L926 C27: new Deque :: Deque clone = new Deque(this);


## XREngine.Data/Lists/Deque/GenericDeque.cs
- L85 C23: new ArgumentNullException :: throw new ArgumentNullException("col");
- L143 C33: new Node :: Node? f = front ??= new Node(defaultValue);
- L147 C28: new Node :: f.Next ??= new Node(defaultValue) { Previous = f };
- L314 C23: new InvalidOperationException :: throw new InvalidOperationException("Deque is empty.");
- L367 C23: new InvalidOperationException :: throw new InvalidOperationException("Deque is empty.");
- L420 C23: new InvalidOperationException :: throw new InvalidOperationException("Deque is empty.");
- L443 C23: new InvalidOperationException :: throw new InvalidOperationException("Deque is empty.");
- L459 C25: new T :: T[] array = new T[Count];
- L488 C20: new SynchronizedDeque :: return new SynchronizedDeque(deque);
- L573 C23: new ArgumentNullException :: throw new ArgumentNullException(nameof(array));
- L577 C23: new ArgumentOutOfRangeException :: throw new ArgumentOutOfRangeException(nameof(index), index,
- L582 C23: new ArgumentException :: throw new ArgumentException("Array is multidimensional.");
- L586 C23: new ArgumentException :: throw new ArgumentException("Index is equal to or greater " +
- L591 C23: new ArgumentException :: throw new ArgumentException(
- L631 C20: new Enumerator :: return new Enumerator(this);
- L660 C20: new Enumerator :: return new Enumerator(this);


## XREngine.Data/Lists/Deque/GenericDeque.Enumerator.cs
- L39 C27: new ObjectDisposedException :: throw new ObjectDisposedException(this.GetType().Name);
- L43 C27: new InvalidOperationException :: throw new InvalidOperationException(
- L62 C31: new ObjectDisposedException :: throw new ObjectDisposedException(this.GetType().Name);
- L66 C31: new InvalidOperationException :: throw new InvalidOperationException(
- L83 C27: new ObjectDisposedException :: throw new ObjectDisposedException(this.GetType().Name);
- L87 C27: new InvalidOperationException :: throw new InvalidOperationException(
- L121 C31: new ObjectDisposedException :: throw new ObjectDisposedException(this.GetType().Name);
- L125 C31: new InvalidOperationException :: throw new InvalidOperationException(


## XREngine.Data/Lists/Deque/GenericDeque.Synchronized.cs
- L31 C27: new ArgumentNullException :: throw new ArgumentNullException("deque");


## XREngine.Data/Lists/Deque/GenericTester.cs
- L117 C27: new int :: int[] array = new int[deque.Count];
- L126 C21: new int :: array = new int[deque.Count * 2];
- L135 C21: new int :: array = new int[deque.Count];
- L183 C30: new int :: deque.CopyTo(new int[10, 10], deque.Count);


## XREngine.Data/Lists/Deque/Tester.cs
- L89 C27: new InvalidOperationException :: throw new InvalidOperationException("Expected integer value in deque test");
- L108 C27: new InvalidOperationException :: throw new InvalidOperationException("Expected integer value in deque test");
- L137 C27: new int :: int[] array = new int[deque.Count];
- L146 C21: new int :: array = new int[deque.Count * 2];
- L155 C21: new int :: array = new int[deque.Count];
- L203 C30: new int :: deque.CopyTo(new int[10, 10], deque.Count);


## XREngine.Data/Lists/EventArray.cs
- L46 C22: new T :: _array = new T[size];
- L49 C48: new HashSet :: private HashSet<int> _changedIndices = new HashSet<int>();
- L66 C55: new ArgumentNullException :: set => _array[index] = (T)(value ?? throw new ArgumentNullException(nameof(value)));
- L94 C20: new EventArray :: return new EventArray<T>(_array);
- L160 C57: new NotifyCollectionChangedEventArgs :: CollectionChanged?.Invoke(this, new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Replace));


## XREngine.Data/Lists/EventList.cs
- L13 C9: new int :: new int Count { get; }
- L35 C9: new T :: new T this[int index] { get; }
- L50 C36: new ReaderWriterLockSlim :: set => _lock = value ? new ReaderWriterLockSlim(LockRecursionPolicy.SupportsRecursion) : null;
- L180 C21: new List :: _list = new List<T>(capacity);
- L246 C53: new TCollectionChangedEventArgs :: CollectionChanged?.Invoke(this, new TCollectionChangedEventArgs<T>(ECollectionChangedAction.Add, item));
- L298 C45: new List :: var filteredItems = new List<T>();
- L336 C53: new TCollectionChangedEventArgs :: CollectionChanged?.Invoke(this, new TCollectionChangedEventArgs<T>(ECollectionChangedAction.Add, collection.ToList()));
- L388 C57: new TCollectionChangedEventArgs :: CollectionChanged?.Invoke(this, new TCollectionChangedEventArgs<T>(ECollectionChangedAction.Remove, item));
- L465 C53: new TCollectionChangedEventArgs :: CollectionChanged?.Invoke(this, new TCollectionChangedEventArgs<T>(ECollectionChangedAction.Remove, removedItems));
- L530 C53: new TCollectionChangedEventArgs :: CollectionChanged?.Invoke(this, new TCollectionChangedEventArgs<T>(ECollectionChangedAction.Remove, item));
- L547 C44: new List :: approvedRemovals = new List<IndexedItem>(_list.Count);
- L549 C50: new IndexedItem :: approvedRemovals.Add(new IndexedItem(i, _list[i]));
- L617 C53: new TCollectionChangedEventArgs :: CollectionChanged?.Invoke(this, new TCollectionChangedEventArgs<T>(ECollectionChangedAction.Clear));
- L690 C53: new TCollectionChangedEventArgs :: CollectionChanged?.Invoke(this, new TCollectionChangedEventArgs<T>(ECollectionChangedAction.Remove, removedItems));
- L763 C53: new TCollectionChangedEventArgs :: CollectionChanged?.Invoke(this, new TCollectionChangedEventArgs<T>(ECollectionChangedAction.Add, item));
- L795 C45: new List :: var filteredItems = new List<T>();
- L833 C53: new TCollectionChangedEventArgs :: CollectionChanged?.Invoke(this, new TCollectionChangedEventArgs<T>(ECollectionChangedAction.Add, collection.ToList()));
- L1029 C53: new TCollectionChangedEventArgs :: CollectionChanged?.Invoke(this, new TCollectionChangedEventArgs<T>(ECollectionChangedAction.Replace, value, index));
- L1100 C29: new ThreadSafeListEnumerator :: => ThreadSafe ? new ThreadSafeListEnumerator<T>(_list, _lock) : _list.GetEnumerator();
- L1154 C23: new ArgumentNullException :: throw new ArgumentNullException(nameof(value));
- L1160 C19: new ArgumentException :: throw new ArgumentException($"Value must be of type {typeof(T).FullName}.", nameof(value));
- L1187 C27: new List :: var deduped = new List<T>(items.Count);
- L1202 C32: new List :: var snapshot = new List<IndexedItem>(count);
- L1204 C34: new IndexedItem :: snapshot.Add(new IndexedItem(index + i, _list[index + i]));
- L1218 C32: new List :: var snapshot = new List<IndexedItem>();
- L1223 C38: new IndexedItem :: snapshot.Add(new IndexedItem(i, item));
- L1238 C28: new List :: var approved = new List<IndexedItem>(candidates.Count);


## XREngine.Data/Lists/EventList.MemoryPack.cs
- L48 C24: new List :: var list = new List<T>(count);
- L54 C21: new EventList :: value = new EventList<T>(list, allowDuplicates, allowNull);


## XREngine.Data/Lists/HashedQueue.cs
- L5 C55: new ReaderWriterLockSlim :: private readonly ReaderWriterLockSlim _lock = new ReaderWriterLockSlim(LockRecursionPolicy.SupportsRecursion);
- L11 C21: new HashSet :: _hash = new HashSet<T>();
- L15 C21: new HashSet :: _hash = new HashSet<T>();
- L19 C21: new HashSet :: _hash = new HashSet<T>();
- L23 C16: new void :: public new void Clear()
- L37 C16: new T :: public new T Dequeue()
- L52 C16: new bool :: public new bool Enqueue(T item)


## XREngine.Data/Lists/HashedStack.cs
- L9 C21: new HashSet :: _hash = new HashSet<T>();
- L13 C21: new HashSet :: _hash = new HashSet<T>();
- L17 C21: new HashSet :: _hash = new HashSet<T>();
- L21 C16: new void :: public new void Clear()
- L26 C16: new T :: public new T Pop()
- L32 C16: new bool :: public new bool Push(T item)


## XREngine.Data/Lists/ThreadSafeEnumerator.cs
- L51 C21: new InvalidOperationException :: ? throw new InvalidOperationException()


## XREngine.Data/Lists/ThreadSafeList.cs
- L18 C16: new ThreadSafeEnumerator :: => new ThreadSafeEnumerator<T>(_inner.GetEnumerator(), _lock);
- L26 C48: new ReaderWriterLockSlim :: protected ReaderWriterLockSlim _lock = new ReaderWriterLockSlim(LockRecursionPolicy.SupportsRecursion);
- L47 C16: new T :: public new T this[int index]
- L79 C16: new void :: public new void Add(T item)
- L84 C16: new void :: public new void AddRange(IEnumerable<T> collection)
- L89 C16: new bool :: public new bool Remove(T item)
- L94 C16: new void :: public new void RemoveRange(int index, int count)
- L99 C16: new void :: public new void RemoveAt(int index)
- L104 C16: new void :: public new void Clear()
- L109 C16: new void :: public new void RemoveAll(Predicate<T> match)
- L114 C16: new void :: public new void Insert(int index, T item)
- L119 C16: new void :: public new void InsertRange(int index, IEnumerable<T> collection)
- L124 C16: new ReadOnlyCollection :: public new ReadOnlyCollection<T> AsReadOnly()
- L129 C16: new int :: public new int BinarySearch(int index, int count, T item, IComparer<T> comparer)
- L134 C16: new int :: public new int BinarySearch(T item)
- L139 C16: new int :: public new int BinarySearch(T item, IComparer<T> comparer)
- L144 C16: new bool :: public new bool Contains(T item)
- L149 C16: new List :: public new List<TOutput> ConvertAll<TOutput>(Converter<T, TOutput> converter)
- L154 C16: new void :: public new void CopyTo(T[] array, int arrayIndex)
- L159 C16: new void :: public new void CopyTo(int index, T[] array, int arrayIndex, int count)
- L164 C16: new void :: public new void CopyTo(T[] array)
- L169 C16: new bool :: public new bool Exists(Predicate<T> match)
- L174 C16: new T :: public new T? Find(Predicate<T> match)
- L179 C16: new List :: public new List<T> FindAll(Predicate<T> match)
- L184 C16: new int :: public new int FindIndex(Predicate<T> match)
- L189 C16: new int :: public new int FindIndex(int startIndex, Predicate<T> match)
- L194 C16: new int :: public new int FindIndex(int startIndex, int count, Predicate<T> match)
- L199 C16: new T :: public new T? FindLast(Predicate<T> match)
- L204 C16: new int :: public new int FindLastIndex(Predicate<T> match)
- L209 C16: new int :: public new int FindLastIndex(int startIndex, Predicate<T> match)
- L214 C16: new int :: public new int FindLastIndex(int startIndex, int count, Predicate<T> match)
- L219 C16: new void :: public new void ForEach(Action<T> action)
- L224 C16: new IEnumerator :: public new IEnumerator<T> GetEnumerator()
- L225 C16: new ThreadSafeListEnumerator :: => new ThreadSafeListEnumerator<T>(this, _lock);
- L226 C16: new List :: public new List<T> GetRange(int index, int count)
- L231 C16: new int :: public new int IndexOf(T item, int index, int count)
- L236 C16: new int :: public new int IndexOf(T item, int index)
- L241 C16: new int :: public new int IndexOf(T item)
- L246 C16: new int :: public new int LastIndexOf(T item)
- L251 C16: new int :: public new int LastIndexOf(T item, int index)
- L256 C16: new int :: public new int LastIndexOf(T item, int index, int count)
- L261 C16: new void :: public new void Reverse(int index, int count)
- L266 C16: new void :: public new void Reverse()
- L271 C16: new void :: public new void Sort(int index, int count, IComparer<T> comparer)
- L276 C16: new void :: public new void Sort(Comparison<T> comparison)
- L281 C16: new void :: public new void Sort()
- L286 C16: new void :: public new void Sort(IComparer<T> comparer)
- L291 C16: new T :: public new T[] ToArray()
- L296 C16: new bool :: public new bool TrueForAll(Predicate<T> match)


## XREngine.Data/Lists/Unsafe/UTF8ArrayPtr.cs
- L40 C28: new IntPtr :: var pointers = new IntPtr[strings.Count];


## XREngine.Data/Measurement.cs
- L40 C20: new FeetInches :: return new FeetInches(ift, (feet - ift) * 12.0f);


## XREngine.Data/MMD/VMD/AnimationBase.cs
- L6 C152: new() :: public abstract class AnimationBase<T> : Dictionary<string, FrameDictionary<T>>, IBinaryDataSource where T : class, IBinaryDataSource, IFramesKey, new()
- L21 C30: new() :: T frameKey = new();
- L38 C77: new byte :: byte[] nameBytes = [.. VMDUtils.ToShiftJisBytes(kv.Key), .. new byte[15 - kv.Key.Length]];
- L49 C32: new() :: StringBuilder sb = new();


## XREngine.Data/MMD/VMD/AnimationListBase.cs
- L3 C87: new() :: public abstract class AnimationListBase<T> : List<T> where T : IBinaryDataSource, new()
- L10 C30: new() :: T frameKey = new();


## XREngine.Data/MMD/VMD/BoneFrameKey.cs
- L17 C66: new Vector3 :: var pos = Interp.Lerp(Translation, next.Translation, new Vector3(
- L31 C27: new Vector3 :: Translation = new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle() * -1.0f) * VMDUtils.MMDUnitsToMeters;
- L32 C44: new Quaternion :: Rotation = InvertZAxisRotation(new Quaternion(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle()));
- L42 C26: new float :: writer.Write(new float[] { translation.X, translation.Y, translation.Z * -1.0f }.SelectMany(BitConverter.GetBytes).ToArray());
- L43 C26: new float :: writer.Write(new float[] { rotation.X, rotation.Y, rotation.Z, rotation.W }.SelectMany(BitConverter.GetBytes).ToArray());
- L58 C34: new VMDBezier :: TranslationXBezier = new VMDBezier(new Vector2(x0, y0), new Vector2(x1, y1));
- L58 C48: new Vector2 :: TranslationXBezier = new VMDBezier(new Vector2(x0, y0), new Vector2(x1, y1));
- L58 C69: new Vector2 :: TranslationXBezier = new VMDBezier(new Vector2(x0, y0), new Vector2(x1, y1));
- L61 C34: new VMDBezier :: TranslationYBezier = new VMDBezier(new Vector2(x2, y2), new Vector2(x3, y3));
- L61 C48: new Vector2 :: TranslationYBezier = new VMDBezier(new Vector2(x2, y2), new Vector2(x3, y3));
- L61 C69: new Vector2 :: TranslationYBezier = new VMDBezier(new Vector2(x2, y2), new Vector2(x3, y3));
- L64 C34: new VMDBezier :: TranslationZBezier = new VMDBezier(new Vector2(x4, y4), new Vector2(x5, y5));
- L64 C48: new Vector2 :: TranslationZBezier = new VMDBezier(new Vector2(x4, y4), new Vector2(x5, y5));
- L64 C69: new Vector2 :: TranslationZBezier = new VMDBezier(new Vector2(x4, y4), new Vector2(x5, y5));
- L67 C30: new VMDBezier :: RotationBezier = new VMDBezier(new Vector2(x6, y6), new Vector2(x7, y7));
- L67 C44: new Vector2 :: RotationBezier = new VMDBezier(new Vector2(x6, y6), new Vector2(x7, y7));
- L67 C65: new Vector2 :: RotationBezier = new VMDBezier(new Vector2(x6, y6), new Vector2(x7, y7));
- L80 C30: new sbyte :: sbyte[] interp = new sbyte[64];
- L82 C36: new VMDBezier :: TranslationXBezier ??= new VMDBezier(Vector2.Zero, Vector2.Zero);
- L85 C36: new VMDBezier :: TranslationYBezier ??= new VMDBezier(Vector2.Zero, Vector2.Zero);
- L88 C36: new VMDBezier :: TranslationZBezier ??= new VMDBezier(Vector2.Zero, Vector2.Zero);
- L91 C32: new VMDBezier :: RotationBezier ??= new VMDBezier(Vector2.Zero, Vector2.Zero);


## XREngine.Data/MMD/VMD/CameraKeyFrameKey.cs
- L12 C55: new sbyte :: public sbyte[] Interp { get; private set; } = new sbyte[24];
- L20 C24: new Vector3 :: Location = new Vector3(reader.ReadBytes(12).SelectEvery(4, x => BitConverter.ToSingle([.. x], 0)).ToArray());
- L21 C24: new Vector3 :: Rotation = new Vector3(reader.ReadBytes(12).SelectEvery(4, x => BitConverter.ToSingle([.. x], 0)).ToArray());
- L31 C26: new float :: writer.Write(new float[] { Location.X, Location.Y, Location.Z }.SelectMany(BitConverter.GetBytes).ToArray());
- L32 C26: new float :: writer.Write(new float[] { Rotation.X, Rotation.Y, Rotation.Z }.SelectMany(BitConverter.GetBytes).ToArray());


## XREngine.Data/MMD/VMD/FrameDictionary.cs
- L7 C124: new() :: public class FrameDictionary<T> : XRBase, IReadOnlyDictionary<uint, T> where T : class, IBinaryDataSource, IFramesKey, new()


## XREngine.Data/MMD/VMD/LampKeyFrameKey.cs
- L16 C21: new Vector3 :: Color = new Vector3(reader.ReadBytes(12).SelectEvery(4, x => BitConverter.ToSingle([.. x], 0)).ToArray());
- L17 C25: new Vector3 :: Direction = new Vector3(reader.ReadBytes(12).SelectEvery(4, x => BitConverter.ToSingle([.. x], 0)).ToArray());
- L23 C26: new float :: writer.Write(new float[] { Color.R, Color.G, Color.B }.SelectMany(BitConverter.GetBytes).ToArray());
- L24 C26: new float :: writer.Write(new float[] { Direction.X, Direction.Y, Direction.Z }.SelectMany(BitConverter.GetBytes).ToArray());


## XREngine.Data/MMD/VMD/PropertyFrameKey.cs
- L31 C70: new byte :: writer.Write(VMDUtils.ToShiftJisBytes(ikName).Concat(new byte[20 - ikName.Length]).ToArray());


## XREngine.Data/MMD/VMD/SelfShadowFrameKey.cs
- L15 C23: new InvalidFileError :: throw new InvalidFileError($"Invalid self shadow mode {Mode} at frame {FrameNumber}");


## XREngine.Data/MMD/VMD/VMDFile.cs
- L19 C32: new BinaryReader :: using var reader = new BinaryReader(File.OpenRead(path));
- L22 C22: new VMDHeader :: Header = new VMDHeader();
- L48 C23: new InvalidOperationException :: throw new InvalidOperationException("Cannot save VMD file without loading it first.");
- L51 C32: new BinaryWriter :: using var writer = new BinaryWriter(File.OpenWrite(path));
- L62 C32: new() :: StringBuilder sb = new();


## XREngine.Data/MMD/VMD/VMDHeader.cs
- L16 C23: new InvalidFileError :: throw new InvalidFileError($"File signature \"{Encoding.ASCII.GetString(sig)}\" is invalid.");
- L24 C69: new byte :: writer.Write(VMDUtils.ToShiftJisBytes(ModelName).Concat(new byte[20 - ModelName.Length]).ToArray());


## XREngine.Data/MMD/VMD/VMDUtils.cs
- L320 C67: new() :: public static readonly Dictionary<string, string> JP2EN = new()


## XREngine.Data/Native/NativeStructs.cs
- L56 C16: new RECT :: => new RECT(x, y, x + width, y + height);


## XREngine.Data/Profiling/ProfilerStatsPacket.cs
- L84 C51: new() :: public AllocationSlice Render { get; set; } = new();
- L85 C56: new() :: public AllocationSlice CollectSwap { get; set; } = new();
- L86 C51: new() :: public AllocationSlice Update { get; set; } = new();
- L87 C56: new() :: public AllocationSlice FixedUpdate { get; set; } = new();


## XREngine.Data/Profiling/UdpProfilerSender.cs
- L23 C44: new() :: private static readonly object _lock = new();
- L75 C20: new CancellationTokenSource :: _cts = new CancellationTokenSource();
- L76 C29: new Thread :: _senderThread = new Thread(() => SenderLoop(port, _cts.Token))
- L131 C29: new byte :: byte[] sendBuffer = new byte[ProfilerProtocol.MaxDatagramSize];
- L132 C24: new IPEndPoint :: var endpoint = new IPEndPoint(IPAddress.Loopback, port);
- L134 C25: new UdpClient :: using var udp = new UdpClient();
- L168 C37: new HeartbeatPacket :: var heartbeat = new HeartbeatPacket
- L258 C20: new List :: var kept = new List<ProfilerNodeData>(nodes.Length);


## XREngine.Data/Remapper.cs
- L29 C23: new InvalidOperationException :: throw new InvalidOperationException();
- L35 C50: new() :: private static readonly object NullKey = new();
- L40 C45: new() :: Dictionary<object, int> cache = new();
- L43 C27: new int :: _remapTable = new int[count];
- L44 C25: new int :: _impTable = new int[count];
- L77 C28: new int :: int[] sorted = new int[impCount];


## XREngine.Data/Rendering/Index/IndexQuad.cs
- L62 C31: new IndexTriangle :: triangles.Add(new IndexTriangle(Point0, Point1, Point2));
- L63 C31: new IndexTriangle :: triangles.Add(new IndexTriangle(Point0, Point2, Point3));
- L67 C31: new IndexTriangle :: triangles.Add(new IndexTriangle(Point0, Point1, Point3));
- L68 C31: new IndexTriangle :: triangles.Add(new IndexTriangle(Point3, Point1, Point2));


## XREngine.Data/Rendering/Index/IndexQuadStrip.cs
- L18 C31: new IndexTriangle :: triangles.Add(new IndexTriangle(_points[i], _points[i + 1], _points[i + 2]));
- L19 C31: new IndexTriangle :: triangles.Add(new IndexTriangle(_points[i + 1], _points[i + 2], _points[i + 3]));


## XREngine.Data/Rendering/Index/IndexTriangleFan.cs
- L14 C31: new IndexTriangle :: triangles.Add(new IndexTriangle(_points[0], _points[i], _points[i + 1]));


## XREngine.Data/Rendering/Index/IndexTriangleStrip.cs
- L21 C23: new Exception :: throw new Exception("A triangle strip needs 3 or more points.");
- L37 C31: new IndexTriangle :: triangles.Add(new IndexTriangle(


## XREngine.Data/Rendering/VertexWeightGroup.cs
- L52 C24: new EventDictionary :: _weights = new EventDictionary<int, float> { { boneIndex, 1.0f } };
- L58 C24: new EventDictionary :: _weights = new EventDictionary<int, float>(weights);
- L107 C34: new int :: int[] keysToRemove = new int[Weights.Count - WeightLimit];
- L160 C38: new int :: int[] keysToRemove = new int[weights.Count - maxWeightCount];


## XREngine.Data/ResourcePool.cs
- L42 C45: new ArgumentNullException :: _generator = generator ?? throw new ArgumentNullException(nameof(generator));


## XREngine.Data/ThreadSafeHashSet.cs
- L8 C57: new ReaderWriterLockSlim :: protected readonly ReaderWriterLockSlim _lock = new ReaderWriterLockSlim(LockRecursionPolicy.SupportsRecursion);
- L13 C22: new HashSet :: _inner = new HashSet<T>();
- L17 C22: new HashSet :: _inner = new HashSet<T>(comparer);
- L21 C22: new HashSet :: _inner = new HashSet<T>(collection);
- L25 C22: new HashSet :: _inner = new HashSet<T>(collection, comparer);
- L71 C16: new ThreadSafeEnumerator :: => new ThreadSafeEnumerator<T>(_inner.GetEnumerator(), _lock);


## XREngine.Data/Tools/CoACD.cs
- L33 C23: new ArgumentException :: throw new ArgumentException("Triangle index buffer length must be divisible by 3.", nameof(triangleIndices));
- L36 C37: new double :: double[] vertexBuffer = new double[checked(positions.Length * 3)];
- L51 C42: new() :: NativeMesh nativeInput = new()
- L114 C26: new List :: var meshes = new List<ConvexHullMesh>(meshCount);
- L125 C39: new double :: double[] vertexData = new double[vertexCount * 3];
- L127 C38: new Vector3 :: Vector3[] vertices = new Vector3[vertexCount];
- L131 C35: new Vector3 :: vertices[v] = new Vector3(
- L138 C53: new int :: int[] indices = triangleCount > 0 ? new int[triangleCount * 3] : Array.Empty<int>();
- L142 C28: new ConvexHullMesh :: meshes.Add(new ConvexHullMesh(vertices, indices));
- L217 C54: new() :: public static CoACDParameters Default => new();


## XREngine.Data/Tools/Miniball.cs
- L26 C22: new FloatingPoint :: center = new FloatingPoint[dim];
- L27 C27: new FloatingPoint :: centerToAff = new FloatingPoint[dim];
- L28 C29: new FloatingPoint :: centerToPoint = new FloatingPoint[dim];
- L29 C23: new FloatingPoint :: lambdas = new FloatingPoint[dim + 1];
- L34 C33: new InvalidOperationException :: => support ?? throw new InvalidOperationException("Miniball is empty.");
- L74 C20: new Subspan :: return new Subspan(dim, S, farthest);
- L239 C24: new Quality :: return new Quality(0, 0, 0, 0, iteration, 0);
- L267 C20: new Quality :: return new Quality(qr_error, min_lambda, max_overlength / radius, Math.Abs(min_underlength / radius), iteration, Support.Size);
- L297 C52: new FloatingPoint :: private readonly FloatingPoint[] _values = new FloatingPoint[size * dimensions];
- L382 C41: new bool :: private readonly bool[] _bits = new bool[size];
- L414 C26: new BitSet :: membership = new BitSet(points.Size);
- L415 C23: new int :: members = new int[dim + 1];
- L419 C17: new FloatingPoint :: Q = new FloatingPoint[dim][];
- L420 C17: new FloatingPoint :: R = new FloatingPoint[dim][];
- L423 C24: new FloatingPoint :: Q[i] = new FloatingPoint[dim];
- L424 C24: new FloatingPoint :: R[i] = new FloatingPoint[dim];
- L426 C17: new FloatingPoint :: u = new FloatingPoint[dim];
- L427 C17: new FloatingPoint :: w = new FloatingPoint[dim];
- L575 C39: new FloatingPoint :: FloatingPoint[] lambdas = new FloatingPoint[Size];
- L576 C34: new FloatingPoint :: FloatingPoint[] pt = new FloatingPoint[dim];


## XREngine.Data/Tools/SimplePriorityQueue.cs
- L7 C63: new() :: private readonly List<KeyValuePair<T, float>> _heap = new();
- L15 C23: new KeyValuePair :: _heap.Add(new KeyValuePair<T, float>(item, priority));
- L33 C23: new InvalidOperationException :: throw new InvalidOperationException("The queue is empty.");
- L123 C28: new KeyValuePair :: _heap[index] = new KeyValuePair<T, float>(item, newPriority);


## XREngine.Data/Tools/SimplePriorityQueue1.cs
- L7 C67: new() :: private readonly SortedDictionary<TKey, List<T>> _queue = new();
- L17 C26: new List :: bucket = new List<T>();
- L27 C23: new InvalidOperationException :: throw new InvalidOperationException("The queue is empty.");
- L31 C23: new InvalidOperationException :: throw new InvalidOperationException("The queue is empty.");


## XREngine.Data/TraceListener.cs
- L13 C41: new() :: private readonly object _lock = new();
- L27 C55: new() :: private static readonly object _installLock = new();
- L40 C35: new TraceListener :: _globalInstance = new TraceListener();


## XREngine.Data/Transforms/Rotations/Rotator.cs
- L211 C28: new Exception :: _ => throw new Exception("Invalid rotation order"),
- L230 C81: new() :: public static Rotator Clamp(Rotator value, Rotator min, Rotator max) => new()
- L242 C20: new Rotator :: return new Rotator(
- L258 C25: new() :: Rotator v = new()
- L495 C20: new Rotator :: return new Rotator(
- L505 C20: new Rotator :: return new Rotator(
- L539 C20: new Rotator :: return new Rotator(float.RadiansToDegrees(euler.X), float.RadiansToDegrees(euler.Y), float.RadiansToDegrees(euler.Z), ERotationOrder.YPR);


## XREngine.Data/Transforms/Rotations/Rotor.cs
- L25 C21: new Vector4 :: => _v = new Vector4(a, b01, b02, b12);
- L106 C20: new Vector3 :: return new Vector3(
- L135 C33: new Vector3 :: Vector3 xy = Rotate(new Vector3(1, 0, 0));
- L136 C33: new Vector3 :: Vector3 xz = Rotate(new Vector3(0, 1, 0));
- L137 C33: new Vector3 :: Vector3 yz = Rotate(new Vector3(0, 0, 1));
- L140 C20: new Matrix4x4 :: return new Matrix4x4(
- L165 C20: new Rotor :: return new Rotor(
- L188 C20: new Rotor :: return new Rotor(
- L203 C24: new Vector3 :: axis = new Vector3(1, 0, 0); // arbitrary
- L205 C24: new Vector3 :: axis = new Vector3(q.X / s, q.Y / s, q.Z / s);
- L210 C16: new Rotor :: => new Rotor(
- L223 C21: new Rotor :: b = new Rotor(-b.A, -b.B01, -b.B02, -b.B12);
- L238 C20: new Rotor :: return new Rotor(


## XREngine.Data/Trees/BVH/BVH.cs
- L67 C24: new List :: var hits = new List<BVHNode<GO>>();
- L97 C23: new Exception :: throw new Exception("In order to use optimize, you must set LEAF_OBJ_MAX=1");
- L137 C28: new BVHNode :: _rootBVH = new BVHNode<GO>(this, objects);
- L140 C28: new BVHNode :: _rootBVH = new BVHNode<GO>(this)


## XREngine.Data/Trees/BVH/BVHNode.cs
- L68 C27: new Exception :: throw new Exception("ssBVH Leaf has objects and left/right pointers!");
- L79 C24: new NotSupportedException :: _ => throw new NotSupportedException(),
- L91 C23: new Exception :: throw new Exception("dangling leaf!");
- L152 C23: new AABB :: box = new AABB(
- L153 C21: new Vector3 :: new Vector3(minX, minY, minZ),
- L154 C21: new Vector3 :: new Vector3(maxX, maxY, maxZ));
- L168 C19: new AABB :: box = new AABB(
- L169 C17: new Vector3 :: new Vector3(minX, minY, minZ),
- L170 C17: new Vector3 :: new Vector3(maxX, maxY, maxZ));
- L183 C23: new NotImplementedException :: throw new NotImplementedException();  // TODO: fix this... we should never get called in this case...
- L253 C20: new AABB :: return new AABB(new Vector3(-radius), new Vector3(radius));
- L253 C29: new Vector3 :: return new AABB(new Vector3(-radius), new Vector3(radius));
- L253 C51: new Vector3 :: return new AABB(new Vector3(-radius), new Vector3(radius));
- L293 C37: new InvalidOperationException :: => adaptor.BVH ?? throw new InvalidOperationException("Adaptor must be bound to a BVH instance.");
- L332 C33: new RotOpt :: Rot.NONE => new RotOpt(mySA, Rot.NONE),
- L334 C27: new RotOpt :: ? new RotOpt(float.MaxValue, Rot.NONE)
- L335 C27: new RotOpt :: : new RotOpt(SA(rightChild.left) + SA(AABBofPair(leftChild, rightChild.right)), rot),
- L337 C27: new RotOpt :: ? new RotOpt(float.MaxValue, Rot.NONE)
- L338 C27: new RotOpt :: : new RotOpt(SA(rightChild.right) + SA(AABBofPair(leftChild, rightChild.left)), rot),
- L340 C27: new RotOpt :: ? new RotOpt(float.MaxValue, Rot.NONE)
- L341 C27: new RotOpt :: : new RotOpt(SA(AABBofPair(rightChild, leftChild.right)) + SA(leftChild.left), rot),
- L343 C27: new RotOpt :: ? new RotOpt(float.MaxValue, Rot.NONE)
- L344 C27: new RotOpt :: : new RotOpt(SA(AABBofPair(rightChild, leftChild.left)) + SA(leftChild.right), rot),
- L346 C27: new RotOpt :: ? new RotOpt(float.MaxValue, Rot.NONE)
- L347 C27: new RotOpt :: : new RotOpt(SA(AABBofPair(rightChild.right, leftChild.right)) + SA(AABBofPair(rightChild.left, leftChild.left)), rot),
- L349 C27: new RotOpt :: ? new RotOpt(float.MaxValue, Rot.NONE)
- L350 C27: new RotOpt :: : new RotOpt(SA(AABBofPair(rightChild.left, leftChild.right)) + SA(AABBofPair(leftChild.left, rightChild.right)), rot),
- L351 C32: new NotImplementedException :: _ => throw new NotImplementedException($"missing implementation for BVH Rotation SAH Computation .. {rot}"),
- L353 C19: new RotOpt :: }) ?? new RotOpt(mySA, Rot.NONE);
- L451 C31: new NotImplementedException :: throw new NotImplementedException($"missing implementation for BVH Rotation .. {bestRot.rot}");
- L495 C23: new InvalidOperationException :: throw new InvalidOperationException("Cannot split a BVH node without objects.");
- L503 C35: new List :: var orderedlist = new List<GO>(splitlist);
- L516 C31: new NotImplementedException :: throw new NotImplementedException("unknown split axis: " + axis.ToString());
- L523 C24: new SplitAxisOpt :: return new SplitAxisOpt(SAH, axis, left_s, right_s);
- L526 C60: new InvalidOperationException :: SplitAxisOpt bestSplit = bestSplitOpt ?? throw new InvalidOperationException("Unable to determine BVH split axis.");
- L531 C20: new BVHNode :: left = new BVHNode<GO>(bvh, this, bestSplit.left, bestSplit.axis, this.depth + 1); // Split the Hierarchy to the left
- L532 C21: new BVHNode :: right = new BVHNode<GO>(bvh, this, bestSplit.right, bestSplit.axis, this.depth + 1); // Split the Hierarchy to the right
- L551 C46: new InvalidOperationException :: var left = curNode.left ?? throw new InvalidOperationException("Left child missing during pushdown.");
- L552 C48: new InvalidOperationException :: var right = curNode.right ?? throw new InvalidOperationException("Right child missing during pushdown.");
- L556 C33: new BVHNode :: var mergedSubnode = new BVHNode<GO>(bvh)
- L568 C30: new BVHNode :: var newSubnode = new BVHNode<GO>(bvh)
- L579 C65: new depths :: curNode.SetDepth(nAda, curNode.depth); // propagate new depths to our children.
- L595 C27: new InvalidOperationException :: throw new InvalidOperationException("Interior BVH nodes must have both children.");
- L640 C23: new Exception :: throw new Exception("removeObject() called on nonLeaf!");
- L673 C23: new Exception :: throw new Exception("bad intermediate node");
- L682 C23: new Exception :: throw new Exception("removeLeaf doesn't match any leaf!");
- L796 C23: new AABB :: box = new AABB(
- L797 C21: new Vector3 :: new Vector3(minX, minY, minZ),
- L798 C21: new Vector3 :: new Vector3(maxX, maxY, maxZ));
- L840 C26: new AABB :: newBox = new AABB(
- L841 C21: new Vector3 :: new Vector3(newMinX, newMinY, newMinZ),
- L842 C21: new Vector3 :: new Vector3(newMaxX, newMaxY, newMaxZ));
- L883 C23: new Exception :: throw new Exception("ssBVHNode constructed with invalid paramaters");


## XREngine.Data/Trees/BVH/SphereBVH.cs
- L7 C23: new SphereBVHNodeAdaptor :: : BVH<Sphere>(new SphereBVHNodeAdaptor(), [], maxSpheresPerLeaf) { }


## XREngine.Data/Trees/BVH/SphereBVHNodeAdaptor.cs
- L24 C23: new Exception :: throw new Exception("missing map for a shuffled child");


## XREngine.Data/Trees/Octree/Octree.cs
- L20 C24: new OctreeNode :: => _head = new OctreeNode<T>(bounds, 0, 0, null, this);
- L40 C21: new OctreeNode :: _head = new OctreeNode<T>(newBounds, 0, 0, null, this);
- L58 C82: new ConcurrentQueue :: internal ConcurrentQueue<(T item, ETreeCommand)> SwapCommands { get; } = new ConcurrentQueue<(T item, ETreeCommand command)>();
- L59 C283: new ConcurrentQueue :: internal ConcurrentQueue<(Segment segment, SortedDictionary<float, List<(T item, object? data)>> items, Func<T, Segment, (float? distance, object? data)> directTest, Action<SortedDictionary<float, List<(T item, object? data)>>> finishedCallback)> RaycastCommands { get; } = new ConcurrentQueue<(Segment segment, SortedDictionary<float, List<(T item, object? data)>> items, Func<T, Segment, (float? distance, object? data)> directTest, Action<SortedDictionary<float, List<(T item, object? data)>>> finishedCallback)>();


## XREngine.Data/Trees/Octree/OctreeArray.cs
- L36 C22: new OctreeNode :: _nodes = new OctreeNode[_maxNodes];
- L86 C17: new Vector3 :: new Vector3(
- L122 C17: new Vector3 :: new Vector3(


## XREngine.Data/Trees/Octree/OctreeNode.cs
- L19 C41: new() :: protected EventList<T> _items = new() { ThreadSafe = false };
- L20 C48: new OctreeNode :: protected OctreeNode<T>?[] _subNodes = new OctreeNode<T>[OctreeBase.MaxChildNodeCount];
- L466 C45: new OctreeNode :: return _subNodes[index] ??= new OctreeNode<T>(bounds, index, _subDivLevel + 1, this, Owner);


## XREngine.Data/Trees/Octree/OctreeNodeBase.cs
- L39 C26: new Vector3 :: 0 => new(new Vector3(Min.X, Min.Y, Min.Z), new Vector3(center.X, center.Y, center.Z)),
- L39 C60: new Vector3 :: 0 => new(new Vector3(Min.X, Min.Y, Min.Z), new Vector3(center.X, center.Y, center.Z)),
- L40 C26: new Vector3 :: 1 => new(new Vector3(Min.X, Min.Y, center.Z), new Vector3(center.X, center.Y, Max.Z)),
- L40 C63: new Vector3 :: 1 => new(new Vector3(Min.X, Min.Y, center.Z), new Vector3(center.X, center.Y, Max.Z)),
- L41 C26: new Vector3 :: 2 => new(new Vector3(Min.X, center.Y, Min.Z), new Vector3(center.X, Max.Y, center.Z)),
- L41 C63: new Vector3 :: 2 => new(new Vector3(Min.X, center.Y, Min.Z), new Vector3(center.X, Max.Y, center.Z)),
- L42 C26: new Vector3 :: 3 => new(new Vector3(Min.X, center.Y, center.Z), new Vector3(center.X, Max.Y, Max.Z)),
- L42 C66: new Vector3 :: 3 => new(new Vector3(Min.X, center.Y, center.Z), new Vector3(center.X, Max.Y, Max.Z)),
- L43 C26: new Vector3 :: 4 => new(new Vector3(center.X, Min.Y, Min.Z), new Vector3(Max.X, center.Y, center.Z)),
- L43 C63: new Vector3 :: 4 => new(new Vector3(center.X, Min.Y, Min.Z), new Vector3(Max.X, center.Y, center.Z)),
- L44 C26: new Vector3 :: 5 => new(new Vector3(center.X, Min.Y, center.Z), new Vector3(Max.X, center.Y, Max.Z)),
- L44 C66: new Vector3 :: 5 => new(new Vector3(center.X, Min.Y, center.Z), new Vector3(Max.X, center.Y, Max.Z)),
- L45 C26: new Vector3 :: 6 => new(new Vector3(center.X, center.Y, Min.Z), new Vector3(Max.X, Max.Y, center.Z)),
- L45 C66: new Vector3 :: 6 => new(new Vector3(center.X, center.Y, Min.Z), new Vector3(Max.X, Max.Y, center.Z)),
- L46 C26: new Vector3 :: 7 => new(new Vector3(center.X, center.Y, center.Z), new Vector3(Max.X, Max.Y, Max.Z)),
- L46 C69: new Vector3 :: 7 => new(new Vector3(center.X, center.Y, center.Z), new Vector3(Max.X, Max.Y, Max.Z)),


## XREngine.Data/Trees/Quadtree/Quadtree.cs
- L18 C24: new QuadtreeNode :: => _head = new QuadtreeNode<T>(bounds, 0, 0, null, this);
- L31 C59: new ConcurrentQueue :: internal ConcurrentQueue<T> AddedItems { get; } = new ConcurrentQueue<T>();
- L32 C61: new ConcurrentQueue :: internal ConcurrentQueue<T> RemovedItems { get; } = new ConcurrentQueue<T>();
- L33 C59: new ConcurrentQueue :: internal ConcurrentQueue<T> MovedItems { get; } = new ConcurrentQueue<T>();
- L78 C21: new QuadtreeNode :: _head = new QuadtreeNode<T>(_remakeRequested!.Value, 0, 0, null, this);
- L268 C24: new SortedDictionary :: var list = new SortedDictionary<int, List<T>>();


## XREngine.Data/Trees/Quadtree/Quadtree2.cs
- L47 C17: new Vector3 :: new Vector3(
- L51 C17: new Vector3 :: new Vector3(


## XREngine.Data/Trees/Quadtree/QuadtreeNode.cs
- L11 C41: new() :: protected EventList<T> _items = new() { ThreadSafe = false };
- L12 C50: new QuadtreeNode :: protected QuadtreeNode<T>?[] _subNodes = new QuadtreeNode<T>?[QuadtreeBase.MaxChildNodeCount];
- L36 C22: new BoundingRectangleF :: 0 => new BoundingRectangleF(min.X, min.Y, halfExtents.X, halfExtents.Y),
- L37 C22: new BoundingRectangleF :: 1 => new BoundingRectangleF(min.X, min.Y + halfExtents.Y, halfExtents.X, halfExtents.Y),
- L38 C22: new BoundingRectangleF :: 2 => new BoundingRectangleF(min.X + halfExtents.X, min.Y + halfExtents.Y, halfExtents.X, halfExtents.Y),
- L39 C22: new BoundingRectangleF :: 3 => new BoundingRectangleF(min.X + halfExtents.X, min.Y, halfExtents.X, halfExtents.Y),
- L656 C45: new QuadtreeNode :: return _subNodes[index] ??= new QuadtreeNode<T>(bounds, index, _subDivLevel + 1, this, Owner);


## XREngine.Data/Unity/UnityAnimationClip.cs
- L22 C42: new StaticDeserializerBuilder :: IDeserializer deserializer = new StaticDeserializerBuilder(new UnityStaticContext())
- L22 C72: new UnityStaticContext :: IDeserializer deserializer = new StaticDeserializerBuilder(new UnityStaticContext())
- L23 C33: new TagName :: .WithTagMapping(new TagName("tag:unity3d.com,2011:74"), typeof(Wrapper))


## XREngine.Data/Vectors/BoolVector2.cs
- L48 C23: new IndexOutOfRangeException :: throw new IndexOutOfRangeException("Cannot access vector at index " + index);
- L54 C23: new IndexOutOfRangeException :: throw new IndexOutOfRangeException("Cannot access vector at index " + index);


## XREngine.Data/Vectors/BoolVector3.cs
- L57 C23: new IndexOutOfRangeException :: throw new IndexOutOfRangeException("Cannot access vector at index " + index);
- L63 C23: new IndexOutOfRangeException :: throw new IndexOutOfRangeException("Cannot access vector at index " + index);


## XREngine.Data/Vectors/BoolVector4.cs
- L59 C23: new IndexOutOfRangeException :: throw new IndexOutOfRangeException("Cannot access vector at index " + index);
- L65 C23: new IndexOutOfRangeException :: throw new IndexOutOfRangeException("Cannot access vector at index " + index);


## XREngine.Data/Vectors/DVector2.cs
- L48 C23: new IndexOutOfRangeException :: throw new IndexOutOfRangeException("Cannot access vector at index " + index);
- L54 C23: new IndexOutOfRangeException :: throw new IndexOutOfRangeException("Cannot access vector at index " + index);


## XREngine.Data/Vectors/DVector3.cs
- L53 C23: new IndexOutOfRangeException :: throw new IndexOutOfRangeException("Cannot access vector at index " + index);
- L59 C23: new IndexOutOfRangeException :: throw new IndexOutOfRangeException("Cannot access vector at index " + index);


## XREngine.Data/Vectors/DVector4.cs
- L58 C23: new IndexOutOfRangeException :: throw new IndexOutOfRangeException("Cannot access vector at index " + index);
- L64 C23: new IndexOutOfRangeException :: throw new IndexOutOfRangeException("Cannot access vector at index " + index);


## XREngine.Data/Vectors/IVector2.cs
- L71 C23: new IndexOutOfRangeException :: throw new IndexOutOfRangeException("Cannot access vector at index " + index);
- L77 C23: new IndexOutOfRangeException :: throw new IndexOutOfRangeException("Cannot access vector at index " + index);
- L153 C12: new() :: => new()


## XREngine.Data/Vectors/IVector3.cs
- L51 C67: new IndexOutOfRangeException :: get => index is not < 0 and not > 2 ? Data[index] : throw new IndexOutOfRangeException($"Cannot access vector at index {index}");
- L58 C27: new IndexOutOfRangeException :: throw new IndexOutOfRangeException($"Cannot access vector at index {index}");


## XREngine.Data/Vectors/IVector4.cs
- L65 C23: new IndexOutOfRangeException :: throw new IndexOutOfRangeException("Cannot access vector at index " + index);
- L71 C23: new IndexOutOfRangeException :: throw new IndexOutOfRangeException("Cannot access vector at index " + index);


## XREngine.Data/Vectors/UVector2.cs
- L48 C23: new IndexOutOfRangeException :: throw new IndexOutOfRangeException("Cannot access vector at index " + index);
- L54 C23: new IndexOutOfRangeException :: throw new IndexOutOfRangeException("Cannot access vector at index " + index);


## XREngine.Data/Vectors/UVector3.cs
- L53 C23: new IndexOutOfRangeException :: throw new IndexOutOfRangeException("Cannot access vector at index " + index);
- L59 C23: new IndexOutOfRangeException :: throw new IndexOutOfRangeException("Cannot access vector at index " + index);


## XREngine.Data/Vectors/UVector4.cs
- L58 C23: new IndexOutOfRangeException :: throw new IndexOutOfRangeException("Cannot access vector at index " + index);
- L64 C23: new IndexOutOfRangeException :: throw new IndexOutOfRangeException("Cannot access vector at index " + index);


## XREngine.Data/XRSingleton.cs
- L5 C52: new() :: public class XRSingleton<T> : XRBase where T : new()
- L7 C45: new Lazy :: static XRSingleton() => _instance = new Lazy<T>(() => new T(), true);
- L7 C63: new T :: static XRSingleton() => _instance = new Lazy<T>(() => new T(), true);


## XREngine.Editor/ArchiveImport/ArchiveImportUtilities.cs
- L28 C55: new() :: public List<ArchiveEntryNode> Children { get; } = new();
- L57 C19: new ArgumentException :: throw new ArgumentException("Archive path must be provided.", nameof(archivePath));
- L60 C19: new FileNotFoundException :: throw new FileNotFoundException("Archive file not found.", archivePath);
- L79 C20: new ArchiveEntryNode :: var root = new ArchiveEntryNode("/", string.Empty, true);
- L81 C69: new SharpCompress.Readers.ReaderOptions :: using var archive = ArchiveFactory.OpenArchive(archivePath, new SharpCompress.Readers.ReaderOptions());
- L95 C16: new ArchiveTreeResult :: return new ArchiveTreeResult(root, false, null);
- L100 C20: new ArchiveEntryNode :: var root = new ArchiveEntryNode("/", string.Empty, true);
- L101 C24: new Dictionary :: var builders = new Dictionary<string, UnityPackageEntryBuilder>(StringComparer.OrdinalIgnoreCase);
- L103 C32: new FileStream :: using var fileStream = new FileStream(archivePath, FileMode.Open, FileAccess.Read, FileShare.Read);
- L104 C32: new GZipInputStream :: using var gzipStream = new GZipInputStream(fileStream);
- L105 C31: new TarInputStream :: using var tarStream = new TarInputStream(gzipStream, Encoding.Default);
- L132 C27: new UnityPackageEntryBuilder :: builder = new UnityPackageEntryBuilder();
- L138 C32: new MemoryStream :: using var ms = new MemoryStream();
- L161 C28: new Dictionary :: var unityEntries = new Dictionary<string, UnityPackageAssetRecord>(StringComparer.OrdinalIgnoreCase);
- L172 C44: new UnityPackageAssetRecord :: unityEntries[normalizedPath] = new UnityPackageAssetRecord(folder, normalizedPath, builder.HasMeta, builder.AssetSize);
- L176 C16: new ArchiveTreeResult :: return new ArchiveTreeResult(root, true, unityEntries);
- L186 C19: new ArgumentNullException :: throw new ArgumentNullException(nameof(selectedEntries));
- L191 C19: new ArgumentException :: throw new ArgumentException("Destination path must be provided.", nameof(destinationRoot));
- L196 C25: new HashSet :: var selection = new HashSet<string>(selectedEntries.Select(NormalizeKey), StringComparer.OrdinalIgnoreCase);
- L200 C69: new SharpCompress.Readers.ReaderOptions :: using var archive = ArchiveFactory.OpenArchive(archivePath, new SharpCompress.Readers.ReaderOptions());
- L216 C26: new ArchiveExtractionProgress :: yield return new ArchiveExtractionProgress(
- L227 C26: new ArchiveExtractionProgress :: yield return new ArchiveExtractionProgress(
- L233 C22: new ArchiveExtractionProgress :: yield return new ArchiveExtractionProgress(1f, "Import complete.", null);
- L244 C19: new ArgumentNullException :: throw new ArgumentNullException(nameof(selectedEntries));
- L249 C19: new ArgumentException :: throw new ArgumentException("Destination path must be provided.", nameof(destinationRoot));
- L254 C25: new HashSet :: var selection = new HashSet<string>(selectedEntries.Select(NormalizeKey), StringComparer.OrdinalIgnoreCase);
- L265 C32: new FileStream :: using var fileStream = new FileStream(archivePath, FileMode.Open, FileAccess.Read, FileShare.Read);
- L266 C32: new GZipInputStream :: using var gzipStream = new GZipInputStream(fileStream);
- L267 C31: new TarInputStream :: using var tarStream = new TarInputStream(gzipStream, Encoding.Default);
- L299 C30: new ArchiveExtractionProgress :: yield return new ArchiveExtractionProgress(
- L310 C30: new ArchiveExtractionProgress :: yield return new ArchiveExtractionProgress(
- L334 C22: new ArchiveExtractionProgress :: yield return new ArchiveExtractionProgress(1f, "Import complete.", null);
- L374 C23: new ArchiveEntryNode :: var created = new ArchiveEntryNode(name, childPath, isDirectory);
- L415 C22: new byte :: var buffer = new byte[8192];


## XREngine.Editor/AssetEditors/RenderPipelineInspector.cs
- L31 C86: new() :: private readonly ConditionalWeakTable<RenderPipeline, EditorState> _stateCache = new();
- L49 C53: new EditorImGuiUI.InspectorTargetSet :: EditorImGuiUI.DrawDefaultAssetInspector(new EditorImGuiUI.InspectorTargetSet(pipelines, targets.CommonType), visitedObjects);
- L55 C57: new EditorState :: var state = _stateCache.GetValue(pipeline, _ => new EditorState());
- L334 C70: new Vector3 :: DrawTonemappedSwatch("##AutoExposure_AverageSwatch", new Vector3(rgba.X, rgba.Y, rgba.Z), new Vector2(160f, 160f));
- L334 C107: new Vector2 :: DrawTonemappedSwatch("##AutoExposure_AverageSwatch", new Vector3(rgba.X, rgba.Y, rgba.Z), new Vector2(160f, 160f));
- L486 C17: new Vector2 :: new Vector2(180f, 90f));
- L487 C25: new Vector2 :: ImGui.Dummy(new Vector2(0f, 6f));
- L491 C17: new Vector3 :: new Vector3(meteredLum, meteredLum, meteredLum),
- L492 C17: new Vector2 :: new Vector2(180f, 90f));
- L581 C16: new Vector3 :: return new Vector3(MathF.Max(0f, r), MathF.Max(0f, g), MathF.Max(0f, b));
- L588 C15: new Vector3 :: rgb = new Vector3(Sanitize(rgb.X), Sanitize(rgb.Y), Sanitize(rgb.Z));
- L589 C19: new Vector3 :: weights = new Vector3(Sanitize(weights.X), Sanitize(weights.Y), Sanitize(weights.Z));
- L604 C31: new Vector4 :: ImGui.ColorButton(id, new Vector4(tonemapped, 1f), ImGuiColorEditFlags.NoTooltip, size);
- L622 C26: new Vector2 :: drawList.AddText(new Vector2(pos.X + 1f, pos.Y + 1f), shadow, overlayText);
- L668 C18: new Vector3 :: mapped = new Vector3(
- L672 C16: new Vector3 :: return new Vector3(Saturate(mapped.X), Saturate(mapped.Y), Saturate(mapped.Z));
- L767 C41: new Vector2 :: Vector2 uv0 = flipPreview ? new Vector2(0f, 1f) : Vector2.Zero;
- L768 C41: new Vector2 :: Vector2 uv1 = flipPreview ? new Vector2(1f, 0f) : Vector2.One;
- L771 C29: new List :: var infoParts = new List<string>
- L794 C26: new List :: var unique = new List<XRTexture>();
- L809 C16: new List :: return new List<XRTexture>();
- L929 C16: new ImGuiChildScope :: using (new ImGuiChildScope("RenderPipelineCommandTree", treeSize))
- L938 C16: new ImGuiChildScope :: using (new ImGuiChildScope("RenderPipelineCommandDetails", new Vector2(0f, treeSize.Y)))
- L938 C68: new Vector2 :: using (new ImGuiChildScope("RenderPipelineCommandDetails", new Vector2(0f, treeSize.Y)))
- L1023 C20: new CommandTreeNode :: var root = new CommandTreeNode(label, path, null);
- L1024 C19: new Dictionary :: nodeMap = new Dictionary<string, CommandTreeNode>(StringComparer.Ordinal);
- L1025 C23: new HashSet :: var visited = new HashSet<ViewportRenderCommandContainer>(ReferenceComparer<ViewportRenderCommandContainer>.Instance);
- L1045 C31: new CommandTreeNode :: var commandNode = new CommandTreeNode(commandLabel, commandPath, command);
- L1134 C24: new CommandTreeNode :: var node = new CommandTreeNode(label, childPath, null);
- L1135 C20: new ChildContainerInfo :: return new ChildContainerInfo(node, container);
- L1165 C23: new StringBuilder :: var builder = new StringBuilder(input.Length * 2);
- L1182 C23: new StringBuilder :: var builder = new StringBuilder(baseSegment.Length);
- L1294 C22: new List :: var badges = new List<string>(4);
- L1360 C23: new Vector2 :: displaySize = new Vector2(64f, 64f);
- L1381 C23: new Vector2 :: displaySize = new Vector2(pixelSize.X * scale, pixelSize.Y * scale);
- L1452 C92: new TextureViewCacheKeyComparer :: private static readonly Dictionary<XRTexture, TexturePreviewState> PreviewStates = new(new TextureViewCacheKeyComparer());
- L1453 C123: new TextureViewCacheKeyComparer :: private static readonly Dictionary<XRTexture, Dictionary<(int mip, int layer), XRTextureViewBase>> PreviewViews = new(new TextureViewCacheKeyComparer());
- L1459 C21: new TexturePreviewState :: state = new TexturePreviewState();
- L1581 C21: new Dictionary :: views = new Dictionary<(int mip, int layer), XRTextureViewBase>();
- L1593 C20: new XRTexture2DView :: var view = new XRTexture2DView(texture, (uint)mip, 1u, texture.SizedInternalFormat, false, texture.MultiSample);
- L1602 C21: new Dictionary :: views = new Dictionary<(int mip, int layer), XRTextureViewBase>();
- L1616 C20: new XRTexture2DArrayView :: var view = new XRTexture2DArrayView(texture, (uint)mip, 1u, (uint)layer, 1u, texture.SizedInternalFormat, false, texture.MultiSample);
- L1628 C34: new Vector2 :: XRTexture2D tex2D => new Vector2(Shifted(tex2D.Width, mipLevel), Shifted(tex2D.Height, mipLevel)),
- L1629 C39: new Vector2 :: XRTexture2DArray array => new Vector2(Shifted(array.Width, mipLevel), Shifted(array.Height, mipLevel)),
- L1631 C39: new Vector2 :: XRTextureViewBase view => new Vector2(
- L1634 C18: new Vector2 :: _ => new Vector2(1f, 1f),
- L1729 C58: new() :: public List<CommandTreeNode> Children { get; } = new();
- L1738 C64: new() :: public static ReferenceComparer<T> Instance { get; } = new();


## XREngine.Editor/AssetEditors/TextFileInspector.cs
- L28 C80: new() :: private readonly ConditionalWeakTable<TextFile, EditorState> _stateCache = new();
- L42 C53: new EditorImGuiUI.InspectorTargetSet :: EditorImGuiUI.DrawDefaultAssetInspector(new EditorImGuiUI.InspectorTargetSet(textFiles, targets.CommonType), visitedObjects);
- L48 C57: new EditorState :: var state = _stateCache.GetValue(textFile, _ => new EditorState());
- L82 C15: new Vector4 :: ? new Vector4(0.95f, 0.45f, 0.45f, 1f)
- L83 C15: new Vector4 :: : new Vector4(0.5f, 0.8f, 0.5f, 1f);
- L92 C16: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!hasPath))
- L100 C16: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!hasPath))


## XREngine.Editor/AssetEditors/XRMaterialInspector.cs
- L223 C22: new Dictionary :: var lookup = new Dictionary<string, ShaderVar>(StringComparer.Ordinal);
- L551 C34: new Vector2 :: XRTexture2D tex2D => new Vector2(tex2D.Width, tex2D.Height),
- L552 C18: new Vector2 :: _ => new Vector2(texture.WidthHeightDepth.X, texture.WidthHeightDepth.Y),
- L562 C20: new Vector2 :: return new Vector2(TexturePreviewFallbackEdge, TexturePreviewFallbackEdge);
- L566 C20: new Vector2 :: return new Vector2(width, height);
- L569 C16: new Vector2 :: return new Vector2(width * scale, height * scale);
- L579 C16: new ParsedShaderData :: return new ParsedShaderData(uniforms, blocks);
- L584 C23: new List :: var results = new List<UniformEntry>();
- L593 C25: new UniformEntry :: results.Add(new UniformEntry(name, type, arraySize));
- L601 C23: new List :: var results = new List<UniformBlockEntry>();
- L608 C27: new List :: var members = new List<UniformEntry>();
- L614 C29: new UniformEntry :: members.Add(new UniformEntry(name, type, arraySize));
- L617 C25: new UniformBlockEntry :: results.Add(new UniformBlockEntry(blockName, instanceName, members));
- L625 C24: new List :: var samplers = new List<SamplerEntry>();
- L626 C20: new HashSet :: var seen = new HashSet<string>(StringComparer.Ordinal);
- L654 C38: new SamplerEntry :: samplers.Add(new SamplerEntry(indexedName, typeLabel, kind, arraySize));
- L660 C34: new SamplerEntry :: samplers.Add(new SamplerEntry(name, typeLabel, kind, arraySize));


## XREngine.Editor/AssetEditors/XRShaderInspector.cs
- L15 C64: new() :: private static readonly TextFileInspector _textInspector = new();
- L30 C53: new EditorImGuiUI.InspectorTargetSet :: EditorImGuiUI.DrawDefaultAssetInspector(new EditorImGuiUI.InspectorTargetSet(shaders, targets.CommonType), visitedObjects);
- L123 C38: new EditorImGuiUI.InspectorTargetSet :: _textInspector.DrawInspector(new EditorImGuiUI.InspectorTargetSet(new object[] { source }, source.GetType()), visitedObjects);
- L123 C75: new object :: _textInspector.DrawInspector(new EditorImGuiUI.InspectorTargetSet(new object[] { source }, source.GetType()), visitedObjects);


## XREngine.Editor/CodeManager.cs
- L234 C13: new XAttribute :: new XAttribute("Sdk", "Microsoft.NET.Sdk"),
- L235 C13: new XElement :: new XElement("PropertyGroup",
- L236 C17: new XElement :: new XElement("OutputType", executable ? "Exe" : "Library"),
- L237 C17: new XElement :: new XElement("TargetFramework", TargetFramework),
- L238 C17: new XElement :: new XElement("RootNamespace", rootNamespace),
- L239 C17: new XElement :: new XElement("AssemblyName", Path.GetFileNameWithoutExtension(projectFilePath)),
- L240 C17: new XElement :: new XElement("ImplicitUsings", implicitUsings ? "enable" : "disable"),
- L241 C17: new XElement :: new XElement("EnableDefaultCompileItems", "false"),
- L242 C17: new XElement :: new XElement("AllowUnsafeBlocks", allowUnsafeBlocks ? "true" : "false"),
- L243 C17: new XElement :: new XElement("PublishAot", aot ? "true" : "false"),
- L244 C17: new XElement :: new XElement("LangVersion", languageVersion), //https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/configure-language-version
- L245 C17: new XElement :: new XElement("Nullable", nullableEnable ? "enable" : "disable"),
- L246 C17: new XElement :: new XElement("Platforms", string.Join(";", platforms)),
- L247 C17: new XElement :: new XElement("PublishSingleFile", publishSingleFile ? "true" : "false"), //https://learn.microsoft.com/en-us/dotnet/core/deploying/single-file/overview?tabs=cli
- L248 C17: new XElement :: new XElement("SelfContained", selfContained ? "true" : "false"),
- L249 C17: new XElement :: new XElement("RuntimeIdentifier", "win-x64"),
- L250 C17: new XElement :: new XElement("BaseOutputPath", "Build")
- L257 C29: new XElement :: content.Add(new XElement("PropertyGroup",
- L258 C21: new XAttribute :: new XAttribute("Condition", $" '$(Configuration)|$(Platform)' == '{build}|{platform}' "),
- L259 C21: new XElement :: new XElement("IsTrimmable", "True"),
- L260 C21: new XElement :: new XElement("IsAotCompatible", "True"),
- L261 C21: new XElement :: new XElement("Optimize", "False"),
- L262 C21: new XElement :: new XElement("DebugType", "embedded")
- L266 C21: new XElement :: content.Add(new XElement("ItemGroup",
- L268 C33: new XElement :: .Select(file => new XElement("Compile", new XAttribute("Include", file)))
- L268 C57: new XAttribute :: .Select(file => new XElement("Compile", new XAttribute("Include", file)))
- L272 C25: new XElement :: content.Add(new XElement("ItemGroup",
- L273 C47: new XElement :: packageReferences.Select(x => new XElement("PackageReference",
- L274 C21: new XAttribute :: new XAttribute("Include", x.name),
- L275 C21: new XAttribute :: new XAttribute("Version", x.version)
- L280 C25: new XElement :: content.Add(new XElement("ItemGroup",
- L281 C50: new XElement :: includedProjectPaths.Select(x => new XElement("ProjectReference",
- L282 C21: new XAttribute :: new XAttribute("Include", x)
- L287 C25: new XElement :: content.Add(new XElement("ItemGroup",
- L288 C52: new XElement :: assemblyReferencePaths.Select(x => new XElement("Reference",
- L289 C21: new XAttribute :: new XAttribute("Include", Path.GetFileNameWithoutExtension(x)),
- L290 C21: new XElement :: new XElement("HintPath", x)
- L294 C23: new XDocument :: var project = new XDocument(new XElement("Project", content));
- L294 C37: new XElement :: var project = new XDocument(new XElement("Project", content));
- L301 C31: new StringBuilder :: var solutionContent = new StringBuilder();
- L352 C28: new StringLogger :: var stringLogger = new StringLogger(LoggerVerbosity.Diagnostic);
- L354 C33: new ProjectCollection :: var projectCollection = new ProjectCollection();
- L355 C31: new BuildParameters :: var buildParameters = new BuildParameters(projectCollection)
- L360 C45: new() :: Dictionary<string, string?> props = new()
- L447 C38: new[] :: foreach (string buildRoot in new[] { primaryBuildRoot, legacyBuildRoot })
- L525 C30: new Dictionary :: var extraProps = new Dictionary<string, string?>
- L539 C23: new InvalidOperationException :: throw new InvalidOperationException($"Failed to publish launcher executable. {publishLog}");
- L544 C23: new FileNotFoundException :: throw new FileNotFoundException("Launcher executable was not produced by publish.", launcherExePath);
- L553 C30: new Dictionary :: extraProps = new Dictionary<string, string?>
- L562 C23: new InvalidOperationException :: throw new InvalidOperationException($"Failed to build launcher executable. {buildLog}");
- L605 C15: new FileNotFoundException :: throw new FileNotFoundException("Launcher executable was not produced by the build.", Path.Combine(buildRoot, fileName));
- L654 C33: new List :: var referenceElements = new List<XElement>();
- L657 C35: new XElement :: referenceElements.Add(new XElement("Reference",
- L658 C17: new XAttribute :: new XAttribute("Include", Path.GetFileNameWithoutExtension(assemblyPath)),
- L659 C17: new XElement :: new XElement("HintPath", assemblyPath)));
- L662 C23: new XDocument :: var project = new XDocument(
- L663 C13: new XElement :: new XElement("Project",
- L664 C17: new XAttribute :: new XAttribute("Sdk", "Microsoft.NET.Sdk"),
- L665 C17: new XElement :: new XElement("PropertyGroup",
- L666 C21: new XElement :: new XElement("OutputType", "WinExe"),
- L667 C21: new XElement :: new XElement("TargetFramework", TargetFramework),
- L668 C21: new XElement :: new XElement("ImplicitUsings", "enable"),
- L669 C21: new XElement :: new XElement("Nullable", "enable"),
- L670 C21: new XElement :: new XElement("EnableDefaultCompileItems", "false"),
- L671 C21: new XElement :: new XElement("AllowUnsafeBlocks", "true"),
- L672 C21: new XElement :: new XElement("PublishAot", "false"),
- L673 C21: new XElement :: new XElement("SelfContained", "false"),
- L674 C21: new XElement :: new XElement("Platforms", platform),
- L675 C21: new XElement :: new XElement("RuntimeIdentifier", "win-x64"),
- L676 C21: new XElement :: new XElement("AssemblyName", assemblyName),
- L677 C21: new XElement :: new XElement("RootNamespace", assemblyName.Replace('.', '_')),
- L678 C21: new XElement :: new XElement("BaseOutputPath", "Build")
- L680 C17: new XElement :: new XElement("ItemGroup",
- L681 C21: new XElement :: new XElement("Compile", new XAttribute("Include", relativeProgramPath)))
- L681 C45: new XAttribute :: new XElement("Compile", new XAttribute("Include", relativeProgramPath)))
- L688 C17: new XElement :: new XElement("ItemGroup",
- L689 C21: new XElement :: new XElement("ProjectReference", new XAttribute("Include", relativeGameProjectPath))));
- L689 C54: new XAttribute :: new XElement("ProjectReference", new XAttribute("Include", relativeGameProjectPath))));
- L693 C31: new XElement :: project.Root?.Add(new XElement("ItemGroup", referenceElements));
- L713 C25: new DiagnosticsProcessStartInfo :: var startInfo = new DiagnosticsProcessStartInfo("dotnet")
- L743 C22: new InvalidOperationException :: ?? throw new InvalidOperationException($"Failed to start dotnet msbuild for '{projectFilePath}'.");
- L801 C18: new StringBuilder :: var sb = new StringBuilder();


## XREngine.Editor/CodeManager.StringLogger.cs
- L9 C47: new() :: private readonly StringBuilder _log = new();


## XREngine.Editor/ComponentEditors/CameraComponentEditor.cs
- L26 C109: new() :: private static readonly ConcurrentDictionary<XRCamera, CameraProjectionTransition> _activeTransitions = new();
- L73 C26: new System.Text.StringBuilder :: var result = new System.Text.StringBuilder();
- L118 C26: new ParameterOption :: .Select(t => new ParameterOption(t))
- L124 C44: new ParameterOption :: return types.Length > 0 ? types : [new ParameterOption(typeof(XRPerspectiveCameraParameters))];
- L193 C30: new List :: var boundViewports = new List<XRViewport>();
- L202 C15: new Vector4 :: ? new Vector4(0.2f, 0.8f, 0.2f, 1.0f)  // Green for active
- L203 C15: new Vector4 :: : new Vector4(0.6f, 0.6f, 0.6f, 1.0f); // Gray for inactive
- L218 C31: new Vector4 :: ImGui.TextColored(new Vector4(0.4f, 0.8f, 1.0f, 1.0f), $"Local Player: {(int)player.LocalPlayerIndex + 1}");
- L232 C31: new Vector4 :: ImGui.TextColored(new Vector4(0.4f, 1.0f, 0.6f, 1.0f), $"Pawn: {pawnName}");
- L248 C31: new Vector4 :: ImGui.TextColored(new Vector4(1.0f, 0.8f, 0.4f, 1.0f), $"Viewports: {viewportCount}");
- L272 C31: new Vector4 :: ImGui.TextColored(new Vector4(1.0f, 0.7f, 0.2f, 1.0f), "⚠ Camera is not rendering");
- L333 C44: new LayerMask :: component.Camera.CullingMask = new LayerMask(cullingMask);
- L518 C15: new ParameterOption :: : new ParameterOption(current.GetType()).Label;
- L521 C82: new ParameterOption :: var currentOption = currentIndex >= 0 ? ParameterOptions[currentIndex] : new ParameterOption(current.GetType());
- L529 C52: new Vector2 :: ImGui.ProgressBar(transition.Progress, new Vector2(-1, 0), "Transitioning...");
- L623 C33: new CameraProjectionTransition :: var newTransition = new CameraProjectionTransition(camera, camera.Transform);
- L708 C16: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(parameters.InheritAspectRatio))
- L728 C16: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(parameters.InheritAspectRatio))
- L845 C16: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(parameters.InheritResolution))
- L865 C16: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(parameters.InheritPrincipalPoint))
- L1152 C51: new Vector3 :: value = NormalizeLuminanceWeights(new Vector3(0.2126f, 0.7152f, 0.0722f), Engine.Rendering.Settings.DefaultLuminance);
- L1159 C51: new Vector3 :: value = NormalizeLuminanceWeights(new Vector3(0.299f, 0.587f, 0.114f), Engine.Rendering.Settings.DefaultLuminance);
- L1166 C51: new Vector3 :: value = NormalizeLuminanceWeights(new Vector3(1.0f, 1.0f, 1.0f), Engine.Rendering.Settings.DefaultLuminance);
- L1187 C13: new Vector3 :: w = new Vector3(Sanitize(w.X), Sanitize(w.Y), Sanitize(w.Z));
- L1220 C39: new Vector2 :: return (T)(object)new Vector2(v3.X, v3.Y);
- L1222 C39: new Vector2 :: return (T)(object)new Vector2(v4.X, v4.Y);
- L1226 C35: new Vector3 :: return (T)(object)new Vector3(v4Value.X, v4Value.Y, v4Value.Z);
- L1441 C16: new Vector2 :: return new Vector2(width, height);
- L1447 C16: new Vector2 :: return new Vector2(MathF.Max(1.0f, dims.X), MathF.Max(1.0f, dims.Y));


## XREngine.Editor/ComponentEditors/ComponentEditorLayout.cs
- L27 C93: new() :: private static readonly ConditionalWeakTable<XRComponent, InspectorModeState> s_modes = new();
- L37 C69: new InspectorModeState :: InspectorModeState state = s_modes.GetValue(component, _ => new InspectorModeState());
- L68 C29: new PreviewDialogState :: s_previewDialog ??= new PreviewDialogState();
- L72 C37: new Vector2 :: s_previewDialog.PixelSize = new Vector2(MathF.Max(1f, pixelSize.X), MathF.Max(1f, pixelSize.Y));
- L88 C33: new Vector2 :: ImGui.SetNextWindowSize(new Vector2(512f, 512f), ImGuiCond.Appearing);
- L94 C51: new Vector2 :: Vector2 uv0 = dialog.FlipVertically ? new Vector2(0f, 1f) : Vector2.Zero;
- L95 C51: new Vector2 :: Vector2 uv1 = dialog.FlipVertically ? new Vector2(1f, 0f) : Vector2.One;
- L125 C16: new Vector2 :: return new Vector2(width * scale, height * scale);


## XREngine.Editor/ComponentEditors/GLObjectEditorAttribute.cs
- L31 C19: new ArgumentException :: throw new ArgumentException($"Target type must be assignable to {nameof(IGLObject)}", nameof(targetType));


## XREngine.Editor/ComponentEditors/GLObjectEditorRegistry.cs
- L22 C81: new() :: private static readonly Dictionary<Type, GLObjectEditorDelegate> _editors = new();
- L24 C44: new() :: private static readonly object _lock = new();
- L232 C35: new System.Numerics.Vector4 :: ImGui.TextColored(new System.Numerics.Vector4(1.0f, 0.3f, 0.3f, 1.0f),


## XREngine.Editor/ComponentEditors/GLObjectEditors.cs
- L190 C20: new Vector4 :: return new Vector4(1.0f, 1.0f, 1.0f, 1.0f);
- L196 C20: new Vector4 :: return new Vector4(0.9f, 0.7f, 0.4f, 1.0f);
- L246 C113: new() :: List<(IFrameBufferAttachement target, EFrameBufferAttachment attachment, int index)> colorAttachments = new();
- L247 C113: new() :: List<(IFrameBufferAttachement target, EFrameBufferAttachment attachment, int index)> depthAttachments = new();
- L248 C115: new() :: List<(IFrameBufferAttachement target, EFrameBufferAttachment attachment, int index)> stencilAttachments = new();
- L387 C45: new Vector2 :: _previewDialogTextureSize = new Vector2(width, height);
- L400 C41: new Vector2 :: _previewDialogTextureSize = new Vector2(width, height);
- L414 C33: new Vector2 :: ImGui.SetNextWindowSize(new Vector2(400, 400), ImGuiCond.FirstUseEver);
- L441 C29: new Vector2 :: imageSize = new Vector2(availableSize.X, availableSize.X / aspectRatio);
- L445 C29: new Vector2 :: imageSize = new Vector2(availableSize.Y * aspectRatio, availableSize.Y);
- L1095 C20: new Vector2 :: return new Vector2(TexturePreviewFallbackEdge, TexturePreviewFallbackEdge);
- L1099 C20: new Vector2 :: return new Vector2(width, height);
- L1102 C16: new Vector2 :: return new Vector2(width * scale, height * scale);


## XREngine.Editor/ComponentEditors/GPULandscapeComponentEditor.cs
- L42 C94: new() :: private static readonly ConditionalWeakTable<LandscapeComponent, EditorState> s_states = new();
- L72 C55: new EditorState :: var state = s_states.GetValue(landscape, _ => new EditorState());
- L222 C39: new Vector2 :: ImGui.BeginChild("LayerList", new Vector2(0, 150), ImGuiChildFlags.Border);
- L233 C78: new Vector2 :: ImGui.ColorButton("##tint", tint, ImGuiColorEditFlags.NoTooltip, new Vector2(16, 16));
- L271 C28: new TerrainLayer :: var newLayer = new TerrainLayer { Name = $"Layer {layers.Count}" };
- L297 C26: new ColorF4 :: layer.Tint = new ColorF4(tint.X, tint.Y, tint.Z, 1.0f);
- L302 C40: new Vector2 :: layer.Tiling = Vector2.Max(new Vector2(0.001f), tiling);
- L357 C40: new Vector2 :: ImGui.BeginChild("ModuleList", new Vector2(0, 150), ImGuiChildFlags.Border);
- L576 C55: new Vector2 :: Vector2 center = ImGui.GetCursorScreenPos() + new Vector2(50, 50);
- L582 C83: new Vector4 :: drawList.AddCircleFilled(center, maxRadius, ImGui.ColorConvertFloat4ToU32(new Vector4(0.3f, 0.5f, 1.0f, 0.2f)), 32);
- L583 C85: new Vector4 :: drawList.AddCircleFilled(center, innerRadius, ImGui.ColorConvertFloat4ToU32(new Vector4(0.3f, 0.5f, 1.0f, 0.5f)), 32);
- L584 C77: new Vector4 :: drawList.AddCircle(center, maxRadius, ImGui.ColorConvertFloat4ToU32(new Vector4(0.3f, 0.5f, 1.0f, 1.0f)), 32, 2.0f);
- L586 C21: new Vector2 :: ImGui.Dummy(new Vector2(100, 100));


## XREngine.Editor/ComponentEditors/GPUParticleEmitterComponentEditor.cs
- L28 C100: new() :: private static readonly ConditionalWeakTable<ParticleEmitterComponent, EditorState> s_states = new();
- L62 C53: new EditorState :: var state = s_states.GetValue(emitter, _ => new EditorState());
- L144 C36: new ColorF4 :: emitter.InitialColor = new ColorF4(initialColor.X, initialColor.Y, initialColor.Z, initialColor.W);
- L152 C44: new Vector3 :: emitter.ScaleMin = Vector3.Max(new Vector3(0.001f), scaleMin);
- L169 C31: new Vector3 :: emitter.Gravity = new Vector3(0, -9.81f, 0);
- L172 C31: new Vector3 :: emitter.Gravity = new Vector3(0, -1.62f, 0);
- L178 C31: new Vector3 :: emitter.Gravity = new Vector3(0, 9.81f, 0);
- L211 C35: new Data.Geometry.AABB :: emitter.LocalBounds = new Data.Geometry.AABB(boundsMin, boundsMax);
- L233 C40: new Vector2 :: ImGui.BeginChild("ModuleList", new Vector2(0, 200), ImGuiChildFlags.Border);
- L392 C33: new ColorF4 :: module.StartColor = new ColorF4(startColor.X, startColor.Y, startColor.Z, startColor.W);
- L396 C31: new ColorF4 :: module.EndColor = new ColorF4(endColor.X, endColor.Y, endColor.Z, endColor.W);
- L409 C30: new Vector2 :: drawList.AddLine(new Vector2(pos.X + i, pos.Y), new Vector2(pos.X + i, pos.Y + size.Y), color);
- L409 C61: new Vector2 :: drawList.AddLine(new Vector2(pos.X + i, pos.Y), new Vector2(pos.X + i, pos.Y + size.Y), color);
- L451 C33: new Vector2 :: module.SpeedRange = new Vector2(MathF.Max(0, speedRange.X), MathF.Max(speedRange.X, speedRange.Y));
- L463 C34: new Vector2 :: ImGui.ProgressBar(usage, new Vector2(-1, 0), $"{usage:P1}");


## XREngine.Editor/ComponentEditors/JointComponentEditors.cs
- L35 C15: new Vector4 :: ? new Vector4(0.2f, 1f, 0.2f, 1f)
- L36 C15: new Vector4 :: : new Vector4(1f, 0.8f, 0.2f, 1f);
- L195 C25: new JointDrive :: drive = new JointDrive(stiffness, damping, forceLimit, accel);
- L197 C25: new JointDrive :: drive = new JointDrive(stiffness, damping, forceLimit, accel);
- L199 C25: new JointDrive :: drive = new JointDrive(stiffness, damping, forceLimit, accel);
- L201 C25: new JointDrive :: drive = new JointDrive(stiffness, damping, forceLimit, accel);
- L222 C33: new Quaternion :: => Quaternion.Normalize(new Quaternion(v.X, v.Y, v.Z, v.W));


## XREngine.Editor/ComponentEditors/LightComponentEditorShared.cs
- L19 C109: new() :: private static readonly ConditionalWeakTable<XRTextureCube, CubemapPreviewCache> CubemapPreviewCaches = new();
- L270 C75: new CubemapPreviewCache :: var previewCache = CubemapPreviewCaches.GetValue(cubemap, cube => new CubemapPreviewCache(cube));
- L359 C29: new Vector2 :: pixelSize = new Vector2(extent, extent);
- L420 C20: new Vector2 :: return new Vector2(PreviewFallbackEdge, PreviewFallbackEdge);
- L423 C20: new Vector2 :: return new Vector2(width, height);
- L426 C16: new Vector2 :: return new Vector2(width * scale, height * scale);
- L432 C34: new Vector2 :: XRTexture2D tex2D => new Vector2(MathF.Max(1.0f, tex2D.Width), MathF.Max(1.0f, tex2D.Height)),
- L434 C17: new Vector2 :: new Vector2(MathF.Max(1.0f, cubeView.ViewedTexture.Extent), MathF.Max(1.0f, cubeView.ViewedTexture.Extent)),
- L435 C18: new Vector2 :: _ => new Vector2(MathF.Max(1.0f, texture.WidthHeightDepth.X), MathF.Max(1.0f, texture.WidthHeightDepth.Y)),
- L453 C59: new XRTextureCubeView :: private readonly XRTextureCubeView[] _faceViews = new XRTextureCubeView[6];
- L466 C24: new XRTextureCubeView :: var view = new XRTextureCubeView(


## XREngine.Editor/ComponentEditors/LightProbeComponentEditor.cs
- L87 C109: new() :: private static readonly ConditionalWeakTable<XRTextureCube, CubemapPreviewCache> CubemapPreviewCaches = new();
- L104 C46: new Vector3 :: lightProbe.ProxyBoxHalfExtents = new Vector3(
- L116 C21: new Quaternion :: var q = new Quaternion(proxyRotation.X, proxyRotation.Y, proxyRotation.Z, proxyRotation.W);
- L209 C75: new CubemapPreviewCache :: var previewCache = CubemapPreviewCaches.GetValue(cubemap, cube => new CubemapPreviewCache(cube));
- L355 C29: new Vector2 :: pixelSize = new Vector2(extent, extent);
- L416 C20: new Vector2 :: return new Vector2(PreviewFallbackEdge, PreviewFallbackEdge);
- L419 C20: new Vector2 :: return new Vector2(width, height);
- L422 C16: new Vector2 :: return new Vector2(width * scale, height * scale);
- L428 C34: new Vector2 :: XRTexture2D tex2D => new Vector2(MathF.Max(1.0f, tex2D.Width), MathF.Max(1.0f, tex2D.Height)),
- L430 C17: new Vector2 :: new Vector2(MathF.Max(1.0f, cubeView.ViewedTexture.Extent), MathF.Max(1.0f, cubeView.ViewedTexture.Extent)),
- L431 C18: new Vector2 :: _ => new Vector2(MathF.Max(1.0f, texture.WidthHeightDepth.X), MathF.Max(1.0f, texture.WidthHeightDepth.Y)),
- L449 C59: new XRTextureCubeView :: private readonly XRTextureCubeView[] _faceViews = new XRTextureCubeView[6];
- L462 C24: new XRTextureCubeView :: var view = new XRTextureCubeView(


## XREngine.Editor/ComponentEditors/ModelComponentEditor.cs
- L72 C62: new() :: public readonly HashSet<XRMesh> AttemptedBvhBuilds = new();
- L73 C100: new() :: public readonly Dictionary<RenderableMesh, RenderInfo.DelPreRenderCallback> MeshHandlers = new();
- L74 C94: new() :: private readonly Dictionary<RenderableMesh, SkinnedBvhCacheEntry> _skinnedBvhCache = new();
- L75 C49: new() :: private readonly object _handlersLock = new();
- L76 C53: new() :: private readonly object _skinnedCacheLock = new();
- L87 C42: new SkinnedBvhCacheEntry :: _skinnedBvhCache[mesh] = new SkinnedBvhCacheEntry(tree, localToWorld);
- L111 C100: new() :: private static readonly ConditionalWeakTable<ModelComponent, ImpostorState> s_impostorStates = new();
- L112 C104: new() :: private static readonly ConditionalWeakTable<ModelComponent, BvhPreviewState> s_bvhPreviewStates = new();
- L113 C107: new() :: private static readonly ConditionalWeakTable<SubMesh, SubMeshMaterialState> s_submeshMaterialStates = new();
- L212 C32: new Dictionary :: var blendshapeValues = new Dictionary<string, List<float>>(StringComparer.InvariantCultureIgnoreCase);
- L213 C28: new Dictionary :: var displayNames = new Dictionary<string, string>(StringComparer.InvariantCultureIgnoreCase);
- L230 C34: new List :: values = new List<float>();
- L295 C70: new BvhPreviewState :: var state = s_bvhPreviewStates.GetValue(modelComponent, _ => new BvhPreviewState());
- L313 C43: new ColorF4 :: state.InternalNodeColor = new ColorF4(internalColor.X, internalColor.Y, internalColor.Z, internalColor.W);
- L317 C39: new ColorF4 :: state.LeafNodeColor = new ColorF4(leafColor.X, leafColor.Y, leafColor.Z, leafColor.W);
- L347 C27: new List :: var removed = new List<RenderableMesh>();
- L439 C41: new Stack :: var nodeStack = t_nodeStack ??= new Stack<BVHNode<Triangle>>();
- L480 C68: new ImpostorState :: var state = s_impostorStates.GetValue(modelComponent, _ => new ImpostorState());
- L492 C58: new Vector2 :: if (ImGui.Button("Generate Octahedral Impostor", new Vector2(-1f, 0f)))
- L494 C85: new OctahedralImposterGenerator.Settings :: state.LastResult = OctahedralImposterGenerator.Generate(modelComponent, new OctahedralImposterGenerator.Settings(state.SheetSize, 1.15f, state.CaptureDepth));
- L528 C59: new Vector2 :: if (ImGui.Button("Create Billboard Impostor", new Vector2(-1f, 0f)))
- L1022 C34: new Vector2 :: XRTexture2D tex2D => new Vector2(tex2D.Width, tex2D.Height),
- L1023 C18: new Vector2 :: _ => new Vector2(texture.WidthHeightDepth.X, texture.WidthHeightDepth.Y),
- L1033 C20: new Vector2 :: return new Vector2(TexturePreviewFallbackEdge, TexturePreviewFallbackEdge);
- L1037 C20: new Vector2 :: return new Vector2(width, height);
- L1040 C16: new Vector2 :: return new Vector2(width * scale, height * scale);
- L1045 C90: new() :: List<(int, SubMeshLOD, LinkedListNode<RenderableMesh.RenderableLOD>?)> entries = new();
- L1568 C26: new List :: var attributes = new List<string>();
- L1597 C68: new SubMeshMaterialState :: var state = s_submeshMaterialStates.GetValue(subMesh, _ => new SubMeshMaterialState());
- L1756 C80: new SubMeshMaterialState :: var materialState = s_submeshMaterialStates.GetValue(subMesh, _ => new SubMeshMaterialState());


## XREngine.Editor/ComponentEditors/RigidBodyComponentEditors.cs
- L26 C47: new() :: public readonly Stopwatch Stopwatch = new();
- L34 C110: new() :: private static readonly ConditionalWeakTable<PhysicsActorComponent, GenerationState> _generationStates = new();
- L35 C108: new() :: private static readonly ConditionalWeakTable<PhysicsActorComponent, HullPreviewState> _previewStates = new();
- L42 C64: new GenerationState :: var state = _generationStates.GetValue(component, _ => new GenerationState());
- L46 C16: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!hasModel || state.InProgress))
- L49 C37: new Vector2 :: if (ImGui.Button(label, new Vector2(-1f, 0f)) && hasModel && !state.InProgress)
- L76 C28: new Progress :: var progress = new Progress<PhysicsActorComponent.ConvexHullGenerationProgress>(p =>
- L116 C68: new HullPreviewState :: var previewState = _previewStates.GetValue(component, _ => new HullPreviewState());
- L121 C16: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!hasHulls))
- L131 C31: new Vector4 :: ImGui.TextColored(new Vector4(0.4f, 0.9f, 0.9f, 1f), "Wireframe preview queued for rendering.");
- L206 C31: new Vector4 :: ImGui.TextColored(new Vector4(0.4f, 0.9f, 0.9f, 1f), $"{spinner} {message}");
- L212 C44: new Vector2 :: ImGui.ProgressBar(percent, new Vector2(-1f, 0f), $"{percent * 100f:0}%");
- L275 C20: new Quaternion :: var quat = new Quaternion(value.X, value.Y, value.Z, value.W);
- L336 C31: new Vector4 :: ImGui.TextColored(new Vector4(1.0f, 0.8f, 0.2f, 1.0f), "Rigid body not created.");
- L603 C31: new Vector4 :: ImGui.TextColored(new Vector4(1.0f, 0.8f, 0.2f, 1.0f), "Rigid body not created.");


## XREngine.Editor/ComponentEditors/UIMaterialComponentEditor.cs
- L99 C40: new Vector2 :: Vector2 uv0 = flipVertically ? new Vector2(0.0f, 1.0f) : Vector2.Zero;
- L100 C40: new Vector2 :: Vector2 uv1 = flipVertically ? new Vector2(1.0f, 0.0f) : Vector2.One;
- L190 C29: new Vector2 :: pixelSize = new Vector2(extent, extent);
- L252 C20: new Vector2 :: return new Vector2(PreviewFallbackEdge, PreviewFallbackEdge);
- L255 C20: new Vector2 :: return new Vector2(width, height);
- L258 C16: new Vector2 :: return new Vector2(width * scale, height * scale);
- L264 C34: new Vector2 :: XRTexture2D tex2D => new Vector2(MathF.Max(1.0f, tex2D.Width), MathF.Max(1.0f, tex2D.Height)),
- L266 C17: new Vector2 :: new Vector2(MathF.Max(1.0f, cubeView.ViewedTexture.Extent), MathF.Max(1.0f, cubeView.ViewedTexture.Extent)),
- L267 C18: new Vector2 :: _ => new Vector2(MathF.Max(1.0f, texture.WidthHeightDepth.X), MathF.Max(1.0f, texture.WidthHeightDepth.Y)),


## XREngine.Editor/ConsoleHelper.cs
- L35 C28: new StreamWriter :: Console.SetOut(new StreamWriter(standardOutput) { AutoFlush = true });
- L36 C30: new StreamWriter :: Console.SetError(new StreamWriter(standardError) { AutoFlush = true });
- L37 C27: new StreamReader :: Console.SetIn(new StreamReader(standardInput));


## XREngine.Editor/ConsolePackProgress.cs
- L17 C37: new() :: private readonly object _lock = new();
- L20 C45: new() :: private readonly Stopwatch _stopwatch = new();
- L136 C44: new FileProgress :: _activeFiles[p.RelativePath] = new FileProgress
- L154 C40: new FileProgress :: _activeFiles[p.RelativePath] = new FileProgress
- L283 C22: new string :: string bar = new string('\u2588', filled) + new string('\u2591', BarWidth - filled);
- L283 C53: new string :: string bar = new string('\u2588', filled) + new string('\u2591', BarWidth - filled);


## XREngine.Editor/EditorFileDropHandler.cs
- L109 C31: new() :: XRTexture2D texture = new();


## XREngine.Editor/EditorFlyingCameraPawnComponent.cs
- L445 C61: new() :: private PhysxScene.PhysxQueryFilter _physxQueryFilter = new();
- L479 C128: new() :: private readonly ConcurrentQueue<SortedDictionary<float, List<(RenderInfo3D item, object? data)>>> _octreePickResultPool = new();
- L480 C129: new() :: private readonly ConcurrentQueue<SortedDictionary<float, List<(XRComponent? item, object? data)>>> _physicsPickResultPool = new();
- L525 C42: new() :: private readonly Lock _raycastLock = new();
- L680 C13: new ShaderVector4 :: new ShaderVector4(HoveredFaceFillColor, "FillColor"),
- L681 C13: new ShaderFloat :: new ShaderFloat(StippleScale, "StippleScale"),
- L682 C13: new ShaderFloat :: new ShaderFloat(StippleThickness, "StippleThickness"),
- L683 C13: new ShaderFloat :: new ShaderFloat(_stippleDepthOffset, "DepthOffset"),
- L685 C19: new XRMaterial :: var mat = new XRMaterial(vars, fragShader);
- L692 C37: new XRMeshRenderer :: _stippledTriangleRenderer = new XRMeshRenderer(_stippledTriangleMesh, mat);
- L920 C30: new ColorF4 :: var nearPlaneColor = new ColorF4(DebugFrustumNearPlaneColor.R, DebugFrustumNearPlaneColor.G, DebugFrustumNearPlaneColor.B, 0.15f);
- L922 C13: new Triangle :: new Triangle(frustum.LeftTopNear, frustum.RightTopNear, frustum.RightBottomNear),
- L925 C13: new Triangle :: new Triangle(frustum.LeftTopNear, frustum.RightBottomNear, frustum.LeftBottomNear),
- L929 C29: new ColorF4 :: var farPlaneColor = new ColorF4(DebugFrustumFarPlaneColor.R, DebugFrustumFarPlaneColor.G, DebugFrustumFarPlaneColor.B, 0.1f);
- L931 C13: new Triangle :: new Triangle(frustum.LeftTopFar, frustum.RightBottomFar, frustum.RightTopFar),
- L934 C13: new Triangle :: new Triangle(frustum.LeftTopFar, frustum.LeftBottomFar, frustum.RightBottomFar),
- L964 C27: new[] :: var baseCorners = new[]
- L1143 C80: new() :: private readonly List<(RenderInfo3D item, object? data)> _firstHitBuffer = new();
- L1382 C60: new Vector2 :: uv = Vector2.Clamp(uv, Vector2.Zero, Vector2.One - new Vector2(epsilon));
- L1411 C47: new Vector3 :: DepthHitNormalizedViewportPoint = new Vector3(p.X, p.Y, depth!.Value);
- L1604 C32: new Vector2 :: _lastRotateDelta = new Vector2(-x * MouseRotateSpeed, y * MouseRotateSpeed);
- L1638 C42: new Vector2 :: _lastMouseTranslationDelta = new Vector2(-x, -y);
- L1687 C28: new CameraFocusLerpState :: _cameraFocusLerp = new CameraFocusLerpState
- L1762 C38: new() :: Stack<TransformBase> stack = new(); stack.Push(focusTransform);
- L1870 C16: new SceneNode :: root = new SceneNode(world, EditorImGuiRootNodeName) { IsEditorOnly = true };
- L1876 C31: new Vector2 :: canvasTfm.SetSize(new Vector2(1920.0f, 1080.0f));
- L1877 C33: new Vector4 :: canvasTfm.Padding = new Vector4(0.0f);
- L1897 C20: new SceneNode :: var node = new SceneNode(root) { Name = EditorImGuiNodeName };
- L1899 C25: new Vector2 :: tfm.MinAnchor = new Vector2(0.0f, 0.0f);
- L1900 C25: new Vector2 :: tfm.MaxAnchor = new Vector2(1.0f, 1.0f);
- L1901 C31: new Vector2 :: tfm.NormalizedPivot = new Vector2(0.0f, 0.0f);
- L2156 C62: new Vector2 :: return Vector2.Clamp(uv, Vector2.Zero, Vector2.One - new Vector2(epsilon));
- L2169 C73: new Vector2 :: Vector3 nearBottomLeft = vp.NormalizedViewportToWorldCoordinate(new Vector2(minUv.X, minUv.Y), nearDepth);
- L2170 C74: new Vector2 :: Vector3 nearBottomRight = vp.NormalizedViewportToWorldCoordinate(new Vector2(maxUv.X, minUv.Y), nearDepth);
- L2171 C70: new Vector2 :: Vector3 nearTopLeft = vp.NormalizedViewportToWorldCoordinate(new Vector2(minUv.X, maxUv.Y), nearDepth);
- L2172 C71: new Vector2 :: Vector3 nearTopRight = vp.NormalizedViewportToWorldCoordinate(new Vector2(maxUv.X, maxUv.Y), nearDepth);
- L2174 C72: new Vector2 :: Vector3 farBottomLeft = vp.NormalizedViewportToWorldCoordinate(new Vector2(minUv.X, minUv.Y), farDepth);
- L2175 C73: new Vector2 :: Vector3 farBottomRight = vp.NormalizedViewportToWorldCoordinate(new Vector2(maxUv.X, minUv.Y), farDepth);
- L2176 C69: new Vector2 :: Vector3 farTopLeft = vp.NormalizedViewportToWorldCoordinate(new Vector2(minUv.X, maxUv.Y), farDepth);
- L2177 C70: new Vector2 :: Vector3 farTopRight = vp.NormalizedViewportToWorldCoordinate(new Vector2(maxUv.X, maxUv.Y), farDepth);
- L2179 C19: new Frustum :: frustum = new Frustum(
- L2187 C29: new HashSet :: var selectedNodes = new HashSet<SceneNode>();
- L2238 C28: new HashSet :: var selectionSet = new HashSet<SceneNode>(Selection.SceneNodes);


## XREngine.Editor/EditorJobTracker.cs
- L42 C44: new() :: private static readonly object _lock = new();
- L43 C73: new() :: private static readonly Dictionary<Guid, TrackedJob> _trackedJobs = new();
- L58 C27: new TrackedJob :: var tracked = new TrackedJob(job, label, payloadFormatter);
- L96 C30: new TrackedJobSnapshot :: .Select(t => new TrackedJobSnapshot(


## XREngine.Editor/EditorPlayModeController.cs
- L275 C36: new ShortcutHandlers :: _shortcutHandlers[local] = new ShortcutHandlers(playPauseHandler, stopHandler, stepFrameHandler);
- L360 C75: new PlayerPossessionSnapshot :: _editorPossessionSnapshot[localPlayer.LocalPlayerIndex] = new PlayerPossessionSnapshot(


## XREngine.Editor/EditorProjectInitializer.cs
- L96 C33: new GameStartupSettings :: Engine.GameSettings ??= new GameStartupSettings();
- L134 C18: new StringBuilder :: var sb = new StringBuilder();
- L192 C24: new List :: var projects = new List<(string Name, string Path, string Guid)>();
- L210 C18: new StringBuilder :: var sb = new StringBuilder();
- L253 C19: new DirectoryInfo :: var dir = new DirectoryInfo(startDirectory);
- L303 C16: new Guid :: return new Guid(hash);
- L311 C18: new StringBuilder :: var sb = new StringBuilder(value.Length);


## XREngine.Editor/EditorVR.cs
- L16 C33: new ActionManifest :: settings.ActionManifest = new ActionManifest<EVRActionCategory, EVRGameAction>()
- L22 C13: new DefaultBinding :: new DefaultBinding()
- L29 C29: new VrManifest :: settings.VRManifest = new VrManifest()
- L43 C10: new() :: new()
- L47 C30: new Dictionary :: LocalizedNames = new Dictionary<string, string>
- L63 C10: new() :: new()
- L67 C30: new Dictionary :: LocalizedNames = new Dictionary<string, string>
- L83 C10: new() :: new()
- L87 C30: new Dictionary :: LocalizedNames = new Dictionary<string, string>
- L103 C10: new() :: new()
- L107 C30: new Dictionary :: LocalizedNames = new Dictionary<string, string>
- L123 C10: new() :: new()
- L127 C30: new Dictionary :: LocalizedNames = new Dictionary<string, string>
- L147 C7: new OpenVR.NET.Manifest.Action :: new OpenVR.NET.Manifest.Action<EVRActionCategory, EVRGameAction>()
- L153 C27: new Dictionary :: LocalizedNames = new Dictionary<string, string>
- L169 C7: new OpenVR.NET.Manifest.Action :: new OpenVR.NET.Manifest.Action<EVRActionCategory, EVRGameAction>()
- L175 C27: new Dictionary :: LocalizedNames = new Dictionary<string, string>
- L191 C7: new OpenVR.NET.Manifest.Action :: new OpenVR.NET.Manifest.Action<EVRActionCategory, EVRGameAction>()
- L197 C27: new Dictionary :: LocalizedNames = new Dictionary<string, string>
- L213 C7: new OpenVR.NET.Manifest.Action :: new OpenVR.NET.Manifest.Action<EVRActionCategory, EVRGameAction>()
- L219 C27: new Dictionary :: LocalizedNames = new Dictionary<string, string>
- L235 C7: new OpenVR.NET.Manifest.Action :: new OpenVR.NET.Manifest.Action<EVRActionCategory, EVRGameAction>()
- L241 C27: new Dictionary :: LocalizedNames = new Dictionary<string, string>
- L257 C7: new OpenVR.NET.Manifest.Action :: new OpenVR.NET.Manifest.Action<EVRActionCategory, EVRGameAction>()
- L263 C27: new Dictionary :: LocalizedNames = new Dictionary<string, string>
- L279 C7: new OpenVR.NET.Manifest.Action :: new OpenVR.NET.Manifest.Action<EVRActionCategory, EVRGameAction>()
- L285 C27: new Dictionary :: LocalizedNames = new Dictionary<string, string>
- L301 C7: new OpenVR.NET.Manifest.Action :: new OpenVR.NET.Manifest.Action<EVRActionCategory, EVRGameAction>()
- L307 C27: new Dictionary :: LocalizedNames = new Dictionary<string, string>
- L323 C7: new OpenVR.NET.Manifest.Action :: new OpenVR.NET.Manifest.Action<EVRActionCategory, EVRGameAction>()
- L329 C27: new Dictionary :: LocalizedNames = new Dictionary<string, string>
- L345 C7: new OpenVR.NET.Manifest.Action :: new OpenVR.NET.Manifest.Action<EVRActionCategory, EVRGameAction>()
- L351 C27: new Dictionary :: LocalizedNames = new Dictionary<string, string>
- L367 C7: new OpenVR.NET.Manifest.Action :: new OpenVR.NET.Manifest.Action<EVRActionCategory, EVRGameAction>()
- L373 C27: new Dictionary :: LocalizedNames = new Dictionary<string, string>
- L389 C7: new OpenVR.NET.Manifest.Action :: new OpenVR.NET.Manifest.Action<EVRActionCategory, EVRGameAction>()
- L395 C27: new Dictionary :: LocalizedNames = new Dictionary<string, string>
- L411 C7: new OpenVR.NET.Manifest.Action :: new OpenVR.NET.Manifest.Action<EVRActionCategory, EVRGameAction>()
- L417 C27: new Dictionary :: LocalizedNames = new Dictionary<string, string>


## XREngine.Editor/EngineProfilerDataSource.cs
- L30 C56: new HeartbeatPacket :: public HeartbeatPacket? LatestHeartbeat { get; } = new HeartbeatPacket
- L73 C23: new ProfilerThreadData :: var threads = new ProfilerThreadData[snapshot.Threads.Count];
- L77 C26: new ProfilerThreadData :: threads[i] = new ProfilerThreadData
- L85 C16: new ProfilerFramePacket :: return new ProfilerFramePacket
- L98 C22: new ProfilerNodeData :: var result = new ProfilerNodeData[nodes.Count];
- L102 C25: new ProfilerNodeData :: result[i] = new ProfilerNodeData
- L115 C31: new RenderMatrixListenerEntry :: var listenerEntries = new RenderMatrixListenerEntry[listenerSnapshot.Length];
- L118 C34: new RenderMatrixListenerEntry :: listenerEntries[i] = new RenderMatrixListenerEntry
- L125 C16: new RenderStatsPacket :: return new RenderStatsPacket
- L174 C16: new ThreadAllocationsPacket :: return new ThreadAllocationsPacket
- L184 C12: new() :: => new()
- L196 C16: new BvhMetricsPacket :: return new BvhMetricsPacket
- L213 C26: new JobPriorityStatsEntry :: var priorities = new JobPriorityStatsEntry[priorityCount];
- L218 C29: new JobPriorityStatsEntry :: priorities[i] = new JobPriorityStatsEntry
- L229 C16: new JobSystemStatsPacket :: return new JobSystemStatsPacket
- L246 C23: new MainThreadInvokeEntryData :: var entries = new MainThreadInvokeEntryData[invokes.Count];
- L250 C26: new MainThreadInvokeEntryData :: entries[i] = new MainThreadInvokeEntryData
- L260 C16: new MainThreadInvokesPacket :: return new MainThreadInvokesPacket { Entries = entries };


## XREngine.Editor/IMGUI/AssetBrowser/AssetExplorerEntryComparer.cs
- L7 C70: new() :: public static readonly AssetExplorerEntryComparer Instance = new();


## XREngine.Editor/IMGUI/EditorImGuiUI.ArchiveImport.cs
- L54 C29: new ArchiveImportDialogState :: var state = new ArchiveImportDialogState
- L128 C53: new Vector4 :: ImGui.PushStyleColor(ImGuiCol.Text, new Vector4(0.9f, 0.4f, 0.4f, 1f));
- L136 C45: new Vector2 :: ImGui.BeginChild("ArchiveTree", new Vector2(640, 360), ImGuiChildFlags.Border, ImGuiWindowFlags.None);
- L153 C53: new Vector4 :: ImGui.PushStyleColor(ImGuiCol.Text, new Vector4(0.9f, 0.4f, 0.4f, 1f));
- L171 C40: new Vector2 :: if (ImGui.Button("Import", new Vector2(120, 0)))
- L180 C40: new Vector2 :: if (ImGui.Button("Cancel", new Vector2(120, 0)))
- L318 C25: new Stack :: var stack = new Stack<ArchiveEntryNode>();
- L435 C34: new JobProgress :: yield return new JobProgress(update.Progress, update);


## XREngine.Editor/IMGUI/EditorImGuiUI.ArchiveInspectorPanel.cs
- L61 C33: new Vector2 :: ImGui.SetNextWindowSize(new Vector2(900, 650), ImGuiCond.FirstUseEver);
- L74 C49: new Vector4 :: ImGui.PushStyleColor(ImGuiCol.Text, new Vector4(1.0f, 0.3f, 0.3f, 1.0f));
- L170 C20: new ArchiveInspectorTreeNode :: var root = new ArchiveInspectorTreeNode
- L178 C28: new Dictionary :: var directoryMap = new Dictionary<string, ArchiveInspectorTreeNode>(StringComparer.OrdinalIgnoreCase)
- L194 C31: new ArchiveInspectorTreeNode :: dirNode = new ArchiveInspectorTreeNode
- L207 C28: new ArchiveInspectorTreeNode :: var fileNode = new ArchiveInspectorTreeNode
- L318 C49: new Vector2 :: if (ImGui.BeginChild("ArchiveTreePane", new Vector2(treeWidth, -1.0f), ImGuiChildFlags.Border | ImGuiChildFlags.ResizeX))
- L328 C52: new Vector2 :: if (ImGui.BeginChild("ArchiveContentPane", new Vector2(contentWidth, -1.0f), ImGuiChildFlags.Border))
- L523 C54: new Vector2 :: if (ImGui.Button("Decompress & Preview", new Vector2(200, 0)))
- L533 C49: new Vector4 :: ImGui.PushStyleColor(ImGuiCol.Text, new Vector4(1.0f, 0.3f, 0.3f, 1.0f));
- L596 C59: new Vector2 :: ImGui.PushStyleVar(ImGuiStyleVar.ItemSpacing, new Vector2(0, 0));
- L598 C22: new StringBuilder :: var sb = new StringBuilder(128);
- L602 C31: new ImGuiListClipper :: var clipper = new ImGuiListClipper();


## XREngine.Editor/IMGUI/EditorImGuiUI.AssetExplorerPanel.cs
- L205 C62: new Vector2 :: if (ImGui.BeginChild($"{state.Id}DirectoryPane", new Vector2(directoryPaneWidth, 0f), ImGuiChildFlags.Border))
- L386 C58: new AssetExplorerEntry :: _assetExplorerScratchEntries.Add(new AssetExplorerEntry(name, normalized, true, 0L, modifiedUtc));
- L411 C40: new FileInfo :: var info = new FileInfo(file);
- L420 C58: new AssetExplorerEntry :: _assetExplorerScratchEntries.Add(new AssetExplorerEntry(name, normalized, false, size, modifiedUtc));
- L735 C44: new Vector2 :: Vector2 previewPos = tilePos + new Vector2(padding, padding);
- L780 C42: new Vector2 :: Vector2 labelPos = tilePos + new Vector2(padding, tileHeight - labelHeight + padding * 0.5f);
- L1137 C35: new ThirdPartyImportSelection :: inspectorTarget = new ThirdPartyImportSelection(path, descriptor.Type);
- L1357 C20: new HashSet :: keys = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
- L1361 C32: new FileStream :: using var fs = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
- L1362 C36: new StreamReader :: using var reader = new StreamReader(fs);
- L1363 C28: new YamlStream :: var yaml = new YamlStream();
- L1396 C32: new FileStream :: using var fs = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
- L1397 C36: new StreamReader :: using var reader = new StreamReader(fs);
- L1513 C20: new AssetTypeDescriptor :: return new AssetTypeDescriptor(resolved, displayName, category, properties, extensions, inspectorTypeName, contextMenus);
- L1525 C24: new[] :: .Split(new[] { ',', ';', ' ' }, StringSplitOptions.RemoveEmptyEntries);
- L1570 C30: new HashSet :: var categories = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
- L1584 C38: new Dictionary :: var previousSelections = new Dictionary<string, bool>(_assetExplorerCategoryFilterSelections, StringComparer.OrdinalIgnoreCase);
- L1660 C25: new List :: var parts = new List<string>(3);
- L1919 C22: new SHFILEOPSTRUCT :: var op = new SHFILEOPSTRUCT
- L1928 C23: new IOException :: throw new IOException($"SHFileOperation failed (code={result}, aborted={op.fAnyOperationsAborted}) for '{path}'.");
- L2176 C66: new HashSet :: _assetExplorerYamlKeyCache[transferredKey] = new HashSet<string>(value, StringComparer.OrdinalIgnoreCase);
- L2190 C65: new HashSet :: _assetExplorerYamlKeyCache[newNormalized] = new HashSet<string>(keys, StringComparer.OrdinalIgnoreCase);
- L2257 C47: new AssetTypeDescriptor :: _assetTypeDescriptors.Add(new AssetTypeDescriptor(type, displayName, category, properties, extensions, inspectorTypeName, contextMenus));
- L2359 C42: new object :: handler.Invoke(null, new object[] { context });
- L2382 C27: new XRAssetContextMenuContext :: context = new XRAssetContextMenuContext(path, assetInstance);
- L2439 C25: new AssetExplorerPreviewCacheEntry :: entry = new AssetExplorerPreviewCacheEntry(path);
- L2457 C49: new XRTexture2D :: XRTexture2D seed = entry.Texture ?? new XRTexture2D();
- L2485 C27: new Vector2 :: displaySize = new Vector2(AssetExplorerPreviewFallbackEdge, AssetExplorerPreviewFallbackEdge);
- L2514 C24: new Vector2 :: return new Vector2(AssetExplorerPreviewFallbackEdge, AssetExplorerPreviewFallbackEdge);
- L2518 C24: new Vector2 :: return new Vector2(width, height);
- L2521 C20: new Vector2 :: return new Vector2(width * scale, height * scale);
- L2561 C31: new ProcessStartInfo :: Process.Start(new ProcessStartInfo("explorer.exe", arguments)


## XREngine.Editor/IMGUI/EditorImGuiUI.ConsolePanel.cs
- L15 C63: new byte :: private static readonly byte[] _consoleFilterBuffer = new byte[256];
- L16 C63: new() :: private static List<LogEntry> _consoleCachedEntries = new();
- L104 C57: new Vector2 :: if (ImGui.BeginChild("ConsoleScrollRegion", new Vector2(0, -footerHeight), ImGuiChildFlags.None, ImGuiWindowFlags.HorizontalScrollbar))
- L184 C45: new Vector4 :: ELogCategory.General => new Vector4(0.9f, 0.9f, 0.9f, 1.0f),
- L185 C47: new Vector4 :: ELogCategory.Rendering => new Vector4(0.4f, 0.8f, 1.0f, 1.0f),
- L186 C44: new Vector4 :: ELogCategory.OpenGL => new Vector4(0.4f, 1.0f, 0.4f, 1.0f),
- L187 C45: new Vector4 :: ELogCategory.Physics => new Vector4(1.0f, 0.8f, 0.4f, 1.0f),
- L188 C47: new Vector4 :: ELogCategory.Animation => new Vector4(1.0f, 0.6f, 0.8f, 1.0f),
- L189 C40: new Vector4 :: ELogCategory.UI => new Vector4(0.8f, 0.6f, 1.0f, 1.0f),
- L190 C26: new Vector4 :: _ => new Vector4(0.9f, 0.9f, 0.9f, 1.0f),
- L204 C20: new Vector4 :: return new Vector4(color.R, color.G, color.B, color.A);


## XREngine.Editor/IMGUI/EditorImGuiUI.HierarchyPanel.cs
- L470 C35: new Vector4 :: ImGui.TextColored(new Vector4(0.9f, 0.7f, 0.2f, 1.0f), "Scene is hidden");
- L493 C56: new Vector2 :: ImGui.PushStyleVar(ImGuiStyleVar.FramePadding, new Vector2(4.0f, 2.0f));
- L494 C55: new Vector2 :: ImGui.PushStyleVar(ImGuiStyleVar.ItemSpacing, new Vector2(4.0f, 2.0f));
- L495 C55: new Vector2 :: ImGui.PushStyleVar(ImGuiStyleVar.CellPadding, new Vector2(4.0f, 2.0f));
- L537 C24: new HashSet :: var assigned = new HashSet<SceneNode>();
- L567 C26: new List :: var unassigned = new List<SceneNode>();


## XREngine.Editor/IMGUI/EditorImGuiUI.Icons.cs
- L18 C74: new() :: private static readonly Dictionary<string, XRTexture2D> _iconCache = new();
- L19 C53: new() :: private static readonly object _iconCacheLock = new();
- L94 C31: new() :: using SKSvg svg = new();


## XREngine.Editor/IMGUI/EditorImGuiUI.ImGui.cs
- L39 C56: new byte :: private static readonly byte[] _renameBuffer = new byte[256];
- L41 C95: new() :: private static readonly Dictionary<Type, IXRComponentEditor?> _componentEditorCache = new();
- L42 C93: new() :: private static readonly Dictionary<Type, IXRAssetInspector?> _assetInspectorCache = new();
- L44 C95: new() :: private static readonly Dictionary<Type, IXRTransformEditor?> _transformEditorCache = new();
- L91 C89: new() :: private static readonly List<AssetExplorerEntry> _assetExplorerScratchEntries = new();
- L92 C69: new byte :: private static readonly byte[] _assetExplorerRenameBuffer = new byte[256];
- L100 C82: new() :: private static readonly List<string> _assetExplorerCategoryFilterOrder = new();
- L155 C103: new() :: private static readonly List<AssetExplorerContextAction> _assetExplorerGlobalContextActions = new();
- L173 C115: new() :: private static readonly Dictionary<Type, List<CollectionTypeDescriptor>> _collectionTypeDescriptorCache = new();
- L183 C77: new() :: private static readonly ConcurrentQueue<Action> _queuedSceneEdits = new();
- L291 C42: new XRViewport :: _scenePanelImGuiViewport ??= new XRViewport(window);
- L300 C40: new XREngine.Data.Geometry.BoundingRectangle :: renderer.SetRenderArea(new XREngine.Data.Geometry.BoundingRectangle(0, 0, fbSize2.X, fbSize2.Y));
- L301 C37: new XREngine.Data.Colors.ColorF4 :: renderer.ClearColor(new XREngine.Data.Colors.ColorF4(0f, 0f, 0f, 1f));
- L379 C23: new ArgumentException :: throw new ArgumentException("Label must be provided.", nameof(label));
- L381 C23: new ArgumentNullException :: throw new ArgumentNullException(nameof(handler));
- L383 C26: new AssetExplorerContextAction :: var action = new AssetExplorerContextAction(label, handler, predicate);
- L514 C36: new Vector2 :: ImGui.SetNextWindowPos(new Vector2(viewport.Pos.X, viewport.Pos.Y + totalReservedHeight));
- L515 C37: new Vector2 :: ImGui.SetNextWindowSize(new Vector2(viewport.Size.X, viewport.Size.Y - totalReservedHeight));
- L588 C53: new Vector2 :: Vector2 dockMax = dockMin + new Vector2(viewport.Size.X, viewport.Size.Y - totalReservedHeight);
- L699 C28: new Vector2 :: var listSize = new Vector2(520, MathF.Min(300, 22 + (_closePromptAssets.Count * 22)));
- L733 C35: new Vector4 :: ImGui.TextColored(new Vector4(1f, 0.35f, 0.35f, 1f), _closePromptSaveError);
- L906 C43: new Vector2 :: 2 => [windowName, new Vector2(-100000f, -100000f)],
- L907 C43: new Vector2 :: 3 => [windowName, new Vector2(-100000f, -100000f), ImGuiCond.Always],
- L948 C61: new Vector2 :: ImGuiDockBuilderNative.SetNodeSize(dockSpaceId, new Vector2(availableWidth, availableHeight));
- L949 C60: new Vector2 :: ImGuiDockBuilderNative.SetNodePos(dockSpaceId, new Vector2(viewport.Pos.X, viewport.Pos.Y + ImGui.GetFrameHeight() + GetToolbarReservedHeight()));
- L984 C61: new Vector2 :: ImGuiDockBuilderNative.SetNodeSize(dockSpaceId, new Vector2(availableWidth, availableHeight));
- L985 C60: new Vector2 :: ImGuiDockBuilderNative.SetNodePos(dockSpaceId, new Vector2(viewport.Pos.X, viewport.Pos.Y + ImGui.GetFrameHeight() + GetToolbarReservedHeight()));
- L1180 C32: new Vector2 :: ImGui.SetCursorPos(new Vector2(centeredX, originalCursor.Y));
- L1184 C36: new Vector4 :: var warningColor = new Vector4(0.96f, 0.78f, 0.32f, 1f);
- L1214 C32: new Vector2 :: ImGui.SetCursorPos(new Vector2(desiredX, cursorY));
- L1221 C27: new Vector2 :: var barSize = new Vector2(indicatorWidth, barHeight);
- L1264 C31: new Dictionary :: var uniqueRoots = new Dictionary<Guid, XRAsset>(dirtySnapshot.Length);
- L1283 C61: new Vector4 :: EditorJobTracker.TrackedJobState.Faulted => new Vector4(0.9f, 0.25f, 0.25f, 1f),
- L1284 C62: new Vector4 :: EditorJobTracker.TrackedJobState.Canceled => new Vector4(0.6f, 0.6f, 0.6f, 1f),
- L1328 C35: new Vector2 :: style.WindowPadding = new Vector2(14.0f, 10.0f);
- L1329 C34: new Vector2 :: style.FramePadding = new Vector2(10.0f, 6.0f);
- L1330 C33: new Vector2 :: style.ItemSpacing = new Vector2(10.0f, 8.0f);
- L1331 C38: new Vector2 :: style.ItemInnerSpacing = new Vector2(6.0f, 4.0f);
- L1349 C45: new Vector4 :: colors[(int)ImGuiCol.ChildBg] = new Vector4(darkBg.X, darkBg.Y, darkBg.Z, 0.75f);
- L1350 C45: new Vector4 :: colors[(int)ImGuiCol.PopupBg] = new Vector4(0.10f, 0.11f, 0.13f, 0.98f);
- L1351 C44: new Vector4 :: colors[(int)ImGuiCol.Border] = new Vector4(0.20f, 0.22f, 0.27f, 1.00f);
- L1352 C50: new Vector4 :: colors[(int)ImGuiCol.BorderShadow] = new Vector4(0f, 0f, 0f, 0f);
- L1358 C54: new Vector4 :: colors[(int)ImGuiCol.TitleBgCollapsed] = new Vector4(midBg.X, midBg.Y, midBg.Z, 0.60f);
- L1360 C49: new Vector4 :: colors[(int)ImGuiCol.ScrollbarBg] = new Vector4(darkBg.X, darkBg.Y, darkBg.Z, 1.00f);
- L1373 C47: new Vector4 :: colors[(int)ImGuiCol.Separator] = new Vector4(0.28f, 0.30f, 0.34f, 1.00f);
- L1382 C50: new Vector4 :: colors[(int)ImGuiCol.TabUnfocused] = new Vector4(midBg.X, midBg.Y, midBg.Z, 0.90f);
- L1384 C52: new Vector4 :: colors[(int)ImGuiCol.DockingPreview] = new Vector4(accent.X, accent.Y, accent.Z, 0.35f);
- L1385 C52: new Vector4 :: colors[(int)ImGuiCol.DockingEmptyBg] = new Vector4(0.08f, 0.08f, 0.09f, 1.00f);
- L1388 C51: new Vector4 :: colors[(int)ImGuiCol.PlotHistogram] = new Vector4(accent.X, accent.Y, accent.Z, 0.70f);
- L1391 C55: new Vector4 :: colors[(int)ImGuiCol.TableBorderStrong] = new Vector4(0.20f, 0.22f, 0.27f, 1.00f);
- L1392 C54: new Vector4 :: colors[(int)ImGuiCol.TableBorderLight] = new Vector4(0.16f, 0.18f, 0.21f, 1.00f);
- L1393 C52: new Vector4 :: colors[(int)ImGuiCol.TextSelectedBg] = new Vector4(accent.X, accent.Y, accent.Z, 0.35f);
- L1394 C52: new Vector4 :: colors[(int)ImGuiCol.DragDropTarget] = new Vector4(accent.X, accent.Y, accent.Z, 0.90f);
- L1396 C59: new Vector4 :: colors[(int)ImGuiCol.NavWindowingHighlight] = new Vector4(accent.X, accent.Y, accent.Z, 0.70f);
- L1397 C55: new Vector4 :: colors[(int)ImGuiCol.NavWindowingDimBg] = new Vector4(0.05f, 0.05f, 0.05f, 0.60f);
- L1398 C54: new Vector4 :: colors[(int)ImGuiCol.ModalWindowDimBg] = new Vector4(0.05f, 0.05f, 0.05f, 0.45f);
- L1503 C23: new ArgumentNullException :: throw new ArgumentNullException(nameof(target));


## XREngine.Editor/IMGUI/EditorImGuiUI.InspectorPanel.cs
- L29 C65: new byte :: private static readonly byte[] _componentRenameBuffer = new byte[256];
- L77 C109: new() :: private static readonly Dictionary<Type, ComponentInspectorLabels> _componentInspectorLabelsCache = new();
- L87 C26: new ComponentInspectorLabels :: var labels = new ComponentInspectorLabels(header, footer);
- L94 C48: new[] :: BeginAddComponentForHierarchyNodes(new[] { node });
- L117 C37: new Vector2 :: ImGui.SetNextWindowSize(new Vector2(640f, 520f), ImGuiCond.FirstUseEver);
- L136 C57: new Vector4 :: ImGui.PushStyleColor(ImGuiCol.Text, new Vector4(1.0f, 0.4f, 0.4f, 1.0f));
- L153 C55: new Vector2 :: if (ImGui.BeginChild("ComponentList", new Vector2(0, componentListHeight), ImGuiChildFlags.Border, ImGuiWindowFlags.HorizontalScrollbar))
- L197 C39: new List :: var failedNodes = new List<SceneNode>();
- L298 C27: new HashSet :: var visited = new HashSet<object>(ReferenceEqualityComparer.Instance);
- L334 C27: new HashSet :: var visited = new HashSet<object>(ReferenceEqualityComparer.Instance)
- L454 C43: new InspectorTargetSet :: if (TryDrawAssetInspector(new InspectorTargetSet(new[] { asset }, asset.GetType()), visited))
- L454 C66: new[] :: if (TryDrawAssetInspector(new InspectorTargetSet(new[] { asset }, asset.GetType()), visited))
- L458 C35: new InspectorTargetSet :: DrawInspectableObject(new InspectorTargetSet(new[] { target }, target.GetType()), "StandaloneInspectorProperties", visited);
- L458 C58: new[] :: DrawInspectableObject(new InspectorTargetSet(new[] { target }, target.GetType()), "StandaloneInspectorProperties", visited);
- L499 C35: new InspectorTargetSet :: DrawInspectableObject(new InspectorTargetSet(new[] { importOptions! }, importOptions!.GetType()), "ThirdPartyImportOptions", visited);
- L499 C58: new[] :: DrawInspectableObject(new InspectorTargetSet(new[] { importOptions! }, importOptions!.GetType()), "ThirdPartyImportOptions", visited);
- L555 C35: new InspectorTargetSet :: DrawInspectableObject(new InspectorTargetSet(new[] { importOptions! }, importOptions!.GetType()), "ThirdPartyImportOptions", visited);
- L555 C58: new[] :: DrawInspectableObject(new InspectorTargetSet(new[] { importOptions! }, importOptions!.GetType()), "ThirdPartyImportOptions", visited);
- L579 C42: new InspectorAssetContextScope :: using var inspectorContext = new InspectorAssetContextScope(assetContext?.SourceAsset);
- L595 C27: new HashSet :: var visited = new HashSet<object>(ReferenceEqualityComparer.Instance);
- L758 C55: new Vector2 :: if (ImGui.BeginChild("TransformTypeList", new Vector2(0f, 260f), ImGuiChildFlags.Border))
- L819 C20: new TransformTypeEntry :: return new TransformTypeEntry(type, label, tooltip);
- L931 C28: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(component.IsDestroyed))
- L941 C28: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(component.IsDestroyed))
- L950 C28: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(component.IsDestroyed))
- L954 C52: new List :: componentsToRemove ??= new List<XRComponent>();
- L1063 C36: new Dictionary :: var componentsByType = new Dictionary<Type, List<XRComponent>>();
- L1064 C30: new Dictionary :: var typeCounts = new Dictionary<Type, int>();
- L1065 C32: new HashSet :: var invalidTypes = new HashSet<Type>();
- L1083 C32: new List :: list = new List<XRComponent>();
- L1215 C33: new InspectorTargetSet :: var targetSet = new InspectorTargetSet(componentList.Cast<object>().ToList(), componentType);
- L1280 C35: new Vector4 :: ImGui.TextColored(new Vector4(0.4f, 0.8f, 0.4f, 1.0f), "✓ Currently Possessed by Player 1");
- L1329 C38: new InspectorTargetSet :: => DrawInspectableObject(new InspectorTargetSet(new[] { component }, component.GetType()), "ComponentProperties", visited);
- L1329 C61: new[] :: => DrawInspectableObject(new InspectorTargetSet(new[] { component }, component.GetType()), "ComponentProperties", visited);
- L1332 C38: new InspectorTargetSet :: => DrawInspectableObject(new InspectorTargetSet(new[] { transform }, transform.GetType()), "TransformProperties", visited);
- L1332 C61: new[] :: => DrawInspectableObject(new InspectorTargetSet(new[] { transform }, transform.GetType()), "TransformProperties", visited);
- L1335 C38: new InspectorTargetSet :: => DrawInspectableObject(new InspectorTargetSet(new[] { asset }, asset.GetType()), "AssetProperties", visited);
- L1335 C61: new[] :: => DrawInspectableObject(new InspectorTargetSet(new[] { asset }, asset.GetType()), "AssetProperties", visited);
- L1342 C27: new HashSet :: var visited = new HashSet<object>(ReferenceEqualityComparer.Instance);
- L1343 C27: new InspectorTargetSet :: var targets = new InspectorTargetSet(new[] { asset }, asset.GetType());
- L1343 C50: new[] :: var targets = new InspectorTargetSet(new[] { asset }, asset.GetType());
- L1593 C51: new ComponentTypeDescriptor :: _componentTypeDescriptors.Add(new ComponentTypeDescriptor(type, displayName, ns, assemblyName));


## XREngine.Editor/IMGUI/EditorImGuiUI.Mipmap2DInspector.cs
- L26 C138: new() :: private static readonly System.Runtime.CompilerServices.ConditionalWeakTable<Mipmap2D, Mipmap2DPreviewState> _mipmap2DPreviewState = new();
- L86 C36: new XRTexture2D :: state.PreviewTexture = new XRTexture2D
- L160 C37: new ImageMagick.MagickImage :: using var img = new ImageMagick.MagickImage(result.SelectedPath);


## XREngine.Editor/IMGUI/EditorImGuiUI.MissingAssetsPanel.cs
- L92 C54: new Vector2 :: if (ImGui.BeginChild("MissingAssetList", new Vector2(-1.0f, listHeight), ImGuiChildFlags.Border))
- L94 C82: new Vector2 :: if (ImGui.BeginTable("ProfilerMissingAssetTable", 6, tableFlags, new Vector2(-1.0f, -1.0f)))
- L188 C29: new Vector2 :: ImGui.Dummy(new Vector2(0.0f, spacing));
- L189 C60: new Vector2 :: if (ImGui.BeginChild("MissingAssetEditor", new Vector2(-1.0f, editorHeight), ImGuiChildFlags.Border))
- L265 C20: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!hasReplacement))


## XREngine.Editor/IMGUI/EditorImGuiUI.ModelDropSpawn.cs
- L207 C20: new SceneNode :: node = new SceneNode(parent);
- L211 C20: new SceneNode :: node = new SceneNode(world);


## XREngine.Editor/IMGUI/EditorImGuiUI.NetworkingPanel.cs
- L26 C37: new Vector2 :: ImGui.SetNextWindowSize(new Vector2(440, 520), ImGuiCond.FirstUseEver);
- L65 C47: new Vector2 :: if (ImGui.Button("Start / Apply", new Vector2(-1, 0)))
- L68 C44: new Vector2 :: if (ImGui.Button("Disconnect", new Vector2(-1, 0)))
- L164 C44: new() :: GameStartupSettings settings = new()
- L188 C40: new() :: GameStartupSettings settings = new() { NetworkingType = GameStartupSettings.ENetworkingType.Local };


## XREngine.Editor/IMGUI/EditorImGuiUI.OpenGLPanel.cs
- L17 C84: new() :: private static readonly List<OpenGLApiObjectRow> _openGlApiObjectScratch = new();
- L144 C37: new Dictionary :: var pipelineOwnership = new Dictionary<GenericRenderObject, string>(ReferenceEqualityComparer.Instance);
- L256 C30: new OpenGLApiObjectRow :: rows.Add(new OpenGLApiObjectRow(
- L409 C58: new Vector2 :: if (ImGui.BeginChild("OpenGLApiObjectsList", new Vector2(-1.0f, contentHeight.Y), ImGuiChildFlags.Border))
- L418 C91: new Vector2 :: else if (ImGui.BeginTable("ProfilerRenderApiObjectsTable", 5, tableFlags, new Vector2(-1.0f, -1.0f)))
- L553 C80: new Vector2 :: if (ImGui.BeginTable("ProfilerRenderApiErrorTable", 8, tableFlags, new Vector2(-1.0f, estimatedHeight)))
- L584 C61: new Vector4 :: ImGui.PushStyleColor(ImGuiCol.Text, new Vector4(1.0f, 0.45f, 0.45f, 1.0f));
- L609 C24: new List :: var rows = new List<RenderApiErrorRow>();
- L613 C26: new RenderApiErrorRow :: rows.Add(new RenderApiErrorRow(
- L632 C26: new RenderApiErrorRow :: rows.Add(new RenderApiErrorRow(
- L693 C147: new Vector2 :: if (!ImGui.BeginTable($"RenderApiExtensions_{apiName}", 2, ImGuiTableFlags.Borders | ImGuiTableFlags.RowBg | ImGuiTableFlags.ScrollY, new Vector2(-1.0f, listHeight)))
- L788 C26: new Dictionary :: var lookup = new Dictionary<string, List<OpenGLApiObjectRow>>(comparer);
- L804 C37: new List :: unownedList ??= new List<OpenGLApiObjectRow>();
- L811 C28: new List :: list = new List<OpenGLApiObjectRow>();


## XREngine.Editor/IMGUI/EditorImGuiUI.ProfilerPanel.cs
- L65 C37: new EngineProfilerDataSource :: _engineProfilerDataSource = new EngineProfilerDataSource();
- L66 C35: new ProfilerPanelRenderer :: _engineProfilerRenderer = new ProfilerPanelRenderer(_engineProfilerDataSource);
- L89 C31: new Vector4 :: ImGui.TextColored(new Vector4(0.3f, 0.85f, 1f, 1f),
- L139 C31: new Vector4 :: ImGui.TextColored(new Vector4(0.7f, 0.7f, 0.7f, 1f), "External Profiler:");
- L156 C31: new Vector4 :: ImGui.TextColored(new Vector4(0.7f, 0.7f, 0.7f, 1f), "Panels:");
- L223 C57: new Vector2 :: ImGuiDockBuilderNative.SetNodeSize(dockSpaceId, new Vector2(availableWidth, availableHeight));
- L258 C35: new ProcessStartInfo :: Process.Start(new ProcessStartInfo(profilerExe!)
- L281 C26: new List :: var candidates = new List<string>(4);


## XREngine.Editor/IMGUI/EditorImGuiUI.PropertyEditor.cs
- L43 C23: new ArgumentException :: throw new ArgumentException("Inspector target list must contain at least one object.", nameof(targets));
- L46 C20: new InspectorTargetSet :: return new InspectorTargetSet(targetList, commonType);
- L91 C78: new() :: private static readonly NullabilityInfoContext _nullabilityContext = new();
- L122 C25: new List :: var names = new List<string>();
- L159 C113: new() :: private static readonly Dictionary<Type, List<CollectionTypeDescriptor>> _propertyTypeDescriptorCache = new();
- L204 C44: new InspectorAssetContextScope :: using var assetScope = new InspectorAssetContextScope(asset.SourceAsset ?? asset);
- L241 C47: new[] :: DrawRuntimeObjectInspector(label, new[] { target }, visited, defaultOpen, description);
- L279 C34: new List :: var values = new List<object?>();
- L297 C28: new SettingPropertyDescriptor :: return new SettingPropertyDescriptor
- L333 C34: new List :: var values = new List<object?>();
- L351 C28: new SettingFieldDescriptor :: return new SettingFieldDescriptor
- L398 C27: new List :: var allRows = new List<InspectorMemberRow>(propertyInfos.Count + fieldInfos.Count);
- L399 C56: new InspectorMemberRow :: allRows.AddRange(propertyInfos.Select(p => new InspectorMemberRow(p)));
- L400 C53: new InspectorMemberRow :: allRows.AddRange(fieldInfos.Select(f => new InspectorMemberRow(f)));
- L620 C44: new InspectorAssetContextScope :: using var assetScope = new InspectorAssetContextScope(asset.SourceAsset ?? asset);
- L626 C73: new InspectorTargetSet :: handledByAssetInspector = TryDrawAssetInspector(new InspectorTargetSet(new[] { asset }, asset.GetType()), visited);
- L626 C96: new[] :: handledByAssetInspector = TryDrawAssetInspector(new InspectorTargetSet(new[] { asset }, asset.GetType()), visited);
- L635 C44: new InspectorTargetSet :: DrawSettingsProperties(new InspectorTargetSet(new[] { value }, value.GetType()), visited);
- L635 C67: new[] :: DrawSettingsProperties(new InspectorTargetSet(new[] { value }, value.GetType()), visited);
- L897 C48: new InspectorTargetSet :: DrawSettingsObject(new InspectorTargetSet(new[] { item }, item.GetType()), $"{label}[{i}]", description, visited, false, property.Name + i.ToString(CultureInfo.InvariantCulture));
- L897 C71: new[] :: DrawSettingsObject(new InspectorTargetSet(new[] { item }, item.GetType()), $"{label}[{i}]", description, visited, false, property.Name + i.ToString(CultureInfo.InvariantCulture));
- L938 C36: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(true))
- L980 C36: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(true))
- L1012 C28: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(true))
- L1045 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canMutate))
- L1139 C48: new InspectorTargetSet :: DrawSettingsObject(new InspectorTargetSet(new[] { entryValue! }, entryValue!.GetType()), childLabel, description, visited, false, property.Name + "_" + i.ToString(CultureInfo.InvariantCulture));
- L1139 C71: new[] :: DrawSettingsObject(new InspectorTargetSet(new[] { entryValue! }, entryValue!.GetType()), childLabel, description, visited, false, property.Name + "_" + i.ToString(CultureInfo.InvariantCulture));
- L1199 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canModifyElements))
- L1220 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canModifyElements || enumNames.Length == 0))
- L1238 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canModifyElements))
- L1255 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canModifyElements))
- L1272 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canModifyElements))
- L1289 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canModifyElements))
- L1318 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canModifyElements))
- L1622 C23: new CollectionBufferAdapter :: adapter = new CollectionBufferAdapter(collection, elementType);
- L1639 C66: new ArgumentNullException :: private readonly LinkedList<T> _list = list ?? throw new ArgumentNullException(nameof(list));
- L1643 C49: new ArgumentOutOfRangeException :: get => (GetNode(index) ?? throw new ArgumentOutOfRangeException(nameof(index))).Value;
- L1646 C56: new ArgumentOutOfRangeException :: var node = GetNode(index) ?? throw new ArgumentOutOfRangeException(nameof(index));
- L1688 C27: new ArgumentOutOfRangeException :: throw new ArgumentOutOfRangeException(nameof(index));
- L1696 C52: new ArgumentOutOfRangeException :: var node = GetNode(index) ?? throw new ArgumentOutOfRangeException(nameof(index));
- L1721 C52: new ArgumentOutOfRangeException :: var node = GetNode(index) ?? throw new ArgumentOutOfRangeException(nameof(index));
- L1756 C27: new List :: _buffer = new List<object?>();
- L1853 C46: new[] :: _add!.Invoke(collection, new[] { ConvertCollectionElement(entry, _addParameter ?? fallbackType) });
- L1864 C24: new CollectionAccessor :: return new CollectionAccessor(clear, add);
- L1969 C31: new List :: var descriptors = new List<CollectionTypeDescriptor>();
- L1975 C33: new CollectionTypeDescriptor :: descriptors.Add(new CollectionTypeDescriptor(
- L2010 C37: new CollectionTypeDescriptor :: descriptors.Add(new CollectionTypeDescriptor(
- L2060 C56: new Vector2 :: if (ImGui.BeginChild("##PropertyTypeList", new Vector2(0f, 280f), ImGuiChildFlags.Border))
- L2272 C58: new Vector2 :: if (ImGui.BeginChild("##CollectionTypeList", new Vector2(0f, 240f), ImGuiChildFlags.Border))
- L2322 C31: new List :: var descriptors = new List<CollectionTypeDescriptor>();
- L2348 C37: new CollectionTypeDescriptor :: descriptors.Add(new CollectionTypeDescriptor(
- L2494 C31: new object :: .Invoke(null, new object?[] { id, current, assign, allowClear, allowCreateOrReplace });
- L2533 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canModifyElements))
- L2554 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canModifyElements || enumNames.Length == 0))
- L2572 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canModifyElements))
- L2589 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canModifyElements))
- L2606 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canModifyElements))
- L2623 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canModifyElements))
- L2653 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canModifyElements))
- L2830 C34: new SettingPropertyDescriptor :: var descriptor = new SettingPropertyDescriptor
- L2891 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canWrite))
- L2927 C28: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canWrite))
- L2930 C60: new Vector2 :: ImGui.SetNextWindowSizeConstraints(new Vector2(420.0f, 0.0f), new Vector2(float.MaxValue, float.MaxValue));
- L2930 C87: new Vector2 :: ImGui.SetNextWindowSizeConstraints(new Vector2(420.0f, 0.0f), new Vector2(float.MaxValue, float.MaxValue));
- L3000 C28: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canWrite || enumNames.Length == 0))
- L3033 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canWrite))
- L3053 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canWrite))
- L3073 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canWrite))
- L3093 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canWrite))
- L3113 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canWrite))
- L3118 C39: new LayerMask :: var newMask = new LayerMask(maskValue);
- L3254 C20: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canWrite))
- L3348 C40: new InspectorTargetSet :: DrawSettingsProperties(new InspectorTargetSet(new[] { value }, value.GetType()), visited);
- L3348 C63: new[] :: DrawSettingsProperties(new InspectorTargetSet(new[] { value }, value.GetType()), visited);
- L3433 C28: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!isEmpty))
- L3546 C27: new XRPersistentCall :: calls.Add(new XRPersistentCall());
- L3592 C43: new Vector2 :: if (ImGui.Button("X", new Vector2(removeButtonSize, removeButtonSize)))
- L3623 C21: new List :: calls = new List<XRPersistentCall>();
- L3632 C25: new EventSignatureOption :: return [new EventSignatureOption(Array.Empty<Type>(), tupleExpanded: false)];
- L3635 C27: new List :: var options = new List<EventSignatureOption>
- L3637 C17: new EventSignatureOption :: new EventSignatureOption([payloadType], tupleExpanded: false)
- L3641 C29: new EventSignatureOption :: options.Add(new EventSignatureOption(tupleTypes, tupleExpanded: true));
- L3653 C41: new Vector2 :: if (ImGui.Button(nodeLabel, new Vector2(-1f, 0f)))
- L3684 C19: new List :: ? new List<EventMethodOption>()
- L3812 C27: new List :: var results = new List<EventMethodOption>();
- L3862 C38: new EventMethodOption :: yield return new EventMethodOption
- L3880 C24: new List :: var list = new List<Type>();
- L3996 C20: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!overrideCanWrite || !hasOverride))
- L4025 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canWrite))
- L4057 C28: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canWrite))
- L4060 C60: new Vector2 :: ImGui.SetNextWindowSizeConstraints(new Vector2(420.0f, 0.0f), new Vector2(float.MaxValue, float.MaxValue));
- L4060 C87: new Vector2 :: ImGui.SetNextWindowSizeConstraints(new Vector2(420.0f, 0.0f), new Vector2(float.MaxValue, float.MaxValue));
- L4124 C28: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canWrite || enumNames.Length == 0))
- L4144 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canWrite))
- L4162 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canWrite))
- L4180 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canWrite))
- L4198 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canWrite))
- L4216 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canWrite))
- L4221 C39: new LayerMask :: var newMask = new LayerMask(maskValue);
- L4239 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canWrite))
- L4244 C40: new ColorF3 :: var newColor = new ColorF3(colorVec.X, colorVec.Y, colorVec.Z);
- L4257 C110: new Vector4 :: Vector4 colorVec = currentValue is ColorF4 color ? new(color.R, color.G, color.B, color.A) : new Vector4(0f, 0f, 0f, 1f);
- L4258 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canWrite))
- L4263 C40: new ColorF4 :: var newColor = new ColorF4(colorVec.X, colorVec.Y, colorVec.Z, colorVec.W);
- L4285 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canWrite))
- L4303 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canWrite))
- L4321 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canWrite))
- L4352 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canWrite))
- L4370 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canWrite))
- L4388 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canWrite))
- L4406 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canWrite))
- L4424 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canWrite))
- L4442 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canWrite))
- L4460 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canWrite))
- L4478 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canWrite))
- L4498 C37: new List :: var previousValueList = new List<object?>(previousValues);
- L4523 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canWrite))
- L4528 C40: new ColorF3 :: var newColor = new ColorF3(colorVec.X, colorVec.Y, colorVec.Z);
- L4543 C110: new Vector4 :: Vector4 colorVec = currentValue is ColorF4 color ? new(color.R, color.G, color.B, color.A) : new Vector4(0f, 0f, 0f, 1f);
- L4544 C24: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!canWrite))
- L4549 C40: new ColorF4 :: var newColor = new ColorF4(colorVec.X, colorVec.Y, colorVec.Z, colorVec.W);
- L4570 C63: new IntPtr :: bool changed = ImGui.InputScalar(label, dataType, new IntPtr(ptr));
- L4614 C16: new InspectorAssetContextScope :: => new InspectorAssetContextScope(asset);
- L4802 C73: new() :: public static readonly ReferenceEqualityComparer Instance = new();


## XREngine.Editor/IMGUI/EditorImGuiUI.RenderPipelineGraphPanel.cs
- L26 C46: new WeakReference :: _renderPipelineGraphPinnedPipeline = new WeakReference<RenderPipeline>(pipeline);
- L35 C66: new() :: public readonly Dictionary<int, Vector2> NodePositions = new();
- L44 C66: new() :: public readonly Dictionary<int, Vector2> NodePositions = new();
- L53 C87: new() :: private static readonly ConditionalWeakTable<object, GraphNodeId> _graphNodeIds = new();
- L56 C105: new() :: private static readonly Dictionary<Guid, RenderPipelineGraphViewState> _renderPipelineGraphStates = new();
- L57 C119: new() :: private static readonly Dictionary<Guid, RenderPipelineCommandGraphViewState> _renderPipelineCommandGraphStates = new();
- L64 C33: new Vector2 :: ImGui.SetNextWindowSize(new Vector2(900, 700), ImGuiCond.FirstUseEver);
- L111 C41: new Vector2 :: passState.Pan = new Vector2(40, 40);
- L135 C23: new RenderPipelineGraphViewState :: var created = new RenderPipelineGraphViewState();
- L148 C23: new RenderPipelineCommandGraphViewState :: var created = new RenderPipelineCommandGraphViewState();
- L184 C62: new GraphNodeId :: var holder = _graphNodeIds.GetValue(obj, static _ => new GraphNodeId(Interlocked.Increment(ref _nextGraphNodeId)));
- L203 C29: new Vector2 :: state.Pan = new Vector2(40, 40);
- L247 C22: new Dictionary :: var widths = new Dictionary<int, int>();
- L248 C20: new HashSet :: var seen = new HashSet<ViewportRenderCommandContainer>(System.Collections.Generic.ReferenceEqualityComparer.Instance);
- L285 C24: new List :: var nodeList = new List<CommandGraphNode>(256);
- L286 C24: new List :: var edgeList = new List<CommandGraphEdge>(512);
- L287 C30: new HashSet :: var seenContainers = new HashSet<ViewportRenderCommandContainer>(System.Collections.Generic.ReferenceEqualityComparer.Instance);
- L295 C26: new CommandGraphNode :: nodeList.Add(new CommandGraphNode(containerId, label, IsContainer: true, container));
- L298 C30: new CommandGraphEdge :: edgeList.Add(new CommandGraphEdge(parentCommandNodeId.Value, containerId, edgeLabel));
- L304 C30: new CommandGraphNode :: nodeList.Add(new CommandGraphNode(cmdId, cmd.GetType().Name, IsContainer: false, cmd));
- L307 C34: new CommandGraphEdge :: edgeList.Add(new CommandGraphEdge(containerId, cmdId, null));
- L309 C34: new CommandGraphEdge :: edgeList.Add(new CommandGraphEdge(prev.Value, cmdId, null));
- L324 C17: new ReadOnlyCollection :: nodes = new ReadOnlyCollection<CommandGraphNode>(nodeList
- L328 C17: new ReadOnlyCollection :: edges = new ReadOnlyCollection<CommandGraphEdge>(edgeList);
- L375 C30: new HashSet :: var seenContainers = new HashSet<ViewportRenderCommandContainer>(System.Collections.Generic.ReferenceEqualityComparer.Instance);
- L391 C47: new Vector2 :: view.NodePositions[containerId] = new Vector2(colStartX, y);
- L402 C45: new Vector2 :: view.NodePositions[cmdId] = new Vector2(cmdX, cmdY);
- L413 C39: new List :: var childWidths = new List<int>(children.Count);
- L463 C13: new Vector2 :: new Vector2(0, 0),
- L503 C51: new RenderPipelineGraphViewState :: DrawGrid(drawList, canvasPos, canvasSize, new RenderPipelineGraphViewState { Pan = view.Pan, Zoom = view.Zoom });
- L546 C23: new Vector2 :: ? p + new Vector2(xLocal, h * view.Zoom)
- L547 C23: new Vector2 :: : p + new Vector2(xLocal, 0);
- L551 C24: new Dictionary :: var outIndex = new Dictionary<(int From, int To), int>();
- L556 C23: new Dictionary :: var outSeen = new Dictionary<int, int>();
- L580 C30: new Vector2 :: Vector2 c1 = a + new Vector2(0, dy);
- L581 C30: new Vector2 :: Vector2 c2 = b - new Vector2(0, dy);
- L587 C40: new Vector2 :: drawList.AddText(mid + new Vector2(6f, -10f), labelColor, e.Label);
- L623 C35: new Vector2 :: Vector2 pMax = pMin + new Vector2(w, h) * view.Zoom;
- L635 C60: new Vector2 :: ImGui.InvisibleButton($"##RPCmdNode{node.Id}", new Vector2(w, h) * view.Zoom);
- L644 C37: new Vector2 :: drawList.AddText(pMin + new Vector2(textPad, 4f * view.Zoom), ImGui.GetColorU32(ImGuiCol.Text), node.Label);
- L651 C45: new Vector2 :: drawList.AddText(pMin + new Vector2(textPad, 34f * view.Zoom), ImGui.GetColorU32(ImGuiCol.TextDisabled), sub);
- L666 C13: new Vector2 :: new Vector2(0, 0),
- L738 C30: new Vector2 :: drawList.AddLine(new Vector2(canvasPos.X + x, canvasPos.Y), new Vector2(canvasPos.X + x, canvasPos.Y + canvasSize.Y), gridColor);
- L738 C73: new Vector2 :: drawList.AddLine(new Vector2(canvasPos.X + x, canvasPos.Y), new Vector2(canvasPos.X + x, canvasPos.Y + canvasSize.Y), gridColor);
- L741 C30: new Vector2 :: drawList.AddLine(new Vector2(canvasPos.X, canvasPos.Y + y), new Vector2(canvasPos.X + canvasSize.X, canvasPos.Y + y), gridColor);
- L741 C73: new Vector2 :: drawList.AddLine(new Vector2(canvasPos.X, canvasPos.Y + y), new Vector2(canvasPos.X + canvasSize.X, canvasPos.Y + y), gridColor);
- L744 C26: new Vector2 :: drawList.AddLine(new Vector2(origin.X, canvasPos.Y), new Vector2(origin.X, canvasPos.Y + canvasSize.Y), originColor, 2.0f);
- L744 C62: new Vector2 :: drawList.AddLine(new Vector2(origin.X, canvasPos.Y), new Vector2(origin.X, canvasPos.Y + canvasSize.Y), originColor, 2.0f);
- L745 C26: new Vector2 :: drawList.AddLine(new Vector2(canvasPos.X, origin.Y), new Vector2(canvasPos.X + canvasSize.X, origin.Y), originColor, 2.0f);
- L745 C62: new Vector2 :: drawList.AddLine(new Vector2(canvasPos.X, origin.Y), new Vector2(canvasPos.X + canvasSize.X, origin.Y), originColor, 2.0f);
- L763 C77: new Vector2 :: Vector2 passCenterIn = WorldToScreen(canvasPos, view, passPos + new Vector2(0, nodeH * 0.5f));
- L770 C80: new Vector2 :: Vector2 depCenterOut = WorldToScreen(canvasPos, view, depPos + new Vector2(nodeW, nodeH * 0.5f));
- L773 C45: new Vector2 :: Vector2 c1 = depCenterOut + new Vector2(dx, 0);
- L774 C45: new Vector2 :: Vector2 c2 = passCenterIn - new Vector2(dx, 0);
- L798 C35: new Vector2 :: Vector2 pMax = pMin + new Vector2(nodeW, nodeH) * view.Zoom;
- L812 C69: new Vector2 :: ImGui.InvisibleButton($"##RPGraphNode{pass.PassIndex}", new Vector2(nodeW, nodeH) * view.Zoom);
- L824 C39: new Vector2 :: Vector2 titlePos = pMin + new Vector2(textPad, 5f * view.Zoom);
- L828 C37: new Vector2 :: Vector2 subPos = pMin + new Vector2(textPad, 34f * view.Zoom);
- L833 C37: new Vector2 :: Vector2 depPos = pMin + new Vector2(textPad, 54f * view.Zoom);
- L853 C25: new Dictionary :: var memoDepth = new Dictionary<int, int>();
- L887 C54: new Vector2 :: view.NodePositions[pass.PassIndex] = new Vector2(group.Key * xStep, i * yStep);


## XREngine.Editor/IMGUI/EditorImGuiUI.SettingsPanel.cs
- L152 C31: new HashSet :: var visited = new HashSet<object>(ReferenceEqualityComparer.Instance);
- L153 C36: new InspectorTargetSet :: DrawSettingsObject(new InspectorTargetSet(new[] { settingsRoot }, settingsRoot.GetType()), headerLabel, null, visited, true);
- L153 C59: new[] :: DrawSettingsObject(new InspectorTargetSet(new[] { settingsRoot }, settingsRoot.GetType()), headerLabel, null, visited, true);


## XREngine.Editor/IMGUI/EditorImGuiUI.ShaderGraphPanel.cs
- L18 C66: new() :: public readonly Dictionary<int, Vector2> NodePositions = new();
- L23 C69: new() :: private static readonly ShaderGraphViewState _shaderGraphView = new();
- L33 C33: new Vector2 :: ImGui.SetNextWindowSize(new Vector2(1150, 780), ImGuiCond.FirstUseEver);
- L62 C36: new Vector2 :: _shaderGraphView.Pan = new Vector2(40, 40);
- L72 C98: new Vector2 :: ImGui.InputTextMultiline("##ShaderGraphSource", ref _shaderGraphSource, (uint)(1 << 18), new Vector2(-1, 170), ImGuiInputTextFlags.AllowTabInput);
- L75 C31: new Vector4 :: ImGui.TextColored(new Vector4(1f, 0.35f, 0.35f, 1f), _shaderGraphError);
- L90 C48: new Vector2 :: ImGui.BeginChild("ShaderGraphSidebar", new Vector2(sidebarWidth, -inspectorHeight - ImGui.GetStyle().ItemSpacing.Y), ImGuiChildFlags.Border | ImGuiChildFlags.ResizeX);
- L96 C53: new Vector2 :: ImGui.BeginChild("ShaderGraphCanvasRegion", new Vector2(0, -inspectorHeight - ImGui.GetStyle().ItemSpacing.Y), ImGuiChildFlags.Border);
- L102 C50: new Vector2 :: ImGui.BeginChild("ShaderGraphInspector", new Vector2(0, inspectorHeight), ImGuiChildFlags.Border);
- L108 C104: new Vector2 :: ImGui.InputTextMultiline("##ShaderGraphGenerated", ref _shaderGraphGenerated, (uint)(1 << 18), new Vector2(-1, 180), ImGuiInputTextFlags.ReadOnly | ImGuiInputTextFlags.AllowTabInput);
- L184 C49: new Vector2 :: ImGui.BeginChild("##ShaderGraphCanvas", new Vector2(0, 0), ImGuiChildFlags.None, ImGuiWindowFlags.NoScrollbar | ImGuiWindowFlags.NoScrollWithMouse);
- L244 C35: new Vector2 :: Vector2 pMax = pMin + new Vector2(nodeW, nodeH) * _shaderGraphView.Zoom;
- L253 C66: new Vector2 :: ImGui.InvisibleButton($"##ShaderGraphNode{node.Id}", new Vector2(nodeW, nodeH) * _shaderGraphView.Zoom);
- L271 C37: new Vector2 :: drawList.AddText(pMin + new Vector2(textPad, 6f * _shaderGraphView.Zoom), ImGui.GetColorU32(ImGuiCol.Text), title);
- L276 C41: new Vector2 :: drawList.AddText(pMin + new Vector2(textPad, 38f * _shaderGraphView.Zoom), ImGui.GetColorU32(ImGuiCol.TextDisabled), inputs);
- L301 C88: new Vector2 :: Vector2 fromAnchor = WorldToScreen(canvasPos, _shaderGraphView, fromPos) + new Vector2(nodeW * 0.5f * _shaderGraphView.Zoom, nodeH * _shaderGraphView.Zoom);
- L302 C84: new Vector2 :: Vector2 toAnchor = WorldToScreen(canvasPos, _shaderGraphView, toPos) + new Vector2(nodeW * 0.5f * _shaderGraphView.Zoom, 0);
- L305 C39: new Vector2 :: Vector2 c1 = fromAnchor + new Vector2(0, dy);
- L306 C37: new Vector2 :: Vector2 c2 = toAnchor - new Vector2(0, dy);
- L391 C29: new ShaderGraphGenerator :: var generator = new ShaderGraphGenerator(_activeShaderGraph);
- L421 C47: new Vector2 :: view.NodePositions[node.Id] = new Vector2(column * columnSpacing, currentRow * rowSpacing);


## XREngine.Editor/IMGUI/EditorImGuiUI.StatePanel.cs
- L42 C40: new Vector4 :: EPlayModeState.Edit => new Vector4(0.4f, 0.7f, 1.0f, 1.0f),      // Blue for edit
- L43 C40: new Vector4 :: EPlayModeState.Play => new Vector4(0.3f, 1.0f, 0.3f, 1.0f),      // Green for play
- L44 C42: new Vector4 :: EPlayModeState.Paused => new Vector4(1.0f, 1.0f, 0.3f, 1.0f),    // Yellow for paused
- L45 C48: new Vector4 :: EPlayModeState.EnteringPlay => new Vector4(0.5f, 1.0f, 0.5f, 1.0f),
- L46 C47: new Vector4 :: EPlayModeState.ExitingPlay => new Vector4(1.0f, 0.5f, 0.5f, 1.0f),
- L47 C22: new Vector4 :: _ => new Vector4(1.0f, 1.0f, 1.0f, 1.0f)
- L69 C52: new Vector2 :: if (ImGui.Button("▶ Play", new Vector2(80, 0)))
- L74 C49: new Vector2 :: if (ImGui.Button("⏸ Pause", new Vector2(80, 0)))
- L77 C48: new Vector2 :: if (ImGui.Button("⏹ Stop", new Vector2(80, 0)))
- L82 C50: new Vector2 :: if (ImGui.Button("▶ Resume", new Vector2(80, 0)))
- L85 C48: new Vector2 :: if (ImGui.Button("⏹ Stop", new Vector2(80, 0)))
- L88 C48: new Vector2 :: if (ImGui.Button("⏭ Step", new Vector2(80, 0)))
- L101 C39: new Vector4 :: ImGui.TextColored(new Vector4(0.8f, 0.8f, 1.0f, 1.0f), gameMode.GetType().Name);
- L112 C39: new Vector4 :: ImGui.TextColored(new Vector4(0.5f, 0.5f, 0.5f, 1.0f), "No active GameMode");
- L133 C39: new Vector4 :: ImGui.TextColored(new Vector4(0.5f, 0.5f, 0.5f, 1.0f), "No local players initialized");
- L163 C51: new Vector4 :: ImGui.TextColored(new Vector4(0.3f, 1.0f, 0.3f, 1.0f), "Yes");
- L165 C51: new Vector4 :: ImGui.TextColored(new Vector4(0.5f, 0.5f, 0.5f, 1.0f), "None");
- L208 C35: new Vector4 :: ImGui.TextColored(new Vector4(0.5f, 0.5f, 0.5f, 1.0f), "<no input>");
- L232 C35: new Vector4 :: ImGui.TextColored(new Vector4(0.5f, 0.5f, 0.5f, 1.0f), "<none>");
- L236 C31: new Vector4 :: ImGui.TextColored(new Vector4(0.8f, 0.8f, 1.0f, 1.0f), pawn.GetType().Name);
- L242 C35: new Vector4 :: ImGui.TextColored(new Vector4(0.6f, 0.6f, 0.6f, 1.0f), $"({pawn.SceneNode.Name})");
- L258 C39: new Vector4 :: ImGui.TextColored(new Vector4(0.5f, 0.5f, 0.5f, 1.0f), "No world instances active");
- L282 C51: new Vector4 :: ImGui.TextColored(new Vector4(0.3f, 1.0f, 0.3f, 1.0f), "Yes");
- L284 C51: new Vector4 :: ImGui.TextColored(new Vector4(0.5f, 0.5f, 0.5f, 1.0f), "No");
- L288 C51: new Vector4 :: ImGui.TextColored(new Vector4(0.3f, 1.0f, 0.3f, 1.0f), "On");
- L290 C51: new Vector4 :: ImGui.TextColored(new Vector4(0.5f, 0.5f, 0.5f, 1.0f), "Off");
- L337 C39: new Vector4 :: ImGui.TextColored(new Vector4(0.5f, 0.5f, 0.5f, 1.0f), "No windows active");
- L346 C63: new Silk.NET.Maths.Vector2D :: var size = window.Window?.Size ?? new Silk.NET.Maths.Vector2D<int>(0, 0);
- L355 C51: new Vector4 :: ImGui.TextColored(new Vector4(0.8f, 0.8f, 1.0f, 1.0f),
- L360 C51: new Vector4 :: ImGui.TextColored(new Vector4(0.5f, 0.5f, 0.5f, 1.0f), "No world instance");
- L392 C63: new Vector4 :: ImGui.TextColored(new Vector4(0.3f, 1.0f, 0.3f, 1.0f),
- L397 C63: new Vector4 :: ImGui.TextColored(new Vector4(0.5f, 0.5f, 0.5f, 1.0f), "<none>");
- L444 C51: new Vector4 :: ImGui.TextColored(new Vector4(0.5f, 0.5f, 0.5f, 1.0f), "No viewports");
- L552 C38: new Vector2 :: XRTexture2D tex2D => new Vector2(tex2D.Width, tex2D.Height),
- L553 C22: new Vector2 :: _ => new Vector2(texture.WidthHeightDepth.X, texture.WidthHeightDepth.Y),
- L572 C20: new Vector2 :: return new Vector2(width, height);


## XREngine.Editor/IMGUI/EditorImGuiUI.Toolbar.cs
- L32 C32: new Vector2 :: ImGui.SetNextWindowPos(new Vector2(viewport.Pos.X, viewport.Pos.Y + menuBarHeight));
- L33 C33: new Vector2 :: ImGui.SetNextWindowSize(new Vector2(viewport.Size.X, ToolbarHeight));
- L46 C57: new Vector2 :: ImGui.PushStyleVar(ImGuiStyleVar.WindowPadding, new Vector2(8f, 4f));
- L161 C15: new Vector4 :: ? new Vector4(0.15f, 0.55f, 0.95f, 1.0f)
- L162 C15: new Vector4 :: : new Vector4(0.4f, 0.4f, 0.4f, 1.0f);
- L244 C19: new Vector4 :: ? new Vector4(0.4f, 0.4f, 0.4f, 1.0f)
- L245 C19: new Vector4 :: : new Vector4(0.9f, 0.3f, 0.3f, 1.0f);
- L258 C19: new Vector4 :: ? new Vector4(0.5f, 0.7f, 0.9f, 1.0f)
- L259 C19: new Vector4 :: : new Vector4(0.4f, 0.4f, 0.4f, 1.0f);
- L277 C26: new Vector4 :: stateColor = new Vector4(0.8f, 0.8f, 0.2f, 1.0f);
- L282 C26: new Vector4 :: stateColor = new Vector4(0.3f, 1.0f, 0.3f, 1.0f);
- L287 C26: new Vector4 :: stateColor = new Vector4(1.0f, 0.8f, 0.2f, 1.0f);
- L336 C43: new Vector2 :: ImGui.GetWindowDrawList().AddText(new Vector2(start.X, y), color, label);
- L339 C21: new Vector2 :: ImGui.Dummy(new Vector2(size.X, ToolbarButtonSize));
- L356 C26: new Vector4 :: hoverColor = new Vector4(
- L361 C25: new Vector4 :: textColor = new Vector4(1f, 1f, 1f, 1f);
- L379 C43: new Vector2 :: clicked = ImGui.Button(label, new Vector2(ToolbarButtonSize, ToolbarButtonSize));
- L415 C43: new Vector2 :: clicked = ImGui.Button(label, new Vector2(ToolbarButtonSize, ToolbarButtonSize));
- L428 C26: new Vector2 :: var buttonSize = new Vector2(ToolbarButtonSize, ToolbarButtonSize);
- L439 C39: new Vector2 :: Vector2 iconMin = buttonMin + new Vector2(padding, padding);
- L440 C39: new Vector2 :: Vector2 iconMax = buttonMax - new Vector2(padding, padding);
- L445 C51: new Vector4 :: uint tint = ImGui.ColorConvertFloat4ToU32(new Vector4(1f, 1f, 1f, 1f));
- L457 C20: new Vector4 :: return new Vector4(0.3f, 0.3f, 0.3f, 1.0f);
- L461 C41: new Vector4 :: ETransformMode.Translate => new Vector4(0.2f, 0.6f, 0.9f, 1.0f), // Blue
- L462 C38: new Vector4 :: ETransformMode.Rotate => new Vector4(0.2f, 0.8f, 0.4f, 1.0f),    // Green
- L463 C37: new Vector4 :: ETransformMode.Scale => new Vector4(0.9f, 0.6f, 0.2f, 1.0f),     // Orange
- L464 C18: new Vector4 :: _ => new Vector4(0.5f, 0.5f, 0.5f, 1.0f)
- L474 C15: new Vector4 :: ? new Vector4(0.15f, 0.55f, 0.95f, 1.0f)  // Active blue
- L475 C15: new Vector4 :: : new Vector4(0.3f, 0.3f, 0.3f, 1.0f);    // Inactive gray


## XREngine.Editor/IMGUI/EditorImGuiUI.ViewportPanel.cs
- L207 C35: new BoundingRectangle :: _scenePanelRenderRegion = new BoundingRectangle(x, y, w, h);


## XREngine.Editor/IMGUI/ImGuiDragDropNative.cs
- L32 C20: new ImRect :: var rect = new ImRect(min, max);


## XREngine.Editor/ImGuiAssetUtilities.cs
- L30 C85: new() :: private static readonly Dictionary<AssetPickerKey, object> _assetPickerStates = new();
- L39 C74: new() :: public static readonly AssetReferenceEqualityComparer Instance = new();
- L131 C85: new Vector2 :: if (ImGui.Selectable(preview, false, ImGuiSelectableFlags.AllowDoubleClick, new Vector2(fieldWidth, 0.0f)))
- L220 C35: new HashSet :: _inlineInspectorStack ??= new HashSet<XRAsset>(AssetReferenceEqualityComparer.Instance);
- L303 C35: new ImGuiListClipper :: var clipper = new ImGuiListClipper();
- L377 C19: new AssetPickerKey :: var key = new AssetPickerKey(typeof(TAsset), extensionKey);
- L382 C21: new AssetPickerState :: var state = new AssetPickerState<TAsset>(options.ResolveExtensions(typeof(TAsset)));
- L401 C21: new List :: var roots = new List<(string Path, bool IsEngine)>();
- L410 C25: new HashSet :: var seenPaths = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
- L443 C38: new AssetCandidate :: state.Candidates.Add(new AssetCandidate<TAsset>(file, isEngine, displayName, existing));
- L467 C32: new FileStream :: using var stream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite | FileShare.Delete);
- L468 C32: new StreamReader :: using var reader = new StreamReader(stream, detectEncodingFromByteOrderMarks: true);
- L622 C76: new() :: private static readonly Dictionary<Type, string[]> DefaultExtensions = new()
- L624 C26: new[] :: { typeof(Model), new[] { ".asset" } },
- L625 C27: new[] :: { typeof(XRMesh), new[] { ".asset", ".mesh", ".model" } },
- L626 C31: new[] :: { typeof(XRMaterial), new[] { ".asset", ".material" } }
- L755 C85: new XRTexture2D :: XRTexture2D seedTexture = (_asset as XRTexture2D) ?? _previewTexture ?? new XRTexture2D();
- L787 C62: new XRTexture2D :: XRTexture2D placeholder = _previewTexture ?? new XRTexture2D();
- L867 C32: new Vector2 :: ImGui.SetCursorPos(new Vector2(cursor.X + offsetX, cursor.Y));
- L885 C21: new Vector2 :: pixelSize = new Vector2(texture.Width, texture.Height);
- L886 C23: new Vector2 :: displaySize = new Vector2(AssetPickerPreviewFallbackEdge, AssetPickerPreviewFallbackEdge);
- L940 C20: new Vector2 :: return new Vector2(AssetPickerPreviewFallbackEdge, AssetPickerPreviewFallbackEdge);
- L944 C20: new Vector2 :: return new Vector2(width, height);
- L947 C16: new Vector2 :: return new Vector2(width * scale, height * scale);
- L1024 C71: new() :: private static readonly Dictionary<Guid, CacheEntry> _cache = new();
- L1048 C36: new CacheEntry :: _cache[asset.ID] = new CacheEntry(new WeakReference<XRAsset>(asset), now + CacheDuration, count);
- L1048 C51: new WeakReference :: _cache[asset.ID] = new CacheEntry(new WeakReference<XRAsset>(asset), now + CacheDuration, count);
- L1073 C105: new() :: private static readonly ConcurrentDictionary<Type, List<Func<object, object?>>> AccessorCache = new();
- L1091 C26: new AssetReferenceWalker :: var walker = new AssetReferenceWalker(target);
- L1191 C33: new List :: var accessors = new List<Func<object, object?>>();
- L1235 C69: new() :: public static readonly ReferenceEqualityComparer Instance = new();
- L1237 C16: new bool :: public new bool Equals(object? x, object? y)


## XREngine.Editor/ImGuiEditorUtilities.cs
- L19 C35: new ArgumentNullException :: _list = list ?? throw new ArgumentNullException(nameof(list));
- L30 C24: new CollectionEditorAdapter :: return new CollectionEditorAdapter(array, elementType, null);
- L44 C20: new CollectionEditorAdapter :: return new CollectionEditorAdapter(array, elementType, ReplacementFactory);
- L148 C26: new List :: var values = new List<object?>(_list.Count);


## XREngine.Editor/ImGuiSceneNodeDragDrop.cs
- L17 C19: new ArgumentNullException :: throw new ArgumentNullException(nameof(node));


## XREngine.Editor/Mcp/Actions/EditorMcpActions.Components.cs
- L39 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Scene node not found.", isError: true));
- L42 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Component type '{componentTypeName}' not found.", isError: true));
- L46 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Failed to add component '{componentTypeName}' to '{nodeId}'.", isError: true));
- L48 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Added component '{componentType.Name}' to '{nodeId}'.", new
- L77 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Scene node not found.", isError: true));
- L86 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Listed components on '{nodeId}'.", new { components }));
- L118 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Provide component_id, component_name, or component_type to target a component.", isError: true));
- L121 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse(nodeError ?? "Scene node not found.", isError: true));
- L125 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse(compError ?? "Component not found on the specified node.", isError: true));
- L133 C44: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Unable to deserialize value.", isError: true));
- L136 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Set property '{property.Name}' on '{componentType.Name}'."));
- L143 C44: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Unable to deserialize value.", isError: true));
- L146 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Set field '{field.Name}' on '{componentType.Name}'."));
- L149 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Property or field '{propertyName}' not found on '{componentType.Name}'.", isError: true));
- L179 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Provide component_id, component_name, or component_type to target a component.", isError: true));
- L182 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse(nodeError ?? "Scene node not found.", isError: true));
- L186 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse(compError ?? "Component not found on the specified node.", isError: true));
- L194 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Retrieved property '{property.Name}' on '{componentType.Name}'.", new { value }));
- L201 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Retrieved field '{field.Name}' on '{componentType.Name}'.", new { value }));
- L204 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Property or field '{propertyName}' not found on '{componentType.Name}'.", isError: true));
- L227 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Provide component_id, component_name, or component_type to target a component.", isError: true));
- L230 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse(nodeError ?? "Scene node not found.", isError: true));
- L234 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse(compError ?? "Component not found on the specified node.", isError: true));
- L237 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Removed component '{component.ID}' from '{nodeId}'."));


## XREngine.Editor/Mcp/Actions/EditorMcpActions.Helpers.cs
- L194 C24: new HashSet :: tags = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
- L206 C25: new List :: var parts = new List<string>();


## XREngine.Editor/Mcp/Actions/EditorMcpActions.Introspection.cs
- L40 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Listed component types.", new { components }));
- L55 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Component type '{componentTypeName}' not found.", isError: true));
- L58 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Retrieved schema for '{componentType.Name}'.", schema));
- L73 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Scene node not found.", isError: true));
- L86 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Listed {children.Length} child transforms.", new { children }));
- L101 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Scene node not found.", isError: true));
- L114 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Retrieved transform matrices for '{nodeId}'.", data));
- L129 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Scene node not found.", isError: true));
- L144 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Retrieved decomposed transform state for '{nodeId}'.", data));
- L181 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Listed {result.Length} loaded assets.", new { assets = result }));
- L198 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Provide asset_id or asset_path.", isError: true));
- L204 C44: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Invalid asset_id '{assetId}'.", isError: true));
- L214 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Asset not found.", isError: true));
- L228 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Retrieved asset info for '{asset.Name ?? asset.ID.ToString()}'.", info));
- L250 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Listed {prefabs.Length} prefab assets.", new { prefabs }));
- L267 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Provide prefab_id or prefab_path.", isError: true));
- L273 C44: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Invalid prefab_id '{prefabId}'.", isError: true));
- L283 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Prefab asset not found.", isError: true));
- L293 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Prefab hierarchy is not available.", isError: true));
- L295 C25: new List :: var nodes = new List<object>();
- L308 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Retrieved prefab hierarchy.", data));
- L349 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Retrieved render state.", data));
- L370 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Retrieved {selection.Length} selected nodes.", new { selection }));
- L393 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Retrieved engine state.", data));
- L421 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Retrieved timing state.", data));
- L446 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Retrieved job manager state.", data));
- L473 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Listed {jobs.Length} active jobs.", new { jobs }));
- L509 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Retrieved undo history.", data));
- L536 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Listed input devices.", new { devices }));
- L567 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Listed {players.Length} local players.", new { players }));
- L585 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("No active world found.", isError: true));
- L591 C44: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Scene not found.", isError: true));
- L602 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Retrieved scene statistics.", new { scenes = stats }));
- L625 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Listed transform types.", new { types }));
- L647 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Retrieved render capabilities.", data));
- L652 C25: new HashSet :: var types = new HashSet<Type>();


## XREngine.Editor/Mcp/Actions/EditorMcpActions.Scene.cs
- L48 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("No active scene found.", isError: true));
- L50 C25: new List :: var nodes = new List<object>();
- L57 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Listed scene nodes.", new { nodes }));
- L85 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Scene node not found.", isError: true));
- L113 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Retrieved info for '{nodeId}'.", info));
- L133 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Scene node not found.", isError: true));
- L136 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Set '{nodeId}' active={isActive}."));
- L158 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Scene node not found.", isError: true));
- L164 C44: new McpToolResponse :: return Task.FromResult(new McpToolResponse(parentError ?? "Parent node not found.", isError: true));
- L168 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Reparented '{nodeId}' to '{newParentId ?? "<root>"}'."));
- L186 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Scene node not found.", isError: true));
- L189 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Deleted scene node '{nodeId}'."));
- L220 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("No active scene found to create the node.", isError: true));
- L226 C44: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Parent node not found.", isError: true));
- L232 C24: new SceneNode :: node = new SceneNode(name);
- L238 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Created scene node '{name}'.", new { id = node.ID, path = BuildNodePath(node) }));
- L253 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Scene node not found.", isError: true));
- L259 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Renamed '{nodeId}' to '{name}'."));
- L278 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Scene node not found.", isError: true));
- L298 C44: new McpToolResponse :: return Task.FromResult(new McpToolResponse(parentError ?? "Parent node not found.", isError: true));
- L313 C44: new McpToolResponse :: return Task.FromResult(new McpToolResponse("No active scene found to place the duplicated node.", isError: true));
- L320 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Duplicated scene node '{nodeId}'.", new { id = clone.ID, path = BuildNodePath(clone) }));
- L339 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Scene node not found.", isError: true));
- L342 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Provide new_index or after_node_id.", isError: true));
- L349 C44: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Node is not a child of its parent transform.", isError: true));
- L355 C48: new McpToolResponse :: return Task.FromResult(new McpToolResponse(afterError ?? "After-node not found.", isError: true));
- L358 C48: new McpToolResponse :: return Task.FromResult(new McpToolResponse("After-node must share the same parent.", isError: true));
- L372 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Moved '{nodeId}' to sibling index {targetIndex}."));
- L377 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Unable to resolve the owning scene for the root node.", isError: true));
- L381 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Node is not registered as a root in its scene.", isError: true));
- L387 C44: new McpToolResponse :: return Task.FromResult(new McpToolResponse(afterError ?? "After-node not found.", isError: true));
- L390 C44: new McpToolResponse :: return Task.FromResult(new McpToolResponse("After-node must be a root node in the same scene.", isError: true));
- L414 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Moved root '{nodeId}' to index {targetRootIndex}.", new { index = targetRootIndex }));
- L429 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Scene node not found.", isError: true));
- L434 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Set active={isActive} for '{nodeId}' and its children."));
- L450 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Name must be provided.", isError: true));
- L453 C26: new List :: var scenes = new List<XRScene>();
- L458 C44: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Scene not found.", isError: true));
- L467 C27: new List :: var results = new List<object>();
- L494 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Found {results.Count} nodes matching '{name}'.", new { nodes = results }));
- L509 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Component type must be provided.", isError: true));
- L512 C26: new List :: var scenes = new List<XRScene>();
- L517 C44: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Scene not found.", isError: true));
- L526 C27: new List :: var results = new List<object>();
- L552 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Found {results.Count} nodes with component '{componentType}'.", new { nodes = results }));
- L568 C27: new List :: var targets = new List<SceneNode>();
- L573 C44: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Scene node not found.", isError: true));
- L582 C48: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? $"Scene node '{id}' not found.", isError: true));
- L590 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Cleared selection."));
- L598 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Selected {Selection.SceneNodes.Length} node(s)."));
- L613 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Scene node not found.", isError: true));
- L617 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("No editor camera pawn available to focus.", isError: true));
- L620 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Focused camera on '{nodeId}'."));
- L638 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Scene node not found.", isError: true));
- L645 C44: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Unknown layer '{layerName}'.", isError: true));
- L654 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Provide layer_index or layer_name.", isError: true));
- L658 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Set layer for '{nodeId}' to {node.Layer}.", new { layer = node.Layer }));
- L671 C24: new HashSet :: var used = new HashSet<int>();
- L691 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Listed layers.", new { layers }));
- L707 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Scene node not found.", isError: true));
- L710 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Tag must be provided.", isError: true));
- L718 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"{(add ? "Added" : "Removed")} tag '{tag}' on '{nodeId}'.", new { tags = tags.ToArray() }));
- L736 C44: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Scene node not found.", isError: true));
- L739 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Listed tags for '{nodeId}'.", new { tags }));
- L742 C27: new HashSet :: var allTags = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
- L759 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Listed tags.", new { tags = allTags.OrderBy(x => x).ToArray() }));
- L803 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Scene node not found.", isError: true));
- L806 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Scene node '{nodeId}' does not use a standard Transform.", isError: true));
- L829 C34: new Vector3 :: var localScale = new Vector3(
- L837 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Updated world transform for '{nodeId}'."));
- L851 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Scene node not found.", isError: true));
- L862 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Retrieved world transform for '{nodeId}'.", info));
- L878 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Scene node not found.", isError: true));
- L881 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Created prefab '{assetName}'.", new { id = prefab.ID, path = prefab.FilePath }));
- L901 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Asset manager is unavailable.", isError: true));
- L907 C44: new McpToolResponse :: return Task.FromResult(new McpToolResponse(parentError ?? "Parent node not found.", isError: true));
- L921 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Provide asset_path or asset_id.", isError: true));
- L925 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Failed to instantiate prefab.", isError: true));
- L931 C44: new McpToolResponse :: return Task.FromResult(new McpToolResponse("No active scene found to place the prefab.", isError: true));
- L938 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Instantiated prefab.", new { id = instance.ID, path = BuildNodePath(instance) }));


## XREngine.Editor/Mcp/Actions/EditorMcpActions.Transform.cs
- L48 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Scene node not found.", isError: true));
- L51 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Scene node '{nodeId}' does not use a standard Transform.", isError: true));
- L55 C31: new Vector3 :: var translation = new Vector3(
- L60 C25: new Vector3 :: var scale = new Vector3(
- L65 C27: new Rotator :: var rotator = new Rotator(
- L92 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Updated transform for '{nodeId}'."));
- L118 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Scene node not found.", isError: true));
- L121 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Scene node '{nodeId}' does not use a standard Transform.", isError: true));
- L123 C27: new Rotator :: var rotator = new Rotator(pitch, yaw, roll);
- L126 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Applied rotation to '{nodeId}'.", new


## XREngine.Editor/Mcp/Actions/EditorMcpActions.Viewport.cs
- L52 C24: new McpToolResponse :: return new McpToolResponse("No viewport found to capture.", isError: true);
- L66 C45: new InvalidOperationException :: tcs.TrySetException(new InvalidOperationException("Screenshot capture returned null."));
- L83 C23: new TaskCompletionSource :: var tcs = new TaskCompletionSource<string>(TaskCreationOptions.RunContinuationsAsynchronously);
- L88 C24: new McpToolResponse :: return new McpToolResponse("No window found to capture from.", isError: true);
- L138 C24: new McpToolResponse :: return new McpToolResponse($"Captured screenshot to '{savedPath}'.", new { path = savedPath });
- L142 C24: new McpToolResponse :: return new McpToolResponse($"Failed to capture screenshot: {ex.Message}", isError: true);


## XREngine.Editor/Mcp/Actions/EditorMcpActions.Workflow.cs
- L25 C19: new McpToolResponse :: ? new McpToolResponse("Undo applied.")
- L26 C19: new McpToolResponse :: : new McpToolResponse("Nothing to undo.", isError: true));
- L36 C19: new McpToolResponse :: ? new McpToolResponse("Redo applied.")
- L37 C19: new McpToolResponse :: : new McpToolResponse("Nothing to redo.", isError: true));
- L46 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Selection cleared."));
- L60 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("No selected nodes found in the active world.", isError: true));
- L66 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Deleted {targets.Length} selected node(s)."));
- L75 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Already in play mode."));
- L78 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Play mode transition requested."));
- L87 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Already in edit mode."));
- L90 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Exit play mode transition requested."));
- L104 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("node_name must be provided.", isError: true));
- L109 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("No active scene found.", isError: true));
- L122 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"No nodes matched '{nodeName}'.", isError: true));
- L129 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Selected {matches.Length} node(s) by name.", new
- L150 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("No active scene found.", isError: true));
- L158 C44: new McpToolResponse :: return Task.FromResult(new McpToolResponse(parentError ?? "Parent node not found.", isError: true));
- L164 C24: new SceneNode :: node = new SceneNode(name ?? "Primitive");
- L177 C48: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Failed to add BoxMeshComponent.", isError: true));
- L179 C31: new AABB :: box.Box = new AABB(new Vector3(-half), new Vector3(half));
- L179 C40: new Vector3 :: box.Box = new AABB(new Vector3(-half), new Vector3(half));
- L179 C60: new Vector3 :: box.Box = new AABB(new Vector3(-half), new Vector3(half));
- L186 C48: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Failed to add SphereMeshComponent.", isError: true));
- L188 C36: new Sphere :: sphere.Shape = new Sphere(Vector3.Zero, sphere.Radius);
- L195 C48: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Failed to add ConeMeshComponent.", isError: true));
- L198 C34: new Cone :: cone.Shape = new Cone(Vector3.Zero, Globals.Up, cone.Height, cone.Radius);
- L204 C44: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Unsupported shape_type '{shapeType}'. Supported: cube, box, sphere, cone.", isError: true));
- L208 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Created {normalized} primitive.", new { id = node.ID, path = BuildNodePath(node) }));
- L220 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("No active world found.", isError: true));
- L224 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Asset manager is unavailable.", isError: true));
- L233 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Saved active world.", new
- L252 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Asset manager is unavailable.", isError: true));
- L268 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("World asset not found. Provide asset_path or the name of an already-loaded world.", isError: true));
- L273 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Loaded world.", new
- L296 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Listed {tools.Length} tools.", new { tools }));


## XREngine.Editor/Mcp/Actions/EditorMcpActions.World.cs
- L41 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Listed active world instances.", new { worlds }));
- L56 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("No active world found.", isError: true));
- L66 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Listed scenes.", new { scenes }));
- L83 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("No active world found.", isError: true));
- L85 C25: new XRScene :: var scene = new XRScene(name) { IsVisible = isVisible };
- L89 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Created scene '{name}'.", new { id = scene.ID }));
- L104 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Scene not found.", isError: true));
- L108 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Deleted scene '{scene.Name ?? scene.ID.ToString()}'."));
- L124 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Scene not found.", isError: true));
- L132 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Scene '{scene.Name ?? scene.ID.ToString()}' visibility set to {isVisible}."));
- L148 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("No active world found.", isError: true));
- L151 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Scene not found.", isError: true));
- L161 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Set '{scene.Name ?? scene.ID.ToString()}' as the active scene."));
- L177 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Scene not found.", isError: true));
- L181 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Asset manager is unavailable.", isError: true));
- L184 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Output directory must be provided.", isError: true));
- L188 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Exported scene '{scene.Name ?? scene.ID.ToString()}'.", new { path = scene.FilePath }));
- L205 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("No active world found.", isError: true));
- L209 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Asset manager is unavailable.", isError: true));
- L212 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Asset path must be provided.", isError: true));
- L216 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse("Failed to load scene asset.", isError: true));
- L225 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse($"Imported scene '{scene.Name ?? scene.ID.ToString()}'.", new { id = scene.ID }));
- L240 C40: new McpToolResponse :: return Task.FromResult(new McpToolResponse(error ?? "Scene not found.", isError: true));
- L242 C26: new System.Collections.Generic.List :: var issues = new System.Collections.Generic.List<string>();
- L259 C36: new McpToolResponse :: return Task.FromResult(new McpToolResponse(issues.Count == 0


## XREngine.Editor/Mcp/McpRateLimiter.cs
- L17 C62: new FixedWindowCounter :: var counter = _counters.GetOrAdd(clientKey, _ => new FixedWindowCounter(nowUtc, 0));
- L48 C43: new() :: public object Sync { get; } = new();


## XREngine.Editor/Mcp/McpServerHost.cs
- L17 C48: new() :: private static readonly object _lock = new();
- L21 C69: new() :: private readonly JsonSerializerOptions _serializerOptions = new()
- L30 C56: new() :: private readonly McpRateLimiter _rateLimiter = new();
- L45 C60: new() :: private static readonly object s_idempotencyLock = new();
- L81 C39: new McpServerHost :: _instance ??= new McpServerHost();
- L163 C20: new CancellationTokenSource :: _cts = new CancellationTokenSource();
- L164 C25: new HttpListener :: _listener = new HttpListener();
- L497 C29: new[] :: var resources = new[]
- L534 C27: new[] :: var prompts = new[]
- L540 C33: new[] :: arguments = new[]
- L549 C33: new[] :: arguments = new[]
- L562 C24: new McpError :: return new McpError(-32602, paramsError ?? "Missing params.");
- L565 C24: new McpError :: return new McpError(-32602, "Missing resource URI.");
- L569 C24: new McpError :: return new McpError(-32602, "Invalid resource URI.");
- L577 C22: new McpError :: _ => new McpError(-32602, $"Unknown resource URI '{uri}'.")
- L587 C28: new[] :: contents = new[]
- L602 C24: new McpError :: return new McpError(-32602, paramsError ?? "Missing params.");
- L605 C24: new McpError :: return new McpError(-32602, "Missing prompt name.");
- L609 C24: new McpError :: return new McpError(-32602, "Invalid prompt name.");
- L626 C32: new[] :: messages = new[]
- L631 C39: new[] :: content = new[]
- L647 C32: new[] :: messages = new[]
- L652 C39: new[] :: content = new[]
- L669 C30: new McpError :: return result ?? new McpError(-32602, $"Unknown prompt '{name}'.");
- L675 C24: new McpError :: return new McpError(-32602, paramsError ?? "Missing params.");
- L678 C24: new McpError :: return new McpError(-32602, "Missing tool name.");
- L684 C24: new McpError :: return new McpError(-32602, policyError ?? $"Tool '{name}' is disallowed by server policy.");
- L687 C24: new McpError :: return new McpError(-32601, $"Tool '{name}' not found.");
- L691 C24: new McpError :: return new McpError(-32000, "No active world instance.");
- L697 C28: new McpError :: return new McpError(-32602, "Invalid arguments. Expected an object.");
- L713 C27: new McpToolContext :: var context = new McpToolContext(world);
- L718 C27: new[] :: content = new[]
- L869 C20: new McpError :: return new McpError(code, message);
- L954 C28: new MemoryStream :: using var ms = new MemoryStream();
- L955 C29: new byte :: byte[] buffer = new byte[8192];
- L966 C27: new InvalidDataException :: throw new InvalidDataException("Request payload exceeds maximum size.");


## XREngine.Editor/Mcp/McpToolRegistry.cs
- L16 C71: new() :: private static readonly JsonSerializerOptions s_jsonOptions = new()
- L36 C25: new List :: var tools = new List<McpToolDefinition>();
- L65 C25: new Dictionary :: var types = new Dictionary<string, Type>(StringComparer.OrdinalIgnoreCase);
- L187 C30: new Dictionary :: var properties = new Dictionary<string, object>();
- L188 C28: new List :: var required = new List<string>();
- L203 C31: new Dictionary :: var inputSchema = new Dictionary<string, object?>
- L211 C20: new McpToolDefinition :: return new McpToolDefinition(
- L220 C26: new Dictionary :: var schema = new Dictionary<string, object?> { ["type"] = MapJsonType(parameterType) };
- L252 C30: new object :: var invokeArgs = new object?[parameters.Length];
- L277 C28: new McpToolResponse :: return new McpToolResponse($"Missing required argument '{parameter.Name}'.", isError: true);
- L281 C28: new McpToolResponse :: return new McpToolResponse(error ?? $"Unable to deserialize argument '{parameter.Name}'.", isError: true);
- L290 C28: new McpToolResponse :: return new McpToolResponse($"Tool '{method.Name}' has no declaring type.", isError: true);
- L298 C28: new McpToolResponse :: return new McpToolResponse($"Failed to construct tool target '{method.DeclaringType.Name}': {ex.Message}", isError: true);
- L308 C20: new McpToolResponse :: return new McpToolResponse($"Tool '{method.Name}' did not return a response.", isError: true);


## XREngine.Editor/MeshEditingPawnComponent.cs
- L28 C54: new() :: private ModelingMeshMetadata _modelingMetadata = new()
- L492 C19: new InvalidOperationException :: throw new InvalidOperationException("No mesh is assigned to the MeshEditingPawnComponent.");
- L498 C60: new InvalidOperationException :: => _mesh?.GenerateAccelerationStructure() ?? throw new InvalidOperationException("No mesh is assigned to the MeshEditingPawnComponent.");
- L501 C35: new InvalidOperationException :: => _mesh?.Bake() ?? throw new InvalidOperationException("No mesh is assigned to the MeshEditingPawnComponent.");
- L518 C19: new InvalidOperationException :: throw new InvalidOperationException("No mesh is assigned to the MeshEditingPawnComponent.");
- L520 C21: new XRMeshModelingExportOptions :: options ??= new XRMeshModelingExportOptions();
- L637 C58: new List :: .Select(channel => channel is null ? new List<Vector2>() : [.. channel])
- L648 C58: new List :: .Select(channel => channel is null ? new List<Vector4>() : [.. channel])
- L679 C34: new ModelingSkinBone :: .Select(x => new ModelingSkinBone
- L686 C65: new ModelingSkinWeight :: .Select(weightSet => weightSet?.Select(x => new ModelingSkinWeight(x.BoneIndex, x.Weight)).ToList() ?? [])
- L693 C40: new ModelingBlendshapeChannel :: .Select(channel => new ModelingBlendshapeChannel
- L709 C33: new ModelingMeshValidationIssue :: diagnostics.Add(new ModelingMeshValidationIssue(
- L713 C23: new InvalidOperationException :: throw new InvalidOperationException("Strict skinning/blendshape fallback policy failed because topology changed.");
- L719 C33: new ModelingMeshValidationIssue :: diagnostics.Add(new ModelingMeshValidationIssue(
- L730 C23: new ArgumentOutOfRangeException :: throw new ArgumentOutOfRangeException(nameof(options.SkinningBlendshapeFallbackPolicy), options.SkinningBlendshapeFallbackPolicy, "Unknown fallback policy.");
- L744 C30: new ModelingSkinBone :: .Select(x => new ModelingSkinBone
- L762 C63: new ModelingSkinWeight :: reprojectedWeights.Add(sourceSet?.Select(x => new ModelingSkinWeight(x.BoneIndex, x.Weight)).ToList() ?? []);
- L773 C57: new() :: ModelingBlendshapeChannel reprojected = new()
- L776 C38: new List :: PositionDeltas = new List<Vector3>(document.Positions.Count),
- L777 C80: new List :: NormalDeltas = sourceChannel.NormalDeltas is null ? null : new List<Vector3>(document.Positions.Count),
- L778 C82: new List :: TangentDeltas = sourceChannel.TangentDeltas is null ? null : new List<Vector3>(document.Positions.Count)
- L811 C25: new ModelingMeshValidationIssue :: diagnostics.Add(new ModelingMeshValidationIssue(
- L819 C21: new int :: int[] map = new int[targetPositions.Count];
- L851 C19: new InvalidOperationException :: throw new InvalidOperationException("No mesh is assigned to the MeshEditingPawnComponent.");


## XREngine.Editor/Program.cs
- L33 C57: new() :: private static readonly object s_startupTimerLock = new();
- L326 C21: new XRScene :: var scene = new XRScene("Main Scene");
- L327 C24: new SceneNode :: var rootNode = new SceneNode("Root Node");
- L340 C80: new Vector3 :: EditorUnitTests.Lighting.AddLightProbes(rootNode, 1, 1, 1, 10, 10, 10, new Vector3(0.0f, 50.0f, 0.0f));
- L345 C21: new XRWorld :: var world = new XRWorld("Default World", scene);
- L366 C27: new Vector3 :: debug.AddLine(new Vector3(x, y, -extent), new Vector3(x, y, extent), color);
- L366 C55: new Vector3 :: debug.AddLine(new Vector3(x, y, -extent), new Vector3(x, y, extent), color);
- L375 C27: new Vector3 :: debug.AddLine(new Vector3(-extent, y, z), new Vector3(extent, y, z), color);
- L375 C55: new Vector3 :: debug.AddLine(new Vector3(-extent, y, z), new Vector3(extent, y, z), color);
- L398 C68: new() :: private static JsonSerializerSettings DefaultJsonSettings() => new()
- L406 C23: new StringEnumConverter :: Converters = [new StringEnumConverter()]
- L418 C80: new EditorUnitTests.Settings :: File.WriteAllText(filePath, JsonConvert.SerializeObject(settings = new EditorUnitTests.Settings(), Formatting.Indented));
- L424 C96: new EditorUnitTests.Settings :: settings = JsonConvert.DeserializeObject<EditorUnitTests.Settings>(content) ?? new EditorUnitTests.Settings();
- L429 C28: new EditorUnitTests.Settings :: settings = new EditorUnitTests.Settings();
- L476 C24: new VRGameStartupSettings :: var settings = new VRGameStartupSettings<EVRActionCategory, EVRGameAction>()
- L481 C17: new() :: new()
- L492 C35: new UserSettings :: DefaultUserSettings = new UserSettings()
- L870 C23: new InvalidOperationException :: throw new InvalidOperationException($"Failed to load XRProject from '{projectFilePath}'.");
- L877 C19: new ArgumentException :: throw new ArgumentException($"Unknown build configuration '{configurationArg}'.");
- L884 C19: new ArgumentException :: throw new ArgumentException($"Unknown build platform '{platformArg}'.");
- L893 C19: new InvalidOperationException :: throw new InvalidOperationException("Managed project compile failed. See log for details.");
- L1051 C23: new InvalidOperationException :: throw new InvalidOperationException($"Failed to load XRProject from '{projectFilePath}'.");
- L1056 C58: new BuildSettings :: BuildSettings settings = Engine.BuildSettings ?? new BuildSettings();
- L1065 C23: new ArgumentException :: throw new ArgumentException($"Unknown build configuration '{configurationArg}'.");
- L1073 C23: new ArgumentException :: throw new ArgumentException($"Unknown build platform '{platformArg}'.");
- L1193 C73: new Version :: return Version.TryParse(numeric, out var parsed) ? parsed : new Version(0, 0);
- L1206 C19: new ArgumentException :: throw new ArgumentException("Project path is required.");
- L1213 C19: new DirectoryNotFoundException :: throw new DirectoryNotFoundException($"Project path does not exist: {normalizedPath}");
- L1220 C19: new FileNotFoundException :: throw new FileNotFoundException($"No .{XRProject.ProjectExtension} file found in '{normalizedPath}'.");
- L1222 C15: new InvalidOperationException :: throw new InvalidOperationException($"Multiple .{XRProject.ProjectExtension} files found in '{normalizedPath}'. Provide an explicit project file path.");
- L1262 C47: new GameStartupSettings :: var fallback = Engine.GameSettings ?? new GameStartupSettings();
- L1394 C19: new DirectoryNotFoundException :: throw new DirectoryNotFoundException($"Source directory not found: {sourcePath}");
- L1428 C38: new ConsolePackProgress :: using var packProgress = new ConsolePackProgress();
- L1432 C22: new FileInfo :: var fi = new FileInfo(outputPath);
- L1473 C15: new DirectoryNotFoundException :: throw new DirectoryNotFoundException("Unable to locate repository root containing XRENGINE.sln.");


## XREngine.Editor/ProjectBuilder.cs
- L52 C49: new() :: private static readonly object _buildLock = new();
- L65 C23: new InvalidOperationException :: throw new InvalidOperationException("A project build is already running.");
- L68 C34: new JobProgress :: progressCallback?.Invoke(new JobProgress(0f, "Starting build..."));
- L78 C38: new JobProgress :: progressCallback?.Invoke(new JobProgress(1f, "Nothing to build."));
- L88 C38: new JobProgress :: progressCallback?.Invoke(new JobProgress(progress, step.Description));
- L91 C34: new JobProgress :: progressCallback?.Invoke(new JobProgress(1f, "Build completed"));
- L140 C22: new JobProgress :: yield return new JobProgress(0f, "Starting build...");
- L150 C26: new JobProgress :: yield return new JobProgress(1f, "Nothing to build.");
- L160 C26: new JobProgress :: yield return new JobProgress(progress, step.Description);
- L163 C22: new JobProgress :: yield return new JobProgress(1f, "Build completed");
- L167 C43: new InvalidOperationException :: => Engine.CurrentProject ?? throw new InvalidOperationException("No project is currently loaded.");
- L171 C47: new BuildSettings :: var current = Engine.BuildSettings ?? new BuildSettings();
- L173 C78: new BuildSettings :: return AssetManager.Deserializer.Deserialize<BuildSettings>(yaml) ?? new BuildSettings();
- L191 C16: new BuildContext :: return new BuildContext(
- L212 C19: new InvalidOperationException :: throw new InvalidOperationException("PublishLauncherAsNativeAot requires BuildLauncherExecutable to be enabled.");
- L220 C23: new BuildStep :: steps.Add(new BuildStep("Saving project settings", Engine.SaveProjectSettings));
- L223 C19: new BuildStep :: steps.Add(new BuildStep("Preparing output directories", () => PrepareOutputDirectories(context, settings.CleanOutputDirectory)));
- L227 C23: new BuildStep :: steps.Add(new BuildStep("Cooking content", () => CookContent(context)));
- L233 C23: new BuildStep :: steps.Add(new BuildStep("Generating config archive", () => GenerateConfigArchive(context)));
- L238 C23: new BuildStep :: steps.Add(new BuildStep("Compiling managed assemblies", () => BuildManagedAssemblies(configuration, platform)));
- L243 C23: new BuildStep :: steps.Add(new BuildStep("Copying game assemblies", () => CopyGameAssemblies(context, configuration, platform, settings.IncludePdbFiles)));
- L248 C23: new BuildStep :: steps.Add(new BuildStep("Copying engine binaries", () => CopyEngineBinaries(context, settings.IncludePdbFiles)));
- L253 C23: new BuildStep :: steps.Add(new BuildStep("Building launcher executable", () => BuildLauncherExecutable(context, settings, configuration, platform)));
- L272 C19: new IOException :: throw new IOException($"Failed to clean build output at '{context.BuildRoot}'.", ex);
- L288 C19: new DirectoryNotFoundException :: throw new DirectoryNotFoundException($"Assets directory not found at '{context.AssetsDirectory}'.");
- L311 C49: new GameStartupSettings :: WriteCookedAsset(Engine.GameSettings ?? new GameStartupSettings(), Path.Combine(staging, StartupAssetName));
- L316 C49: new UserSettings :: WriteCookedAsset(Engine.UserSettings ?? new UserSettings(), Path.Combine(staging, XRProject.UserSettingsFileName));
- L342 C19: new InvalidOperationException :: throw new InvalidOperationException("Asset system unavailable; cannot build assemblies.");
- L347 C19: new InvalidOperationException :: throw new InvalidOperationException("Managed build failed. See log for details.");
- L355 C19: new DirectoryNotFoundException :: throw new DirectoryNotFoundException($"Managed build output not found for {configuration}|{platform}.");
- L414 C19: new FileNotFoundException :: throw new FileNotFoundException("Config archive not found. Enable config generation before building the launcher.", context.ConfigArchivePath);
- L472 C29: new HashSet :: existingPaths = new HashSet<string>(AssetPacker.GetAssetPaths(context.ConfigArchivePath), StringComparer.Ordinal);
- L633 C28: new FileInfo :: var fileInfo = new FileInfo(filePath);
- L634 C38: new AssetTimestampEntry :: snapshot[relativePath] = new AssetTimestampEntry(relativePath, fileInfo.LastWriteTimeUtc.Ticks, fileInfo.Length);
- L710 C34: new CookProgress :: progress?.Invoke(new CookProgress(i + 1, totalFiles, relative, cookedAsBinaryAsset));
- L715 C30: new CookProgress :: progress?.Invoke(new CookProgress(i + 1, totalFiles, relative, cookedAsBinaryAsset));
- L724 C19: new ArgumentException :: throw new ArgumentException("Assets directory must be provided.", nameof(assetsDirectory));
- L726 C19: new DirectoryNotFoundException :: throw new DirectoryNotFoundException($"Assets directory not found at '{assetsDirectory}'.");
- L729 C19: new ArgumentException :: throw new ArgumentException("Intermediate directory must be provided.", nameof(intermediateDirectory));
- L735 C23: new XRProject :: var project = new XRProject("UnitTestProject")
- L741 C23: new BuildContext :: var context = new BuildContext(
- L743 C13: new BuildSettings :: new BuildSettings(),
- L762 C19: new InvalidOperationException :: throw new InvalidOperationException($"Asset '{sourcePath}' is missing an __assetType hint and cannot be cooked.");
- L765 C22: new InvalidOperationException :: ?? throw new InvalidOperationException($"Unable to resolve asset type '{typeHint}' referenced by '{sourcePath}'.");
- L768 C22: new InvalidOperationException :: ?? throw new InvalidOperationException($"Failed to deserialize asset '{sourcePath}' as '{assetType.FullName}'.");
- L786 C16: new CookedAssetBlob :: return new CookedAssetBlob(typeName, CookedAssetFormat.BinaryV1, payload);
- L792 C28: new StringReader :: using var reader = new StringReader(yaml);
- L818 C28: new StringReader :: using var reader = new StringReader(yaml);
- L863 C19: new InvalidOperationException :: throw new InvalidOperationException($"Project {friendlyName} directory is not configured.");


## XREngine.Editor/TransformEditors/UIBoundableTransformEditor.cs
- L26 C9: new UITransformEditor :: new UITransformEditor().DrawInspector(ui, visited);
- L58 C21: new Vector2 :: pivot = new Vector2(Math.Clamp(pivot.X, 0f, 1f), Math.Clamp(pivot.Y, 0f, 1f));
- L81 C25: new Vector2 :: minAnchor = new Vector2(Math.Clamp(minAnchor.X, 0f, 1f), Math.Clamp(minAnchor.Y, 0f, 1f));
- L96 C25: new Vector2 :: maxAnchor = new Vector2(Math.Clamp(maxAnchor.X, 0f, 1f), Math.Clamp(maxAnchor.Y, 0f, 1f));
- L184 C16: new ImGuiDisabledScope :: using (new ImGuiDisabledScope(!enabled))


## XREngine.Editor/UI/ConsolePanel.cs
- L7 C55: new TraceListener :: public TraceListener TraceListener { get; } = new TraceListener();


## XREngine.Editor/UI/EditorDragDropUtility.cs
- L105 C19: new ArgumentNullException :: throw new ArgumentNullException(nameof(source));
- L113 C26: new DragSession :: _activeSession = new DragSession(source, payload, startCanvasPosition);
- L125 C19: new ArgumentNullException :: throw new ArgumentNullException(nameof(transform));
- L127 C19: new ArgumentNullException :: throw new ArgumentNullException(nameof(onDrop));
- L129 C28: new DropTargetRegistration :: var registration = new DropTargetRegistration(transform, onDrop, canAccept, hoverChanged);
- L131 C16: new DropTargetHandle :: return new DropTargetHandle(registration);
- L230 C38: new ArgumentNullException :: TypeId = typeId ?? throw new ArgumentNullException(nameof(typeId));
- L231 C34: new ArgumentNullException :: Data = data ?? throw new ArgumentNullException(nameof(data));
- L253 C29: new WeakReference :: _transformRef = new WeakReference<UIBoundableTransform>(transform);


## XREngine.Editor/UI/ImGuiFileBrowser.cs
- L61 C49: new byte :: public byte[] FileNameBuffer { get; } = new byte[256];
- L62 C45: new byte :: public byte[] PathBuffer { get; } = new byte[512];
- L68 C50: new byte :: public byte[] NewFolderBuffer { get; } = new byte[256];
- L69 C53: new() :: public Stack<string> BackHistory { get; } = new();
- L70 C56: new() :: public Stack<string> ForwardHistory { get; } = new();
- L95 C78: new() :: private static readonly Dictionary<string, DialogState> _activeDialogs = new();
- L96 C49: new() :: private static readonly object _stateLock = new();
- L114 C21: new DialogState :: var state = new DialogState
- L206 C28: new GameWindowStartupSettings :: var settings = new GameWindowStartupSettings
- L258 C21: new XRScene :: var scene = new XRScene($"FileBrowserScene_{state.Id}");
- L259 C29: new SceneNode :: scene.RootNodes.Add(new SceneNode("FileBrowserRoot"));
- L260 C16: new XRWorld :: return new XRWorld($"FileBrowserWorld_{state.Id}", scene);
- L343 C57: new Vector2 :: ImGui.PushStyleVar(ImGuiStyleVar.WindowPadding, new Vector2(10f, 10f));
- L375 C47: new Vector4 :: ImGui.PushStyleColor(ImGuiCol.Button, new Vector4(0.6f, 0.2f, 0.2f, 1f));
- L376 C54: new Vector4 :: ImGui.PushStyleColor(ImGuiCol.ButtonHovered, new Vector4(0.8f, 0.3f, 0.3f, 1f));
- L377 C53: new Vector4 :: ImGui.PushStyleColor(ImGuiCol.ButtonActive, new Vector4(0.9f, 0.1f, 0.1f, 1f));
- L378 C31: new Vector2 :: if (ImGui.Button("X", new Vector2(closeButtonWidth, 0)))
- L395 C26: new Vector2 :: var dialogSize = new Vector2(800, 550);
- L423 C41: new Vector2 :: if (ImGui.BeginChild("Sidebar", new Vector2(sidebarWidth, contentHeight), ImGuiChildFlags.Border))
- L431 C42: new Vector2 :: if (ImGui.BeginChild("FileList", new Vector2(-1, contentHeight), ImGuiChildFlags.Border))
- L439 C31: new Vector4 :: ImGui.TextColored(new Vector4(1f, 0.3f, 0.3f, 1f), state.ErrorMessage);
- L461 C37: new Vector2 :: if (ImGui.Button("<##Back", new Vector2(buttonSize, 0)))
- L472 C40: new Vector2 :: if (ImGui.Button(">##Forward", new Vector2(buttonSize, 0)))
- L483 C35: new Vector2 :: if (ImGui.Button("^##Up", new Vector2(buttonSize, 0)))
- L506 C37: new Vector2 :: if (ImGui.Button("Refresh", new Vector2(refreshWidth, 0)))
- L513 C40: new Vector2 :: if (ImGui.Button("New Folder", new Vector2(newFolderWidth, 0)))
- L532 C40: new Vector2 :: if (ImGui.Button("Create", new Vector2(80f, 0)))
- L537 C51: new Vector2 :: if (ImGui.Button("Cancel##NewFolder", new Vector2(80f, 0)))
- L671 C35: new Vector2 :: if (ImGui.Button(confirm, new Vector2(buttonWidth, 0)))
- L678 C36: new Vector2 :: if (ImGui.Button("Cancel", new Vector2(buttonWidth, 0)))
- L742 C40: new[] :: var paths = path is not null ? new[] { path } : null;
- L804 C22: new DialogResult :: var result = new DialogResult
- L928 C27: new Vector4 :: ImGui.TextColored(new Vector4(0.7f, 0.7f, 0.7f, 1f), "Quick Access");
- L936 C27: new Vector4 :: ImGui.TextColored(new Vector4(0.7f, 0.7f, 0.7f, 1f), "Drives");
- L1036 C27: new DirectoryInfo :: var dirInfo = new DirectoryInfo(state.CurrentDirectory);
- L1042 C39: new FileSystemEntry :: state.Entries.Add(new FileSystemEntry
- L1062 C43: new FileSystemEntry :: state.Entries.Add(new FileSystemEntry
- L1143 C22: new List :: var result = new List<(string, string[])>();


## XREngine.Editor/UI/NativeUIElements.cs
- L39 C46: new Vector4 :: buttonTransform.Margins = margins ?? new Vector4(4.0f, 2.0f, 4.0f, 2.0f);
- L47 C44: new Vector4 :: label.BoundableTransform.Margins = new Vector4(6.0f, 0.0f, 6.0f, 0.0f);
- L86 C62: new Vector4 :: textComp.BoundableTransform.Margins = textMargins ?? new Vector4(5.0f, 2.0f, 5.0f, 2.0f);
- L110 C25: new Vector2 :: tfm.MinAnchor = new Vector2(0.0f, 0.0f);
- L111 C25: new Vector2 :: tfm.MaxAnchor = new Vector2(0.0f, 0.0f);
- L182 C13: new ShaderFloat :: new ShaderFloat(2.0f, OutlineWidthUniformName),
- L183 C13: new ShaderVector4 :: new ShaderVector4(ColorF4.Transparent, OutlineColorUniformName),
- L184 C13: new ShaderVector4 :: new ShaderVector4(ColorF4.Transparent, FillColorUniformName),
- L186 C19: new XRMaterial :: var mat = new XRMaterial(parameters, frag);


## XREngine.Editor/UI/Panels/EditorPanel.cs
- L35 C13: new ShaderVector4 :: new ShaderVector4(new ColorF4(166/255.0f, 179/255.0f, 178/255.0f, 1.0f), "MatColor"),
- L35 C31: new ColorF4 :: new ShaderVector4(new ColorF4(166/255.0f, 179/255.0f, 178/255.0f, 1.0f), "MatColor"),
- L36 C13: new ShaderFloat :: new ShaderFloat(10.0f, "BlurStrength"),
- L37 C13: new ShaderInt :: new ShaderInt(15, "SampleCount"),
- L40 C21: new XRMaterial :: var bgMat = new XRMaterial(parameters, [grabTex], bgShader)
- L48 C68: new() :: private static RenderingParameters RenderParameters { get; } = new()
- L51 C21: new() :: DepthTest = new()


## XREngine.Editor/UI/Panels/HierarchyPanel.cs
- L51 C88: new() :: private readonly Dictionary<UIInteractableComponent, Vector2> _pendingDragStarts = new();
- L59 C54: new() :: private readonly HashSet<Guid> _collapsedNodes = new();
- L65 C57: new() :: private readonly HashSet<Guid> _collapsedSections = new();
- L173 C13: new ContextMenuItem :: new ContextMenuItem("Rename", () => BeginRename(_contextMenuTargetNode)),
- L174 C13: new ContextMenuItem :: new ContextMenuItem("Add Child", () => CreateChildSceneNode(_contextMenuTargetNode)),
- L175 C13: new ContextMenuItem :: new ContextMenuItem("Focus Camera", () => TryFocusCameraOnNode(_contextMenuTargetNode)),
- L177 C13: new ContextMenuItem :: new ContextMenuItem("Delete", () => DeleteNode(_contextMenuTargetNode)));
- L251 C27: new Vector4 :: listTfm.Padding = new Vector4(0.0f);
- L259 C39: new Vector2 :: scrollbarTrackTfm.MinAnchor = new Vector2(1.0f, 0.0f);
- L260 C39: new Vector2 :: scrollbarTrackTfm.MaxAnchor = new Vector2(1.0f, 1.0f);
- L262 C37: new Vector4 :: scrollbarTrackTfm.Margins = new Vector4(0.0f, ScrollbarPadding, ScrollbarPadding, ScrollbarPadding);
- L263 C67: new ColorF4 :: var trackMat = XRMaterial.CreateUnlitColorMaterialForward(new ColorF4(0.0f, 0.0f, 0.0f, 0.15f));
- L271 C39: new Vector2 :: scrollbarThumbTfm.MinAnchor = new Vector2(0.0f, 1.0f);
- L272 C39: new Vector2 :: scrollbarThumbTfm.MaxAnchor = new Vector2(1.0f, 1.0f);
- L274 C45: new Vector2 :: scrollbarThumbTfm.NormalizedPivot = new Vector2(0.0f, 1.0f);
- L276 C67: new ColorF4 :: var thumbMat = XRMaterial.CreateUnlitColorMaterialForward(new ColorF4(1.0f, 1.0f, 1.0f, 0.35f));
- L335 C31: new Vector2 :: toggleTfm.MaxAnchor = new Vector2(1.0f, 1.0f);
- L336 C29: new Vector4 :: toggleTfm.Margins = new Vector4(0.0f);
- L340 C33: new Vector2 :: checkboxTfm.MinAnchor = new Vector2(0.0f, 0.5f);
- L341 C33: new Vector2 :: checkboxTfm.MaxAnchor = new Vector2(0.0f, 0.5f);
- L344 C35: new Vector2 :: checkboxTfm.Translation = new Vector2(8.0f, 0.0f);
- L345 C76: new ColorF4 :: var checkboxBorderMat = XRMaterial.CreateUnlitColorMaterialForward(new ColorF4(0.85f, 0.85f, 0.85f, 1.0f));
- L354 C35: new Vector4 :: checkboxFillTfm.Margins = new Vector4(3.0f);
- L365 C34: new Vector4 :: toggleLabelTfm.Margins = new Vector4(28.0f, Margin, 8.0f, Margin);
- L394 C28: new Vector2 :: rowTfm.MaxAnchor = new Vector2(1.0f, 1.0f);
- L395 C26: new Vector4 :: rowTfm.Margins = new Vector4(0.0f);
- L407 C28: new Vector4 :: labelTfm.Margins = new Vector4(8.0f, Margin, 8.0f, Margin);
- L428 C32: new Vector2 :: sectionTfm.MaxAnchor = new Vector2(1.0f, 1.0f);
- L429 C30: new Vector4 :: sectionTfm.Margins = new Vector4(0.0f);
- L434 C34: new Vector2 :: headerBtnTfm.MinAnchor = new Vector2(0.0f, 0.0f);
- L435 C34: new Vector2 :: headerBtnTfm.MaxAnchor = new Vector2(0.75f, 1.0f);
- L436 C32: new Vector4 :: headerBtnTfm.Margins = new Vector4(0.0f);
- L442 C33: new Vector4 :: headerTextTfm.Margins = new Vector4(6.0f, 2.0f, 6.0f, 2.0f);
- L467 C33: new Vector2 :: controlsTfm.MinAnchor = new Vector2(0.75f, 0.0f);
- L468 C33: new Vector2 :: controlsTfm.MaxAnchor = new Vector2(1.0f, 1.0f);
- L469 C31: new Vector4 :: controlsTfm.Margins = new Vector4(0.0f);
- L474 C28: new Vector2 :: visTfm.MinAnchor = new Vector2(0.0f, 0.0f);
- L475 C28: new Vector2 :: visTfm.MaxAnchor = new Vector2(0.5f, 1.0f);
- L476 C26: new Vector4 :: visTfm.Margins = new Vector4(2.0f);
- L483 C31: new Vector4 :: visGlyphTfm.Margins = new Vector4(0.0f);
- L504 C31: new Vector2 :: unloadTfm.MinAnchor = new Vector2(0.5f, 0.0f);
- L505 C31: new Vector2 :: unloadTfm.MaxAnchor = new Vector2(1.0f, 1.0f);
- L506 C29: new Vector4 :: unloadTfm.Margins = new Vector4(2.0f);
- L513 C34: new Vector4 :: unloadGlyphTfm.Margins = new Vector4(0.0f);
- L538 C32: new Vector2 :: sectionTfm.MaxAnchor = new Vector2(1.0f, 1.0f);
- L539 C30: new Vector4 :: sectionTfm.Margins = new Vector4(0.0f);
- L547 C36: new Vector4 :: headerBtnTfm.Margins = new Vector4(0.0f);
- L553 C37: new Vector4 :: headerTextTfm.Margins = new Vector4(6.0f, 2.0f, 6.0f, 2.0f);
- L570 C37: new Vector4 :: headerTextTfm.Margins = new Vector4(6.0f, 2.0f, 6.0f, 2.0f);
- L584 C29: new Vector2 :: infoTfm.MaxAnchor = new Vector2(1.0f, 1.0f);
- L585 C27: new Vector4 :: infoTfm.Margins = new Vector4(0.0f);
- L589 C27: new Vector4 :: textTfm.Margins = new Vector4(16.0f, Margin, 10.0f, Margin);
- L601 C24: new HashSet :: var assigned = new HashSet<SceneNode>();
- L625 C26: new List :: var unassigned = new List<SceneNode>();
- L765 C48: new Vector2 :: _scrollbarThumbTransform.Translation = new Vector2(0.0f, -travel * ratio);
- L792 C35: new Vector2 :: buttonTfm.MaxAnchor = new Vector2(1.0f, 1.0f);
- L793 C33: new Vector4 :: buttonTfm.Margins = new Vector4(0.0f);
- L804 C38: new Vector2 :: arrowTfm.MinAnchor = new Vector2(0.0f, 0.0f);
- L805 C38: new Vector2 :: arrowTfm.MaxAnchor = new Vector2(0.0f, 1.0f);
- L807 C40: new Vector2 :: arrowTfm.Translation = new Vector2(depthOffset, 0.0f);
- L814 C41: new Vector4 :: arrowGlyphTfm.Margins = new Vector4(0.0f);
- L830 C61: new Vector4 :: background.Material?.SetVector4("MatColor", new Vector4(0.15f, 0.35f, 0.6f, 0.85f));
- L843 C37: new Vector4 :: renameTfm.Margins = new Vector4(10.0f, Margin, 10.0f, Margin);
- L844 C41: new Vector2 :: renameTfm.Translation = new Vector2(depthOffset + ArrowWidth, 0.0f);
- L846 C39: new Vector2 :: renameTfm.MaxAnchor = new Vector2(0.0f, 1.0f);
- L861 C35: new Vector4 :: textTfm.Margins = new Vector4(10.0f, Margin, 10.0f, Margin);
- L866 C39: new Vector2 :: textTfm.Translation = new Vector2(depthOffset + ArrowWidth, 0.0f);
- L868 C37: new Vector2 :: textTfm.MaxAnchor = new Vector2(0.0f, 1.0f);
- L876 C35: new Vector2 :: toggleTfm.MinAnchor = new Vector2(1.0f, 0.0f);
- L877 C35: new Vector2 :: toggleTfm.MaxAnchor = new Vector2(1.0f, 1.0f);
- L879 C33: new Vector4 :: toggleTfm.Margins = new Vector4(2.0f);
- L886 C38: new Vector4 :: toggleGlyphTfm.Margins = new Vector4(0.0f);
- L891 C69: new ColorF4 :: toggleGlyph.Color = node.IsActiveSelf ? ColorF4.White : new ColorF4(0.5f, 0.5f, 0.5f, 1.0f);
- L901 C99: new ColorF4 :: capturedToggleGlyph.Color = capturedToggleNode.IsActiveSelf ? ColorF4.White : new ColorF4(0.5f, 0.5f, 0.5f, 1.0f);
- L978 C31: new Vector2 :: noticeTfm.MaxAnchor = new Vector2(1.0f, 1.0f);
- L979 C29: new Vector4 :: noticeTfm.Margins = new Vector4(0.0f);
- L983 C27: new Vector4 :: textTfm.Margins = new Vector4(10.0f, Margin, 10.0f, Margin);
- L1005 C73: new Vector2 :: Vector2 canvasPoint = comp.BoundableTransform.LocalToCanvas(new Vector2(x, y));
- L1108 C29: new ColorF4 :: preview.Color = new ColorF4(1.0f, 1.0f, 1.0f, 0.45f);
- L1119 C25: new ColorF4 :: preview.Color = new ColorF4(1.0f, 1.0f, 1.0f, 0.75f);
- L1158 C25: new SceneNode :: var child = new SceneNode(parent);


## XREngine.Editor/UI/Panels/Inspector/Editors/DataTransformers/InspectorPropertyEditors.LayerMaskTransformer.cs
- L43 C27: new LayerMask :: var newMask = new LayerMask(Value ?? 0);


## XREngine.Editor/UI/Panels/Inspector/Editors/DataTransformers/InspectorPropertyEditors.Vector2Transformer.cs
- L38 C29: new Vector2 :: var newVector = new Vector2(


## XREngine.Editor/UI/Panels/Inspector/Editors/DataTransformers/InspectorPropertyEditors.Vector3Transformer.cs
- L45 C29: new Vector3 :: var newVector = new Vector3(


## XREngine.Editor/UI/Panels/Inspector/Editors/DataTransformers/InspectorPropertyEditors.Vector4Transformer.cs
- L52 C29: new Vector4 :: var newVector = new Vector4(


## XREngine.Editor/UI/Panels/Inspector/Editors/InspectorPropertyEditors.CollectionTypes.cs
- L25 C97: new() :: private static readonly Dictionary<Type, CollectionAccessor?> CollectionAccessorCache = new();
- L40 C31: new CollectionEditorContext :: var context = new CollectionEditorContext(prop, objects, propType, container);
- L182 C52: new Vector4 :: label.BoundableTransform.Margins = new Vector4(4.0f, 2.0f, 4.0f, 2.0f);
- L198 C41: new() :: List<object> bindings = new();
- L418 C52: new Vector4 :: label.BoundableTransform.Margins = new Vector4(4.0f, 2.0f, 4.0f, 2.0f);
- L434 C41: new() :: List<object> bindings = new();
- L578 C52: new Vector4 :: label.BoundableTransform.Margins = new Vector4(4.0f, 2.0f, 4.0f, 2.0f);
- L594 C41: new() :: List<object> bindings = new();
- L621 C65: new[] :: var addLast = listType.GetMethod("AddLast", new[] { elementType });
- L627 C52: new[] :: addLast.Invoke(collection, new[] { ConvertValue(newValue, elementType) });
- L654 C69: new[] :: var removeMethod = listType.GetMethod("Remove", new[] { node.GetType() })
- L655 C57: new[] :: ?? listType.GetMethod("Remove", new[] { elementType });
- L660 C61: new[] :: removeMethod.Invoke(collection, new[] { node });
- L662 C61: new[] :: removeMethod.Invoke(collection, new[] { node.GetType().GetProperty("Value")?.GetValue(node) });
- L743 C52: new Vector4 :: label.BoundableTransform.Margins = new Vector4(4.0f, 2.0f, 4.0f, 2.0f);
- L759 C115: new[] :: BuildValueEditor(valueNode, elementType, bindingProperty, proxy is null ? Array.Empty<object>() : new[] { proxy });
- L822 C46: new[] :: _add!.Invoke(collection, new[] { ConvertValue(entry, _addParameter ?? fallbackType) });
- L833 C24: new CollectionAccessor :: return new CollectionAccessor(clear, add);
- L891 C35: new() :: List<object> owners = new();
- L903 C36: new() :: List<object?> buffer = new();
- L1028 C26: new Vector4 :: margins: new Vector4(2.0f),


## XREngine.Editor/UI/Panels/Inspector/Editors/InspectorPropertyEditors.cs
- L70 C13: new ShaderFloat :: new ShaderFloat(2.0f, OutlineWidthUniformName),
- L71 C13: new ShaderVector4 :: new ShaderVector4(ColorF4.Transparent, OutlineColorUniformName),
- L72 C13: new ShaderVector4 :: new ShaderVector4(ColorF4.Transparent, FillColorUniformName),
- L74 C19: new XRMaterial :: var mat = new XRMaterial(parameters, frag);


## XREngine.Editor/UI/Panels/Inspector/Editors/InspectorPropertyEditors.Custom.cs
- L35 C27: new HashSet :: var visited = new HashSet<XRAsset>(ReferenceEqualityComparer.Instance);
- L63 C27: new HashSet :: var visited = new HashSet<OpenGLRenderer.GLObjectBase>(ReferenceEqualityComparer.Instance);
- L100 C114: new List :: var embedded = asset.EmbeddedAssets?.Where(x => x is not null && !ReferenceEquals(x, asset)).ToList() ?? new List<XRAsset>();
- L113 C32: new Vector4 :: embeddedList.Padding = new Vector4(18.0f, 0.0f, 4.0f, 2.0f);
- L116 C86: new Vector4 :: AddInfoLabel(embeddedListNode, $"• {GetAssetDescriptor(embeddedAsset)}", new Vector4(2.0f, 0.0f, 2.0f, 0.0f));
- L167 C39: new Vector4 :: attachmentsList.Padding = new Vector4(18.0f, 0.0f, 4.0f, 2.0f);
- L170 C92: new Vector4 :: AddInfoLabel(attachmentsNode, $"• {DescribeAttachmentTarget(attachment)}", new Vector4(2.0f, 0.0f, 2.0f, 0.0f));
- L195 C36: new Vector4 :: previewTransform.Margins = new Vector4(6.0f, 4.0f, 6.0f, 8.0f);
- L340 C26: new() :: List<T> values = new();
- L384 C24: new Vector4 :: list.Padding = new Vector4(0.0f);
- L396 C30: new Vector4 :: cardLayout.Padding = new Vector4(6.0f, 4.0f, 6.0f, 4.0f);
- L397 C30: new Vector4 :: cardLayout.Margins = new Vector4(0.0f, 4.0f, 0.0f, 4.0f);
- L403 C50: new Vector4 :: var header = AddInfoLabel(parent, title, new Vector4(4.0f, 4.0f, 4.0f, 2.0f), EditorUI.Styles.PropertyNameTextColor);
- L416 C55: new Vector4 :: label.BoundableTransform.Margins = margins ?? new Vector4(6.0f, 2.0f, 6.0f, 2.0f);


## XREngine.Editor/UI/Panels/Inspector/Editors/InspectorPropertyEditors.DataTransformerBase.cs
- L47 C98: new InvalidOperationException :: => GetType().GetProperty(name, BindingFlags.Public | BindingFlags.Instance) ?? throw new InvalidOperationException($"Property '{name}' not found.");


## XREngine.Editor/UI/Panels/Inspector/InspectorPanel.cs
- L108 C27: new Vector4 :: listTfm.Padding = new Vector4(0.0f);
- L168 C27: new Vector4 :: nameTfm.Margins = new Vector4(leftMargin, verticalSpacing, rightMargin, verticalSpacing);


## XREngine.Editor/UI/Toolbar/UIToolbarComponent.cs
- L83 C27: new Vector4 :: listTfm.Padding = new Vector4(0.0f);
- L132 C31: new Vector2 :: buttonTfm.MaxAnchor = new Vector2(0.0f, 1.0f);
- L133 C29: new Vector4 :: buttonTfm.Margins = new Vector4(Margin);
- L137 C27: new Vector4 :: textTfm.Margins = new Vector4(10.0f, Margin, 10.0f, Margin);
- L143 C113: new ToolbarButton :: UIListTransform submenuList = CreateMenu(buttonNode, false, null, null, [.. tbd.Options.Select(x => new ToolbarButton(x))], true, SubmenuItemHeight, toolbar);
- L150 C19: new Vector2 :: ? new Vector2(Margin, Margin)
- L151 C19: new Vector2 :: : new Vector2(-Margin, -Margin);
- L153 C43: new Vector2 :: submenuList.NormalizedPivot = new Vector2(0.0f, 1.0f);
- L157 C41: new Vector2 :: submenuList.MaxAnchor = new Vector2(1.0f, 1.0f);
- L158 C41: new Vector2 :: submenuList.MinAnchor = new Vector2(1.0f, 1.0f);
- L163 C41: new Vector2 :: submenuList.MaxAnchor = new Vector2(0.0f, 0.0f);
- L164 C41: new Vector2 :: submenuList.MinAnchor = new Vector2(0.0f, 0.0f);
- L174 C32: new Vector4 :: separatorTfm.Padding = new Vector4(0.0f);
- L193 C31: new Vector2 :: buttonTfm.MaxAnchor = new Vector2(0.0f, 1.0f);
- L194 C29: new Vector4 :: buttonTfm.Margins = new Vector4(Margin);
- L199 C27: new Vector4 :: textTfm.Margins = new Vector4(10.0f, Margin, 10.0f, Margin);
- L215 C19: new Vector2 :: ? new Vector2(Margin, Margin)
- L216 C19: new Vector2 :: : new Vector2(-Margin, -Margin);
- L219 C43: new Vector2 :: submenuList.NormalizedPivot = new Vector2(0.0f, 1.0f);
- L223 C41: new Vector2 :: submenuList.MaxAnchor = new Vector2(1.0f, 1.0f);
- L224 C41: new Vector2 :: submenuList.MinAnchor = new Vector2(1.0f, 1.0f);
- L229 C41: new Vector2 :: submenuList.MaxAnchor = new Vector2(0.0f, 0.0f);
- L230 C41: new Vector2 :: submenuList.MinAnchor = new Vector2(0.0f, 0.0f);


## XREngine.Editor/UI/Tools/ShaderAnalyzerTool.cs
- L36 C77: new Dictionary :: public IReadOnlyDictionary<string, int> CategoryTotals { get; init; } = new Dictionary<string, int>();
- L57 C21: new GlslCostEstimatorOptions :: options ??= new GlslCostEstimatorOptions();
- L59 C19: new ArgumentException :: throw new ArgumentException("GLSL source is empty.", nameof(glslSource));
- L61 C19: new ArgumentOutOfRangeException :: throw new ArgumentOutOfRangeException(nameof(options.InvocationsPerFrame));
- L64 C22: new Dictionary :: var counts = new Dictionary<string, int>(StringComparer.Ordinal);
- L70 C26: new List :: var operations = new List<OperationResult>(counts.Count);
- L71 C30: new Dictionary :: var categoryTotals = new Dictionary<string, int>(StringComparer.Ordinal);
- L87 C28: new OperationResult :: operations.Add(new OperationResult(info, kvp.Value, cycleCost, opCost));
- L93 C16: new ShaderCostReport :: return new ShaderCostReport
- L200 C23: new StringBuilder :: var builder = new StringBuilder(source.Length);
- L290 C23: new Dictionary :: var all = new Dictionary<string, OperationInfo>(functions.Count + keywords.Count + operators.Count, StringComparer.Ordinal);
- L305 C35: new HashSet :: SingleCharOperators = new HashSet<char>(operators.Keys
- L315 C20: new OperationCatalog :: return new OperationCatalog(functions, keywords, operators);
- L333 C20: new Regex :: return new Regex(pattern, RegexOptions.CultureInvariant | RegexOptions.Compiled);
- L338 C24: new Dictionary :: var dict = new Dictionary<string, OperationInfo>(StringComparer.Ordinal);
- L555 C30: new OperationInfo :: yield return new OperationInfo(name, name, category, cycles, kind);


## XREngine.Editor/UI/Tools/ShaderAnalyzerWindow.cs
- L15 C66: new ShaderAnalyzerWindow :: public static ShaderAnalyzerWindow Instance => _instance ??= new ShaderAnalyzerWindow();
- L17 C53: new() :: private readonly GlslCostEstimator _estimator = new();
- L61 C33: new Vector2 :: ImGui.SetNextWindowSize(new Vector2(1000, 750), ImGuiCond.FirstUseEver);
- L146 C41: new Vector2 :: ImGui.BeginChild("SourcePanel", new Vector2(400, availableHeight), ImGuiChildFlags.Border | ImGuiChildFlags.ResizeX);
- L216 C31: new Vector4 :: ImGui.TextColored(new Vector4(1, 0.3f, 0.3f, 1), _errorMessage);
- L251 C31: new Vector4 :: ImGui.TextColored(new Vector4(0.5f, 0.5f, 0.5f, 1),
- L306 C13: new Vector4 :: new Vector4(0.2f, 0.4f, 0.8f, 1));
- L312 C13: new Vector4 :: new Vector4(0.2f, 0.6f, 0.4f, 1));
- L318 C13: new Vector4 :: new Vector4(0.6f, 0.4f, 0.2f, 1));
- L324 C13: new Vector4 :: new Vector4(0.5f, 0.3f, 0.6f, 1));
- L335 C43: new Vector2 :: drawList.AddRectFilled(pos, pos + new Vector2(width, height),
- L336 C43: new Vector4 :: ImGui.ColorConvertFloat4ToU32(new Vector4(color.X * 0.3f, color.Y * 0.3f, color.Z * 0.3f, 0.8f)), 4);
- L337 C37: new Vector2 :: drawList.AddRect(pos, pos + new Vector2(width, height),
- L341 C40: new Vector2 :: ImGui.SetCursorScreenPos(pos + new Vector2(8, 4));
- L342 C27: new Vector4 :: ImGui.TextColored(new Vector4(0.7f, 0.7f, 0.7f, 1), label);
- L344 C40: new Vector2 :: ImGui.SetCursorScreenPos(pos + new Vector2(8, 22));
- L349 C40: new Vector2 :: ImGui.SetCursorScreenPos(pos + new Vector2(8, 42));
- L350 C27: new Vector4 :: ImGui.TextColored(new Vector4(0.5f, 0.5f, 0.5f, 1), unit);
- L352 C40: new Vector2 :: ImGui.SetCursorScreenPos(pos + new Vector2(width + 4, 0));
- L353 C21: new Vector2 :: ImGui.Dummy(new Vector2(0, height));
- L480 C47: new Vector2 :: drawList.AddRectFilled(pos, pos + new Vector2(chartWidth, barHeight),
- L481 C47: new Vector4 :: ImGui.ColorConvertFloat4ToU32(new Vector4(0.2f, 0.2f, 0.2f, 1)), 2);
- L485 C47: new Vector2 :: drawList.AddRectFilled(pos, pos + new Vector2(barWidth, barHeight),
- L490 C36: new Vector2 :: drawList.AddText(pos + new Vector2(barWidth + 5, (barHeight - 14) / 2),
- L491 C47: new Vector4 :: ImGui.ColorConvertFloat4ToU32(new Vector4(1, 1, 1, 1)), label);
- L493 C25: new Vector2 :: ImGui.Dummy(new Vector2(chartWidth + 80, barHeight + 4));
- L506 C43: new Vector2 :: drawList.AddRectFilled(pos, pos + new Vector2(width, height),
- L507 C43: new Vector4 :: ImGui.ColorConvertFloat4ToU32(new Vector4(0.2f, 0.2f, 0.2f, 1)), 2);
- L510 C43: new Vector2 :: drawList.AddRectFilled(pos, pos + new Vector2(width * fraction, height),
- L513 C21: new Vector2 :: ImGui.Dummy(new Vector2(width, height));
- L520 C35: new Vector4 :: "Texture Sampling" => new Vector4(0.9f, 0.3f, 0.3f, 1),
- L521 C32: new Vector4 :: "Texture Query" => new Vector4(0.8f, 0.4f, 0.4f, 1),
- L522 C35: new Vector4 :: "Image Operations" => new Vector4(0.9f, 0.5f, 0.3f, 1),
- L523 C32: new Vector4 :: "Image Atomics" => new Vector4(1.0f, 0.4f, 0.2f, 1),
- L524 C31: new Vector4 :: "Trigonometry" => new Vector4(0.3f, 0.7f, 0.9f, 1),
- L525 C30: new Vector4 :: "Exponential" => new Vector4(0.4f, 0.6f, 0.9f, 1),
- L526 C27: new Vector4 :: "Geometry" => new Vector4(0.3f, 0.9f, 0.5f, 1),
- L527 C25: new Vector4 :: "Matrix" => new Vector4(0.5f, 0.8f, 0.4f, 1),
- L528 C29: new Vector4 :: "Arithmetic" => new Vector4(0.7f, 0.7f, 0.3f, 1),
- L529 C29: new Vector4 :: "Comparison" => new Vector4(0.6f, 0.6f, 0.4f, 1),
- L530 C26: new Vector4 :: "Logical" => new Vector4(0.5f, 0.5f, 0.5f, 1),
- L531 C26: new Vector4 :: "Bitwise" => new Vector4(0.6f, 0.4f, 0.7f, 1),
- L532 C31: new Vector4 :: "Control Flow" => new Vector4(0.9f, 0.6f, 0.2f, 1),
- L533 C25: new Vector4 :: "Common" => new Vector4(0.5f, 0.7f, 0.7f, 1),
- L534 C30: new Vector4 :: "Derivatives" => new Vector4(0.7f, 0.5f, 0.8f, 1),
- L535 C27: new Vector4 :: "Barriers" => new Vector4(1.0f, 0.3f, 0.5f, 1),
- L536 C26: new Vector4 :: "Atomics" => new Vector4(0.9f, 0.2f, 0.4f, 1),
- L537 C24: new Vector4 :: "Noise" => new Vector4(0.4f, 0.8f, 0.8f, 1),
- L538 C18: new Vector4 :: _ => new Vector4(0.6f, 0.6f, 0.6f, 1)
- L553 C27: new GlslCostEstimatorOptions :: var options = new GlslCostEstimatorOptions
- L684 C22: new System.Text.StringBuilder :: var sb = new System.Text.StringBuilder();


## XREngine.Editor/UI/Tools/ShaderCrossCompilerWindow.cs
- L18 C71: new ShaderCrossCompilerWindow :: public static ShaderCrossCompilerWindow Instance => _instance ??= new ShaderCrossCompilerWindow();
- L65 C33: new Vector2 :: ImGui.SetNextWindowSize(new Vector2(1100, 750), ImGuiCond.FirstUseEver);
- L130 C31: new Vector4 :: ImGui.TextColored(new Vector4(1f, 0.4f, 0.4f, 1f), _errorMessage);
- L136 C41: new Vector2 :: ImGui.BeginChild("SourcePanel", new Vector2(480, availableHeight), ImGuiChildFlags.Border | ImGuiChildFlags.ResizeX);
- L218 C84: new Vector2 :: ImGui.InputTextMultiline("##ShaderSource", ref _shaderSource, 1024 * 1024, new Vector2(-1, -1));
- L234 C80: new Vector2 :: ImGui.InputTextMultiline("##HlslOutput", ref _hlslSource, 1024 * 1024, new Vector2(-1, -1), ImGuiInputTextFlags.ReadOnly);
- L239 C80: new Vector2 :: ImGui.InputTextMultiline("##GlslOutput", ref _glslOutput, 1024 * 1024, new Vector2(-1, -1), ImGuiInputTextFlags.ReadOnly);
- L421 C19: new InvalidOperationException :: throw new InvalidOperationException("SPIR-V bytecode length is not aligned.");
- L449 C23: new InvalidOperationException :: throw new InvalidOperationException("SPIRV-Cross produced empty output.");
- L477 C15: new InvalidOperationException :: throw new InvalidOperationException($"{message} {detail}".Trim());


## XREngine.Editor/UI/Tools/ShaderLockingTool.cs
- L136 C28: new UniformLockInfo :: var info = new UniformLockInfo
- L179 C35: new UniformLockInfo :: _uniforms[name] = new UniformLockInfo
- L213 C24: new int :: "ivec2" => new int[] { 0, 0 },
- L214 C24: new int :: "ivec3" => new int[] { 0, 0, 0 },
- L215 C24: new int :: "ivec4" => new int[] { 0, 0, 0, 0 },
- L231 C22: new StringBuilder :: var result = new StringBuilder(source);
- L243 C22: new StringBuilder :: result = new StringBuilder(Regex.Replace(result.ToString(), uniformPattern, constDeclaration));
- L601 C26: new StringBuilder :: var header = new StringBuilder();


## XREngine.Editor/UI/Tools/ShaderLockingWindow.cs
- L16 C65: new ShaderLockingWindow :: public static ShaderLockingWindow Instance => _instance ??= new ShaderLockingWindow();
- L18 C39: new() :: private ShaderLockingTool _tool = new();
- L49 C33: new Vector2 :: ImGui.SetNextWindowSize(new Vector2(900, 700), ImGuiCond.FirstUseEver);
- L138 C39: new Vector2 :: ImGui.BeginChild("LeftPanel", new Vector2(leftWidth, 0), ImGuiChildFlags.Border | ImGuiChildFlags.ResizeX);
- L159 C46: new Vector2 :: ImGui.BeginChild("PatternsList", new Vector2(0, 100), ImGuiChildFlags.Border);
- L231 C19: new Vector4 :: ? new Vector4(0.3f, 0.8f, 0.3f, 1.0f)  // Green for animated
- L232 C19: new Vector4 :: : new Vector4(0.8f, 0.5f, 0.2f, 1.0f); // Orange for locked
- L285 C31: new Vector4 :: ImGui.TextColored(new Vector4(1, 1, 0, 1), "No shader loaded. Use File > Load Shader or Load Material.");
- L318 C31: new Vector4 :: ImGui.TextColored(new Vector4(0.5f, 0.5f, 0.5f, 1), "No preview available.");
- L434 C26: new XRShader :: var shader = new XRShader(XRShader.ResolveType(Path.GetExtension(path)))
- L436 C26: new Core.Files.TextFile :: Source = new Core.Files.TextFile { Text = source, FilePath = path }


## XREngine.Editor/UI/UIEditorComponent.cs
- L89 C31: new UltralightGpuWebRendererBackend :: webComp.Backend = new UltralightGpuWebRendererBackend();
- L139 C23: new XRMaterial :: var mat = new XRMaterial(bgShader)
- L142 C33: new RenderingParameters :: RenderOptions = new RenderingParameters
- L145 C33: new DepthTest :: DepthTest = new DepthTest()


## XREngine.Editor/UI/UIProjectBrowserComponent.cs
- L106 C30: new FileInfo :: _fileCache.Add(path, new FileInfo(args.FullPath));
- L116 C39: new FileInfo :: _fileCache.Add(args.FullPath, new FileInfo(args.FullPath));


## XREngine.Editor/Undo.cs
- L45 C44: new() :: private static readonly object _sync = new();
- L57 C62: new() :: private static readonly Stack<ChangeScope> _scopeStack = new();
- L63 C60: new() :: private static readonly Stack<UndoAction> _undoStack = new();
- L69 C60: new() :: private static readonly Stack<UndoAction> _redoStack = new();
- L81 C91: new() :: private static readonly AsyncLocal<UserInteractionContext?> _userInteractionContext = new();
- L104 C87: new() :: private static readonly ConcurrentQueue<TransformBase> _pendingTransformRefresh = new();
- L231 C21: new ChangeScope :: var scope = new ChangeScope(string.IsNullOrWhiteSpace(description) ? "Change" : description.Trim());
- L268 C23: new UserInteractionContext :: context = new UserInteractionContext();
- L274 C16: new UserInteractionScope :: return new UserInteractionScope(context);
- L414 C27: new TrackedObject :: var context = new TrackedObject(instance);
- L565 C40: new ShortcutHandlers :: _shortcutHandlers[local] = new ShortcutHandlers(undoHandler, redoHandler);
- L656 C36: new SceneNodeContext :: var sceneContext = new SceneNodeContext(node);
- L744 C24: new PropertyChangeStep :: var step = new PropertyChangeStep(target, propertyName, previousValue, newValue);
- L745 C26: new UndoAction :: var action = new UndoAction(BuildDescription(step), [step], DateTime.UtcNow);
- L747 C58: new changes :: _redoStack.Clear(); // Clear redo stack when new changes are made
- L762 C23: new RecordingSuppressionScope :: using var _ = new RecordingSuppressionScope();
- L773 C23: new RecordingSuppressionScope :: using var _ = new RecordingSuppressionScope();
- L842 C31: new UndoAction :: committedAction = new UndoAction(scope.Description, steps, scope.TimestampUtc);
- L859 C20: new List :: var list = new List<UndoEntry>(entries.Length);
- L1030 C25: new HashSet :: var processed = new HashSet<TransformBase>(ReferenceEqualityComparer.Instance);
- L1409 C29: new PropertyChangeStep :: Changes.Add(new PropertyChangeStep(target, propertyName, previousValue, newValue));
- L1497 C20: new WeakReference :: => new(new WeakReference<XRBase>(Target), GetDisplayName(Target), Target.GetType(), PropertyName, OriginalValue, CurrentValue);


## XREngine.Editor/Undo/ImGuiUndoHelper.cs
- L17 C67: new() :: private static readonly Dictionary<uint, ScopeInfo> _scopes = new();
- L83 C31: new ScopeInfo :: _scopes[itemId] = new ScopeInfo(scope, interaction, frame);


## XREngine.Editor/Undo/TransformTool3D.Undo.cs
- L10 C41: new() :: private static readonly object _sync = new();


## XREngine.Editor/Unit Tests/Default/UnitTestingWorld.Audio.cs
- L45 C25: new SceneNode :: var sound = new SceneNode(rootNode) { Name = "TestSoundNode" };


## XREngine.Editor/Unit Tests/Default/UnitTestingWorld.cs
- L80 C21: new XRScene :: var scene = new XRScene("Main Scene");
- L81 C24: new SceneNode :: var rootNode = new SceneNode("Root Node");
- L110 C24: new() :: Random r = new();
- L114 C72: new Vector3 :: Lighting.AddLightProbes(rootNode, 1, 1, 1, 10, 10, 10, new Vector3(0.0f, 50.0f, 0.0f));
- L133 C21: new XRWorld :: var world = new XRWorld("Default World", scene);
- L153 C33: new Vector3 :: mirrorTfm.Translation = new Vector3(0.0f, 0.0f, -20.0f);
- L154 C27: new Vector3 :: mirrorTfm.Scale = new Vector3(160.0f, 90.0f, 1.0f);
- L163 C31: new Vector3 :: tfmRoot.Translation = new Vector3(0.0f, 0.0f, 0.0f);
- L168 C28: new Vector3 :: tfm1.Translation = new Vector3(0.0f, 5.0f, 0.0f);
- L173 C28: new Vector3 :: tfm2.Translation = new Vector3(0.0f, 5.0f, 0.0f);
- L180 C33: new Vector3 :: targetTfm.Translation = new Vector3(2.0f, 5.0f, 0.0f);
- L193 C25: new SceneNode :: var decalNode = new SceneNode(rootNode) { Name = "TestDecalNode" };
- L195 C32: new Vector3 :: decalTfm.Translation = new Vector3(0.0f, 5.0f, 0.0f);
- L197 C26: new Vector3 :: decalTfm.Scale = new Vector3(7.0f);
- L206 C32: new() :: PropAnimVector3 anim = new();
- L207 C20: new() :: Random r = new();
- L215 C32: new Vector3Keyframe :: anim.Keyframes.Add(new Vector3Keyframe(t, value, tangent, EVectorInterpType.Smooth));


## XREngine.Editor/Unit Tests/Default/UnitTestingWorld.Lighting.cs
- L22 C29: new SceneNode :: var probeRoot = new SceneNode(rootNode) { Name = "LightProbeRoot" };
- L37 C37: new SceneNode :: var probe = new SceneNode(probeRoot) { Name = $"LightProbe_{i}_{j}_{k}" };
- L39 C63: new Vector3 :: probeTransform.Translation = center + new Vector3(w - halfWidth, h, d - halfDepth);
- L56 C32: new SceneNode :: var dirLightNode = new SceneNode(rootNode) { Name = "TestDirectionalLightNode" };
- L58 C45: new Vector3 :: dirLightTransform.Translation = new Vector3(0.0f, 0.0f, 0.0f);
- L66 C34: new Vector3 :: dirLightComp.Color = new Vector3(1, 1, 1);
- L68 C34: new Vector3 :: dirLightComp.Scale = new Vector3(100.0f, 100.0f, 900.0f);
- L75 C33: new SceneNode :: var dirLightNode2 = new SceneNode(rootNode) { Name = "TestDirectionalLightNode2" };
- L77 C46: new Vector3 :: dirLightTransform2.Translation = new Vector3(0.0f, 10.0f, 0.0f);
- L83 C35: new Vector3 :: dirLightComp2.Color = new Vector3(1.0f, 0.8f, 0.8f);
- L85 C35: new Vector3 :: dirLightComp2.Scale = new Vector3(1000.0f, 1000.0f, 1000.0f);
- L91 C33: new SceneNode :: var spotLightNode = new SceneNode(rootNode) { Name = "TestSpotLightNode" };
- L93 C46: new Vector3 :: spotLightTransform.Translation = new Vector3(0.0f, 10.0f, 0.0f);
- L99 C35: new Vector3 :: spotLightComp.Color = new Vector3(1.0f, 1.0f, 1.0f);
- L110 C30: new SceneNode :: var pointLight = new SceneNode(rootNode) { Name = "TestPointLightNode" };
- L112 C47: new Vector3 :: pointLightTransform.Translation = new Vector3(0.0f, 2.0f, 0.0f);
- L117 C36: new Vector3 :: pointLightComp.Color = new Vector3(1.0f, 1.0f, 1.0f);


## XREngine.Editor/Unit Tests/Default/UnitTestingWorld.Models.cs
- L51 C51: new Vector3 :: var mesh = XRMesh.Shapes.SolidBox(new Vector3(-0.5f), new Vector3(0.5f), true, XRMesh.Shapes.ECubemapTextureUVs.None);
- L51 C71: new Vector3 :: var mesh = XRMesh.Shapes.SolidBox(new Vector3(-0.5f), new Vector3(0.5f), true, XRMesh.Shapes.ECubemapTextureUVs.None);
- L55 C33: new Model :: boxComp.Model = new Model([new SubMesh(mesh, material)
- L55 C44: new SubMesh :: boxComp.Model = new Model([new SubMesh(mesh, material)
- L58 C25: new AABB :: new AABB(new Vector3(-0.5f),
- L58 C34: new Vector3 :: new AABB(new Vector3(-0.5f),
- L59 C25: new Vector3 :: new Vector3(0.5f)),
- L86 C50: new ModelImporter :: using var importer = new ModelImporter(resolvedPath, null, null);
- L108 C58: new SceneNode :: importedStaticModelsRootNode ??= new SceneNode(rootNode) { Name = "Static Model Root", Layer = DefaultLayers.StaticIndex };
- L233 C26: new SceneNode :: var skybox = new SceneNode(rootNode) { Name = "TestSkyboxNode" };
- L348 C81: new TransformState :: ikTargetNode.GetTransformAs<Transform>(true)!.SetFrameState(new TransformState()
- L352 C33: new Vector3 :: Scale = new Vector3(1.0f),
- L644 C34: new Vector3 :: phys.Force = new Vector3(0.0f, 0.0f, 0.0f);
- L645 C36: new Vector3 :: phys.Gravity = new Vector3(0.0f, -0.1f, 0.0f);
- L893 C52: new() :: Dictionary<string, string> pathRemap = new()
- L1072 C23: new XRTexture2D :: tex = new XRTexture2D()
- L1103 C17: new ShaderVector3 :: new ShaderVector3(new Vector3(1.0f, 1.0f, 1.0f), "BaseColor"),
- L1103 C35: new Vector3 :: new ShaderVector3(new Vector3(1.0f, 1.0f, 1.0f), "BaseColor"),
- L1104 C17: new ShaderFloat :: new ShaderFloat(1.0f, "Opacity"),
- L1105 C17: new ShaderFloat :: new ShaderFloat(1.0f, "Roughness"),
- L1106 C17: new ShaderFloat :: new ShaderFloat(0.0f, "Metallic"),
- L1107 C17: new ShaderFloat :: new ShaderFloat(0.0f, "Specular"),
- L1108 C17: new ShaderFloat :: new ShaderFloat(0.0f, "Emission"),


## XREngine.Editor/Unit Tests/Default/UnitTestingWorld.Pawns.cs
- L103 C49: new Vector3 :: characterTfm.SetPositionAndRotation(new Vector3(0.0f, spawnY, 0.0f), Quaternion.Identity);
- L116 C35: new Vector3 :: footTfm.Translation = new Vector3(0.0f, -movementComp.HalfHeight, 0.0f);
- L213 C37: new Vector3 :: movementComp.Velocity = new Vector3(0.0f, 0.0f, 0.0f);
- L367 C49: new Vector3 :: characterTfm.SetPositionAndRotation(new Vector3(0.0f, spawnY, 0.0f), Quaternion.Identity);
- L371 C35: new Vector3 :: footTfm.Translation = new Vector3(0.0f, -movementComp.HalfHeight, 0.0f);
- L378 C43: new Vector3 :: cameraOffsetTfm.Translation = new Vector3(0.0f, (movementComp.HalfHeight * 1.8f), 0.0f);
- L420 C30: new SceneNode :: var cameraNode = new SceneNode(parentNode, "TestCameraNode");


## XREngine.Editor/Unit Tests/Default/UnitTestingWorld.Physics.cs
- L39 C29: new() :: Random random = new();
- L48 C25: new SceneNode :: var floor = new SceneNode(rootNode) { Name = "Floor" };
- L57 C34: new IPhysicsGeometry.Box :: floorComp.Geometry = new IPhysicsGeometry.Box(floorHalfExtents);
- L58 C45: new Vector3 :: floorTfm.SetPositionAndRotation(new Vector3(0.0f, -floorHalfExtents.Y, 0.0f), Quaternion.Identity);
- L100 C32: new Model :: floorModel.Model = new Model([new SubMesh(XRMesh.Create(VertexQuad.PosY(10000.0f)), floorMat)
- L100 C43: new SubMesh :: floorModel.Model = new Model([new SubMesh(XRMesh.Create(VertexQuad.PosY(10000.0f)), floorMat)
- L129 C24: new SceneNode :: var ball = new SceneNode(rootNode) { Name = "Ball" };
- L134 C33: new IPhysicsGeometry.Sphere :: ballComp.Geometry = new IPhysicsGeometry.Sphere(ballRadius);
- L181 C31: new Model :: ballModel.Model = new Model([new SubMesh(XRMesh.Shapes.SolidSphere(Vector3.Zero, ballRadius, 32), ballMat)]);
- L181 C42: new SubMesh :: ballModel.Model = new Model([new SubMesh(XRMesh.Shapes.SolidSphere(Vector3.Zero, ballRadius, 32), ballMat)]);


## XREngine.Editor/Unit Tests/Default/UnitTestingWorld.Toggles.cs
- L12 C52: new() :: public static Settings Toggles { get; set; } = new();


## XREngine.Editor/Unit Tests/Default/UnitTestingWorld.UserInterface.cs
- L30 C56: new() :: private static readonly Queue<float> _fpsAvg = new();
- L77 C43: new Vector2 :: textTransform.MinAnchor = new Vector2(0.0f, 1.0f);
- L78 C43: new Vector2 :: textTransform.MaxAnchor = new Vector2(0.0f, 1.0f);
- L79 C49: new Vector2 :: textTransform.NormalizedPivot = new Vector2(0.0f, 1.0f);
- L83 C43: new Vector2 :: textTransform.MinAnchor = new Vector2(1.0f, 0.0f);
- L84 C43: new Vector2 :: textTransform.MaxAnchor = new Vector2(1.0f, 0.0f);
- L85 C49: new Vector2 :: textTransform.NormalizedPivot = new Vector2(1.0f, 0.0f);
- L87 C37: new Vector4 :: textTransform.Margins = new Vector4(10.0f, 10.0f, 10.0f, 10.0f);
- L88 C35: new Vector3 :: textTransform.Scale = new Vector3(1.0f);
- L107 C34: new SceneNode :: var rootCanvasNode = new SceneNode(parent.World, "TestUINode") { IsEditorOnly = true };
- L149 C31: new Vector2 :: canvasTfm.SetSize(new Vector2(1920.0f, 1080.0f));
- L150 C33: new Vector4 :: canvasTfm.Padding = new Vector4(0.0f);
- L203 C33: new Vector2 :: tfm.MaxAnchor = new Vector2(1.0f, 1.0f);
- L204 C33: new Vector2 :: tfm.MinAnchor = new Vector2(0.0f, 0.0f);
- L205 C39: new Vector2 :: tfm.NormalizedPivot = new Vector2(0.0f, 0.0f);
- L239 C33: new Vector2 :: tfm.MinAnchor = new Vector2(0.0f, 0.0f);
- L240 C33: new Vector2 :: tfm.MaxAnchor = new Vector2(1.0f, 1.0f);
- L241 C39: new Vector2 :: tfm.NormalizedPivot = new Vector2(0.0f, 0.0f);
- L256 C37: new Vector2 :: tfm.MinAnchor = new Vector2(0.0f, 0.0f);
- L257 C37: new Vector2 :: tfm.MaxAnchor = new Vector2(1.0f, 1.0f);
- L258 C43: new Vector2 :: tfm.NormalizedPivot = new Vector2(0.0f, 0.0f);
- L259 C39: new Vector2 :: tfm.Translation = new Vector2(0.0f, 0.0f);
- L286 C36: new Vector2 :: previewTfm.MinAnchor = new Vector2(0.0f, 0.0f);
- L287 C36: new Vector2 :: previewTfm.MaxAnchor = new Vector2(1.0f, 1.0f);
- L288 C42: new Vector2 :: previewTfm.NormalizedPivot = new Vector2(0.0f, 0.0f);
- L294 C33: new Vector2 :: leftTfm.MinAnchor = new Vector2(0.0f, 0.0f);
- L295 C33: new Vector2 :: leftTfm.MaxAnchor = new Vector2(0.5f, 1.0f);
- L296 C39: new Vector2 :: leftTfm.NormalizedPivot = new Vector2(0.0f, 0.0f);
- L302 C34: new Vector2 :: rightTfm.MinAnchor = new Vector2(0.5f, 0.0f);
- L303 C34: new Vector2 :: rightTfm.MaxAnchor = new Vector2(1.0f, 1.0f);
- L304 C40: new Vector2 :: rightTfm.NormalizedPivot = new Vector2(0.0f, 0.0f);
- L365 C27: new XRMaterial :: var mat = new XRMaterial([texture], frag);
- L424 C55: new byte :: private static byte[] _newProjectNameBuffer = new byte[256];
- L425 C55: new byte :: private static byte[] _newProjectPathBuffer = new byte[512];
- L468 C97: new System.Numerics.Vector2 :: ImGuiNET.ImGui.SetNextWindowPos(viewport.GetCenter(), ImGuiNET.ImGuiCond.Appearing, new System.Numerics.Vector2(0.5f, 0.5f));
- L469 C46: new System.Numerics.Vector2 :: ImGuiNET.ImGui.SetNextWindowSize(new System.Numerics.Vector2(500, 180));
- L486 C53: new System.Numerics.Vector2 :: if (ImGuiNET.ImGui.Button("Create", new System.Numerics.Vector2(120, 0)))
- L505 C53: new System.Numerics.Vector2 :: if (ImGuiNET.ImGui.Button("Cancel", new System.Numerics.Vector2(120, 0)))
- L565 C44: new ToolbarButton :: _saveMenu.ChildOptions.Add(new ToolbarButton("No asset manager available"));
- L572 C44: new ToolbarButton :: _saveMenu.ChildOptions.Add(new ToolbarButton("No modified assets"));
- L580 C44: new ToolbarButton :: _saveMenu.ChildOptions.Add(new ToolbarButton(displayName, _ => SaveSingleAsset(capturedAsset.Value)));
- L609 C27: new ToolbarButton :: _saveMenu ??= new ToolbarButton("Save");
- L613 C17: new ToolbarButton :: new ToolbarButton("File", [Key.ControlLeft, Key.F],
- L616 C17: new ToolbarButton :: new ToolbarButton("Save All", SaveAll, [Key.ControlLeft, Key.ShiftLeft, Key.S]),
- L617 C17: new ToolbarButton :: new ToolbarButton("Open", [
- L618 C21: new ToolbarButton :: new ToolbarButton("Project", OpenProjectDialog),
- L620 C17: new ToolbarButton :: new ToolbarButton("New Project", _ => ShowNewProjectDialog()),
- L623 C13: new ToolbarButton :: new ToolbarButton("Assets"),
- L624 C13: new ToolbarButton :: new ToolbarButton("Tools", [Key.ControlLeft, Key.T],
- L626 C17: new ToolbarButton :: new ToolbarButton("Take Screenshot", TakeScreenshot),
- L627 C17: new ToolbarButton :: new ToolbarButton("Shader Locking Tool", _ => ShaderLockingWindow.Instance.Open()),
- L628 C17: new ToolbarButton :: new ToolbarButton("Shader Analyzer Tool", _ => ShaderAnalyzerWindow.Instance.Open()),
- L630 C13: new ToolbarButton :: new ToolbarButton("View"),
- L631 C13: new ToolbarButton :: new ToolbarButton("Window"),
- L632 C13: new ToolbarButton :: new ToolbarButton("Help"),
- L687 C30: new ToolbarButton :: var undoButton = new ToolbarButton("Undo", OnToolbarUndo, [Key.ControlLeft, Key.Z]);
- L688 C30: new ToolbarButton :: var redoButton = new ToolbarButton("Redo", OnToolbarRedo, [Key.ControlLeft, Key.Y]);
- L689 C34: new ToolbarButton :: _undoHistoryMenu ??= new ToolbarButton("Undo History");
- L692 C20: new ToolbarButton :: return new ToolbarButton("Edit", undoButton, redoButton, _undoHistoryMenu);
- L715 C51: new ToolbarButton :: _undoHistoryMenu.ChildOptions.Add(new ToolbarButton("No undo steps available"));
- L724 C51: new ToolbarButton :: _undoHistoryMenu.ChildOptions.Add(new ToolbarButton(label, _ => UndoMultiple(targetIndex)));


## XREngine.Editor/Unit Tests/Math/UnitTestingWorld.Math.cs
- L18 C21: new XRScene :: var scene = new XRScene("Math Intersections Scene");
- L19 C24: new SceneNode :: var rootNode = new SceneNode("Root Node");
- L33 C21: new XRWorld :: var world = new XRWorld("Math Intersections World", scene);
- L46 C27: new Vector3 :: debug.AddLine(new Vector3(x, 0.0f, -extent), new Vector3(x, 0.0f, extent), x == 0.0f ? ColorF4.White : ColorF4.Gray);
- L46 C58: new Vector3 :: debug.AddLine(new Vector3(x, 0.0f, -extent), new Vector3(x, 0.0f, extent), x == 0.0f ? ColorF4.White : ColorF4.Gray);
- L50 C27: new Vector3 :: debug.AddLine(new Vector3(-extent, 0.0f, z), new Vector3(extent, 0.0f, z), z == 0.0f ? ColorF4.White : ColorF4.Gray);
- L50 C58: new Vector3 :: debug.AddLine(new Vector3(-extent, 0.0f, z), new Vector3(extent, 0.0f, z), z == 0.0f ? ColorF4.White : ColorF4.Gray);
- L52 C23: new Vector3 :: debug.AddLine(new Vector3(0.0f, 0.0f, 0.0f), new Vector3(0.0f, 4.0f, 0.0f), ColorF4.LightGold);
- L52 C54: new Vector3 :: debug.AddLine(new Vector3(0.0f, 0.0f, 0.0f), new Vector3(0.0f, 4.0f, 0.0f), ColorF4.LightGold);
- L61 C35: new Vector3 :: frustumATfm.Translation = new Vector3(-2.5f, 2.0f, 7.5f);
- L67 C35: new Vector3 :: frustumBTfm.Translation = new Vector3(3.5f, 2.5f, 5.0f);
- L84 C39: new Vector3 :: frustumBTfm.Translation = new Vector3(
- L105 C50: new Vector3 :: Vector3 rayDirection = Vector3.Normalize(new Vector3(1.0f, 0.05f, 1.0f));
- L140 C34: new Vector3 :: frustumTfm.Translation = new Vector3(0.0f, 2.0f, -6.0f);
- L165 C26: new Sphere :: var sphere = new Sphere(
- L166 C17: new Vector3 :: new Vector3(MathF.Sin(t * 0.8f) * 4.0f, 2.0f + MathF.Sin(t * 0.55f) * 0.8f, 4.0f + MathF.Cos(t * 0.7f) * 2.0f),
- L174 C24: new AABB :: var aabb = new AABB(boxCenter - boxHalf, boxCenter + boxHalf);
- L180 C35: new Vector3 :: Vector3 capB = capA + new Vector3(0.0f, 2.3f, 0.0f);
- L185 C27: new Capsule :: var capsule = new Capsule((capA + capB) * 0.5f, capUp, capR, capLen * 0.5f);
- L244 C45: new Vector3 :: Vector3 dir = Vector3.Normalize(new Vector3(1.0f, MathF.Sin(t * 0.35f) * 0.15f, 0.85f));
- L271 C16: new Frustum :: return new Frustum(fovY, aspect, nearZ, farZ, forward, up, position);


## XREngine.Editor/Unit Tests/Mesh Editing/UnitTestingWorld.MeshEditing.cs
- L21 C91: new() :: private static readonly XRMeshModelingExportOptions MeshEditingPreviewExportOptions = new()
- L30 C21: new XRScene :: var scene = new XRScene("Mesh Editing Scene");
- L31 C24: new SceneNode :: var rootNode = new SceneNode("Root Node");
- L39 C22: new InvalidOperationException :: ?? throw new InvalidOperationException("MeshEditingPawnComponent failed to load source XRMesh.");
- L43 C37: new Vector3 :: meshTransform.Translation = new Vector3(0.0f, 1.5f, 6.0f);
- L61 C21: new XRWorld :: var world = new XRWorld("Mesh Editing World", scene);
- L71 C17: new Vector3 :: new(new Vector3(-h, -h, -h)),
- L72 C17: new Vector3 :: new(new Vector3(h, -h, -h)),
- L73 C17: new Vector3 :: new(new Vector3(h, h, -h)),
- L74 C17: new Vector3 :: new(new Vector3(-h, h, -h)),
- L75 C17: new Vector3 :: new(new Vector3(-h, -h, h)),
- L76 C17: new Vector3 :: new(new Vector3(h, -h, h)),
- L77 C17: new Vector3 :: new(new Vector3(h, h, h)),
- L78 C17: new Vector3 :: new(new Vector3(-h, h, h))
- L91 C16: new XRMesh :: return new XRMesh(vertices, indices);
- L105 C23: new SubMesh :: var subMesh = new SubMesh(mesh, material)
- L110 C27: new Model :: modelComp.Model = new Model(subMesh);
- L118 C13: new ModelingMeshMetadata :: new ModelingMeshMetadata


## XREngine.Editor/Unit Tests/Physx/UnitTestingWorld.PhysxTesting.cs
- L26 C21: new XRScene :: var scene = new XRScene("PhysX Testing Scene");
- L27 C24: new SceneNode :: var rootNode = new SceneNode("Root Node");
- L36 C21: new XRWorld :: var world = new XRWorld("PhysX Testing World", scene);
- L53 C30: new Vector3 :: halfExtents: new Vector3(0.5f, 0.5f, 0.5f),
- L54 C27: new Vector3 :: position: new Vector3(-6.0f, 1.0f + i * 1.05f, 8.0f));
- L61 C26: new Vector3 :: halfExtents: new Vector3(5.0f, 0.35f, 2.5f),
- L62 C23: new Vector3 :: position: new Vector3(6.0f, 0.65f, 10.0f),
- L69 C26: new Vector3 :: halfExtents: new Vector3(1.25f, 1.25f, 1.25f),
- L70 C23: new Vector3 :: position: new Vector3(6.0f, 4.5f, 4.0f),
- L83 C20: new SceneNode :: var node = new SceneNode(rootNode) { Name = name };
- L88 C25: new IPhysicsGeometry.Box :: body.Geometry = new IPhysicsGeometry.Box(halfExtents);
- L95 C23: new Model :: model.Model = new Model([
- L96 C13: new SubMesh :: new SubMesh(XRMesh.Shapes.SolidBox(Vector3.Zero, halfExtents * 2.0f), mat)
- L102 C20: new SceneNode :: var node = new SceneNode(rootNode) { Name = name };
- L107 C25: new IPhysicsGeometry.Box :: body.Geometry = new IPhysicsGeometry.Box(halfExtents);
- L112 C23: new Model :: model.Model = new Model([
- L113 C13: new SubMesh :: new SubMesh(XRMesh.Shapes.SolidBox(Vector3.Zero, halfExtents * 2.0f), mat)


## XREngine.Editor/Unit Tests/Uber Shader/UnitTestingWorld.UberShader.cs
- L22 C21: new XRScene :: var scene = new XRScene("Uber Shader Scene");
- L23 C24: new SceneNode :: var rootNode = new SceneNode("Root Node");
- L32 C21: new XRWorld :: var world = new XRWorld("Uber Shader World", scene);
- L48 C22: new UberMaterialConfig :: ("Base", new UberMaterialConfig()),
- L49 C26: new UberMaterialConfig :: ("Emission", new UberMaterialConfig { EnableEmission = true }),
- L50 C24: new UberMaterialConfig :: ("Matcap", new UberMaterialConfig { EnableMatcap = true }),
- L51 C33: new UberMaterialConfig :: ("Emission+Matcap", new UberMaterialConfig { EnableEmission = true, EnableMatcap = true }),
- L73 C27: new Model :: model.Model = new Model([
- L74 C17: new SubMesh :: new SubMesh(
- L81 C28: new Vector3 :: debug.AddPoint(new Vector3(0, radius + 0.2f, 0), ColorF4.White);
- L82 C27: new Vector3 :: debug.AddLine(new Vector3(0, radius + 0.2f, 0), new Vector3(0, radius + 1.0f, 0), ColorF4.White);
- L82 C61: new Vector3 :: debug.AddLine(new Vector3(0, radius + 0.2f, 0), new Vector3(0, radius + 1.0f, 0), ColorF4.White);
- L91 C30: new Vector3 :: refDebug.AddLine(new Vector3(x, 0.0f, -extent), new Vector3(x, 0.0f, extent), x == 0.0f ? ColorF4.White : ColorF4.Gray);
- L91 C61: new Vector3 :: refDebug.AddLine(new Vector3(x, 0.0f, -extent), new Vector3(x, 0.0f, extent), x == 0.0f ? ColorF4.White : ColorF4.Gray);
- L93 C30: new Vector3 :: refDebug.AddLine(new Vector3(-extent, 0.0f, z), new Vector3(extent, 0.0f, z), z == 0.0f ? ColorF4.White : ColorF4.Gray);
- L93 C61: new Vector3 :: refDebug.AddLine(new Vector3(-extent, 0.0f, z), new Vector3(extent, 0.0f, z), z == 0.0f ? ColorF4.White : ColorF4.Gray);
- L122 C24: new XRTexture :: var textures = new XRTexture?[] { main, bump };
- L126 C26: new ShaderVar :: var parameters = new ShaderVar[]
- L128 C13: new ShaderVector4 :: new ShaderVector4(new Vector4(config.Tint.R, config.Tint.G, config.Tint.B, config.Tint.A), "_Color"),
- L128 C31: new Vector4 :: new ShaderVector4(new Vector4(config.Tint.R, config.Tint.G, config.Tint.B, config.Tint.A), "_Color"),
- L131 C13: new ShaderVector4 :: new ShaderVector4(new Vector4(1, 1, 0, 0), "_MainTex_ST"),
- L131 C31: new Vector4 :: new ShaderVector4(new Vector4(1, 1, 0, 0), "_MainTex_ST"),
- L132 C13: new ShaderVector2 :: new ShaderVector2(Vector2.Zero, "_MainTexPan"),
- L133 C13: new ShaderInt :: new ShaderInt(0, "_MainTexUV"),
- L136 C13: new ShaderVector4 :: new ShaderVector4(new Vector4(1, 1, 0, 0), "_BumpMap_ST"),
- L136 C31: new Vector4 :: new ShaderVector4(new Vector4(1, 1, 0, 0), "_BumpMap_ST"),
- L137 C13: new ShaderVector2 :: new ShaderVector2(Vector2.Zero, "_BumpMapPan"),
- L138 C13: new ShaderInt :: new ShaderInt(0, "_BumpMapUV"),
- L139 C13: new ShaderFloat :: new ShaderFloat(0.0f, "_BumpScale"),
- L142 C13: new ShaderFloat :: new ShaderFloat(1.0f, "_ShadingEnabled"),
- L143 C13: new ShaderInt :: new ShaderInt(6, "_LightingMode"), // Realistic (simple lambert) to avoid ramp dependencies.
- L144 C13: new ShaderVector3 :: new ShaderVector3(new Vector3(1, 1, 1), "_LightingShadowColor"),
- L144 C31: new Vector3 :: new ShaderVector3(new Vector3(1, 1, 1), "_LightingShadowColor"),
- L145 C13: new ShaderFloat :: new ShaderFloat(1.0f, "_ShadowStrength"),
- L146 C13: new ShaderFloat :: new ShaderFloat(0.0f, "_LightingMinLightBrightness"),
- L147 C13: new ShaderFloat :: new ShaderFloat(0.0f, "_LightingMonochromatic"),
- L148 C13: new ShaderFloat :: new ShaderFloat(0.0f, "_LightingCapEnabled"),
- L149 C13: new ShaderFloat :: new ShaderFloat(10.0f, "_LightingCap"),
- L152 C13: new ShaderInt :: new ShaderInt(0, "_MainAlphaMaskMode"),
- L153 C13: new ShaderFloat :: new ShaderFloat(0.0f, "_AlphaMod"),
- L154 C13: new ShaderFloat :: new ShaderFloat(1.0f, "_AlphaForceOpaque"),
- L155 C13: new ShaderFloat :: new ShaderFloat(0.5f, "_Cutoff"),
- L156 C13: new ShaderInt :: new ShaderInt(0, "_Mode"),
- L159 C13: new ShaderFloat :: new ShaderFloat(config.EnableEmission ? 1.0f : 0.0f, "_EnableEmission"),
- L160 C13: new ShaderVector4 :: new ShaderVector4(new Vector4(1, 0.7f, 0.2f, 1), "_EmissionColor"),
- L160 C31: new Vector4 :: new ShaderVector4(new Vector4(1, 0.7f, 0.2f, 1), "_EmissionColor"),
- L161 C13: new ShaderFloat :: new ShaderFloat(2.5f, "_EmissionStrength"),
- L164 C13: new ShaderFloat :: new ShaderFloat(config.EnableMatcap ? 1.0f : 0.0f, "_MatcapEnable"),
- L165 C13: new ShaderVector4 :: new ShaderVector4(new Vector4(1, 1, 1, 1), "_MatcapColor"),
- L165 C31: new Vector4 :: new ShaderVector4(new Vector4(1, 1, 1, 1), "_MatcapColor"),
- L166 C13: new ShaderFloat :: new ShaderFloat(1.0f, "_MatcapIntensity"),
- L167 C13: new ShaderFloat :: new ShaderFloat(0.0f, "_MatcapReplace"),
- L168 C13: new ShaderFloat :: new ShaderFloat(1.0f, "_MatcapMultiply"),
- L169 C13: new ShaderFloat :: new ShaderFloat(0.0f, "_MatcapAdd"),
- L174 C27: new List :: var textureList = new List<XRTexture?>(textures);
- L182 C24: new XRMaterial :: var material = new XRMaterial(parameters, [.. textureList], vert, frag)
- L194 C17: new XRTexture2D :: var t = new XRTexture2D


## XREngine.Extensions/Array.cs
- L18 C46: new StringBuilder :: return list.Cast<object>().Aggregate(new StringBuilder(),
- L39 C37: new() :: StringBuilder builder = new();
- L59 C37: new() :: StringBuilder builder = new();
- L79 C37: new() :: StringBuilder builder = new();
- L104 C37: new() :: StringBuilder builder = new();
- L127 C37: new() :: StringBuilder builder = new();
- L172 C37: new() :: StringBuilder builder = new();
- L196 C37: new() :: StringBuilder builder = new();
- L224 C37: new() :: StringBuilder builder = new();
- L275 C37: new() :: StringBuilder builder = new();
- L298 C37: new() :: StringBuilder builder = new();
- L391 C26: new T :: T[] result = new T[length];
- L397 C25: new T :: T[] final = new T[data.Length + appended.Length];
- L430 C61: new() :: public static T[] Fill<T>(this T[] array) where T : new()
- L433 C28: new T :: array[i] = new T();
- L458 C47: new() :: ParallelOptions options = new()
- L480 C47: new() :: ParallelOptions options = new()


## XREngine.Extensions/Enumerable.cs
- L61 C47: new() :: ParallelOptions options = new()
- L83 C47: new() :: ParallelOptions options = new()


## XREngine.Extensions/Generic.cs
- L22 C30: new byte :: byte[] dataArr = new byte[sizeof(T)];
- L32 C23: new() :: T value = new();


## XREngine.Extensions/List.cs
- L53 C37: new Queue :: Queue<uint>[] buckets = new Queue<uint>[15];
- L55 C30: new Queue :: buckets[i] = new Queue<uint>();
- L104 C47: new() :: ParallelOptions options = new()
- L126 C47: new() :: ParallelOptions options = new()


## XREngine.Extensions/Memory/MarshalExtension.cs
- L11 C20: new CoTaskMemoryHandle :: return new CoTaskMemoryHandle(ptr);
- L17 C20: new CoTaskMemoryHandle :: return new CoTaskMemoryHandle(ptr);
- L23 C20: new CoTaskMemoryHandle :: return new CoTaskMemoryHandle(ptr);
- L29 C20: new CoTaskMemoryHandle :: return new CoTaskMemoryHandle(ptr);
- L35 C20: new CoTaskMemoryHandle :: return new CoTaskMemoryHandle(ptr);
- L41 C20: new CoTaskMemoryHandle :: return new CoTaskMemoryHandle(ptr);


## XREngine.Extensions/Numbers/MatrixExtension.cs
- L22 C13: new Vector3 :: new Vector3(matrix.M11, matrix.M12, matrix.M13).Length(),
- L23 C13: new Vector3 :: new Vector3(matrix.M21, matrix.M22, matrix.M23).Length(),
- L24 C13: new Vector3 :: new Vector3(matrix.M31, matrix.M32, matrix.M33).Length());


## XREngine.Extensions/ReaderWriterLockSlim.cs
- L40 C16: new ReadLockToken :: => new ReadLockToken(obj);
- L42 C16: new WriteLockToken :: => new WriteLockToken(obj);


## XREngine.Extensions/Reflection/Type.cs
- L18 C38: new() :: NewClass,           //class, new()
- L19 C31: new() :: NewStructOrClass,   //new()
- L23 C78: new() :: private static readonly Dictionary<Type, string> DefaultDictionary = new()
- L140 C23: new Exception :: throw new Exception();
- L161 C28: new() :: List<T> list = new();
- L174 C40: new() :: List<MemberInfo> members = new();


## XREngine.Extensions/Stream.cs
- L10 C28: new byte :: byte[] bytes = new byte[size];
- L20 C28: new byte :: byte[] bytes = new byte[size];
- L30 C26: new byte :: byte[] arr = new byte[size];
- L40 C26: new byte :: byte[] arr = new byte[size];
- L55 C27: new EndOfStreamException :: throw new EndOfStreamException($"Stream ended early: expected {buffer.Length} bytes, got {totalRead} bytes.");
- L67 C27: new EndOfStreamException :: throw new EndOfStreamException($"Stream ended early: expected {buffer.Length} bytes, got {totalRead} bytes.");


## XREngine.Extensions/String.cs
- L102 C67: new char :: string[] mainParts = Path.GetFullPath(mainPath).Split(new char[] { Path.DirectorySeparatorChar }, StringSplitOptions.RemoveEmptyEntries);
- L103 C69: new char :: string[] otherParts = Path.GetFullPath(otherPath).Split(new char[] { Path.DirectorySeparatorChar }, StringSplitOptions.RemoveEmptyEntries);
- L333 C42: new() :: ConcurrentBag<int> bag = new();
- L345 C31: new() :: List<int> o = new();
- L357 C27: new() :: List<int> o = new();


## XREngine.Input/Devices/InputDevice.cs
- L11 C99: new() :: private static readonly Dictionary<EInputDeviceType, List<InputDevice>> _currentDevices = new()
- L13 C41: new List :: { EInputDeviceType.Gamepad, new List<InputDevice>() },
- L14 C41: new List :: { EInputDeviceType.Keyboard,new List<InputDevice>() },
- L15 C39: new List :: { EInputDeviceType.Mouse, new List<InputDevice>() },
- L40 C29: new ButtonManager :: _buttonStates = new ButtonManager[GetButtonCount()];
- L41 C27: new AxisManager :: _axisStates = new AxisManager[GetAxisCount()];
- L63 C23: new ButtonManager :: var man = new ButtonManager(index, name.ToString());
- L71 C23: new ButtonManager :: var man = new ButtonManager(index, name.ToString());
- L79 C23: new ButtonManager :: var man = new ButtonManager(index, name.ToString());
- L87 C23: new AxisManager :: var man = new AxisManager(index, name.ToString());


## XREngine.Input/Devices/InputInterfaces/LocalInputInterface.cs
- L216 C27: new GlfwGamepad :: Gamepad = new GlfwGamepad(gamepads[_localPlayerIndex]);
- L223 C28: new GlfwKeyboard :: Keyboard = new GlfwKeyboard(keyboards[0]);
- L226 C25: new GlfwMouse :: Mouse = new GlfwMouse(mice[0]);
- L411 C59: new OpenVRActionSetInputs :: _registeredOpenVRActions.Add(c, actions = new OpenVRActionSetInputs());
- L422 C59: new OpenVRActionSetInputs :: _registeredOpenVRActions.Add(c, actions = new OpenVRActionSetInputs());
- L433 C59: new OpenVRActionSetInputs :: _registeredOpenVRActions.Add(c, actions = new OpenVRActionSetInputs());
- L444 C59: new OpenVRActionSetInputs :: _registeredOpenVRActions.Add(c, actions = new OpenVRActionSetInputs());


## XREngine.Input/Devices/Managers/ButtonManager.cs
- L18 C24: new Dictionary :: _actions = new Dictionary<EButtonInputType, List<Action?>?>(4)
- L41 C37: new() :: private Lock _actionsLock = new();


## XREngine.Input/Devices/Managers/CursorManager.cs
- L13 C70: new List :: private readonly List<DelCursorUpdate?>?[] _onCursorUpdate = new List<DelCursorUpdate?>?[2];


## XREngine.Input/Devices/Types/BaseGamepad.cs
- L47 C38: new DXGamepad :: EInputType.XInput => new DXGamepad(index),
- L48 C28: new InvalidOperationException :: _ => throw new InvalidOperationException(),


## XREngine.Input/Devices/Types/BaseMouse.cs
- L17 C43: new() :: protected CursorManager _cursor = new();
- L18 C47: new() :: protected ScrollWheelManager _wheel = new();


## XREngine.Input/Devices/Types/DirectX/DXGamepad.cs
- L10 C69: new DXGamepadConfiguration :: public static DXGamepadConfiguration Config { get; set; } = new DXGamepadConfiguration();
- L14 C27: new() :: Vibration v = new()


## XREngine.Input/Devices/Types/DirectX/DXGamepadAwaiter.cs
- L19 C16: new DXGamepad :: => new DXGamepad(controllerIndex);


## XREngine.Input/Devices/Types/Glfw/GlfwGamepad.cs
- L129 C23: new GlfwButtonManager :: var man = new GlfwButtonManager(index, name.ToString(), GetGlfwButtonFactory(name));
- L141 C27: new GlfwAxisManager :: man = new GlfwAxisManager(index, name.ToString(), () => _controller.Triggers[0].Position);
- L144 C27: new GlfwAxisManager :: man = new GlfwAxisManager(index, name.ToString(), () => _controller.Triggers[1].Position);
- L148 C27: new GlfwAxisManager :: man = new GlfwAxisManager(index, name.ToString(), () => _controller.Thumbsticks[0].X);
- L151 C27: new GlfwAxisManager :: man = new GlfwAxisManager(index, name.ToString(), () => -_controller.Thumbsticks[0].Y);
- L155 C27: new GlfwAxisManager :: man = new GlfwAxisManager(index, name.ToString(), () => _controller.Thumbsticks[1].X);
- L158 C27: new GlfwAxisManager :: man = new GlfwAxisManager(index, name.ToString(), () => -_controller.Thumbsticks[1].Y);


## XREngine.Modeling/EditableMesh.cs
- L32 C23: new EditableFaceData :: faces.Add(new EditableFaceData(indexArray[i], indexArray[i + 1], indexArray[i + 2]));
- L34 C21: new HalfEdgeTopology :: _topology = new HalfEdgeTopology(vertices, faces);
- L113 C29: new EditableFaceData :: faces[faceId] = new EditableFaceData(edge.A, newIndex, opposite);
- L114 C23: new EditableFaceData :: faces.Add(new EditableFaceData(newIndex, edge.B, opposite));
- L145 C26: new EditableFaceData :: remapped.Add(new EditableFaceData(a, b, c));
- L153 C27: new EditableFaceData :: remapped[i] = new EditableFaceData(
- L178 C29: new EditableFaceData :: faces[faceId] = new EditableFaceData(vertexA, vertexB, third);
- L220 C23: new EditableFaceData :: faces.Add(new EditableFaceData(oldToNew[face.A], oldToNew[face.B], oldToNew[face.C]));
- L237 C23: new EditableFaceData :: faces.Add(new EditableFaceData(edge.A, edge.B, b2));
- L238 C23: new EditableFaceData :: faces.Add(new EditableFaceData(edge.A, b2, a2));
- L278 C23: new EditableFaceData :: faces.Add(new EditableFaceData(a2, b2, c2));
- L279 C23: new EditableFaceData :: faces.Add(new EditableFaceData(face.A, face.B, b2));
- L280 C23: new EditableFaceData :: faces.Add(new EditableFaceData(face.A, b2, a2));
- L281 C23: new EditableFaceData :: faces.Add(new EditableFaceData(face.B, face.C, c2));
- L282 C23: new EditableFaceData :: faces.Add(new EditableFaceData(face.B, c2, b2));
- L283 C23: new EditableFaceData :: faces.Add(new EditableFaceData(face.C, face.A, a2));
- L284 C23: new EditableFaceData :: faces.Add(new EditableFaceData(face.C, a2, c2));
- L331 C13: new EditableFaceData :: new EditableFaceData(first.A, first.B, second.B),
- L332 C13: new EditableFaceData :: new EditableFaceData(first.A, second.B, second.A)];
- L378 C16: new MeshAccelerationData :: return new MeshAccelerationData
- L448 C22: new EdgeKey :: yield return new EdgeKey(A, B);
- L449 C22: new EdgeKey :: yield return new EdgeKey(B, C);
- L450 C22: new EdgeKey :: yield return new EdgeKey(C, A);
- L456 C19: new InvalidOperationException :: throw new InvalidOperationException("Edge does not belong to this face.");


## XREngine.Modeling/EditableMeshConverter.cs
- L13 C19: new InvalidOperationException :: throw new InvalidOperationException(BuildValidationMessage(report));
- L15 C16: new EditableMesh :: return new EditableMesh(document.Positions, document.TriangleIndices);
- L24 C16: new ModelingMeshDocument :: return new ModelingMeshDocument


## XREngine.Modeling/HalfEdgeTopology.cs
- L82 C51: new() :: Dictionary<int, HashSet<int>> adjacency = new();
- L107 C22: new EdgeKey :: loop.Add(new EdgeKey(edge.Origin, edge.Destination));
- L126 C43: new() :: TopologyValidationReport report = new();
- L134 C28: new TopologyValidationIssue :: report.Add(new TopologyValidationIssue(
- L144 C28: new TopologyValidationIssue :: report.Add(new TopologyValidationIssue(
- L156 C28: new TopologyValidationIssue :: report.Add(new TopologyValidationIssue(
- L168 C28: new TopologyValidationIssue :: report.Add(new TopologyValidationIssue(
- L176 C28: new TopologyValidationIssue :: report.Add(new TopologyValidationIssue(
- L188 C28: new TopologyValidationIssue :: report.Add(new TopologyValidationIssue(
- L199 C28: new TopologyValidationIssue :: report.Add(new TopologyValidationIssue(
- L217 C81: new() :: Dictionary<(int Origin, int Destination), int> directedEdgeToHalfEdge = new();
- L227 C28: new HalfEdgeData :: _halfEdges.Add(new HalfEdgeData(face.A, face.B, faceIndex, h1, h2, -1));
- L228 C28: new HalfEdgeData :: _halfEdges.Add(new HalfEdgeData(face.B, face.C, faceIndex, h2, h0, -1));
- L229 C28: new HalfEdgeData :: _halfEdges.Add(new HalfEdgeData(face.C, face.A, faceIndex, h0, h1, -1));


## XREngine.Modeling/MeshGenerator.cs
- L33 C39: new() :: MeshGenerator generator = new();
- L41 C23: new Vector3 :: AddVertex(new Vector3(-1, t, 0) * radius);
- L42 C23: new Vector3 :: AddVertex(new Vector3(1, t, 0) * radius);
- L43 C23: new Vector3 :: AddVertex(new Vector3(-1, -t, 0) * radius);
- L44 C23: new Vector3 :: AddVertex(new Vector3(1, -t, 0) * radius);
- L46 C23: new Vector3 :: AddVertex(new Vector3(0, -1, t) * radius);
- L47 C23: new Vector3 :: AddVertex(new Vector3(0, 1, t) * radius);
- L48 C23: new Vector3 :: AddVertex(new Vector3(0, -1, -t) * radius);
- L49 C23: new Vector3 :: AddVertex(new Vector3(0, 1, -t) * radius);
- L51 C23: new Vector3 :: AddVertex(new Vector3(t, 0, -1) * radius);
- L52 C23: new Vector3 :: AddVertex(new Vector3(t, 0, 1) * radius);
- L53 C23: new Vector3 :: AddVertex(new Vector3(-t, 0, -1) * radius);
- L54 C23: new Vector3 :: AddVertex(new Vector3(-t, 0, 1) * radius);
- L80 C55: new Dictionary :: IDictionary<long, int> middlePointCache = new Dictionary<long, int>();
- L113 C39: new() :: MeshGenerator generator = new();
- L134 C38: new Vector3 :: Vector3 vertex = new Vector3(x, y, z) * radius;
- L152 C38: new Vector3 :: Vector3 vertex = new Vector3(x, y, z) * radius;
- L179 C39: new() :: MeshGenerator generator = new();
- L191 C39: new() :: MeshGenerator generator = new();
- L208 C38: new Vector3 :: Vector3 vertex = new Vector3(x, y, z) * radius;
- L275 C37: new Vector3 :: Vector3[] newVertices = new Vector3[Vertices.Count + edgeVertices.Count];
- L286 C34: new Edge :: edgeVertices[new Edge(cornerVertices[0], cornerVertices[1])],
- L287 C34: new Edge :: edgeVertices[new Edge(cornerVertices[1], cornerVertices[2])],
- L288 C34: new Edge :: edgeVertices[new Edge(cornerVertices[2], cornerVertices[0])]
- L316 C33: new Vector3 :: Vector3[] normals = new Vector3[Vertices.Count];


## XREngine.Modeling/ModelingMeshDocument.cs
- L16 C58: new() :: public ModelingMeshMetadata Metadata { get; set; } = new();


## XREngine.Modeling/ModelingMeshMetadata.cs
- L22 C16: new ModelingMeshMetadata :: return new ModelingMeshMetadata


## XREngine.Modeling/ModelingMeshValidation.cs
- L35 C47: new() :: ModelingMeshValidationReport report = new();
- L42 C24: new ModelingMeshValidationIssue :: report.Add(new ModelingMeshValidationIssue(
- L50 C24: new ModelingMeshValidationIssue :: report.Add(new ModelingMeshValidationIssue(
- L58 C24: new ModelingMeshValidationIssue :: report.Add(new ModelingMeshValidationIssue(
- L69 C28: new ModelingMeshValidationIssue :: report.Add(new ModelingMeshValidationIssue(
- L85 C28: new ModelingMeshValidationIssue :: report.Add(new ModelingMeshValidationIssue(
- L102 C28: new ModelingMeshValidationIssue :: report.Add(new ModelingMeshValidationIssue(
- L120 C32: new ModelingMeshValidationIssue :: report.Add(new ModelingMeshValidationIssue(
- L139 C32: new ModelingMeshValidationIssue :: report.Add(new ModelingMeshValidationIssue(
- L158 C32: new ModelingMeshValidationIssue :: report.Add(new ModelingMeshValidationIssue(
- L179 C32: new ModelingMeshValidationIssue :: report.Add(new ModelingMeshValidationIssue(
- L195 C36: new ModelingMeshValidationIssue :: report.Add(new ModelingMeshValidationIssue(
- L204 C36: new ModelingMeshValidationIssue :: report.Add(new ModelingMeshValidationIssue(
- L215 C28: new ModelingMeshValidationIssue :: report.Add(new ModelingMeshValidationIssue(
- L230 C32: new ModelingMeshValidationIssue :: report.Add(new ModelingMeshValidationIssue(
- L240 C32: new ModelingMeshValidationIssue :: report.Add(new ModelingMeshValidationIssue(
- L248 C32: new ModelingMeshValidationIssue :: report.Add(new ModelingMeshValidationIssue(
- L276 C24: new ModelingMeshValidationIssue :: report.Add(new ModelingMeshValidationIssue(


## XREngine.Modeling/ModelingOperationOptions.cs
- L16 C63: new() :: public static readonly ModelingOperationOptions Default = new();


## XREngine.Profiler.UI/ProfilerPanelRenderer.cs
- L18 C89: new() :: private readonly Dictionary<string, ProfilerRootMethodAggregate> _rootMethodCache = new();
- L37 C61: new() :: private Dictionary<int, float[]> _lastHistorySnapshot = new();
- L45 C71: new() :: private readonly List<FpsDropSpikePathEntry> _fpsDropSpikePaths = new();
- L47 C61: new() :: private readonly List<int> _fpsDropSpikeSortedIndices = new();
- L53 C79: new() :: private readonly Dictionary<int, ProfilerThreadCacheEntry> _threadCache = new();
- L56 C54: new() :: private readonly List<int> _threadKeysToRemove = new();
- L59 C75: new() :: private readonly List<ProfilerRootMethodAggregate> _cachedGraphList = new();
- L60 C79: new() :: private readonly List<ProfilerRootMethodAggregate> _cachedHierarchyList = new();
- L61 C55: new() :: private readonly List<string> _rootKeysToRemove = new();
- L62 C56: new() :: private readonly List<string> _childKeysToRemove = new();
- L71 C64: new() :: private readonly Dictionary<string, bool> _nodeOpenCache = new();
- L75 C60: new float :: private readonly float[] _vulkanPipelineBindsHistory = new float[RenderStatsHistorySamples];
- L76 C62: new float :: private readonly float[] _vulkanDescriptorBindsHistory = new float[RenderStatsHistorySamples];
- L77 C63: new float :: private readonly float[] _vulkanPipelineSkipRateHistory = new float[RenderStatsHistorySamples];
- L78 C65: new float :: private readonly float[] _vulkanDescriptorSkipRateHistory = new float[RenderStatsHistorySamples];
- L79 C67: new float :: private readonly float[] _vulkanPipelineCacheHitRateHistory = new float[RenderStatsHistorySamples];
- L80 C59: new float :: private readonly float[] _vulkanFrameTotalMsHistory = new float[RenderStatsHistorySamples];
- L81 C63: new float :: private readonly float[] _vulkanFrameWaitFenceMsHistory = new float[RenderStatsHistorySamples];
- L82 C73: new float :: private readonly float[] _vulkanFrameRecordCommandBufferMsHistory = new float[RenderStatsHistorySamples];
- L83 C70: new float :: private readonly float[] _vulkanFrameGpuCommandBufferMsHistory = new float[RenderStatsHistorySamples];
- L84 C59: new float :: private readonly float[] _renderStatsHistoryScratch = new float[RenderStatsHistorySamples];
- L226 C31: new Vector4 :: ImGui.TextColored(new Vector4(0.55f, 0.75f, 1.00f, 1.00f), "Raw Hz");
- L228 C31: new Vector4 :: ImGui.TextColored(new Vector4(1.00f, 0.70f, 0.25f, 1.00f), "Display Hz");
- L236 C66: new Vector4 :: if (isStale) ImGui.PushStyleColor(ImGuiCol.Text, new Vector4(0.65f, 0.65f, 0.70f, 1.0f));
- L263 C25: new Vector2 :: new Vector2(-1f, 44f));
- L346 C13: new Vector2 :: new Vector2(-1f, estH)))
- L725 C13: new Vector2 :: new Vector2(-1f, estH)))
- L740 C26: new DateTime :: var ts = new DateTime(entry.TimestampTicks, DateTimeKind.Utc).ToLocalTime();
- L779 C31: new Vector4 :: ImGui.TextColored(new Vector4(0.2f, 0.9f, 0.2f, 1f), "Status: Connected");
- L786 C35: new Vector4 :: ImGui.TextColored(new Vector4(0.9f, 0.9f, 0.2f, 1f), "Status: Waiting for data...");
- L791 C35: new Vector4 :: ImGui.TextColored(new Vector4(0.9f, 0.3f, 0.3f, 1f), "Status: Disconnected");
- L818 C35: new Vector4 :: ImGui.TextColored(new Vector4(1.0f, 0.7f, 0.2f, 1f),
- L847 C47: new Vector4 :: ImGui.TextColored(new Vector4(0.2f, 0.9f, 0.2f, 1f), "active");
- L849 C47: new Vector4 :: ImGui.TextColored(new Vector4(0.9f, 0.9f, 0.2f, 1f), $"{age:F0}s ago");
- L968 C25: new ProfilerThreadCacheEntry :: entry = new ProfilerThreadCacheEntry { ThreadId = thread.ThreadId };
- L1016 C31: new ProfilerRootMethodAggregate :: agg = new ProfilerRootMethodAggregate { Name = rootNode.Name };
- L1047 C35: new float :: agg.Samples = new float[maxLen];
- L1122 C34: new float :: entry.RawHzSamples = new float[sampleCount];
- L1124 C38: new float :: entry.DisplayHzSamples = new float[sampleCount];
- L1167 C89: new Vector4 :: DrawHzSeriesLine(drawList, rawHzSamples, sampleCount, pMin, pMax, minHz, maxHz, new Vector4(0.55f, 0.75f, 1.00f, 1.00f));
- L1168 C93: new Vector4 :: DrawHzSeriesLine(drawList, displayHzSamples, sampleCount, pMin, pMax, minHz, maxHz, new Vector4(1.00f, 0.70f, 0.25f, 1.00f));
- L1187 C24: new Vector2 :: var curr = new Vector2(
- L1324 C119: new Vector2 :: ImGui.PlotLines($"##{label}", ref _renderStatsHistoryScratch[0], _renderStatsHistoryCount, 0, null, min, max, new Vector2(-1f, 52f));
- L1364 C29: new FpsDropSpikePathEntry :: var candidate = new FpsDropSpikePathEntry(
- L1518 C23: new AggregatedChildNode :: agg = new AggregatedChildNode { Name = child.Name };
- L1595 C32: new AggregatedChildNode :: sorted = visible > 0 ? new AggregatedChildNode[visible] : [];
- L1634 C26: new float :: float[] window = new float[count];
- L1655 C21: new List :: var parts = new List<string>(8) { hottest.Name };
- L1717 C76: new() :: public Dictionary<string, AggregatedChildNode> Children { get; } = new();
- L1732 C50: new() :: public HashSet<int> ThreadIds { get; } = new();
- L1733 C60: new() :: public List<ProfilerNodeData> RootNodes { get; } = new();
- L1738 C76: new() :: public Dictionary<string, AggregatedChildNode> Children { get; } = new();


## XREngine.Profiler/ProfilerImGuiApp.cs
- L42 C18: new ImGuiController :: _imgui = new ImGuiController(_gl, window, _input);
- L50 C21: new UdpProfilerReceiver :: _receiver = new UdpProfilerReceiver(port);
- L51 C21: new ProfilerPanelRenderer :: _renderer = new ProfilerPanelRenderer(_receiver);
- L94 C26: new Vector2 :: io.DisplaySize = new Vector2(width, height);
- L99 C38: new Vector2 :: io.DisplayFramebufferScale = new Vector2(scaleX, scaleY);
- L156 C27: new Vector4 :: statusColor = new Vector4(0.2f, 0.9f, 0.2f, 1.0f);
- L161 C27: new Vector4 :: statusColor = new Vector4(0.9f, 0.9f, 0.2f, 1.0f);
- L166 C27: new Vector4 :: statusColor = new Vector4(0.9f, 0.3f, 0.3f, 1.0f);
- L183 C19: new Vector2 :: var pos = new Vector2(viewport.Pos.X, viewport.Pos.Y + menuBarHeight);
- L184 C20: new Vector2 :: var size = new Vector2(viewport.Size.X, viewport.Size.Y - menuBarHeight);
- L224 C34: new Vector2 :: ImGui.SetCursorScreenPos(new Vector2(centerX - titleSize.X * 0.5f, centerY - 20f));
- L225 C27: new Vector4 :: ImGui.TextColored(new Vector4(0.8f, 0.8f, 0.8f, 1.0f), title);
- L227 C34: new Vector2 :: ImGui.SetCursorScreenPos(new Vector2(centerX - subtitleSize.X * 0.5f, centerY + 10f));
- L228 C27: new Vector4 :: ImGui.TextColored(new Vector4(0.5f, 0.5f, 0.55f, 1.0f), subtitle);
- L240 C32: new Vector2 :: ImGui.SetNextWindowPos(new Vector2(viewport.Pos.X, viewport.Pos.Y + menuBarHeight));
- L241 C33: new Vector2 :: ImGui.SetNextWindowSize(new Vector2(viewport.Size.X, viewport.Size.Y - menuBarHeight));
- L277 C57: new Vector2 :: ImGuiDockBuilderNative.SetNodeSize(dockSpaceId, new Vector2(availableWidth, availableHeight));
- L320 C31: new Vector2 :: style.WindowPadding = new Vector2(8, 8);
- L321 C30: new Vector2 :: style.FramePadding = new Vector2(6, 4);
- L322 C29: new Vector2 :: style.ItemSpacing = new Vector2(8, 6);
- L325 C42: new Vector4 :: colors[(int)ImGuiCol.WindowBg] = new Vector4(0.12f, 0.12f, 0.14f, 1.00f);
- L326 C41: new Vector4 :: colors[(int)ImGuiCol.ChildBg] = new Vector4(0.12f, 0.12f, 0.14f, 1.00f);
- L327 C41: new Vector4 :: colors[(int)ImGuiCol.PopupBg] = new Vector4(0.14f, 0.14f, 0.16f, 0.96f);
- L328 C40: new Vector4 :: colors[(int)ImGuiCol.Border] = new Vector4(0.30f, 0.30f, 0.35f, 0.50f);
- L329 C41: new Vector4 :: colors[(int)ImGuiCol.FrameBg] = new Vector4(0.18f, 0.18f, 0.22f, 1.00f);
- L330 C48: new Vector4 :: colors[(int)ImGuiCol.FrameBgHovered] = new Vector4(0.24f, 0.24f, 0.30f, 1.00f);
- L331 C47: new Vector4 :: colors[(int)ImGuiCol.FrameBgActive] = new Vector4(0.28f, 0.28f, 0.36f, 1.00f);
- L332 C41: new Vector4 :: colors[(int)ImGuiCol.TitleBg] = new Vector4(0.10f, 0.10f, 0.12f, 1.00f);
- L333 C47: new Vector4 :: colors[(int)ImGuiCol.TitleBgActive] = new Vector4(0.14f, 0.14f, 0.18f, 1.00f);
- L334 C43: new Vector4 :: colors[(int)ImGuiCol.MenuBarBg] = new Vector4(0.14f, 0.14f, 0.16f, 1.00f);
- L335 C40: new Vector4 :: colors[(int)ImGuiCol.Header] = new Vector4(0.22f, 0.22f, 0.28f, 1.00f);
- L336 C47: new Vector4 :: colors[(int)ImGuiCol.HeaderHovered] = new Vector4(0.28f, 0.28f, 0.36f, 1.00f);
- L337 C46: new Vector4 :: colors[(int)ImGuiCol.HeaderActive] = new Vector4(0.32f, 0.32f, 0.42f, 1.00f);
- L338 C37: new Vector4 :: colors[(int)ImGuiCol.Tab] = new Vector4(0.16f, 0.16f, 0.20f, 1.00f);
- L339 C44: new Vector4 :: colors[(int)ImGuiCol.TabHovered] = new Vector4(0.28f, 0.28f, 0.36f, 1.00f);
- L340 C43: new Vector4 :: colors[(int)ImGuiCol.TabActive] = new Vector4(0.22f, 0.22f, 0.30f, 1.00f);
- L341 C40: new Vector4 :: colors[(int)ImGuiCol.Button] = new Vector4(0.20f, 0.20f, 0.26f, 1.00f);
- L342 C47: new Vector4 :: colors[(int)ImGuiCol.ButtonHovered] = new Vector4(0.28f, 0.28f, 0.36f, 1.00f);
- L343 C46: new Vector4 :: colors[(int)ImGuiCol.ButtonActive] = new Vector4(0.32f, 0.32f, 0.42f, 1.00f);
- L344 C45: new Vector4 :: colors[(int)ImGuiCol.ScrollbarBg] = new Vector4(0.10f, 0.10f, 0.12f, 1.00f);
- L345 C47: new Vector4 :: colors[(int)ImGuiCol.ScrollbarGrab] = new Vector4(0.24f, 0.24f, 0.30f, 1.00f);
- L346 C54: new Vector4 :: colors[(int)ImGuiCol.ScrollbarGrabHovered] = new Vector4(0.30f, 0.30f, 0.38f, 1.00f);
- L347 C53: new Vector4 :: colors[(int)ImGuiCol.ScrollbarGrabActive] = new Vector4(0.36f, 0.36f, 0.46f, 1.00f);
- L348 C47: new Vector4 :: colors[(int)ImGuiCol.TableHeaderBg] = new Vector4(0.16f, 0.16f, 0.20f, 1.00f);
- L349 C51: new Vector4 :: colors[(int)ImGuiCol.TableBorderStrong] = new Vector4(0.24f, 0.24f, 0.30f, 1.00f);
- L350 C50: new Vector4 :: colors[(int)ImGuiCol.TableBorderLight] = new Vector4(0.20f, 0.20f, 0.26f, 1.00f);
- L351 C44: new Vector4 :: colors[(int)ImGuiCol.TableRowBg] = new Vector4(0.00f, 0.00f, 0.00f, 0.00f);
- L352 C47: new Vector4 :: colors[(int)ImGuiCol.TableRowBgAlt] = new Vector4(1.00f, 1.00f, 1.00f, 0.03f);
- L353 C48: new Vector4 :: colors[(int)ImGuiCol.TextSelectedBg] = new Vector4(0.26f, 0.59f, 0.98f, 0.35f);
- L354 C48: new Vector4 :: colors[(int)ImGuiCol.DockingPreview] = new Vector4(0.26f, 0.59f, 0.98f, 0.70f);
- L355 C48: new Vector4 :: colors[(int)ImGuiCol.DockingEmptyBg] = new Vector4(0.12f, 0.12f, 0.14f, 1.00f);
- L356 C43: new Vector4 :: colors[(int)ImGuiCol.Separator] = new Vector4(0.28f, 0.28f, 0.32f, 0.50f);


## XREngine.Profiler/Program.cs
- L26 C20: new Vector2D :: Size = new Vector2D<int>(1440, 900),
- L27 C19: new GraphicsAPI :: API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(3, 3)),
- L27 C107: new APIVersion :: API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(3, 3)),
- L38 C19: new ProfilerImGuiApp :: app = new ProfilerImGuiApp(window, port);


## XREngine.Profiler/UdpProfilerReceiver.cs
- L72 C84: new() :: private readonly ConcurrentDictionary<int, ProfilerSourceInfo> _knownSources = new();
- L80 C20: new List :: var list = new List<ProfilerSourceInfo>();
- L97 C19: new Thread :: _thread = new Thread(ReceiverLoop)
- L128 C22: new UdpClient :: client = new UdpClient(_port);
- L137 C22: new IPEndPoint :: var remote = new IPEndPoint(IPAddress.Any, 0);
- L200 C38: new ProfilerSourceInfo :: _ => new ProfilerSourceInfo


## XREngine.Server/Authenticator.cs
- L14 C32: new JwtSecurityTokenHandler :: var tokenHandler = new JwtSecurityTokenHandler();
- L16 C35: new SecurityTokenDescriptor :: var tokenDescriptor = new SecurityTokenDescriptor
- L18 C27: new ClaimsIdentity :: Subject = new ClaimsIdentity(
- L23 C38: new SigningCredentials :: SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key), SecurityAlgorithms.HmacSha256Signature)
- L23 C61: new SymmetricSecurityKey :: SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key), SecurityAlgorithms.HmacSha256Signature)
- L32 C32: new JwtSecurityTokenHandler :: var tokenHandler = new JwtSecurityTokenHandler();
- L37 C44: new TokenValidationParameters :: var validationParameters = new TokenValidationParameters
- L40 C40: new SymmetricSecurityKey :: IssuerSigningKey = new SymmetricSecurityKey(key),


## XREngine.Server/Commands/CommandProcessor.Auth.cs
- L68 C66: new string :: command.Parameters.AddWithValue("@sessionToken", new string(sessionToken));
- L126 C36: new byte :: byte[] saltBytes = new byte[16];
- L135 C41: new() :: StringBuilder builder = new();


## XREngine.Server/Commands/CommandProcessor.cs
- L35 C19: new NotImplementedException :: throw new NotImplementedException();
- L40 C19: new NotImplementedException :: throw new NotImplementedException();
- L45 C19: new NotImplementedException :: throw new NotImplementedException();
- L50 C19: new NotImplementedException :: throw new NotImplementedException();
- L55 C19: new NotImplementedException :: throw new NotImplementedException();
- L60 C19: new NotImplementedException :: throw new NotImplementedException();
- L65 C19: new NotImplementedException :: throw new NotImplementedException();
- L70 C19: new NotImplementedException :: throw new NotImplementedException();


## XREngine.Server/Commands/CommandServer.cs
- L63 C26: new byte :: var buffer = new byte[1024];


## XREngine.Server/Controllers/LoadBalancerController.cs
- L27 C26: new Server :: var server = new Server
- L122 C20: new() :: => new()


## XREngine.Server/Instances/ServerInstanceManager.cs
- L18 C82: new() :: private readonly ConcurrentDictionary<Guid, ServerInstance> _instances = new();
- L46 C27: new ServerInstance :: var created = new ServerInstance(id, locator, worldInstance, enableDevRendering);
- L85 C74: new() :: private readonly Dictionary<int, ServerPlayerBinding> _players = new();


## XREngine.Server/Instances/WorldDownloadService.cs
- L24 C41: new HttpClient :: _httpClient = httpClient ?? new HttpClient();
- L69 C29: new() :: XRWorld world = new()
- L118 C31: new StringBuilder :: var builder = new StringBuilder();
- L130 C24: new Uri :: return new Uri(builder.ToString());
- L141 C28: new InvalidOperationException :: _ => throw new InvalidOperationException("World locator did not provide a resolvable download URI.")


## XREngine.Server/LoadBalance/Balancers/ConsistentHashingLoadBalancer.cs
- L10 C47: new() :: private readonly object _circleLock = new();


## XREngine.Server/LoadBalance/LoadBalancerService.cs
- L24 C41: new() :: private readonly object _gate = new();
- L154 C20: new ServerStatus :: return new ServerStatus(


## XREngine.Server/Program.cs
- L80 C32: new WorldDownloadService :: _worldDownloader = new WorldDownloadService();
- L81 C32: new ServerInstanceManager :: _instanceManager = new ServerInstanceManager(_worldDownloader);
- L110 C115: new EditorUnitTests.Settings :: EditorUnitTests.Toggles = JsonConvert.DeserializeObject<EditorUnitTests.Settings>(content) ?? new EditorUnitTests.Settings();
- L124 C32: new RoundRobinLeastLoadBalancer :: var strategy = new RoundRobinLeastLoadBalancer(Array.Empty<Server>());
- L125 C40: new LoadBalancerService :: _loadBalancerService = new LoadBalancerService(strategy, TimeSpan.FromSeconds(60));
- L159 C51: new WorldLocator :: var locator = request.WorldLocator ?? new WorldLocator
- L172 C20: new ServerInstanceContext :: return new ServerInstanceContext(instance.InstanceId, instance.WorldInstance);
- L180 C26: new Server :: var server = new Server
- L201 C25: new XRScene :: var scene = new XRScene("Main Scene");
- L202 C28: new SceneNode :: var rootNode = new SceneNode("Root Node");
- L208 C84: new Vector3 :: EditorUnitTests.Lighting.AddLightProbes(rootNode, 1, 1, 1, 10, 10, 10, new Vector3(0.0f, 50.0f, 0.0f));
- L212 C25: new XRWorld :: var world = new XRWorld("Default World", scene);
- L218 C25: new XRScene :: var scene = new XRScene("Server Console Scene");
- L219 C28: new SceneNode :: var rootNode = new SceneNode("Root Node");
- L230 C30: new SceneNode :: var uiRootNode = new SceneNode("Server UI Root");
- L234 C20: new XRWorld :: return new XRWorld("Server World", scene);
- L253 C31: new Vector3 :: debug.AddLine(new Vector3(x, y, -extent), new Vector3(x, y, extent), color);
- L253 C59: new Vector3 :: debug.AddLine(new Vector3(x, y, -extent), new Vector3(x, y, extent), color);
- L262 C31: new Vector3 :: debug.AddLine(new Vector3(-extent, y, z), new Vector3(extent, y, z), color);
- L262 C59: new Vector3 :: debug.AddLine(new Vector3(-extent, y, z), new Vector3(extent, y, z), color);
- L268 C30: new SceneNode :: var cameraNode = new SceneNode(parentNode, "TestCameraNode");
- L315 C33: new Vector4 :: canvasTfm.Padding = new Vector4(0.0f);
- L338 C32: new Vector2 :: logTfm.MinAnchor = new Vector2(0.0f, 0.0f);
- L339 C32: new Vector2 :: logTfm.MaxAnchor = new Vector2(1.0f, 1.0f);
- L340 C30: new Vector4 :: logTfm.Margins = new Vector4(10.0f, 10.0f, 10.0f, 10.0f);
- L381 C39: new Vector2 :: textTransform.MinAnchor = new Vector2(1.0f, 0.0f);
- L382 C39: new Vector2 :: textTransform.MaxAnchor = new Vector2(1.0f, 0.0f);
- L383 C45: new Vector2 :: textTransform.NormalizedPivot = new Vector2(1.0f, 0.0f);
- L386 C37: new Vector4 :: textTransform.Margins = new Vector4(10.0f, 10.0f, 10.0f, 10.0f);
- L387 C35: new Vector3 :: textTransform.Scale = new Vector3(1.0f);
- L391 C56: new() :: private static readonly Queue<float> _fpsAvg = new();
- L418 C29: new Vector2 :: tfm.MinAnchor = new Vector2(0.5f, 0.5f);
- L419 C29: new Vector2 :: tfm.MaxAnchor = new Vector2(0.5f, 0.5f);
- L420 C35: new Vector2 :: tfm.NormalizedPivot = new Vector2(0.5f, 0.5f);
- L438 C17: new ShaderVector4 :: new ShaderVector4(new ColorF4(0.0f, 1.0f), "MatColor"),
- L438 C35: new ColorF4 :: new ShaderVector4(new ColorF4(0.0f, 1.0f), "MatColor"),
- L439 C17: new ShaderFloat :: new ShaderFloat(10.0f, "BlurStrength"),
- L440 C17: new ShaderInt :: new ShaderInt(30, "SampleCount"),
- L443 C28: new XRMaterial :: var floorMat = new XRMaterial(floorUniforms, [grabTex], floorShader);
- L461 C20: new GameStartupSettings :: return new GameStartupSettings()
- L467 C21: new() :: new()
- L470 C54: new XRWorld :: TargetWorld = targetWorld ?? new XRWorld(),
- L481 C43: new XREngine.Data.Core.OverrideableSetting :: OutputVerbosityOverride = new XREngine.Data.Core.OverrideableSetting<EOutputVerbosity>(EOutputVerbosity.Verbose, true),
- L487 C39: new UserSettings :: DefaultUserSettings = new UserSettings()


## XREngine.Server/VirtualizedConsoleUIComponent.cs
- L13 C66: new() :: private readonly ConcurrentQueue<string> _pendingLines = new();
- L225 C56: new Vector2 :: BoundableTransform.LocalPivotTranslation = new Vector2(0, yOffset);
- L302 C31: new ConsoleWriter :: => Console.SetOut(new ConsoleWriter(this));
- L314 C36: new TraceWriter :: => Trace.Listeners.Add(new TraceWriter(this));


## XREngine.UnitTests/Animation/AnimStateMachineNetworkingTests.cs
- L20 C29: new AnimStateMachineComponent :: var component = new AnimStateMachineComponent();
- L22 C27: new List :: var entries = new List<AnimStateMachine.AnimParameterSchemaEntry>
- L48 C29: new AnimStateMachineComponent :: var component = new AnimStateMachineComponent();
- L51 C26: new List :: var schema = new List<AnimStateMachine.AnimParameterSchemaEntry>
- L65 C25: new byte :: var bytes = new byte[(totalBits + 7) / 8];
- L90 C35: new AnimBool :: sm.Variables[name1] = new AnimBool(name1, false);
- L91 C35: new AnimBool :: sm.Variables[name2] = new AnimBool(name2, false);
- L96 C29: new AnimStateMachineComponent :: var component = new AnimStateMachineComponent { StateMachine = sm };
- L99 C32: new[] :: string[] ordered = new[] { name1, name2 }.OrderBy(n => n, StringComparer.Ordinal).ToArray();
- L108 C25: new byte :: var bytes = new byte[(totalBits + 7) / 8];
- L123 C22: new AnimStateMachine :: var sm = new AnimStateMachine
- L125 C29: new EventDictionary :: Variables = new EventDictionary<string, AnimVar>()
- L132 C28: new MemoryStream :: using var ms = new MemoryStream();
- L133 C29: new BinaryWriter :: using (var bw = new BinaryWriter(ms, Encoding.UTF8, leaveOpen: true))
- L156 C35: new InvalidOperationException :: throw new InvalidOperationException($"Unsupported schema type: {entry.Type}");
- L179 C24: new Dictionary :: var seen = new Dictionary<ushort, string>();
- L185 C31: new AnimBool :: ushort hash = new AnimBool(name, false).Hash;
- L193 C19: new AssertionException :: throw new AssertionException($"Failed to find a 16-bit hash collision within {maxAttempts} attempts.");


## XREngine.UnitTests/Audio/AudioProcessorTests.cs
- L21 C35: new PassthroughProcessor :: using var processor = new PassthroughProcessor();
- L22 C34: new AudioEffectsSettings :: processor.Initialize(new AudioEffectsSettings { SampleRate = 44100, FrameSize = 1024 });
- L24 C46: new AudioEffectsSourceSettings :: var handle = processor.AddSource(new AudioEffectsSourceSettings());
- L40 C35: new PassthroughProcessor :: using var processor = new PassthroughProcessor();
- L41 C34: new AudioEffectsSettings :: processor.Initialize(new AudioEffectsSettings());
- L43 C46: new AudioEffectsSourceSettings :: var handle = processor.AddSource(new AudioEffectsSourceSettings());
- L52 C35: new PassthroughProcessor :: using var processor = new PassthroughProcessor();
- L64 C35: new PassthroughProcessor :: using var processor = new PassthroughProcessor();
- L65 C34: new AudioEffectsSettings :: processor.Initialize(new AudioEffectsSettings());
- L67 C42: new AudioEffectsSourceSettings :: var h1 = processor.AddSource(new AudioEffectsSourceSettings());
- L68 C42: new AudioEffectsSourceSettings :: var h2 = processor.AddSource(new AudioEffectsSourceSettings());
- L78 C35: new PassthroughProcessor :: using var processor = new PassthroughProcessor();
- L79 C34: new AudioEffectsSettings :: processor.Initialize(new AudioEffectsSettings());
- L81 C46: new AudioEffectsSourceSettings :: var handle = processor.AddSource(new AudioEffectsSourceSettings());
- L91 C35: new PassthroughProcessor :: using var processor = new PassthroughProcessor();
- L94 C34: new AudioEffectsSettings :: processor.Initialize(new AudioEffectsSettings { SampleRate = 48000, FrameSize = 512 });
- L178 C31: new AudioManager :: var manager = new AudioManager
- L205 C31: new AudioManager :: var manager = new AudioManager
- L236 C31: new AudioManager :: var manager = new AudioManager
- L270 C29: new SteamAudioProcessor :: processor = new SteamAudioProcessor();
- L271 C38: new AudioEffectsSettings :: processor.Initialize(new AudioEffectsSettings { SampleRate = 44100, FrameSize = 1024 });
- L298 C29: new SteamAudioProcessor :: processor = new SteamAudioProcessor();
- L299 C38: new AudioEffectsSettings :: processor.Initialize(new AudioEffectsSettings { SampleRate = 44100, FrameSize = 1024 });
- L312 C45: new AudioEffectsSourceSettings :: var h = processor.AddSource(new AudioEffectsSourceSettings
- L314 C32: new Vector3 :: Position = new Vector3(5, 0, 0),
- L333 C29: new SteamAudioProcessor :: processor = new SteamAudioProcessor();
- L334 C38: new AudioEffectsSettings :: processor.Initialize(new AudioEffectsSettings { SampleRate = 44100, FrameSize = 1024 });
- L349 C45: new AudioEffectsSourceSettings :: var h = processor.AddSource(new AudioEffectsSourceSettings());
- L350 C44: new Vector3 :: processor.SetSourcePose(h, new Vector3(3, 0, 0), -Vector3.UnitZ);
- L363 C29: new SteamAudioProcessor :: processor = new SteamAudioProcessor();
- L364 C38: new AudioEffectsSettings :: processor.Initialize(new AudioEffectsSettings { SampleRate = 44100, FrameSize = 256 });
- L379 C45: new AudioEffectsSourceSettings :: var h = processor.AddSource(new AudioEffectsSourceSettings
- L381 C32: new Vector3 :: Position = new Vector3(5, 0, 0),
- L388 C29: new float :: var input = new float[256];
- L393 C30: new float :: var output = new float[512];
- L419 C29: new SteamAudioProcessor :: processor = new SteamAudioProcessor();
- L420 C38: new AudioEffectsSettings :: processor.Initialize(new AudioEffectsSettings { SampleRate = 44100, FrameSize = 1024 });
- L434 C38: new AudioEffectsSettings :: processor.Initialize(new AudioEffectsSettings { SampleRate = 48000, FrameSize = 512 });


## XREngine.UnitTests/Audio/OpenALRegressionTests.cs
- L26 C29: new ListenerContext :: _listener = new ListenerContext();
- L67 C23: new Vector3 :: var pos = new Vector3(1.5f, 2.5f, -3.0f);
- L78 C23: new Vector3 :: var vel = new Vector3(0.1f, -0.2f, 0.3f);
- L89 C45: new Vector3 :: var forward = Vector3.Normalize(new Vector3(1, 0, -1));
- L90 C22: new Vector3 :: var up = new Vector3(0, 1, 0);
- L161 C31: new short :: short[] silence = new short[4410]; // ~100ms @ 44100 mono16
- L216 C23: new Vector3 :: var pos = new Vector3(10, 20, 30);
- L301 C28: new short :: short[] data = new short[1024];
- L312 C28: new short :: short[] data = new short[2048];
- L323 C27: new byte :: byte[] data = new byte[512];
- L341 C31: new short :: short[] silence = new short[4410];
- L363 C31: new short :: short[] silence = new short[4410];
- L401 C44: new Vector3 :: float gain = Listener.CalcGain(new Vector3(1, 0, 0), referenceDistance: 1.0f, maxDistance: 100f, rolloffFactor: 1.0f);
- L405 C38: new Vector3 :: gain = Listener.CalcGain(new Vector3(2, 0, 0), referenceDistance: 1.0f, maxDistance: 100f, rolloffFactor: 1.0f);
- L502 C23: new AudioManager :: var mgr = new AudioManager();


## XREngine.UnitTests/Core/AssetCacheTests.cs
- L18 C29: new AssetCacheSandbox :: using var sandbox = new AssetCacheSandbox();
- L19 C23: new AssetManager :: var manager = new AssetManager();


## XREngine.UnitTests/Core/AssetPackerTests.cs
- L53 C42: new UTF8Encoding :: File.WriteAllText(path, content, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false));
- L95 C24: new[] :: paths.ShouldBe(new[] { "a.txt", "nested/b.txt" });
- L360 C27: new byte :: byte[] original = new byte[256 * 1024];
- L361 C19: new Random :: var rng = new Random(42);


## XREngine.UnitTests/Core/EventListTests.cs
- L15 C20: new EventList :: var list = new EventList<int>();
- L33 C20: new EventList :: var list = new EventList<int> { 1 };
- L41 C48: new[] :: Assert.That(list.ToArray(), Is.EqualTo(new[] { 1, 2, 3 }));
- L47 C20: new EventList :: var list = new EventList<int>([1, 2, 3, 4]);
- L55 C45: new[] :: Assert.That(postRemoved, Is.EqualTo(new[] { 2, 4 }));
- L56 C48: new[] :: Assert.That(list.ToArray(), Is.EqualTo(new[] { 1, 3 }));
- L62 C20: new EventList :: var list = new EventList<int>([1, 2, 3, 4, 5, 6]);
- L70 C45: new[] :: Assert.That(postRemoved, Is.EqualTo(new[] { 2, 6 }));
- L71 C48: new[] :: Assert.That(list.ToArray(), Is.EqualTo(new[] { 1, 3, 4, 5 }));
- L77 C20: new EventList :: var list = new EventList<int>(allowDuplicates: false, allowNull: true) { 1 };
- L81 C48: new[] :: Assert.That(list.ToArray(), Is.EqualTo(new[] { 1, 2, 3 }));
- L87 C22: new EventList :: IList list = new EventList<int>(allowDuplicates: false, allowNull: true);


## XREngine.UnitTests/Core/ProfilerProtocolTests.cs
- L20 C24: new ProfilerFramePacket :: var original = new ProfilerFramePacket
- L25 C17: new ProfilerThreadData :: new ProfilerThreadData
- L31 C25: new ProfilerNodeData :: new ProfilerNodeData
- L37 C33: new ProfilerNodeData :: new ProfilerNodeData { Name = "Physics", ElapsedMs = 1.5f, Children = [] }
- L40 C25: new ProfilerNodeData :: new ProfilerNodeData { Name = "Render", ElapsedMs = 1.5f, Children = [] }
- L43 C17: new ProfilerThreadData :: new ProfilerThreadData
- L47 C34: new ProfilerNodeData :: RootNodes = [new ProfilerNodeData { Name = "Audio", ElapsedMs = 1.0f, Children = [] }]
- L50 C29: new Dictionary :: ThreadHistory = new Dictionary<int, float[]>
- L69 C41: new[] :: clone.ThreadHistory[1].ShouldBe(new[] { 1.0f, 2.0f, 3.0f });
- L75 C24: new ProfilerFramePacket :: var original = new ProfilerFramePacket { FrameTime = 0.0f, Threads = [], ThreadHistory = [] };
- L86 C24: new RenderStatsPacket :: var original = new RenderStatsPacket
- L103 C17: new RenderMatrixListenerEntry :: new RenderMatrixListenerEntry { Name = "MeshRenderer", Count = 500 },
- L104 C17: new RenderMatrixListenerEntry :: new RenderMatrixListenerEntry { Name = "LightProbe", Count = 200 }
- L135 C24: new ThreadAllocationsPacket :: var original = new ThreadAllocationsPacket
- L137 C22: new AllocationSlice :: Render = new AllocationSlice { LastBytes = 1024, AverageBytes = 900.5, MaxBytes = 2048, Samples = 120, Capacity = 240 },
- L138 C27: new AllocationSlice :: CollectSwap = new AllocationSlice { LastBytes = 512, AverageBytes = 400.0, MaxBytes = 1024, Samples = 60, Capacity = 240 },
- L139 C22: new AllocationSlice :: Update = new AllocationSlice { LastBytes = 2048, AverageBytes = 1800.0, MaxBytes = 4096, Samples = 200, Capacity = 240 },
- L140 C27: new AllocationSlice :: FixedUpdate = new AllocationSlice { LastBytes = 256, AverageBytes = 200.0, MaxBytes = 512, Samples = 30, Capacity = 240 },
- L158 C24: new BvhMetricsPacket :: var original = new BvhMetricsPacket
- L184 C24: new JobSystemStatsPacket :: var original = new JobSystemStatsPacket
- L193 C17: new JobPriorityStatsEntry :: new JobPriorityStatsEntry { Priority = 0, PriorityName = "Lowest", QueuedAny = 5, QueuedMain = 1, QueuedCollect = 0, AvgWaitMs = 12.5 },
- L194 C17: new JobPriorityStatsEntry :: new JobPriorityStatsEntry { Priority = 4, PriorityName = "Highest", QueuedAny = 0, QueuedMain = 0, QueuedCollect = 0, AvgWaitMs = 0.1 },
- L214 C24: new MainThreadInvokesPacket :: var original = new MainThreadInvokesPacket
- L218 C17: new MainThreadInvokeEntryData :: new MainThreadInvokeEntryData
- L241 C24: new MainThreadInvokesPacket :: var original = new MainThreadInvokesPacket { Entries = [] };
- L251 C24: new HeartbeatPacket :: var original = new HeartbeatPacket
- L271 C25: new byte :: byte[] buffer = new byte[ProfilerProtocol.MaxDatagramSize];
- L293 C30: new byte :: byte[] hugePayload = new byte[ProfilerProtocol.MaxPayloadSize + 1];
- L294 C25: new byte :: byte[] buffer = new byte[ProfilerProtocol.MaxDatagramSize];
- L304 C24: new ProfilerFramePacket :: var original = new ProfilerFramePacket
- L309 C17: new ProfilerThreadData :: new ProfilerThreadData
- L313 C34: new ProfilerNodeData :: RootNodes = [new ProfilerNodeData { Name = "Tick", ElapsedMs = 8.0f, Children = [] }]
- L316 C29: new Dictionary :: ThreadHistory = new Dictionary<int, float[]> { [5] = [8.0f] }
- L323 C25: new byte :: byte[] buffer = new byte[ProfilerProtocol.MaxDatagramSize];


## XREngine.UnitTests/Core/XRAssetMemoryPackCoverageTests.cs
- L31 C30: new TestCaseData :: yield return new TestCaseData(type)
- L58 C30: new HashSet :: var assemblies = new HashSet<Assembly>();


## XREngine.UnitTests/Core/XRAssetSerializationTests.cs
- L14 C24: new StubAsset :: var original = new StubAsset
- L34 C24: new StubAsset :: var original = new StubAsset
- L54 C20: new List :: var list = new List<XRAsset>
- L56 C13: new StubAsset :: new StubAsset { Name = "A", Payload = "p1", Value = 1 },
- L57 C13: new StubAsset :: new StubAsset { Name = "B", Payload = "p2", Value = 2 }
- L75 C20: new Dictionary :: var dict = new Dictionary<string, XRAsset>
- L77 C25: new StubAsset :: ["first"] = new StubAsset { Name = "One", Payload = "p-one", Value = 11 },
- L78 C26: new StubAsset :: ["second"] = new StubAsset { Name = "Two", Payload = "p-two", Value = 22 }
- L81 C59: new StubAssetContainer :: byte[] bytes = XRAssetMemoryPackAdapter.Serialize(new StubAssetContainer { Assets = dict });
- L102 C67: new() :: public Dictionary<string, XRAsset> Assets { get; set; } = new();


## XREngine.UnitTests/Editor/AssetCookingTests.cs
- L30 C27: new GameStartupSettings :: var startup = new GameStartupSettings


## XREngine.UnitTests/Editor/CommonAssetsArchiveTests.cs
- L42 C13: new FileInfo :: new FileInfo(archiveOutputPath).Length.ShouldBeGreaterThan(0, "Cooked archive is empty.");
- L78 C15: new DirectoryNotFoundException :: throw new DirectoryNotFoundException("Unable to locate repository root containing XRENGINE.sln.");


## XREngine.UnitTests/GpuTestBase.cs
- L107 C24: new Vector2D :: options.Size = new Vector2D<int>(
- L111 C23: new GraphicsAPI :: options.API = new GraphicsAPI(
- L115 C13: new APIVersion :: new APIVersion(4, 6));
- L176 C25: new CancellationTokenSource :: using var cts = new CancellationTokenSource(timeoutMs);
- L213 C25: new CancellationTokenSource :: using var cts = new CancellationTokenSource(timeoutMs);
- L260 C19: new InvalidOperationException :: throw new InvalidOperationException($"Compute program linking failed:\n{infoLog}");
- L277 C19: new InvalidOperationException :: throw new InvalidOperationException($"{type} compilation failed:\n{infoLog}");
- L295 C19: new InvalidOperationException :: throw new InvalidOperationException($"Program linking failed:\n{infoLog}");


## XREngine.UnitTests/Mcp/McpDocsParityTests.cs
- L50 C18: new StringBuilder :: var sb = new StringBuilder();
- L75 C15: new DirectoryNotFoundException :: throw new DirectoryNotFoundException("Unable to locate repository root containing XRENGINE.sln.");


## XREngine.UnitTests/Mcp/McpRateLimiterTests.cs
- L14 C23: new McpRateLimiter :: var limiter = new McpRateLimiter();
- L28 C23: new McpRateLimiter :: var limiter = new McpRateLimiter();


## XREngine.UnitTests/Mcp/McpServerHostProtocolTests.cs
- L19 C18: new InvalidOperationException :: ?? throw new InvalidOperationException("HandleRpcAsync method not found.");
- L23 C18: new InvalidOperationException :: ?? throw new InvalidOperationException("TryResolveCorsOrigin method not found.");
- L27 C18: new InvalidOperationException :: ?? throw new InvalidOperationException("ReadRequestBodyAsync method not found.");
- L31 C18: new InvalidOperationException :: ?? throw new InvalidOperationException("CanInvokeTool method not found.");
- L37 C74: new EditorPreferences :: object result = await InvokeHandleRpcAsync(document.RootElement, new EditorPreferences());
- L49 C74: new EditorPreferences :: object result = await InvokeHandleRpcAsync(document.RootElement, new EditorPreferences());
- L59 C74: new EditorPreferences :: object result = await InvokeHandleRpcAsync(document.RootElement, new EditorPreferences());
- L69 C74: new EditorPreferences :: object result = await InvokeHandleRpcAsync(document.RootElement, new EditorPreferences());
- L79 C21: new EditorPreferences :: var prefs = new EditorPreferences { McpServerIncludeStatusInPing = true };
- L90 C25: new object :: var allowCall = new object?[] { "https://app.local", "https://app.local;https://tools.local", null };
- L96 C24: new object :: var denyCall = new object?[] { "https://evil.local", "https://app.local", null };
- L104 C28: new MemoryStream :: using var stream = new MemoryStream(new byte[8]);
- L104 C45: new byte :: using var stream = new MemoryStream(new byte[8]);
- L118 C28: new MemoryStream :: using var stream = new MemoryStream(new byte[16]);
- L118 C45: new byte :: using var stream = new MemoryStream(new byte[16]);
- L119 C25: new CancellationTokenSource :: using var cts = new CancellationTokenSource();
- L134 C21: new EditorPreferences :: var prefs = new EditorPreferences { McpServerReadOnly = true };
- L135 C20: new object :: var call = new object?[] { "create_scene_node", prefs, null };


## XREngine.UnitTests/Modeling/EditableMeshTopologyOperatorTests.cs
- L18 C42: new EdgeKey :: int splitVertex = mesh.SplitEdge(new EdgeKey(0, 1), 0.5f);
- L21 C44: new EdgeKey :: bool collapsed = mesh.CollapseEdge(new EdgeKey(0, splitVertex));
- L33 C48: new[] :: List<int> extruded = mesh.ExtrudeFaces(new[] { 0 }, 0.25f);
- L36 C43: new[] :: List<int> inset = mesh.InsetFaces(new[] { 0 }, 0.35f);
- L39 C71: new EdgeKey :: int edgeIndex = mesh.Edges.ToList().FindIndex(edge => edge == new EdgeKey(0, 1));
- L42 C45: new[] :: List<int> beveled = mesh.BevelEdges(new[] { edgeIndex }, 0.1f);
- L54 C50: new EdgeKey :: List<int> created = mesh.LoopCutFromEdge(new EdgeKey(0, 1), 0.5f);
- L66 C76: new EdgeKey :: int firstEdgeIndex = mesh.Edges.ToList().FindIndex(edge => edge == new EdgeKey(0, 1));
- L83 C13: new Vector3 :: new Vector3(0f, 0f, 0f),
- L84 C13: new Vector3 :: new Vector3(1f, 0f, 0f),
- L85 C13: new Vector3 :: new Vector3(1f, 1f, 0f),
- L86 C13: new Vector3 :: new Vector3(0f, 1f, 0f)
- L90 C16: new EditableMesh :: return new EditableMesh(vertices, indices);
- L97 C13: new Vector3 :: new Vector3(0f, 0f, 0f),
- L98 C13: new Vector3 :: new Vector3(1f, 0f, 0f),
- L99 C13: new Vector3 :: new Vector3(0f, 1f, 0f),
- L100 C13: new Vector3 :: new Vector3(2f, 0f, 0f),
- L101 C13: new Vector3 :: new Vector3(3f, 0f, 0f),
- L102 C13: new Vector3 :: new Vector3(2f, 1f, 0f)
- L106 C16: new EditableMesh :: return new EditableMesh(vertices, indices);


## XREngine.UnitTests/Physics/ConvexHullUtilityTests.cs
- L51 C28: new CoACD.ConvexHullMesh :: var expectedHull = new CoACD.ConvexHullMesh(
- L52 C13: new[] :: new[] { Vector3.Zero, Vector3.UnitX, Vector3.UnitY, Vector3.UnitZ },
- L53 C13: new[] :: new[] { 0, 1, 2, 0, 2, 3 });
- L74 C13: new CoACD.ConvexHullMesh :: new CoACD.ConvexHullMesh(
- L75 C17: new[] :: new[] { Vector3.Zero, Vector3.UnitX, Vector3.UnitY },
- L76 C17: new[] :: new[] { 0, 1, 2 })
- L89 C20: new SceneNode :: var node = new SceneNode("ConvexHullTests");
- L99 C13: new Vector3 :: new Vector3(0f, 0f, 0f),
- L100 C13: new Vector3 :: new Vector3(1f, 0f, 0f),
- L101 C13: new Vector3 :: new Vector3(0f, 1f, 0f),
- L102 C13: new Vector3 :: new Vector3(0f, 1f, 0f),
- L103 C13: new Vector3 :: new Vector3(1f, 0f, 0f),
- L104 C13: new Vector3 :: new Vector3(1f, 1f, 0f));
- L106 C19: new SubMeshLOD :: var lod = new SubMeshLOD(material: null, mesh, maxVisibleDistance: 0f);
- L107 C23: new SubMesh :: var subMesh = new SubMesh(lod);
- L108 C27: new Model :: component.Model = new Model(subMesh);
- L113 C47: new() :: private readonly StubRunner _runner = new();


## XREngine.UnitTests/Physics/GPUPhysicsChainComponentTests.cs
- L23 C24: new SceneNode :: var rootNode = new SceneNode("GPUPhysicsChainRoot");
- L24 C24: new Transform :: var rootBone = new Transform();
- L27 C21: new Transform :: var bones = new Transform[boneCount];
- L32 C24: new Transform :: var bone = new Transform();
- L34 C32: new Vector3 :: bone.Translation = new Vector3(0, -boneLength, 0);
- L52 C29: new Vector3 :: component.Gravity = new Vector3(0, -9.8f, 0);
- L65 C17: new GPUPhysicsChainComponent :: var c = new GPUPhysicsChainComponent();
- L110 C19: new GPUPhysicsChainComponent :: var gpu = new GPUPhysicsChainComponent();
- L111 C19: new PhysicsChainComponent :: var cpu = new PhysicsChainComponent();
- L120 C23: new Vector3 :: var gravity = new Vector3(0, -10f, 0);
- L122 C21: new Vector3 :: var force = new Vector3(1, 0, 0);
- L138 C19: new GPUPhysicsChainComponent :: var gpu = new GPUPhysicsChainComponent();
- L139 C19: new PhysicsChainComponent :: var cpu = new PhysicsChainComponent();
- L140 C24: new Transform :: var rootBone = new Transform();
- L154 C25: new GPUPhysicsChainComponent :: var component = new GPUPhysicsChainComponent();
- L155 C21: new AnimationCurve :: var curve = new AnimationCurve();
- L180 C29: new Transform :: var characterRoot = new Transform();
- L191 C29: new Vector3 :: component.Gravity = new Vector3(0, -10f, 0);
- L192 C27: new Vector3 :: component.Force = new Vector3(1, 0, 0);
- L229 C29: new Transform :: var characterRoot = new Transform();


## XREngine.UnitTests/Physics/GPUPhysicsChainDispatcherTests.cs
- L22 C24: new SceneNode :: var rootNode = new SceneNode($"DispatcherTestRoot_{Guid.NewGuid():N}");
- L23 C24: new Transform :: var rootBone = new Transform();
- L26 C21: new Transform :: var bones = new Transform[boneCount];
- L31 C24: new Transform :: var bone = new Transform();
- L33 C32: new Vector3 :: bone.Translation = new Vector3(0, -boneLength, 0);
- L48 C29: new Vector3 :: component.Gravity = new Vector3(0, -9.8f, 0);
- L142 C26: new List :: var components = new List<GPUPhysicsChainComponent>();
- L143 C21: new List :: var nodes = new List<SceneNode>();
- L230 C25: new List :: var particles = new List<GPUPhysicsChainDispatcher.GPUParticleData>
- L232 C13: new() :: new() { Position = Vector3.Zero, ParentIndex = -1 },
- L233 C32: new Vector3 :: new() { Position = new Vector3(0, -0.1f, 0), ParentIndex = 0 }
- L233 C13: new() :: new() { Position = new Vector3(0, -0.1f, 0), ParentIndex = 0 }
- L236 C21: new List :: var trees = new List<GPUPhysicsChainDispatcher.GPUParticleTreeData>
- L238 C36: new Vector3 :: new() { LocalGravity = new Vector3(0, -9.8f, 0), ParticleStart = 0, ParticleCount = 2 }
- L238 C13: new() :: new() { LocalGravity = new Vector3(0, -9.8f, 0), ParticleStart = 0, ParticleCount = 2 }
- L241 C26: new List :: var transforms = new List<Matrix4x4> { Matrix4x4.Identity, Matrix4x4.Identity };
- L242 C25: new List :: var colliders = new List<GPUPhysicsChainDispatcher.GPUColliderData>();
- L254 C22: new Vector3 :: gravity: new Vector3(0, -9.8f, 0),
- L271 C26: new List :: var components = new List<GPUPhysicsChainComponent>();
- L272 C21: new List :: var nodes = new List<SceneNode>();
- L287 C29: new List :: var particles = new List<GPUPhysicsChainDispatcher.GPUParticleData>
- L289 C17: new() :: new() { Position = Vector3.Zero, ParentIndex = -1 }
- L292 C25: new List :: var trees = new List<GPUPhysicsChainDispatcher.GPUParticleTreeData>
- L294 C17: new() :: new() { ParticleStart = 0, ParticleCount = 1 }
- L304 C31: new Vector3 :: Vector3.Zero, new Vector3(0, -9.8f, 0), Vector3.Zero,


## XREngine.UnitTests/Physics/JoltIntegrationPhase12Tests.cs
- L22 C18: new JoltScene :: _scene = new JoltScene();
- L36 C13: new IPhysicsGeometry.Sphere :: new IPhysicsGeometry.Sphere(0.25f),
- L40 C13: new LayerMask :: new LayerMask(1 << layerBit));
- L49 C13: new IPhysicsGeometry.Sphere :: new IPhysicsGeometry.Sphere(0.3f),
- L53 C13: new LayerMask :: new LayerMask(1 << layerBit));
- L85 C41: new Vector3 :: var bodyA = CreateDynamicSphere(new Vector3(-1.0f, 0.0f, 0.0f), 1);
- L86 C41: new Vector3 :: var bodyB = CreateDynamicSphere(new Vector3(1.0f, 0.0f, 0.0f), 1);
- L98 C28: new Vector3 :: CreateStaticSphere(new Vector3(2.5f, 0.0f, 0.0f), 5);
- L99 C27: new Vector3 :: Segment ray = new(new Vector3(2.0f, 0.0f, 0.0f), new Vector3(3.0f, 0.0f, 0.0f));
- L99 C58: new Vector3 :: Segment ray = new(new Vector3(2.0f, 0.0f, 0.0f), new Vector3(3.0f, 0.0f, 0.0f));
- L101 C49: new LayerMask :: bool included = _scene!.RaycastAny(ray, new LayerMask(1 << 5), null, out _);
- L102 C48: new LayerMask :: bool excluded = _scene.RaycastAny(ray, new LayerMask(1 << 2), null, out _);


## XREngine.UnitTests/Physics/PhysicsChainComponentTests.cs
- L23 C24: new SceneNode :: var rootNode = new SceneNode("PhysicsChainRoot");
- L24 C24: new Transform :: var rootBone = new Transform();
- L27 C21: new Transform :: var bones = new Transform[boneCount];
- L32 C24: new Transform :: var bone = new Transform();
- L34 C32: new Vector3 :: bone.Translation = new Vector3(0, -boneLength, 0);
- L52 C29: new Vector3 :: component.Gravity = new Vector3(0, -9.8f, 0);
- L64 C17: new PhysicsChainComponent :: var c = new PhysicsChainComponent();
- L194 C31: new Vector3 :: component.EndOffset = new Vector3(0, -0.05f, 0);
- L208 C25: new PhysicsChainComponent :: var component = new PhysicsChainComponent();
- L209 C21: new AnimationCurve :: var curve = new AnimationCurve();
- L234 C29: new Transform :: var characterRoot = new Transform();
- L245 C29: new Vector3 :: component.Gravity = new Vector3(0, -10f, 0);
- L246 C27: new Vector3 :: component.Force = new Vector3(1, 0, 0);
- L267 C29: new Transform :: var characterRoot = new Transform();


## XREngine.UnitTests/Physics/PhysicsChainComputeIntegrationTests.cs
- L122 C36: new[] :: var expectedUniforms = new[]
- L181 C33: new float :: float[] particles = new float[particleCount * particleStride];
- L185 C27: new Vector3 :: position: new Vector3(0, 0, 0),
- L186 C31: new Vector3 :: prevPosition: new Vector3(0, 0, 0),
- L187 C36: new Vector3 :: transformPosition: new Vector3(0, 0, 0),
- L188 C41: new Vector3 :: transformLocalPosition: new Vector3(0, 0, 0),
- L195 C27: new Vector3 :: position: new Vector3(0, -0.1f, 0),
- L196 C31: new Vector3 :: prevPosition: new Vector3(0, -0.1f, 0),
- L197 C36: new Vector3 :: transformPosition: new Vector3(0, -0.1f, 0),
- L198 C41: new Vector3 :: transformLocalPosition: new Vector3(0, -0.1f, 0),
- L204 C33: new float :: float[] treesData = new float[28]; // 28 floats per tree
- L206 C31: new Vector3 :: localGravity: new Vector3(1, 0, 0),
- L213 C34: new float :: float[] transforms = new float[particleCount * 16];
- L247 C33: new float :: float[] colliders = new float[12]; // 1 dummy collider
- L276 C31: new float :: float[] results = new float[particles.Length];
- L298 C32: new Vector3 :: childPosition: new Vector3(0, -0.1f, 0),
- L299 C36: new Vector3 :: childPrevPosition: new Vector3(0, -0.1f, 0),
- L300 C41: new Vector3 :: childTransformPosition: new Vector3(0, -0.1f, 0),
- L302 C26: new Vector3 :: gravity: new Vector3(1, 0, 0),
- L353 C33: new float :: float[] particles = new float[2 * particleStride];
- L357 C27: new Vector3 :: position: new Vector3(0, 0, 0),
- L358 C31: new Vector3 :: prevPosition: new Vector3(0, 0, 0),
- L359 C36: new Vector3 :: transformPosition: new Vector3(0, 0, 0),
- L360 C41: new Vector3 :: transformLocalPosition: new Vector3(0, 0, 0),
- L367 C27: new Vector3 :: position: new Vector3(0.05f, 0, 0), // Inside the sphere at origin
- L368 C31: new Vector3 :: prevPosition: new Vector3(0.05f, 0, 0),
- L369 C36: new Vector3 :: transformPosition: new Vector3(0.1f, 0, 0),
- L370 C41: new Vector3 :: transformLocalPosition: new Vector3(0.1f, 0, 0),
- L376 C33: new float :: float[] treesData = new float[28];
- L385 C34: new float :: float[] transforms = new float[2 * 16];
- L395 C33: new float :: float[] colliders = new float[12];
- L433 C31: new float :: float[] results = new float[particles.Length];


## XREngine.UnitTests/Physics/PhysicsJointComponentTests.cs
- L24 C99: new() :: private static SceneNode CreateNodeWithJoint<T>(out T joint) where T : PhysicsJointComponent, new()
- L26 C20: new SceneNode :: var node = new SceneNode($"{typeof(T).Name}TestNode");
- L27 C27: new Transform :: node.SetTransform(new Transform());
- L127 C17: new Vector3 :: var v = new Vector3(1, 2, 3);
- L149 C17: new Vector3 :: var v = new Vector3(-1, 5, 0);
- L303 C17: new FixedJointComponent :: var c = new FixedJointComponent();
- L1003 C17: new Vector3 :: var v = new Vector3(1, 2, 3);
- L1021 C17: new Vector3 :: var v = new Vector3(10, 0, 0);
- L1030 C17: new Vector3 :: var v = new Vector3(0, 1, 0);
- L1091 C32: new Vector3 :: j.AnchorPosition = new Vector3(0, 1, 0);
- L1162 C37: new Vector3 :: j.DriveTargetPosition = new Vector3(1, 2, 3);
- L1164 C37: new Vector3 :: j.DriveLinearVelocity = new Vector3(1, 0, 0);
- L1165 C38: new Vector3 :: j.DriveAngularVelocity = new Vector3(0, 1, 0);
- L1187 C24: new SceneNode :: var handNode = new SceneNode("VRHand");
- L1188 C31: new Transform :: handNode.SetTransform(new Transform());
- L1190 C26: new SceneNode :: var objectNode = new SceneNode("GrabbedObject");
- L1191 C33: new Transform :: objectNode.SetTransform(new Transform());
- L1209 C32: new Vector3 :: joint.AnchorPosition = new Vector3(0, 0.05f, 0); // offset from center
- L1220 C39: new Vector3 :: joint.AnchorPosition.ShouldBe(new Vector3(0, 0.05f, 0));
- L1228 C26: new SceneNode :: var objectNode = new SceneNode("GrabbedObject");
- L1229 C33: new Transform :: objectNode.SetTransform(new Transform());
- L1250 C26: new SceneNode :: var objectNode = new SceneNode("GrabbedObject");
- L1251 C33: new Transform :: objectNode.SetTransform(new Transform());
- L1263 C37: new Vector3 :: joint.DriveTargetPosition = new Vector3(0.5f, 1.2f, -0.3f);
- L1270 C44: new Vector3 :: joint.DriveTargetPosition.ShouldBe(new Vector3(0.5f, 1.2f, -0.3f));


## XREngine.UnitTests/Rendering/GpuBackendParityTests.cs
- L55 C13: new GPUIndirectRenderCommand :: new GPUIndirectRenderCommand { MeshID = 10, MaterialID = 100, RenderPass = 1 },
- L56 C13: new GPUIndirectRenderCommand :: new GPUIndirectRenderCommand { MeshID = 11, MaterialID = 101, RenderPass = 1 },
- L57 C13: new GPUIndirectRenderCommand :: new GPUIndirectRenderCommand { MeshID = 12, MaterialID = 102, RenderPass = 2 },
- L74 C13: new GPUIndirectRenderCommand :: new GPUIndirectRenderCommand { MeshID = 10, MaterialID = 100, RenderPass = 1 },
- L75 C13: new GPUIndirectRenderCommand :: new GPUIndirectRenderCommand { MeshID = 11, MaterialID = 101, RenderPass = 1 },
- L92 C13: new GPUIndirectRenderCommand :: new GPUIndirectRenderCommand { MeshID = 10, MaterialID = 100, RenderPass = 1 },
- L93 C13: new GPUIndirectRenderCommand :: new GPUIndirectRenderCommand { MeshID = 11, MaterialID = 101, RenderPass = 1 },
- L110 C13: new GPUIndirectRenderCommand :: new GPUIndirectRenderCommand { MeshID = 10, MaterialID = 100, RenderPass = 1 },
- L111 C13: new GPUIndirectRenderCommand :: new GPUIndirectRenderCommand { MeshID = 11, MaterialID = 101, RenderPass = 1 },
- L116 C13: new GPUIndirectRenderCommand :: new GPUIndirectRenderCommand { MeshID = 10, MaterialID = 100, RenderPass = 1 },
- L117 C13: new GPUIndirectRenderCommand :: new GPUIndirectRenderCommand { MeshID = 99, MaterialID = 101, RenderPass = 1 },


## XREngine.UnitTests/Rendering/GpuBvhAndIndirectIntegrationTests.cs
- L30 C13: new static :: private new static void AssertHardwareComputeOrInconclusive(GL gl)
- L264 C17: new Vector4 :: new Vector4(0, 0, 0, 1), new Vector4(1, 1, 1, 1),
- L264 C42: new Vector4 :: new Vector4(0, 0, 0, 1), new Vector4(1, 1, 1, 1),
- L265 C17: new Vector4 :: new Vector4(2, 0, 0, 1), new Vector4(3, 1, 1, 1),
- L265 C42: new Vector4 :: new Vector4(2, 0, 0, 1), new Vector4(3, 1, 1, 1),
- L266 C17: new Vector4 :: new Vector4(0, 2, 0, 1), new Vector4(1, 3, 1, 1),
- L266 C42: new Vector4 :: new Vector4(0, 2, 0, 1), new Vector4(1, 3, 1, 1),
- L267 C17: new Vector4 :: new Vector4(-1, -1, -1, 1), new Vector4(0, 0, 0, 1),
- L267 C45: new Vector4 :: new Vector4(-1, -1, -1, 1), new Vector4(0, 0, 0, 1),
- L283 C31: new uint :: uint[] nodeData = new uint[nodeScalars];
- L286 C29: new uint :: uint[] ranges = new uint[nodeCount * 2u];
- L292 C31: new uint :: uint[] counters = new uint[nodeCount];
- L295 C34: new float :: float[] transforms = new float[numPrimitives * 16u];
- L568 C38: new float :: float[] culledCommands = new float[numCommands * COMMAND_FLOATS];
- L614 C36: new uint :: uint[] indirectDraws = new uint[numCommands * 5];
- L620 C34: new uint :: uint[] submeshData = new uint[numCommands * 4];
- L723 C38: new float :: float[] culledCommands = new float[numCommands * COMMAND_FLOATS];
- L747 C36: new uint :: uint[] indirectDraws = new uint[numCommands * 5];
- L752 C34: new uint :: uint[] submeshData = new uint[numCommands * 4];
- L847 C37: new float :: float[] inputCommands = new float[numCommands * COMMAND_FLOATS];
- L850 C55: new Vector3 :: SetupCullingTestCommand(inputCommands, 0, new Vector3(0, 0, -5), 1f, layerMask: 1, renderPass: 0);
- L853 C55: new Vector3 :: SetupCullingTestCommand(inputCommands, 1, new Vector3(2, 0, -5), 1f, layerMask: 1, renderPass: 0);
- L856 C55: new Vector3 :: SetupCullingTestCommand(inputCommands, 2, new Vector3(-100, 0, -5), 1f, layerMask: 1, renderPass: 0);
- L859 C55: new Vector3 :: SetupCullingTestCommand(inputCommands, 3, new Vector3(0, 0, 10), 1f, layerMask: 1, renderPass: 0);
- L865 C17: new Vector3 :: new Vector3(0, 0, 0),
- L866 C17: new Vector3 :: new Vector3(0, 0, -1),
- L886 C38: new float :: float[] outputCommands = new float[numCommands * COMMAND_FLOATS];
- L904 C28: new uint :: uint[] stats = new uint[20];
- L916 C37: new float :: float[] planeData = new float[24];
- L1059 C28: new uint :: uint[] stats = new uint[20];
- L1164 C38: new float :: float[] culledCommands = new float[numCommands * COMMAND_FLOATS];
- L1167 C49: new Vector3 :: SetupTestCommand(culledCommands, 0, new Vector3(0, 0, -1), 1f);
- L1168 C49: new Vector3 :: SetupTestCommand(culledCommands, 1, new Vector3(0, 0, -2), 1f);
- L1169 C49: new Vector3 :: SetupTestCommand(culledCommands, 2, new Vector3(0, 0, -3), 1f);
- L1195 C34: new uint :: uint[] keyIndexOut = new uint[numCommands * KEY_UINTS];
- L1277 C34: new float :: float[] inCommands = new float[numCommands * COMMAND_FLOATS];
- L1299 C35: new float :: float[] outCommands = new float[numCommands * COMMAND_FLOATS];
- L1309 C28: new uint :: uint[] debug = new uint[16];
- L1385 C37: new float :: float[] inputCommands = new float[numCommands * COMMAND_FLOATS];
- L1386 C55: new Vector3 :: SetupCullingTestCommand(inputCommands, 0, new Vector3(0, 0, -5), 1f, layerMask: 1, renderPass: 0);
- L1387 C55: new Vector3 :: SetupCullingTestCommand(inputCommands, 1, new Vector3(2, 0, -5), 1f, layerMask: 1, renderPass: 0);
- L1388 C55: new Vector3 :: SetupCullingTestCommand(inputCommands, 2, new Vector3(-100, 0, -5), 1f, layerMask: 1, renderPass: 0);
- L1389 C55: new Vector3 :: SetupCullingTestCommand(inputCommands, 3, new Vector3(0, 0, 10), 1f, layerMask: 1, renderPass: 0);
- L1392 C53: new Vector3 :: Matrix4x4 view = Matrix4x4.CreateLookAt(new Vector3(0, 0, 0), new Vector3(0, 0, -1), Vector3.UnitY);
- L1392 C75: new Vector3 :: Matrix4x4 view = Matrix4x4.CreateLookAt(new Vector3(0, 0, 0), new Vector3(0, 0, -1), Vector3.UnitY);
- L1407 C38: new float :: float[] culledCommands = new float[numCommands * COMMAND_FLOATS];
- L1422 C28: new uint :: uint[] stats = new uint[20];
- L1431 C37: new float :: float[] planeData = new float[24];
- L1502 C36: new uint :: uint[] indirectDraws = new uint[numCommands * 5];
- L1507 C34: new uint :: uint[] submeshData = new uint[numCommands * 4];
- L1619 C28: new System.Text.RegularExpressions.Regex :: var includeRegex = new System.Text.RegularExpressions.Regex(
- L1662 C21: new System.Text.RegularExpressions.Regex :: var regex = new System.Text.RegularExpressions.Regex(
- L1706 C26: new float :: float[] planes = new float[24]; // 6 planes * 4 floats (a, b, c, d)
- L1844 C28: new Vector4 :: Vector4[] planes = new Vector4[6];
- L1847 C21: new Vector4 :: planes[0] = new Vector4(
- L1854 C21: new Vector4 :: planes[1] = new Vector4(
- L1861 C21: new Vector4 :: planes[2] = new Vector4(
- L1868 C21: new Vector4 :: planes[3] = new Vector4(
- L1875 C21: new Vector4 :: planes[4] = new Vector4(
- L1882 C21: new Vector4 :: planes[5] = new Vector4(


## XREngine.UnitTests/Rendering/GpuCullingPipelineTests.cs
- L51 C19: new FileNotFoundException :: throw new FileNotFoundException($"Shader file not found: {fullPath}");
- L195 C26: new Vector3 :: var normal = new Vector3(plane.X, plane.Y, plane.Z);
- L203 C22: new Vector4 :: var planes = new Vector4[6];
- L209 C21: new Vector4 :: planes[0] = new Vector4(m.M14 + m.M11, m.M24 + m.M21, m.M34 + m.M31, m.M44 + m.M41);
- L211 C21: new Vector4 :: planes[1] = new Vector4(m.M14 - m.M11, m.M24 - m.M21, m.M34 - m.M31, m.M44 - m.M41);
- L213 C21: new Vector4 :: planes[2] = new Vector4(m.M14 + m.M12, m.M24 + m.M22, m.M34 + m.M32, m.M44 + m.M42);
- L215 C21: new Vector4 :: planes[3] = new Vector4(m.M14 - m.M12, m.M24 - m.M22, m.M34 - m.M32, m.M44 - m.M42);
- L217 C21: new Vector4 :: planes[4] = new Vector4(m.M14 + m.M13, m.M24 + m.M23, m.M34 + m.M33, m.M44 + m.M43);
- L219 C21: new Vector4 :: planes[5] = new Vector4(m.M14 - m.M13, m.M24 - m.M23, m.M34 - m.M33, m.M44 - m.M43);
- L224 C26: new Vector3 :: var normal = new Vector3(planes[i].X, planes[i].Y, planes[i].Z);
- L243 C18: new Vector3 :: eye: new Vector3(0, 0, 5),
- L263 C18: new Vector3 :: eye: new Vector3(0, 0, 5),
- L275 C45: new Vector3 :: bool visible = TestSphereVisibility(new Vector3(0, 0, 10), 1f, planes);
- L283 C18: new Vector3 :: eye: new Vector3(0, 0, 5),
- L295 C45: new Vector3 :: bool visible = TestSphereVisibility(new Vector3(0, 0, -200), 1f, planes);
- L303 C18: new Vector3 :: eye: new Vector3(0, 0, 5),
- L315 C45: new Vector3 :: bool visible = TestSphereVisibility(new Vector3(10, 0, -5), 12f, planes);
- L332 C26: new Vector3 :: var normal = new Vector3(plane.X, plane.Y, plane.Z);
- L349 C18: new Vector3 :: eye: new Vector3(0, 0, 10),
- L359 C19: new AABB :: var box = new AABB(new Vector3(-1), new Vector3(1));
- L359 C28: new Vector3 :: var box = new AABB(new Vector3(-1), new Vector3(1));
- L359 C45: new Vector3 :: var box = new AABB(new Vector3(-1), new Vector3(1));
- L369 C18: new Vector3 :: eye: new Vector3(0, 0, 10),
- L379 C19: new AABB :: var box = new AABB(new Vector3(-100, -1, -1), new Vector3(-90, 1, 1));
- L379 C28: new Vector3 :: var box = new AABB(new Vector3(-100, -1, -1), new Vector3(-90, 1, 1));
- L379 C55: new Vector3 :: var box = new AABB(new Vector3(-100, -1, -1), new Vector3(-90, 1, 1));
- L389 C26: new Vector3 :: var normal = new Vector3(plane.X, plane.Y, plane.Z);
- L392 C27: new Vector3 :: var pVertex = new Vector3(
- L413 C24: new CullingCounters :: var counters = new CullingCounters();
- L425 C24: new CullingCounters :: var counters = new CullingCounters();
- L440 C24: new CullingCounters :: var counters = new CullingCounters
- L559 C19: new AABB :: var box = new AABB(new Vector3(-1, -1, -5), new Vector3(1, 1, -5));
- L559 C28: new Vector3 :: var box = new AABB(new Vector3(-1, -1, -5), new Vector3(1, 1, -5));
- L559 C53: new Vector3 :: var box = new AABB(new Vector3(-1, -1, -5), new Vector3(1, 1, -5));
- L562 C21: new Vector3 :: target: new Vector3(0, 0, -1),
- L579 C23: new[] :: var corners = new[]
- L581 C13: new Vector3 :: new Vector3(box.Min.X, box.Min.Y, box.Min.Z),
- L582 C13: new Vector3 :: new Vector3(box.Max.X, box.Min.Y, box.Min.Z),
- L583 C13: new Vector3 :: new Vector3(box.Min.X, box.Max.Y, box.Min.Z),
- L584 C13: new Vector3 :: new Vector3(box.Max.X, box.Max.Y, box.Min.Z),
- L585 C13: new Vector3 :: new Vector3(box.Min.X, box.Min.Y, box.Max.Z),
- L586 C13: new Vector3 :: new Vector3(box.Max.X, box.Min.Y, box.Max.Z),
- L587 C13: new Vector3 :: new Vector3(box.Min.X, box.Max.Y, box.Max.Z),
- L588 C13: new Vector3 :: new Vector3(box.Max.X, box.Max.Y, box.Max.Z)
- L591 C25: new Vector2 :: var screenMin = new Vector2(float.MaxValue);
- L592 C25: new Vector2 :: var screenMax = new Vector2(float.MinValue);
- L596 C42: new Vector4 :: var clip = Vector4.Transform(new Vector4(corner, 1), viewProjection);
- L599 C23: new Vector2 :: var ndc = new Vector2(clip.X / clip.W, clip.Y / clip.W);
- L660 C23: new uint :: var indices = new uint[10];
- L713 C22: new[] :: var stages = new[]
- L740 C23: new float :: var centerX = new float[commandCount];
- L741 C23: new float :: var centerY = new float[commandCount];
- L742 C23: new float :: var centerZ = new float[commandCount];
- L743 C22: new float :: var radius = new float[commandCount];
- L767 C20: new Vector4 :: var row0 = new Vector4[commandCount];
- L768 C20: new Vector4 :: var row1 = new Vector4[commandCount];
- L769 C20: new Vector4 :: var row2 = new Vector4[commandCount];
- L770 C20: new Vector4 :: var row3 = new Vector4[commandCount];
- L773 C19: new Vector4 :: row0[0] = new Vector4(1, 0, 0, 0);
- L774 C19: new Vector4 :: row1[0] = new Vector4(0, 1, 0, 0);
- L775 C19: new Vector4 :: row2[0] = new Vector4(0, 0, 1, 0);
- L776 C19: new Vector4 :: row3[0] = new Vector4(0, 0, 0, 1);


## XREngine.UnitTests/Rendering/GpuIndirectPhase10HardeningTests.cs
- L93 C15: new DirectoryNotFoundException :: throw new DirectoryNotFoundException($"Could not find workspace root from base directory '{AppContext.BaseDirectory}'.");


## XREngine.UnitTests/Rendering/GpuIndirectPhase2Tests.cs
- L36 C20: new GPURenderPassCollection :: var pass = new GPURenderPassCollection(renderPass: 0);
- L44 C31: new XREngine.Rendering.XRDataBuffer :: var fakeCountBuffer = new XREngine.Rendering.XRDataBuffer(
- L68 C20: new GPURenderPassCollection :: var pass = new GPURenderPassCollection(renderPass: 0);


## XREngine.UnitTests/Rendering/GpuIndirectPhase3PolicyTests.cs
- L114 C15: new FileNotFoundException :: throw new FileNotFoundException($"Could not resolve workspace path for '{relativePath}' from test base directory '{AppContext.BaseDirectory}'.");


## XREngine.UnitTests/Rendering/GpuIndirectPhase3ScaffoldTests.cs
- L13 C24: new XREngine.Engine.Rendering.EngineSettings :: var settings = new XREngine.Engine.Rendering.EngineSettings();
- L21 C24: new XREngine.Engine.Rendering.EngineSettings :: var settings = new XREngine.Engine.Rendering.EngineSettings();
- L36 C20: new GPURenderPassCollection :: var pass = new GPURenderPassCollection(renderPass: 0);


## XREngine.UnitTests/Rendering/GpuIndirectPhase4HotLayoutTests.cs
- L165 C15: new FileNotFoundException :: throw new FileNotFoundException($"Could not resolve workspace path for '{relativePath}' from test base directory '{AppContext.BaseDirectory}'.");


## XREngine.UnitTests/Rendering/GpuIndirectPhase5DescriptorFastPathTests.cs
- L64 C31: new GPUMaterialEntry :: table.AddOrUpdate(2u, new GPUMaterialEntry { Flags = 1u });
- L65 C32: new GPUMaterialEntry :: table.AddOrUpdate(12u, new GPUMaterialEntry { Flags = 1u });
- L96 C15: new FileNotFoundException :: throw new FileNotFoundException($"Could not resolve workspace path for '{relativePath}' from test base directory '{AppContext.BaseDirectory}'.");


## XREngine.UnitTests/Rendering/GpuIndirectPhase6SortingTests.cs
- L86 C15: new FileNotFoundException :: throw new FileNotFoundException($"Could not resolve workspace path for '{relativePath}' from test base directory '{AppContext.BaseDirectory}'.");


## XREngine.UnitTests/Rendering/GpuIndirectPhase9ValidationTests.cs
- L32 C13: new GPUIndirectRenderCommand :: new GPUIndirectRenderCommand { MeshID = 100, MaterialID = 200, RenderPass = 0 },
- L33 C13: new GPUIndirectRenderCommand :: new GPUIndirectRenderCommand { MeshID = 101, MaterialID = 201, RenderPass = 0 },
- L34 C13: new GPUIndirectRenderCommand :: new GPUIndirectRenderCommand { MeshID = 102, MaterialID = 202, RenderPass = 1 },
- L35 C13: new GPUIndirectRenderCommand :: new GPUIndirectRenderCommand { MeshID = 103, MaterialID = 203, RenderPass = 1 },
- L178 C15: new DirectoryNotFoundException :: throw new DirectoryNotFoundException($"Could not find workspace root from base directory '{AppContext.BaseDirectory}'.");


## XREngine.UnitTests/Rendering/GpuIndirectRenderDispatchTests.cs
- L52 C19: new FileNotFoundException :: throw new FileNotFoundException($"Shader file not found: {fullPath}");
- L179 C19: new DrawElementsIndirectCommand :: var cmd = new DrawElementsIndirectCommand
- L195 C19: new DrawElementsIndirectCommand :: var cmd = new DrawElementsIndirectCommand();
- L207 C19: new DrawElementsIndirectCommand :: var cmd = new DrawElementsIndirectCommand
- L227 C19: new DrawElementsIndirectCommand :: var cmd = new DrawElementsIndirectCommand
- L412 C25: new uint :: uint[] buffer = new uint[1] { expectedDrawCount };
- L477 C27: new uint :: var materialIds = new uint[] { 1, 1, 1, 1, 1 };
- L491 C27: new uint :: var materialIds = new uint[] { 1, 1, 2, 2, 2, 3 };
- L521 C27: new uint :: var materialIds = new uint[] { 1, 2, 1, 2, 1, 2 };
- L541 C23: new List :: var batches = new List<DrawBatch>();
- L550 C29: new DrawBatch :: batches.Add(new DrawBatch
- L568 C21: new DrawBatch :: batches.Add(new DrawBatch
- L692 C24: new GPURenderPassCollection.IndirectDebugSettings :: var settings = new GPURenderPassCollection.IndirectDebugSettings();
- L702 C24: new GPURenderPassCollection.IndirectDebugSettings :: var settings = new GPURenderPassCollection.IndirectDebugSettings
- L713 C24: new GPURenderPassCollection.IndirectDebugSettings :: var settings = new GPURenderPassCollection.IndirectDebugSettings
- L728 C19: new GPUIndirectRenderCommand :: var cmd = new GPUIndirectRenderCommand
- L733 C24: new Vector3 :: var localPos = new Vector3(1, 2, 3);
- L744 C19: new GPUIndirectRenderCommand :: var cmd = new GPUIndirectRenderCommand
- L749 C24: new Vector3 :: var localPos = new Vector3(1, 2, 3);
- L760 C19: new GPUIndirectRenderCommand :: var cmd = new GPUIndirectRenderCommand
- L765 C24: new Vector3 :: var localPos = new Vector3(1, 2, 3);
- L779 C19: new GPUIndirectRenderCommand :: var cmd = new GPUIndirectRenderCommand
- L786 C24: new Vector3 :: var localPos = new Vector3(0, 0, 0);
- L804 C30: new Vector3 :: var objectPosition = new Vector3(0, 0, -50); // 50 units away
- L817 C30: new Vector3 :: var objectPosition = new Vector3(0, 0, -150); // 150 units away
- L833 C30: new Vector3 :: var objectPosition = new Vector3(0, 0, -50);


## XREngine.UnitTests/Rendering/GpuRenderingBacklogTests.cs
- L25 C21: new GPUScene :: var scene = new GPUScene();
- L38 C25: new IndexTriangle :: faceIndices.Add(new IndexTriangle(0, 1, 2));
- L67 C27: new AABB :: var localBounds = new AABB(new Vector3(-1f, -1f, -1f), new Vector3(1f, 1f, 1f));
- L67 C36: new Vector3 :: var localBounds = new AABB(new Vector3(-1f, -1f, -1f), new Vector3(1f, 1f, 1f));
- L67 C64: new Vector3 :: var localBounds = new AABB(new Vector3(-1f, -1f, -1f), new Vector3(1f, 1f, 1f));
- L85 C20: new GPURenderPassCollection :: var pass = new GPURenderPassCollection(renderPass: 0);
- L86 C21: new GPUScene :: var scene = new GPUScene
- L89 C27: new StubBvhProvider :: BvhProvider = new StubBvhProvider(isReady: true)
- L92 C57: new XRRenderProgram :: SetPrivateField(pass, "_bvhFrustumCullProgram", new XRRenderProgram());
- L110 C20: new GPURenderPassCollection :: var pass = new GPURenderPassCollection(renderPass: 0);
- L132 C27: new CpuRenderOcclusionCoordinator :: var coordinator = new CpuRenderOcclusionCoordinator();
- L133 C22: new XRCamera :: var camera = new XRCamera();
- L148 C27: new CpuRenderOcclusionCoordinator :: var coordinator = new CpuRenderOcclusionCoordinator();
- L176 C13: new GPUIndirectRenderCommand :: new GPUIndirectRenderCommand { MeshID = 1, MaterialID = 10, RenderPass = 0 },
- L177 C13: new GPUIndirectRenderCommand :: new GPUIndirectRenderCommand { MeshID = 2, MaterialID = 11, RenderPass = 0 },
- L191 C13: new GPUIndirectRenderCommand :: new GPUIndirectRenderCommand { MeshID = 101, MaterialID = 201, RenderPass = 1 },
- L192 C13: new GPUIndirectRenderCommand :: new GPUIndirectRenderCommand { MeshID = 102, MaterialID = 202, RenderPass = 1 },
- L193 C13: new GPUIndirectRenderCommand :: new GPUIndirectRenderCommand { MeshID = 103, MaterialID = 203, RenderPass = 1 },
- L207 C13: new GPUIndirectRenderCommand :: new GPUIndirectRenderCommand { MeshID = 501, MaterialID = 11, RenderPass = 0 },
- L208 C13: new GPUIndirectRenderCommand :: new GPUIndirectRenderCommand { MeshID = 502, MaterialID = 12, RenderPass = 1 },
- L209 C13: new GPUIndirectRenderCommand :: new GPUIndirectRenderCommand { MeshID = 503, MaterialID = 13, RenderPass = 2 },
- L210 C13: new GPUIndirectRenderCommand :: new GPUIndirectRenderCommand { MeshID = 504, MaterialID = 14, RenderPass = 2 },
- L224 C13: new GPUViewDescriptor :: new GPUViewDescriptor { ViewId = 0, Flags = (uint)(GPUViewFlags.StereoEyeLeft | GPUViewFlags.FullRes | GPUViewFlags.UsesSharedVisibility) },
- L225 C13: new GPUViewDescriptor :: new GPUViewDescriptor { ViewId = 1, Flags = (uint)(GPUViewFlags.StereoEyeRight | GPUViewFlags.FullRes | GPUViewFlags.UsesSharedVisibility) },
- L226 C13: new GPUViewDescriptor :: new GPUViewDescriptor { ViewId = 2, Flags = (uint)(GPUViewFlags.StereoEyeLeft | GPUViewFlags.Foveated | GPUViewFlags.UsesSharedVisibility) },
- L227 C13: new GPUViewDescriptor :: new GPUViewDescriptor { ViewId = 3, Flags = (uint)(GPUViewFlags.StereoEyeRight | GPUViewFlags.Foveated | GPUViewFlags.UsesSharedVisibility) },
- L228 C13: new GPUViewDescriptor :: new GPUViewDescriptor { ViewId = 4, Flags = (uint)(GPUViewFlags.Mirror | GPUViewFlags.UsesSharedVisibility) },
- L244 C13: new GPUIndirectRenderCommand :: new GPUIndirectRenderCommand { MeshID = 1001, MaterialID = 2001, RenderPass = 0 },
- L245 C13: new GPUIndirectRenderCommand :: new GPUIndirectRenderCommand { MeshID = 1002, MaterialID = 2002, RenderPass = 0 },
- L287 C24: new XREngine.Engine.Rendering.EngineSettings :: var settings = new XREngine.Engine.Rendering.EngineSettings();
- L340 C15: new FileNotFoundException :: throw new FileNotFoundException($"Unable to locate file '{relativePath}' from '{AppContext.BaseDirectory}'.");


## XREngine.UnitTests/Rendering/GpuSceneBvhTests.cs
- L52 C19: new FileNotFoundException :: throw new FileNotFoundException($"Shader file not found: {fullPath}");
- L231 C24: new GpuBvhNode :: var leafNode = new GpuBvhNode
- L253 C25: new[] :: var positions = new[]
- L255 C13: new Vector3 :: new Vector3(0, 0, 0),
- L256 C13: new Vector3 :: new Vector3(1, 0, 0),
- L257 C13: new Vector3 :: new Vector3(0, 1, 0),
- L258 C13: new Vector3 :: new Vector3(0, 0, 1),
- L259 C13: new Vector3 :: new Vector3(1, 1, 1)
- L262 C27: new uint :: var mortonCodes = new uint[positions.Length];
- L265 C78: new Vector3 :: mortonCodes[i] = CalculateMortonCode(positions[i], Vector3.Zero, new Vector3(2f));
- L269 C27: new HashSet :: var uniqueCodes = new HashSet<uint>(mortonCodes);
- L277 C20: new Vector3 :: var pos1 = new Vector3(0.1f, 0.1f, 0.1f);
- L278 C20: new Vector3 :: var pos2 = new Vector3(0.11f, 0.11f, 0.11f);
- L279 C20: new Vector3 :: var pos3 = new Vector3(0.9f, 0.9f, 0.9f);
- L282 C24: new Vector3 :: var sceneMax = new Vector3(1f);
- L369 C17: new AABB :: var a = new AABB(new Vector3(-1, -1, -1), new Vector3(1, 1, 1));
- L369 C26: new Vector3 :: var a = new AABB(new Vector3(-1, -1, -1), new Vector3(1, 1, 1));
- L369 C51: new Vector3 :: var a = new AABB(new Vector3(-1, -1, -1), new Vector3(1, 1, 1));
- L370 C17: new AABB :: var b = new AABB(new Vector3(0, 0, 0), new Vector3(2, 2, 2));
- L370 C26: new Vector3 :: var b = new AABB(new Vector3(0, 0, 0), new Vector3(2, 2, 2));
- L370 C48: new Vector3 :: var b = new AABB(new Vector3(0, 0, 0), new Vector3(2, 2, 2));
- L386 C24: new AABB :: var unitCube = new AABB(Vector3.Zero, Vector3.One);
- L391 C21: new AABB :: var cube2 = new AABB(Vector3.Zero, new Vector3(2f));
- L391 C44: new Vector3 :: var cube2 = new AABB(Vector3.Zero, new Vector3(2f));
- L405 C19: new AABB :: var box = new AABB(new Vector3(-1, -1, -1), new Vector3(1, 1, 1));
- L405 C28: new Vector3 :: var box = new AABB(new Vector3(-1, -1, -1), new Vector3(1, 1, 1));
- L405 C53: new Vector3 :: var box = new AABB(new Vector3(-1, -1, -1), new Vector3(1, 1, 1));
- L408 C27: new Vector3 :: box.ContainsPoint(new Vector3(0.5f, 0.5f, 0.5f)).ShouldBeTrue();
- L409 C27: new Vector3 :: box.ContainsPoint(new Vector3(2f, 0f, 0f)).ShouldBeFalse();
- L415 C17: new AABB :: var a = new AABB(new Vector3(-1, -1, -1), new Vector3(1, 1, 1));
- L415 C26: new Vector3 :: var a = new AABB(new Vector3(-1, -1, -1), new Vector3(1, 1, 1));
- L415 C51: new Vector3 :: var a = new AABB(new Vector3(-1, -1, -1), new Vector3(1, 1, 1));
- L416 C17: new AABB :: var b = new AABB(new Vector3(0, 0, 0), new Vector3(2, 2, 2));
- L416 C26: new Vector3 :: var b = new AABB(new Vector3(0, 0, 0), new Vector3(2, 2, 2));
- L416 C48: new Vector3 :: var b = new AABB(new Vector3(0, 0, 0), new Vector3(2, 2, 2));
- L417 C17: new AABB :: var c = new AABB(new Vector3(5, 5, 5), new Vector3(6, 6, 6));
- L417 C26: new Vector3 :: var c = new AABB(new Vector3(5, 5, 5), new Vector3(6, 6, 6));
- L417 C48: new Vector3 :: var c = new AABB(new Vector3(5, 5, 5), new Vector3(6, 6, 6));
- L440 C19: new GPUIndirectRenderCommand :: var cmd = new GPUIndirectRenderCommand();
- L441 C22: new Vector3 :: var center = new Vector3(1f, 2f, 3f);
- L455 C19: new GPUIndirectRenderCommand :: var cmd = new GPUIndirectRenderCommand
- L468 C19: new GPUIndirectRenderCommand :: var cmd = new GPUIndirectRenderCommand();
- L492 C28: new Vector3 :: var sphereCenter = new Vector3(0, 0, -10); // In front of camera
- L509 C28: new Vector3 :: var sphereCenter = new Vector3(0, 0, 5); // Behind camera (positive Z)
- L526 C28: new Vector3 :: var sphereCenter = new Vector3(0, 0, -200); // Way past far plane
- L544 C28: new Vector3 :: var sphereCenter = new Vector3(10, 0, -10);
- L559 C22: new Vector4 :: var planes = new Vector4[6];
- L562 C21: new Vector4 :: planes[0] = new Vector4(0, 0, -1, -nearZ); // points into frustum
- L565 C21: new Vector4 :: planes[1] = new Vector4(0, 0, 1, farZ);
- L576 C21: new Vector4 :: planes[2] = new Vector4(cosAngle, 0, -sinAngle, 0);
- L578 C21: new Vector4 :: planes[3] = new Vector4(-cosAngle, 0, -sinAngle, 0);
- L580 C21: new Vector4 :: planes[4] = new Vector4(0, -cosAngle, -sinAngle, 0);
- L582 C21: new Vector4 :: planes[5] = new Vector4(0, cosAngle, -sinAngle, 0);
- L594 C26: new Vector3 :: var normal = new Vector3(plane.X, plane.Y, plane.Z);


## XREngine.UnitTests/Rendering/IndirectMultiDrawTests.cs
- L23 C13: new static :: private new static bool ShowWindow
- L52 C13: new static :: private new static int ShowWindowDurationMs
- L78 C24: new Vector2D :: options.Size = new Vector2D<int>(Width, Height);
- L80 C23: new GraphicsAPI :: options.API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(4, 6));
- L80 C111: new APIVersion :: options.API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(4, 6));
- L226 C24: new Vector2D :: options.Size = new Vector2D<int>(Width, Height);
- L228 C23: new GraphicsAPI :: options.API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(4, 6));
- L228 C111: new APIVersion :: options.API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(4, 6));
- L383 C24: new Vector2D :: options.Size = new Vector2D<int>(Width, Height);
- L385 C23: new GraphicsAPI :: options.API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(4, 6));
- L385 C111: new APIVersion :: options.API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(4, 6));
- L569 C24: new float :: float[] data = new float[16 * 6];
- L611 C26: new uint :: uint[] indices = new uint[8 * indicesPerCube];
- L626 C13: new() :: new()
- L634 C13: new() :: new()
- L647 C43: new Vector3 :: var view = Matrix4x4.CreateLookAt(new Vector3(0f, 0f, 4f), Vector3.Zero, Vector3.UnitY);
- L680 C42: new Vector4 :: Vector4 clip = Vector4.Transform(new Vector4(position, 1f), mvp);
- L732 C24: new float :: float[] data = new float[8 * 8 * 6]; // 8 cubes, 8 vertices, 6 floats per vertex
- L768 C26: new uint :: uint[] indices = new uint[8 * 36]; // 8 cubes, 36 indices each
- L782 C50: new DrawElementsIndirectCommand :: DrawElementsIndirectCommand[] commands = new DrawElementsIndirectCommand[4];
- L789 C34: new DrawElementsIndirectCommand :: commands[batchIdx] = new DrawElementsIndirectCommand
- L805 C43: new Vector3 :: var view = Matrix4x4.CreateLookAt(new Vector3(0f, 0f, 6f), Vector3.Zero, Vector3.UnitY);


## XREngine.UnitTests/Rendering/IndirectRenderingAdditionalTests.cs
- L43 C24: new Vector2D :: options.Size = new Vector2D<int>(Width, Height);
- L45 C23: new GraphicsAPI :: options.API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(4, 6));
- L45 C111: new APIVersion :: options.API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(4, 6));
- L117 C36: new float :: float[] readbackVertices = new float[expandedVertices.Length];
- L205 C24: new Vector2D :: options.Size = new Vector2D<int>(Width, Height);
- L207 C23: new GraphicsAPI :: options.API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(4, 6));
- L207 C111: new APIVersion :: options.API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(4, 6));
- L345 C31: new Dictionary :: var uniformMetadata = new Dictionary<string, (GLEnum Type, int Size)>
- L375 C31: new Dictionary :: var uniformMetadata = new Dictionary<string, (GLEnum Type, int Size)>
- L427 C24: new Vector2D :: options.Size = new Vector2D<int>(Width, Height);
- L429 C23: new GraphicsAPI :: options.API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(4, 6));
- L429 C111: new APIVersion :: options.API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(4, 6));
- L475 C13: new() :: new() { Count = 3, InstanceCount = 1, FirstIndex = 0, BaseVertex = 0, BaseInstance = 0 },
- L476 C13: new() :: new() { Count = 3, InstanceCount = 1, FirstIndex = 3, BaseVertex = 0, BaseInstance = 1 }
- L521 C28: new byte :: byte[] leftPixel = new byte[4];
- L526 C29: new byte :: byte[] rightPixel = new byte[4];
- L575 C24: new Vector2D :: options.Size = new Vector2D<int>(Width, Height);
- L577 C23: new GraphicsAPI :: options.API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(4, 6));
- L577 C111: new APIVersion :: options.API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(4, 6));
- L633 C24: new Vector2D :: options.Size = new Vector2D<int>(Width, Height);
- L635 C23: new GraphicsAPI :: options.API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(4, 6));
- L635 C111: new APIVersion :: options.API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(4, 6));
- L707 C24: new Vector2D :: options.Size = new Vector2D<int>(Width, Height);
- L709 C23: new GraphicsAPI :: options.API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(4, 6));
- L709 C111: new APIVersion :: options.API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(4, 6));
- L769 C24: new Vector2D :: options.Size = new Vector2D<int>(Width, Height);
- L771 C23: new GraphicsAPI :: options.API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(4, 6));
- L771 C111: new APIVersion :: options.API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(4, 6));
- L833 C24: new Vector2D :: options.Size = new Vector2D<int>(Width, Height);
- L835 C23: new GraphicsAPI :: options.API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(4, 6));
- L835 C111: new APIVersion :: options.API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(4, 6));
- L900 C24: new Vector2D :: options.Size = new Vector2D<int>(Width, Height);
- L902 C23: new GraphicsAPI :: options.API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(4, 6));
- L902 C111: new APIVersion :: options.API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(4, 6));
- L993 C16: new RenderState :: return new RenderState


## XREngine.UnitTests/Rendering/LightProbeOctaTests.cs
- L31 C24: new Vector2D :: options.Size = new Vector2D<int>(Width, Height);
- L33 C23: new GraphicsAPI :: options.API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(4, 6));
- L33 C111: new APIVersion :: options.API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(4, 6));
- L80 C18: new Vector2D :: (new Vector2D<int>(Width / 2, Height / 2), new Vector3(0.0f, 0.0f, 1.0f), "+Y center"),
- L80 C60: new Vector3 :: (new Vector2D<int>(Width / 2, Height / 2), new Vector3(0.0f, 0.0f, 1.0f), "+Y center"),
- L81 C18: new Vector2D :: (new Vector2D<int>((int)(Width * 0.9f), Height / 2), new Vector3(1.0f, 0.0f, 0.0f), "+X right"),
- L81 C70: new Vector3 :: (new Vector2D<int>((int)(Width * 0.9f), Height / 2), new Vector3(1.0f, 0.0f, 0.0f), "+X right"),
- L82 C18: new Vector2D :: (new Vector2D<int>((int)(Width * 0.1f), Height / 2), new Vector3(0.0f, 1.0f, 0.0f), "-X left"),
- L82 C70: new Vector3 :: (new Vector2D<int>((int)(Width * 0.1f), Height / 2), new Vector3(0.0f, 1.0f, 0.0f), "-X left"),
- L83 C18: new Vector2D :: (new Vector2D<int>(Width / 2, (int)(Height * 0.9f)), new Vector3(1.0f, 0.0f, 1.0f), "+Z top"),
- L83 C70: new Vector3 :: (new Vector2D<int>(Width / 2, (int)(Height * 0.9f)), new Vector3(1.0f, 0.0f, 1.0f), "+Z top"),
- L84 C18: new Vector2D :: (new Vector2D<int>(Width / 2, (int)(Height * 0.1f)), new Vector3(0.0f, 1.0f, 1.0f), "-Z bottom"),
- L84 C70: new Vector3 :: (new Vector2D<int>(Width / 2, (int)(Height * 0.1f)), new Vector3(0.0f, 1.0f, 1.0f), "-Z bottom"),
- L85 C18: new Vector2D :: (new Vector2D<int>((int)(Width * 0.15f), (int)(Height * 0.15f)), new Vector3(1.0f, 1.0f, 0.0f), "-Y corner"),
- L85 C82: new Vector3 :: (new Vector2D<int>((int)(Width * 0.15f), (int)(Height * 0.15f)), new Vector3(1.0f, 1.0f, 0.0f), "-Y corner"),
- L116 C24: new Vector2D :: options.Size = new Vector2D<int>(32, 32); // Irradiance is usually lower resolution
- L118 C23: new GraphicsAPI :: options.API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(4, 6));
- L118 C111: new APIVersion :: options.API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(4, 6));
- L131 C65: new Vector4 :: uint octaEnvTex = CreateFilledTexture2D(gl, 64, 64, new Vector4(0.5f, 0.3f, 0.7f, 1.0f));
- L191 C13: new Vector4 :: new Vector4(1.0f, 0.0f, 0.0f, 1.0f), // +X Red
- L192 C13: new Vector4 :: new Vector4(0.0f, 1.0f, 0.0f, 1.0f), // -X Green
- L193 C13: new Vector4 :: new Vector4(0.0f, 0.0f, 1.0f, 1.0f), // +Y Blue
- L194 C13: new Vector4 :: new Vector4(1.0f, 1.0f, 0.0f, 1.0f), // -Y Yellow
- L195 C13: new Vector4 :: new Vector4(1.0f, 0.0f, 1.0f, 1.0f), // +Z Magenta
- L196 C13: new Vector4 :: new Vector4(0.0f, 1.0f, 1.0f, 1.0f), // -Z Cyan
- L201 C28: new float :: float[] data = new float[64 * 64 * 4];
- L261 C24: new float :: float[] data = new float[width * height * 4];
- L482 C29: new Vector3 :: var expectedBytes = new Vector3(expected.X, expected.Y, expected.Z) * 255.0f;


## XREngine.UnitTests/Rendering/MortonCodeAndSortingTests.cs
- L43 C19: new FileNotFoundException :: throw new FileNotFoundException($"Shader file not found: {fullPath}");
- L143 C25: new Vector3 :: var positionX = new Vector3(1f, 0f, 0f);
- L158 C25: new Vector3 :: var positionY = new Vector3(0f, 1f, 0f);
- L172 C25: new Vector3 :: var positionZ = new Vector3(0f, 0f, 1f);
- L186 C20: new Vector3 :: var pos1 = new Vector3(0.5f, 0.5f, 0.5f);
- L187 C20: new Vector3 :: var pos2 = new Vector3(0.5f, 0.5f, 0.6f);  // Only Z differs slightly
- L188 C20: new Vector3 :: var pos3 = new Vector3(0.1f, 0.1f, 0.1f);  // Different octant entirely
- L214 C24: new Vector3 :: var sceneMin = new Vector3(-100, -100, -100);
- L215 C24: new Vector3 :: var sceneMax = new Vector3(100, 100, 100);
- L232 C26: new Vector3 :: var outsidePos = new Vector3(2f, 2f, 2f);
- L277 C21: new uint :: var codes = new uint[] { 100, 50, 200, 25, 150, 75 };
- L278 C23: new uint :: var indices = new uint[] { 0, 1, 2, 3, 4, 5 };
- L292 C29: new uint :: var originalCodes = new uint[] { 100, 50, 200, 25, 150, 75 };
- L294 C23: new uint :: var indices = new uint[] { 0, 1, 2, 3, 4, 5 };
- L308 C21: new uint :: var codes = new uint[] { 10, 20, 30, 40, 50 };
- L310 C23: new uint :: var indices = new uint[] { 0, 1, 2, 3, 4 };
- L320 C21: new uint :: var codes = new uint[] { 50, 40, 30, 20, 10 };
- L321 C23: new uint :: var indices = new uint[] { 0, 1, 2, 3, 4 };
- L325 C24: new uint :: codes.ShouldBe(new uint[] { 10, 20, 30, 40, 50 });
- L331 C21: new uint :: var codes = new uint[] { 50, 50, 50, 50 };
- L332 C23: new uint :: var indices = new uint[] { 0, 1, 2, 3 };
- L346 C21: new uint :: var codes = new uint[] { 42 };
- L347 C23: new uint :: var indices = new uint[] { 0 };
- L368 C21: new uint :: var codes = new uint[count];
- L369 C23: new uint :: var indices = new uint[count];
- L370 C22: new Random :: var random = new Random(12345);
- L425 C20: new uint :: var data = new uint[] { 8, 4, 2, 6, 1, 5, 3, 7 };
- L429 C23: new uint :: data.ShouldBe(new uint[] { 1, 2, 3, 4, 5, 6, 7, 8 });
- L435 C20: new uint :: var data = new uint[] { 2, 1 };
- L439 C23: new uint :: data.ShouldBe(new uint[] { 1, 2 });
- L502 C20: new uint :: var data = new uint[] { 0x10, 0x20, 0x10, 0x30, 0x10 };
- L504 C25: new uint :: var histogram = new uint[256];
- L522 C25: new uint :: var histogram = new uint[] { 3, 2, 1, 4 };
- L524 C25: new uint :: var prefixSum = new uint[histogram.Length];
- L542 C20: new uint :: var keys = new uint[] { 2, 0, 1, 0 };
- L543 C22: new uint :: var output = new uint[4];
- L544 C23: new uint :: var offsets = new uint[] { 0, 2, 3 }; // prefix sums for buckets 0, 1, 2
- L551 C25: new uint :: output.ShouldBe(new uint[] { 0, 0, 1, 2 });
- L649 C27: new uint :: var sortedCodes = new uint[]
- L694 C21: new Vector3Int :: var cellA = new Vector3Int(0, 0, 0);
- L695 C21: new Vector3Int :: var cellB = new Vector3Int(1, 0, 0);
- L706 C21: new Vector3Int :: var cellA = new Vector3Int(5, 10, 15);
- L707 C21: new Vector3Int :: var cellB = new Vector3Int(5, 10, 15);
- L718 C20: new Vector3Int :: var cell = new Vector3Int(-5, -10, -15);


## XREngine.UnitTests/Rendering/RenderingNamingConventionTests.cs
- L30 C34: new Dictionary :: var expectedRoleSuffix = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
- L61 C22: new HashSet :: var banned = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
- L90 C21: new Dictionary :: var rules = new Dictionary<string, string[]>(StringComparer.OrdinalIgnoreCase)
- L143 C15: new DirectoryNotFoundException :: throw new DirectoryNotFoundException($"Could not find workspace root from base directory '{AppContext.BaseDirectory}'.");


## XREngine.UnitTests/Rendering/SurfelGiComputeIntegrationTests.cs
- L117 C20: new float :: var data = new float[width * height * 4];
- L145 C20: new float :: var data = new float[width * height];
- L166 C20: new uint :: var data = new uint[width * height];
- L378 C24: new uint :: var seed = new uint[cellCount];
- L434 C42: new SurfelGpu :: UploadSsbo(gl, surfelBuffer, new SurfelGpu[(int)maxSurfels]);
- L437 C40: new uint :: UploadSsbo(gl, gridCounts, new uint[cellCount]);
- L438 C28: new uint :: var sentinel = new uint[cellCount * maxPerCell];
- L444 C46: new SurfelGpu :: WriteSurfel(gl, surfelBuffer, 0, new SurfelGpu
- L446 C29: new Vector4 :: PosRadius = new Vector4(0.1f, 0.1f, 0.1f, 0.1f),
- L447 C26: new Vector4 :: Normal = new Vector4(0, 0, 1, 0),
- L448 C26: new Vector4 :: Albedo = new Vector4(1, 0, 0, 1),
- L454 C46: new SurfelGpu :: WriteSurfel(gl, surfelBuffer, 1, new SurfelGpu
- L456 C29: new Vector4 :: PosRadius = new Vector4(1.1f, 0.1f, 0.1f, 0.1f),
- L457 C26: new Vector4 :: Normal = new Vector4(0, 0, 1, 0),
- L458 C26: new Vector4 :: Albedo = new Vector4(0, 1, 0, 1),
- L465 C46: new SurfelGpu :: WriteSurfel(gl, surfelBuffer, 2, new SurfelGpu
- L467 C29: new Vector4 :: PosRadius = new Vector4(0.2f, 0.2f, 0.2f, 0.1f),
- L468 C26: new Vector4 :: Normal = new Vector4(0, 0, 1, 0),
- L469 C26: new Vector4 :: Albedo = new Vector4(0, 0, 1, 1),
- L476 C46: new SurfelGpu :: WriteSurfel(gl, surfelBuffer, 3, new SurfelGpu
- L478 C29: new Vector4 :: PosRadius = new Vector4(1000f, 0, 0, 0.1f),
- L479 C26: new Vector4 :: Normal = new Vector4(0, 0, 1, 0),
- L480 C26: new Vector4 :: Albedo = new Vector4(1, 1, 1, 1),
- L555 C42: new SurfelGpu :: UploadSsbo(gl, surfelBuffer, new SurfelGpu[(int)maxSurfels]);
- L556 C40: new uint :: UploadSsbo(gl, gridCounts, new uint[cellCount]);
- L558 C28: new uint :: var sentinel = new uint[cellCount * maxPerCell + extraSentinel];
- L566 C50: new SurfelGpu :: WriteSurfel(gl, surfelBuffer, i, new SurfelGpu
- L568 C33: new Vector4 :: PosRadius = new Vector4(1.0f + i * 0.01f, 1.0f, 1.0f, 0.1f),
- L569 C30: new Vector4 :: Normal = new Vector4(0, 0, 1, 0),
- L570 C30: new Vector4 :: Albedo = new Vector4(1, 1, 1, 1),
- L647 C42: new SurfelGpu :: UploadSsbo(gl, surfelBuffer, new SurfelGpu[(int)maxSurfels]);
- L648 C40: new uint :: UploadSsbo(gl, gridCounts, new uint[cellCount]);
- L649 C41: new uint :: UploadSsbo(gl, gridIndices, new uint[cellCount * maxPerCell]);
- L653 C26: new float :: var culled = new float[48];
- L661 C46: new SurfelGpu :: WriteSurfel(gl, surfelBuffer, 0, new SurfelGpu
- L663 C29: new Vector4 :: PosRadius = new Vector4(0.1f, 0.1f, 0.1f, 0.1f),
- L664 C26: new Vector4 :: Normal = new Vector4(0, 0, 1, 0),
- L665 C26: new Vector4 :: Albedo = new Vector4(1, 0, 0, 1),
- L746 C50: new SurfelGpu :: WriteSurfel(gl, surfelBuffer, oldId, new SurfelGpu
- L748 C29: new Vector4 :: PosRadius = new Vector4(0, 0, 0, 0.1f),
- L749 C26: new Vector4 :: Normal = new Vector4(0, 0, 1, 0),
- L750 C26: new Vector4 :: Albedo = new Vector4(1, 1, 1, 1),
- L824 C40: new uint :: UploadSsbo(gl, gridCounts, new uint[cellCount]);
- L825 C41: new uint :: UploadSsbo(gl, gridIndices, new uint[cellCount * maxPerCell]);
- L835 C65: new Vector4 :: uint normalTex = CreateFloatTexture2D(gl, res, res, new Vector4(0.5f, 0.5f, 1.0f, 1.0f));
- L836 C65: new Vector4 :: uint albedoTex = CreateFloatTexture2D(gl, res, res, new Vector4(1.0f, 0.0f, 0.0f, 1.0f));
- L855 C56: new Vector3 :: SetUniform(gl, spawnProgram, "gridOrigin", new Vector3(-10f, -10f, -10f));
- L946 C42: new SurfelGpu :: UploadSsbo(gl, surfelBuffer, new SurfelGpu[(int)maxSurfels]);
- L947 C40: new uint :: UploadSsbo(gl, gridCounts, new uint[cellCount]);
- L948 C41: new uint :: UploadSsbo(gl, gridIndices, new uint[cellCount * maxPerCell]);
- L952 C26: new float :: var culled = new float[48];
- L967 C65: new Vector4 :: uint normalTex = CreateFloatTexture2D(gl, res, res, new Vector4(0.5f, 0.5f, 1.0f, 1.0f));
- L968 C65: new Vector4 :: uint albedoTex = CreateFloatTexture2D(gl, res, res, new Vector4(1.0f, 0.0f, 0.0f, 1.0f));
- L977 C30: new Vector3 :: var gridOrigin = new Vector3(-2f, -2f, -2f);
- L1007 C28: new Vector3 :: var worldPos = new Vector3(uvx * 2f - 1f, uvy * 2f - 1f, 0f);
- L1008 C44: new Vector3 :: var expectedLocal = worldPos - new Vector3(tx, 0f, 0f);
- L1093 C42: new SurfelGpu :: UploadSsbo(gl, surfelBuffer, new SurfelGpu[(int)maxSurfels]);
- L1094 C40: new uint :: UploadSsbo(gl, gridCounts, new uint[cellCount]);
- L1095 C41: new uint :: UploadSsbo(gl, gridIndices, new uint[cellCount * maxPerCell]);
- L1096 C45: new uint :: UploadSsbo(gl, freeStackBuffer, new uint[maxSurfels]);
- L1103 C65: new Vector4 :: uint normalTex = CreateFloatTexture2D(gl, res, res, new Vector4(0.5f, 0.5f, 1.0f, 1.0f));
- L1104 C65: new Vector4 :: uint albedoTex = CreateFloatTexture2D(gl, res, res, new Vector4(1.0f, 0.0f, 0.0f, 1.0f));
- L1121 C56: new Vector3 :: SetUniform(gl, spawnProgram, "gridOrigin", new Vector3(-10f, -10f, -10f));
- L1190 C40: new uint :: UploadSsbo(gl, gridCounts, new uint[cellCount]);
- L1191 C41: new uint :: UploadSsbo(gl, gridIndices, new uint[cellCount * maxPerCell]);
- L1205 C53: new SurfelGpu :: WriteSurfel(gl, surfelBuffer, surfelId, new SurfelGpu
- L1207 C29: new Vector4 :: PosRadius = new Vector4(0f, 0f, 1f, 0.5f),
- L1208 C26: new Vector4 :: Normal = new Vector4(0f, 0f, -1f, 0f),
- L1209 C26: new Vector4 :: Albedo = new Vector4(1f, 0f, 0f, 1f),
- L1218 C65: new Vector4 :: uint normalTex = CreateFloatTexture2D(gl, res, res, new Vector4(0.5f, 0.5f, 1.0f, 1.0f));
- L1219 C65: new Vector4 :: uint albedoTex = CreateFloatTexture2D(gl, res, res, new Vector4(0.0f, 0.0f, 0.0f, 1.0f));
- L1236 C51: new Vector3 :: SetUniform(gl, program, "gridOrigin", new Vector3(-10f, -10f, -10f));


## XREngine.UnitTests/Rendering/SwapchainContextCoalescingTests.cs
- L310 C24: new VulkanRenderGraphCompiler :: var compiler = new VulkanRenderGraphCompiler();
- L335 C24: new VulkanRenderGraphCompiler :: var compiler = new VulkanRenderGraphCompiler();
- L365 C24: new VulkanRenderGraphCompiler :: var compiler = new VulkanRenderGraphCompiler();
- L366 C25: new Dictionary :: var passOrder = new Dictionary<int, int>
- L393 C24: new VulkanRenderGraphCompiler :: var compiler = new VulkanRenderGraphCompiler();
- L394 C25: new Dictionary :: var passOrder = new Dictionary<int, int>
- L415 C24: new VulkanRenderGraphCompiler :: var compiler = new VulkanRenderGraphCompiler();
- L426 C24: new VulkanRenderGraphCompiler :: var compiler = new VulkanRenderGraphCompiler();
- L439 C24: new VulkanRenderGraphCompiler :: var compiler = new VulkanRenderGraphCompiler();
- L440 C25: new Dictionary :: var passOrder = new Dictionary<int, int>
- L482 C24: new VulkanRenderGraphCompiler :: var compiler = new VulkanRenderGraphCompiler();
- L521 C24: new VulkanRenderGraphCompiler :: var compiler = new VulkanRenderGraphCompiler();
- L551 C24: new VulkanRenderGraphCompiler :: var compiler = new VulkanRenderGraphCompiler();
- L554 C30: new int :: int[][] allResults = new int[100][];


## XREngine.UnitTests/Rendering/VulkanGpuDrivenPhase02Tests.cs
- L85 C28: new TextFile :: var shaderSource = new TextFile
- L98 C16: new CompiledShaderResult :: return new CompiledShaderResult(loadedShader.Source, rewrittenSource, entryPoint, spirv);
- L108 C19: new FileNotFoundException :: throw new FileNotFoundException($"Shader file not found: {fullPath}", fullPath);
- L110 C16: new LoadedShaderSource :: return new LoadedShaderSource(fullPath, File.ReadAllText(fullPath));
- L125 C15: new DirectoryNotFoundException :: throw new DirectoryNotFoundException("Could not locate Build/CommonAssets/Shaders from test base directory.");
- L130 C20: new HashSet :: var seen = new HashSet<BindingKey>();
- L134 C23: new BindingKey :: var key = new BindingKey(binding.Set, binding.Binding);
- L142 C49: new BindingKey :: return bindings.ToDictionary(binding => new BindingKey(binding.Set, binding.Binding));


## XREngine.UnitTests/Rendering/VulkanShaderCompilationRegressionTests.cs
- L36 C28: new TextFile :: var shaderSource = new TextFile
- L67 C28: new TextFile :: var shaderSource = new TextFile
- L93 C19: new FileNotFoundException :: throw new FileNotFoundException($"Shader file not found: {fullPath}", fullPath);
- L95 C16: new LoadedShaderSource :: return new LoadedShaderSource(fullPath, File.ReadAllText(fullPath));
- L110 C15: new DirectoryNotFoundException :: throw new DirectoryNotFoundException("Could not locate Build/CommonAssets/Shaders from test base directory.");


## XREngine.UnitTests/Rendering/VulkanShaderPreprocessParityTests.cs
- L39 C32: new TextFile :: var shaderSource = new TextFile


## XREngine.UnitTests/Rendering/VulkanShaderRewriteDiagnosticsTests.cs
- L67 C28: new TextFile :: var shaderSource = new TextFile
- L136 C19: new FileNotFoundException :: throw new FileNotFoundException($"Shader file not found: {fullPath}", fullPath);
- L138 C16: new LoadedShaderSource :: return new LoadedShaderSource(fullPath, File.ReadAllText(fullPath));
- L153 C15: new DirectoryNotFoundException :: throw new DirectoryNotFoundException("Could not locate Build/CommonAssets/Shaders from test base directory.");


## XREngine.UnitTests/Rendering/VulkanTodoP2ValidationTests.cs
- L30 C21: new VisualScene3D :: var scene = new VisualScene3D();
- L31 C59: new Vector3 :: scene.SetBounds(AABB.FromCenterSize(Vector3.Zero, new Vector3(256.0f, 256.0f, 256.0f)));
- L35 C57: new Vector3 :: RenderInfo3D visible = CreateRenderInfo3D(pass, new Vector3(0.0f, 0.0f, -5.0f), () => renderedCount++);
- L36 C56: new Vector3 :: RenderInfo3D hidden = CreateRenderInfo3D(pass, new Vector3(0.0f, 0.0f, 200.0f), () => renderedCount++);
- L44 C30: new Frustum :: var cullingFrustum = new Frustum(
- L61 C21: new VisualScene2D :: var scene = new VisualScene2D();
- L62 C25: new BoundingRectangleF :: scene.SetBounds(new BoundingRectangleF(-100.0f, -100.0f, 200.0f, 200.0f));
- L65 C56: new BoundingRectangleF :: RenderInfo2D inside = CreateRenderInfo2D(pass, new BoundingRectangleF(0.0f, 0.0f, 16.0f, 16.0f), () => renderedCount++);
- L66 C57: new BoundingRectangleF :: RenderInfo2D outside = CreateRenderInfo2D(pass, new BoundingRectangleF(80.0f, 80.0f, 16.0f, 16.0f), () => renderedCount++);
- L74 C46: new BoundingRectangleF :: scene.CollectRenderedItems(commands, new BoundingRectangleF(-8.0f, -8.0f, 32.0f, 32.0f), null);
- L85 C25: new UIMaterialComponent :: var component = new UIMaterialComponent();
- L102 C22: new UICanvasComponent :: var canvas = new UICanvasComponent
- L116 C29: new RenderCommandMethod2D :: commands.AddCPU(new RenderCommandMethod2D(pass, () =>
- L121 C29: new RenderCommandMethod2D :: commands.AddCPU(new RenderCommandMethod2D(pass, () =>
- L126 C29: new RenderCommandMethod2D :: commands.AddCPU(new RenderCommandMethod2D(pass, () =>
- L133 C35: new VPRC_RenderUIBatched :: var renderUiBatched = new VPRC_RenderUIBatched
- L141 C31: new VisualScene2D :: scene: new VisualScene2D(),
- L172 C24: new BranchMetadataGapPipeline :: var pipeline = new BranchMetadataGapPipeline();
- L173 C24: new XRRenderPipelineInstance :: var instance = new XRRenderPipelineInstance(pipeline);
- L175 C20: new VisualScene2D :: scene: new VisualScene2D(),
- L194 C24: new RenderPassMetadataCollection :: var metadata = new RenderPassMetadataCollection();
- L201 C23: new VulkanBarrierPlanner :: var planner = new VulkanBarrierPlanner();
- L202 C31: new VulkanResourcePlanner :: var resourcePlanner = new VulkanResourcePlanner();
- L203 C25: new VulkanResourceAllocator :: var allocator = new VulkanResourceAllocator();
- L210 C29: new VulkanBarrierPlanner.QueueOwnershipConfig :: queueOwnership: new VulkanBarrierPlanner.QueueOwnershipConfig(
- L228 C16: new Dictionary :: => new(new Dictionary<int, IComparer<RenderCommand>?>
- L235 C21: new TestRenderable :: var owner = new TestRenderable();
- L236 C23: new RenderCommandMethod3D :: var command = new RenderCommandMethod3D(renderPass, () => onRender());
- L246 C21: new TestRenderable :: var owner = new TestRenderable();
- L247 C23: new RenderCommandMethod2D :: var command = new RenderCommandMethod2D(renderPass, onRender);
- L278 C24: new ViewportRenderCommandContainer :: var root = new ViewportRenderCommandContainer(this);
- L282 C30: new ViewportRenderCommandContainer :: var trueBranch = new ViewportRenderCommandContainer(this);
- L283 C28: new PushPassIndexOnlyCommand :: trueBranch.Add(new PushPassIndexOnlyCommand
- L289 C36: new ViewportRenderCommandContainer :: ifElse.FalseCommands = new ViewportRenderCommandContainer(this);
- L294 C16: new() :: => new()


## XREngine.UnitTests/Rendering/XRMeshBvhTests.cs
- L64 C29: new Vector3 :: mesh.SetPosition(0, new Vector3(-1f, -1f, 0f));
- L82 C13: new Vector3 :: new Vector3(0f, 0f, 0f),
- L83 C13: new Vector3 :: new Vector3(1f, 0f, 0f),
- L84 C13: new Vector3 :: new Vector3(0f, 1f, 0f),
- L85 C13: new Vector3 :: new Vector3(1f, 0f, 0f),
- L86 C13: new Vector3 :: new Vector3(1f, 1f, 0f),
- L87 C13: new Vector3 :: new Vector3(0f, 1f, 0f)


## XREngine.UnitTests/Rendering/XRMeshModelingBridgeTests.cs
- L40 C41: new() :: ModelingMeshDocument document = new()
- L44 C17: new Vector3 :: new Vector3(0f, 0f, 0f),
- L45 C17: new Vector3 :: new Vector3(1f, 0f, 0f),
- L46 C17: new Vector3 :: new Vector3(0f, 1f, 0f)
- L49 C24: new ModelingMeshMetadata :: Metadata = new ModelingMeshMetadata
- L65 C13: new Vertex :: new Vertex(new Vector3(0f, 0f, 0f)),
- L65 C24: new Vector3 :: new Vertex(new Vector3(0f, 0f, 0f)),
- L66 C13: new Vertex :: new Vertex(new Vector3(1f, 0f, 0f)),
- L66 C24: new Vector3 :: new Vertex(new Vector3(1f, 0f, 0f)),
- L67 C13: new Vertex :: new Vertex(new Vector3(0f, 1f, 0f))
- L67 C24: new Vector3 :: new Vertex(new Vector3(0f, 1f, 0f))
- L93 C29: new Vector3 :: mesh.SetPosition(0, new Vector3(10f, 0f, 0f));
- L133 C47: new() :: XRMeshModelingExportOptions options = new()
- L150 C47: new() :: XRMeshModelingExportOptions options = new()
- L158 C13: new Vector3 :: new Vector3(0f, 0f, 0f),
- L159 C13: new Vector3 :: new Vector3(0f, 1f, 0f),
- L160 C13: new Vector3 :: new Vector3(1f, 0f, 0f),
- L161 C13: new Vector3 :: new Vector3(1f, 1f, 0f)
- L178 C22: new InvalidOperationException :: ?? throw new InvalidOperationException("Failed to create MeshEditingPawnComponent.");
- L204 C22: new InvalidOperationException :: ?? throw new InvalidOperationException("Failed to create MeshEditingPawnComponent.");
- L221 C47: new() :: XRMeshModelingExportOptions options = new()
- L239 C22: new InvalidOperationException :: ?? throw new InvalidOperationException("Failed to create MeshEditingPawnComponent.");
- L306 C13: new ModelingSkinBone :: new ModelingSkinBone
- L314 C14: new ModelingSkinWeight :: [new ModelingSkinWeight(0, 1f)],
- L315 C14: new ModelingSkinWeight :: [new ModelingSkinWeight(9, 1f)],
- L316 C14: new ModelingSkinWeight :: [new ModelingSkinWeight(0, 1f)],
- L317 C14: new ModelingSkinWeight :: [new ModelingSkinWeight(0, 1f)]
- L330 C22: new InvalidOperationException :: ?? throw new InvalidOperationException("Failed to create MeshEditingPawnComponent.");
- L335 C42: new Vector3 :: _ = pawn.InsertVertexOnSelection(new Vector3(0.5f, 0.0f, 0.0f));
- L337 C47: new() :: XRMeshModelingExportOptions options = new()
- L353 C22: new InvalidOperationException :: ?? throw new InvalidOperationException("Failed to create MeshEditingPawnComponent.");
- L358 C42: new Vector3 :: _ = pawn.InsertVertexOnSelection(new Vector3(0.5f, 0.0f, 0.0f));
- L360 C47: new() :: XRMeshModelingExportOptions options = new()
- L378 C22: new InvalidOperationException :: ?? throw new InvalidOperationException("Failed to create MeshEditingPawnComponent.");
- L383 C42: new Vector3 :: _ = pawn.InsertVertexOnSelection(new Vector3(0.5f, 0.0f, 0.0f));
- L385 C47: new() :: XRMeshModelingExportOptions options = new()
- L403 C33: new Vector3 :: document.Positions[0] = new Vector3(8f, 0f, 0f);
- L405 C67: new XRMeshModelingExportOptions :: XRMesh exported = XRMeshModelingExporter.Export(document, new XRMeshModelingExportOptions
- L421 C13: new Vertex :: new Vertex(new Vector3(0f, 0f, 0f)),
- L421 C24: new Vector3 :: new Vertex(new Vector3(0f, 0f, 0f)),
- L422 C13: new Vertex :: new Vertex(new Vector3(1f, 0f, 0f)),
- L422 C24: new Vector3 :: new Vertex(new Vector3(1f, 0f, 0f)),
- L423 C13: new Vertex :: new Vertex(new Vector3(1f, 1f, 0f)),
- L423 C24: new Vector3 :: new Vertex(new Vector3(1f, 1f, 0f)),
- L424 C13: new Vertex :: new Vertex(new Vector3(0f, 1f, 0f))
- L424 C24: new Vector3 :: new Vertex(new Vector3(0f, 1f, 0f))
- L428 C16: new XRMesh :: return new XRMesh(vertices, indices);
- L438 C13: new Vertex :: new Vertex(new Vector3(0f, 0f, 0f), normal, new Vector2(0f, 0f), new Vector4(1f, 0f, 0f, 1f)) { Tangent = tangent },
- L438 C24: new Vector3 :: new Vertex(new Vector3(0f, 0f, 0f), normal, new Vector2(0f, 0f), new Vector4(1f, 0f, 0f, 1f)) { Tangent = tangent },
- L438 C57: new Vector2 :: new Vertex(new Vector3(0f, 0f, 0f), normal, new Vector2(0f, 0f), new Vector4(1f, 0f, 0f, 1f)) { Tangent = tangent },
- L438 C78: new Vector4 :: new Vertex(new Vector3(0f, 0f, 0f), normal, new Vector2(0f, 0f), new Vector4(1f, 0f, 0f, 1f)) { Tangent = tangent },
- L439 C13: new Vertex :: new Vertex(new Vector3(1f, 0f, 0f), normal, new Vector2(1f, 0f), new Vector4(0f, 1f, 0f, 1f)) { Tangent = tangent },
- L439 C24: new Vector3 :: new Vertex(new Vector3(1f, 0f, 0f), normal, new Vector2(1f, 0f), new Vector4(0f, 1f, 0f, 1f)) { Tangent = tangent },
- L439 C57: new Vector2 :: new Vertex(new Vector3(1f, 0f, 0f), normal, new Vector2(1f, 0f), new Vector4(0f, 1f, 0f, 1f)) { Tangent = tangent },
- L439 C78: new Vector4 :: new Vertex(new Vector3(1f, 0f, 0f), normal, new Vector2(1f, 0f), new Vector4(0f, 1f, 0f, 1f)) { Tangent = tangent },
- L440 C13: new Vertex :: new Vertex(new Vector3(1f, 1f, 0f), normal, new Vector2(1f, 1f), new Vector4(0f, 0f, 1f, 1f)) { Tangent = tangent },
- L440 C24: new Vector3 :: new Vertex(new Vector3(1f, 1f, 0f), normal, new Vector2(1f, 1f), new Vector4(0f, 0f, 1f, 1f)) { Tangent = tangent },
- L440 C57: new Vector2 :: new Vertex(new Vector3(1f, 1f, 0f), normal, new Vector2(1f, 1f), new Vector4(0f, 0f, 1f, 1f)) { Tangent = tangent },
- L440 C78: new Vector4 :: new Vertex(new Vector3(1f, 1f, 0f), normal, new Vector2(1f, 1f), new Vector4(0f, 0f, 1f, 1f)) { Tangent = tangent },
- L441 C13: new Vertex :: new Vertex(new Vector3(0f, 1f, 0f), normal, new Vector2(0f, 1f), new Vector4(1f, 1f, 1f, 1f)) { Tangent = tangent }
- L441 C24: new Vector3 :: new Vertex(new Vector3(0f, 1f, 0f), normal, new Vector2(0f, 1f), new Vector4(1f, 1f, 1f, 1f)) { Tangent = tangent }
- L441 C57: new Vector2 :: new Vertex(new Vector3(0f, 1f, 0f), normal, new Vector2(0f, 1f), new Vector4(1f, 1f, 1f, 1f)) { Tangent = tangent }
- L441 C78: new Vector4 :: new Vertex(new Vector3(0f, 1f, 0f), normal, new Vector2(0f, 1f), new Vector4(1f, 1f, 1f, 1f)) { Tangent = tangent }
- L445 C16: new XRMesh :: return new XRMesh(vertices, indices);
- L450 C16: new ModelingMeshDocument :: return new ModelingMeshDocument
- L454 C17: new Vector3 :: new Vector3(1f, 1f, 0f),
- L455 C17: new Vector3 :: new Vector3(0f, 0f, 0f),
- L456 C17: new Vector3 :: new Vector3(1f, 0f, 0f),
- L457 C17: new Vector3 :: new Vector3(0f, 1f, 0f)
- L462 C17: new Vector3 :: new Vector3(0f, 0f, 1f),
- L463 C17: new Vector3 :: new Vector3(0f, 0f, 1f),
- L464 C17: new Vector3 :: new Vector3(0f, 0f, 1f),
- L465 C17: new Vector3 :: new Vector3(0f, 0f, 1f)
- L469 C17: new Vector3 :: new Vector3(1f, 0f, 0f),
- L470 C17: new Vector3 :: new Vector3(1f, 0f, 0f),
- L471 C17: new Vector3 :: new Vector3(1f, 0f, 0f),
- L472 C17: new Vector3 :: new Vector3(1f, 0f, 0f)
- L477 C21: new Vector2 :: new Vector2(1f, 1f),
- L478 C21: new Vector2 :: new Vector2(0f, 0f),
- L479 C21: new Vector2 :: new Vector2(1f, 0f),
- L480 C21: new Vector2 :: new Vector2(0f, 1f)
- L486 C21: new Vector4 :: new Vector4(1f, 1f, 1f, 1f),
- L487 C21: new Vector4 :: new Vector4(1f, 0f, 0f, 1f),
- L488 C21: new Vector4 :: new Vector4(0f, 1f, 0f, 1f),
- L489 C21: new Vector4 :: new Vector4(0f, 0f, 1f, 1f)
- L492 C24: new ModelingMeshMetadata :: Metadata = new ModelingMeshMetadata
- L503 C27: new() :: Transform boneA = new() { Name = "BoneA", InverseBindMatrix = Matrix4x4.Identity };
- L504 C27: new() :: Transform boneB = new() { Name = "BoneB", InverseBindMatrix = Matrix4x4.CreateTranslation(0f, 0f, -1f) };
- L514 C30: new Dictionary :: vertex.Weights = new Dictionary<TransformBase, (float weight, Matrix4x4 bindInvWorldMatrix)>
- L524 C21: new VertexData :: new VertexData
- L526 C54: new Vector3 :: Position = vertex.Position + new Vector3(0f, 0.05f, 0f),
- L540 C31: new Vector3 :: Vector3[] positions = new Vector3[mesh.VertexCount];
- L541 C29: new Vector3 :: Vector3[] normals = new Vector3[mesh.VertexCount];
- L542 C30: new Vector3 :: Vector3[] tangents = new Vector3[mesh.VertexCount];
- L543 C32: new Vector2 :: Vector2[] texCoords0 = new Vector2[mesh.VertexCount];
- L544 C29: new Vector4 :: Vector4[] colors0 = new Vector4[mesh.VertexCount];
- L558 C16: new MeshSnapshot :: return new MeshSnapshot


## XREngine.UnitTests/Rendering/XRMeshRendererTests.cs
- L25 C24: new XRMeshRenderer :: var renderer = new XRMeshRenderer();
- L26 C30: new EventList :: renderer.Submeshes = new EventList<XRMeshRenderer.SubMesh>();
- L28 C32: new XRMeshRenderer.SubMesh :: renderer.Submeshes.Add(new XRMeshRenderer.SubMesh
- L33 C32: new XRMeshRenderer.SubMesh :: renderer.Submeshes.Add(new XRMeshRenderer.SubMesh
- L66 C24: new XRMeshRenderer :: var renderer = new XRMeshRenderer();
- L67 C30: new EventList :: renderer.Submeshes = new EventList<XRMeshRenderer.SubMesh>();
- L76 C13: new Vector3 :: new Vector3(0f, 0f, 0f),
- L77 C13: new Vector3 :: new Vector3(1f, 0f, 0f),
- L78 C13: new Vector3 :: new Vector3(0f, 1f, 0f)
- L87 C13: new Vector3 :: new Vector3(0f, 0f, 1f),
- L88 C13: new Vector3 :: new Vector3(1f, 0f, 1f),
- L89 C13: new Vector3 :: new Vector3(0f, 1f, 1f)


## XREngine.UnitTests/XRMath/RotationBetweenVectorsTests.cs
- L74 C43: new Vector3 :: axis = den > XRMath.Epsilon ? new Vector3(rotation.X / den, rotation.Y / den, rotation.Z / den) : Vector3.UnitX;


## XREngine.VRClient/Program.cs
- L51 C55: new GameState :: Engine.Run((GameStartupSettings)settings, new GameState());
- L80 C54: new AssemblyName :: => AssemblyBuilder.DefineDynamicAssembly(new AssemblyName(dynamicAssemblyName), AssemblyBuilderAccess.Run).DefineDynamicModule(dynamicAssemblyName);
- L114 C34: new ManagementObjectSearcher :: using var searcher = new ManagementObjectSearcher(wmiQueryString);
- L132 C28: new VRGameStartupSettings :: var settings = new VRGameStartupSettings<TActionCategory, TGameAction>()
- L139 C30: new VrManifest :: VRManifest = new VrManifest()
- L148 C21: new GameWindowStartupSettings :: new GameWindowStartupSettings()
- L159 C43: new XREngine.Data.Core.OverrideableSetting :: OutputVerbosityOverride = new XREngine.Data.Core.OverrideableSetting<EOutputVerbosity>(EOutputVerbosity.Verbose, true),
- L160 C50: new XREngine.Data.Core.OverrideableSetting :: UseIntegerWeightingIdsOverride = new XREngine.Data.Core.OverrideableSetting<bool>(true, true),
- L161 C39: new UserSettings :: DefaultUserSettings = new UserSettings()
- L167 C34: new ActionManifest :: ActionManifest = new ActionManifest<TActionCategory, TGameAction>()
- L190 C25: new XRWorld :: var world = new XRWorld();
- L191 C25: new XRScene :: var scene = new XRScene() { Name = "FillerScene" };


## XRENGINE/Core/Attributes/XRAssetAttributes.cs
- L19 C19: new ArgumentException :: throw new ArgumentException("Inspector type name must be provided.", nameof(inspectorTypeName));
- L35 C25: new ArgumentException :: ?? throw new ArgumentException("Inspector type did not provide a name.", nameof(inspectorType));
- L53 C19: new ArgumentException :: throw new ArgumentException("Menu label must be provided.", nameof(label));
- L55 C19: new ArgumentException :: throw new ArgumentException("Handler type name must be provided.", nameof(handlerTypeName));
- L57 C19: new ArgumentException :: throw new ArgumentException("Handler method name must be provided.", nameof(handlerMethodName));
- L86 C25: new ArgumentException :: ?? throw new ArgumentException("Handler type did not provide a name.", nameof(handlerType));


## XRENGINE/Core/Attributes/XRComponentEditorAttribute.cs
- L17 C19: new ArgumentException :: throw new ArgumentException("Editor type name must be provided.", nameof(editorTypeName));


## XRENGINE/Core/Editor/EditorState.cs
- L16 C71: new Dictionary :: private Dictionary<string, List<object>> _changedProperties = new Dictionary<string, List<object>>();
- L88 C64: new List :: public static List<EditorState> DirtyStates { get; } = new List<EditorState>();
- L103 C53: new List :: private List<GlobalChange> _globalChanges = new List<GlobalChange>();
- L125 C17: new void :: private new void OnSelectedChanged(bool selected)
- L145 C41: new GlobalChange :: GlobalChange globalChange = new GlobalChange
- L147 C33: new ConcurrentBag :: ChangedStates = new ConcurrentBag<(EditorState State, LocalValueChange Change)>()


## XRENGINE/Core/Engine/AssetDiagnostics.cs
- L32 C56: new() :: private static readonly object _missingAssetLock = new();
- L46 C29: new MissingAssetAggregate :: aggregate = new MissingAssetAggregate
- L60 C40: new HashSet :: aggregate.Contexts ??= new HashSet<string>(StringComparer.Ordinal);
- L73 C28: new MissingAssetInfo :: var snapshot = new MissingAssetInfo[_missingAssets.Count];
- L81 C37: new MissingAssetInfo :: snapshot[index++] = new MissingAssetInfo


## XRENGINE/Core/Engine/AssetManager.cs
- L55 C23: new TaskCompletionSource :: var tcs = new TaskCompletionSource<T>(TaskCreationOptions.RunContinuationsAsynchronously);
- L71 C23: new TaskCompletionSource :: var tcs = new TaskCompletionSource<T>(TaskCreationOptions.RunContinuationsAsynchronously);
- L145 C23: new DirectoryNotFoundException :: throw new DirectoryNotFoundException($"Could not find the engine assets directory at '{EngineAssetsPath}'.");
- L213 C23: new ArgumentException :: throw new ArgumentException($"{argumentName} cannot be null or empty.", argumentName);
- L302 C57: new FileSystemWatcher :: public FileSystemWatcher GameWatcher { get; } = new FileSystemWatcher();
- L303 C59: new FileSystemWatcher :: public FileSystemWatcher EngineWatcher { get; } = new FileSystemWatcher();
- L354 C49: new() :: private readonly object _metadataLock = new();


## XRENGINE/Core/Engine/AssetManager.Loading.cs
- L22 C160: new() :: private T? LoadCore<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicParameterlessConstructor)] T>(string filePath) where T : XRAsset, new()
- L114 C245: new() :: public async Task<T?> LoadAsync<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicParameterlessConstructor)] T>(string filePath, JobPriority priority = JobPriority.Normal, bool bypassJobThread = false) where T : XRAsset, new()
- L130 C228: new() :: public T? Load<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicParameterlessConstructor)] T>(string filePath, JobPriority priority = JobPriority.Normal, bool bypassJobThread = false) where T : XRAsset, new()
- L138 C173: new() :: public T LoadEngineAsset<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] T>(params string[] relativePathFolders) where T : XRAsset, new()
- L141 C217: new() :: public T LoadEngineAsset<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] T>(JobPriority priority, bool bypassJobThread, params string[] relativePathFolders) where T : XRAsset, new()
- L144 C70: new FileNotFoundException :: return Load<T>(path, priority, bypassJobThread) ?? throw new FileNotFoundException($"Unable to find engine file at {path}");
- L147 C195: new() :: public T LoadEngineAsset<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] T>(JobPriority priority, params string[] relativePathFolders) where T : XRAsset, new()
- L150 C53: new FileNotFoundException :: return Load<T>(path, priority) ?? throw new FileNotFoundException($"Unable to find engine file at {path}");
- L153 C184: new() :: public Task<T> LoadEngineAssetAsync<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] T>(params string[] relativePathFolders) where T : XRAsset, new()
- L156 C234: new() :: public async Task<T> LoadEngineAssetAsync<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] T>(JobPriority priority, bool bypassJobThread, params string[] relativePathFolders) where T : XRAsset, new()
- L159 C81: new FileNotFoundException :: return await LoadAsync<T>(path, priority, bypassJobThread) ?? throw new FileNotFoundException($"Unable to find engine file at {path}");
- L162 C212: new() :: public async Task<T> LoadEngineAssetAsync<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] T>(JobPriority priority, params string[] relativePathFolders) where T : XRAsset, new()
- L165 C64: new FileNotFoundException :: return await LoadAsync<T>(path, priority) ?? throw new FileNotFoundException($"Unable to find engine file at {path}");
- L168 C342: new() :: public T LoadEngineAssetRemote<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] T>(RemoteAssetLoadMode mode = RemoteAssetLoadMode.RequestFromRemote, JobPriority priority = JobPriority.Normal, IReadOnlyDictionary<string, string>? metadata = null, params string[] relativePathFolders) where T : XRAsset, new()
- L171 C341: new() :: public T? LoadGameAssetRemote<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] T>(RemoteAssetLoadMode mode = RemoteAssetLoadMode.RequestFromRemote, JobPriority priority = JobPriority.Normal, IReadOnlyDictionary<string, string>? metadata = null, params string[] relativePathFolders) where T : XRAsset, new()
- L174 C359: new() :: public async Task<T> LoadEngineAssetRemoteAsync<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] T>(RemoteAssetLoadMode mode = RemoteAssetLoadMode.RequestFromRemote, JobPriority priority = JobPriority.Normal, IReadOnlyDictionary<string, string>? metadata = null, params string[] relativePathFolders) where T : XRAsset, new()
- L178 C26: new FileNotFoundException :: ?? throw new FileNotFoundException($"Unable to load engine file at {path} via remote path.");
- L181 C172: new() :: public T? LoadGameAsset<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] T>(params string[] relativePathFolders) where T : XRAsset, new()
- L187 C189: new() :: public async Task<T?> LoadGameAssetAsync<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] T>(params string[] relativePathFolders) where T : XRAsset, new()
- L193 C358: new() :: public async Task<T?> LoadGameAssetRemoteAsync<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] T>(RemoteAssetLoadMode mode = RemoteAssetLoadMode.RequestFromRemote, JobPriority priority = JobPriority.Normal, IReadOnlyDictionary<string, string>? metadata = null, params string[] relativePathFolders) where T : XRAsset, new()
- L199 C313: new() :: public T? LoadByIdRemote<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] T>(Guid assetId, RemoteAssetLoadMode mode = RemoteAssetLoadMode.RequestFromRemote, JobPriority priority = JobPriority.Normal, IReadOnlyDictionary<string, string>? metadata = null) where T : XRAsset, new()
- L202 C377: new() :: public async Task<T?> LoadByIdRemoteAsync<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] T>(Guid assetId, RemoteAssetLoadMode mode = RemoteAssetLoadMode.RequestFromRemote, JobPriority priority = JobPriority.Normal, IReadOnlyDictionary<string, string>? metadata = null, CancellationToken cancellationToken = default) where T : XRAsset, new()
- L227 C182: new() :: public T LoadEngineAssetImmediate<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] T>(params string[] relativePathFolders) where T : XRAsset, new()
- L230 C86: new FileNotFoundException :: return Load<T>(path, JobPriority.Normal, bypassJobThread: true) ?? throw new FileNotFoundException($"Unable to find engine file at {path}");
- L233 C164: new() :: public T? LoadImmediate<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicParameterlessConstructor)] T>(string filePath) where T : XRAsset, new()
- L251 C333: new() :: private async Task<T?> LoadAssetRemoteAsync<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicParameterlessConstructor)] T>(string filePath, RemoteAssetLoadMode mode, JobPriority priority, CancellationToken cancellationToken, IReadOnlyDictionary<string, string>? additionalMetadata = null) where T : XRAsset, new()
- L257 C19: new Dictionary :: ? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
- L258 C19: new Dictionary :: : new Dictionary<string, string>(additionalMetadata, StringComparer.OrdinalIgnoreCase);
- L273 C27: new RemoteJobRequest :: var request = new RemoteJobRequest
- L324 C19: new Dictionary :: ? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
- L325 C19: new Dictionary :: : new Dictionary<string, string>(additionalMetadata, StringComparer.OrdinalIgnoreCase);
- L330 C27: new RemoteJobRequest :: var request = new RemoteJobRequest
- L385 C19: new Dictionary :: ? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
- L386 C19: new Dictionary :: : new Dictionary<string, string>(additionalMetadata, StringComparer.OrdinalIgnoreCase);
- L391 C27: new RemoteJobRequest :: var request = new RemoteJobRequest
- L451 C162: new() :: private static T? DeserializeAssetFile<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicMethods)] T>(string filePath) where T : XRAsset, new()
- L454 C28: new FileStream :: using var fs = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
- L455 C32: new StreamReader :: using var reader = new StreamReader(fs);
- L462 C28: new FileStream :: using var fs = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
- L463 C32: new StreamReader :: using var reader = new StreamReader(fs);
- L467 C179: new() :: private static async Task<T?> DeserializeAssetFileAsync<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicMethods)] T>(string filePath) where T : XRAsset, new()
- L473 C32: new FileStream :: using var fs = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
- L474 C36: new StreamReader :: using var reader = new StreamReader(fs);
- L485 C32: new FileStream :: using var fs = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
- L486 C36: new StreamReader :: using var reader = new StreamReader(fs);
- L491 C168: new() :: private T? Load3rdPartyWithCache<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicMethods)] T>(string filePath, string ext) where T : XRAsset, new()
- L539 C185: new() :: private async Task<T?> Load3rdPartyWithCacheAsync<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicMethods)] T>(string filePath, string ext) where T : XRAsset, new()
- L600 C244: new() :: private static bool TryLoadCachedAsset<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicParameterlessConstructor)] T>(string cachePath, string originalPath, DateTime sourceTimestampUtc, out T? asset) where T : XRAsset, new()
- L652 C238: new() :: private async Task<T?> TryLoadCachedAssetAsync<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicParameterlessConstructor)] T>(string cachePath, string originalPath, DateTime sourceTimestampUtc) where T : XRAsset, new()
- L708 C171: new() :: private static T? Load3rdPartyAsset<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicMethods)] T>(string filePath, string ext) where T : XRAsset, new()
- L739 C33: new T :: var asset = new T
- L814 C188: new() :: private static async Task<T?> Load3rdPartyAssetAsync<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicMethods)] T>(string filePath, string ext) where T : XRAsset, new()
- L854 C33: new T :: var asset = new T


## XRENGINE/Core/Engine/AssetManager.Metadata.cs
- L131 C67: new AssetMetadata :: AssetMetadata meta = TryReadMetadata(metaPath) ?? new AssetMetadata();
- L162 C41: new AssetImportMetadata :: meta.Import ??= new AssetImportMetadata();
- L261 C40: new FileStream :: using var stream = new FileStream(
- L267 C40: new StreamReader :: using var reader = new StreamReader(stream, detectEncodingFromByteOrderMarks: true);


## XRENGINE/Core/Engine/AssetManager.Published.cs
- L30 C66: new() :: [NotNullWhen(true)] out T? asset) where T : XRAsset, new()
- L130 C27: new HashSet :: var yielded = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
- L140 C27: new List :: var results = new List<string>();
- L170 C27: new HashSet :: var emitted = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
- L184 C27: new List :: var results = new List<string>();


## XRENGINE/Core/Engine/AssetManager.Serialization.cs
- L24 C27: new SerializerBuilder :: var builder = new SerializerBuilder()
- L28 C62: new PolymorphicTypeGraphVisitor :: .WithEmissionPhaseObjectGraphVisitor(args => new PolymorphicTypeGraphVisitor(args.InnerVisitor))
- L29 C50: new DepthTrackingEventEmitter :: .WithEventEmitter(nextEmitter => new DepthTrackingEventEmitter(nextEmitter))
- L40 C39: new XRAssetYamlConverter :: builder.WithTypeConverter(new XRAssetYamlConverter());
- L47 C27: new DeserializerBuilder :: var builder = new DeserializerBuilder()
- L54 C30: new DepthTrackingNodeDeserializer :: inner => new DepthTrackingNodeDeserializer(inner),
- L57 C30: new NotSupportedAnnotatingNodeDeserializer :: inner => new NotSupportedAnnotatingNodeDeserializer(inner),
- L65 C42: new XRAssetDeserializer :: builder.WithNodeDeserializer(new XRAssetDeserializer(), w => w.OnTop());
- L68 C42: new PolymorphicYamlNodeDeserializer :: builder.WithNodeDeserializer(new PolymorphicYamlNodeDeserializer(), w => w.OnTop());


## XRENGINE/Core/Engine/AssetManager.ThirdPartyImport.cs
- L27 C23: new Dictionary :: var map = new Dictionary<string, Type>(StringComparer.OrdinalIgnoreCase);
- L670 C27: new HashSet :: var visited = new HashSet<object>(ReferenceEqualityComparer.Instance);
- L671 C25: new Stack :: var stack = new Stack<object>();
- L675 C26: new Dictionary :: var depths = new Dictionary<object, int>(ReferenceEqualityComparer.Instance)
- L952 C80: new() :: public static XRAssetReferenceEqualityComparer Instance { get; } = new();


## XRENGINE/Core/Engine/Debug.cs
- L54 C93: new() :: private static readonly ConcurrentDictionary<string, DateTime> RecentMessageCache = new();
- L55 C94: new() :: private static readonly ConcurrentDictionary<string, long> RateLimitedMessageCache = new();
- L58 C67: new Queue :: public static Queue<(string, DateTime)> Output { get; } = new Queue<(string, DateTime)>();
- L68 C56: new() :: private static readonly object LogWriterLock = new();
- L69 C61: new() :: private static readonly object ConsoleEntriesLock = new();
- L70 C66: new() :: private static readonly List<LogEntry> _consoleEntries = new();
- L71 C86: new() :: private static readonly Dictionary<ELogCategory, StreamWriter?> LogWriters = new()
- L93 C24: new List :: return new List<LogEntry>(_consoleEntries);
- L137 C30: new LogEntry :: addedEntry = new LogEntry(message, category, DateTime.Now);
- L183 C48: new StackTrace :: string firstChanceStackTrace = new StackTrace(1, true).ToString();
- L883 C30: new StreamWriter :: var writer = new StreamWriter(new FileStream(filePath, FileMode.Create, FileAccess.Write, FileShare.Read))
- L883 C47: new FileStream :: var writer = new StreamWriter(new FileStream(filePath, FileMode.Create, FileAccess.Write, FileShare.Read))
- L1016 C29: new string :: var sanitized = new string(segment


## XRENGINE/Core/Engine/PolymorphicTypeGraphVisitor.cs
- L49 C26: new Scalar :: emitter.Emit(new Scalar(TypeKey));
- L50 C26: new Scalar :: emitter.Emit(new Scalar(typeName));


## XRENGINE/Core/Engine/PolymorphicYamlNodeDeserializer.cs
- L57 C27: new YamlException :: throw new YamlException($"Polymorphic YAML type '{typeName}' is not assignable to '{expectedType.FullName}'.");
- L59 C50: new ReplayParser :: value = nestedObjectDeserializer(new ReplayParser(events), concreteType);
- L66 C50: new ReplayParser :: value = nestedObjectDeserializer(new ReplayParser(events), typeof(XRTexture2D));
- L73 C50: new ReplayParser :: value = nestedObjectDeserializer(new ReplayParser(events), inferred);
- L229 C26: new List :: var events = new List<ParsingEvent>();
- L281 C19: new YamlException :: throw new YamlException("Unsupported YAML node encountered while capturing polymorphic data.");
- L291 C27: new Queue :: _events = new Queue<ParsingEvent>(events);
- L295 C62: new InvalidOperationException :: public ParsingEvent Current => _current ?? throw new InvalidOperationException("The parser is not positioned on an event.");


## XRENGINE/Core/Engine/ShaderVarYamlTypeConverter.cs
- L41 C23: new YamlException :: throw new YamlException("Expected a mapping to deserialize a ShaderVar.");
- L86 C23: new YamlException :: throw new YamlException($"Failed to create a ShaderVar instance of type '{concreteType.FullName}'.");
- L204 C23: new YamlException :: throw new YamlException(errorMessage);
- L238 C19: new YamlException :: throw new YamlException("Unsupported YAML node encountered while skipping a value.");
- L273 C24: new Vector2 :: return new Vector2(ParseFloat(parts, 0), ParseFloat(parts, 1));
- L275 C24: new Vector3 :: return new Vector3(ParseFloat(parts, 0), ParseFloat(parts, 1), ParseFloat(parts, 2));
- L277 C24: new Vector4 :: return new Vector4(ParseFloat(parts, 0), ParseFloat(parts, 1), ParseFloat(parts, 2), ParseFloat(parts, 3));
- L281 C27: new YamlException :: throw new YamlException("Expected Matrix4x4 format with 16 components.");
- L283 C24: new Matrix4x4 :: return new Matrix4x4(
- L291 C24: new IVector2 :: return new IVector2(ParseInt(parts, 0), ParseInt(parts, 1));
- L293 C24: new IVector3 :: return new IVector3(ParseInt(parts, 0), ParseInt(parts, 1), ParseInt(parts, 2));
- L295 C24: new IVector4 :: return new IVector4(ParseInt(parts, 0), ParseInt(parts, 1), ParseInt(parts, 2), ParseInt(parts, 3));
- L298 C24: new UVector2 :: return new UVector2(ParseUInt(parts, 0), ParseUInt(parts, 1));
- L300 C24: new UVector3 :: return new UVector3(ParseUInt(parts, 0), ParseUInt(parts, 1), ParseUInt(parts, 2));
- L302 C24: new UVector4 :: return new UVector4(ParseUInt(parts, 0), ParseUInt(parts, 1), ParseUInt(parts, 2), ParseUInt(parts, 3));
- L305 C24: new DVector2 :: return new DVector2(ParseDouble(parts, 0), ParseDouble(parts, 1));
- L307 C24: new DVector3 :: return new DVector3(ParseDouble(parts, 0), ParseDouble(parts, 1), ParseDouble(parts, 2));
- L309 C24: new DVector4 :: return new DVector4(ParseDouble(parts, 0), ParseDouble(parts, 1), ParseDouble(parts, 2), ParseDouble(parts, 3));
- L312 C24: new BoolVector2 :: return new BoolVector2(ParseBool(parts, 0), ParseBool(parts, 1));
- L314 C24: new BoolVector3 :: return new BoolVector3(ParseBool(parts, 0), ParseBool(parts, 1), ParseBool(parts, 2));
- L316 C24: new BoolVector4 :: return new BoolVector4(ParseBool(parts, 0), ParseBool(parts, 1), ParseBool(parts, 2), ParseBool(parts, 3));
- L323 C19: new YamlException :: throw new YamlException($"Unsupported ShaderVar Value type '{targetType.FullName}'.");
- L329 C23: new YamlException :: throw new YamlException("Not enough components in scalar value.");
- L336 C23: new YamlException :: throw new YamlException("Not enough components in scalar value.");
- L343 C23: new YamlException :: throw new YamlException("Not enough components in scalar value.");
- L350 C23: new YamlException :: throw new YamlException("Not enough components in scalar value.");
- L357 C23: new YamlException :: throw new YamlException("Not enough components in scalar value.");


## XRENGINE/Core/Engine/TransformBaseYamlTypeConverter.cs
- L53 C31: new InvalidOperationException :: throw new InvalidOperationException($"Deserialized type '{deserialized.GetType().FullName}' is not a {nameof(TransformBase)}.");
- L67 C20: new Transform :: result ??= new Transform();
- L79 C26: new Scalar :: emitter.Emit(new Scalar(null, null, "null", ScalarStyle.Plain, true, false));
- L85 C22: new MappingStart :: emitter.Emit(new MappingStart(null, null, false, MappingStyle.Block));
- L86 C22: new Scalar :: emitter.Emit(new Scalar(TypeKey));
- L87 C22: new Scalar :: emitter.Emit(new Scalar(runtimeType.AssemblyQualifiedName ?? runtimeType.FullName ?? runtimeType.Name));
- L88 C22: new Scalar :: emitter.Emit(new Scalar(ValueKey));
- L92 C22: new MappingEnd :: emitter.Emit(new MappingEnd());
- L101 C22: new Scalar :: emitter.Emit(new Scalar(ChildrenKey));
- L102 C22: new SequenceStart :: emitter.Emit(new SequenceStart(null, null, false, SequenceStyle.Block));
- L105 C22: new SequenceEnd :: emitter.Emit(new SequenceEnd());
- L119 C29: new List :: results ??= new List<TransformBase>(source.Count);
- L187 C15: new YamlException :: throw new YamlException("Unsupported YAML node encountered while skipping transform metadata.");


## XRENGINE/Core/Engine/XRAssetYamlTypeConverter.cs
- L126 C36: new ReplayParser :: var replayParser = new ReplayParser(capturedEvents);
- L261 C26: new List :: var events = new List<ParsingEvent>();
- L345 C19: new YamlException :: throw new YamlException("Unsupported YAML node encountered while capturing XRAsset data.");
- L448 C27: new Queue :: _events = new Queue<ParsingEvent>(events);
- L453 C62: new InvalidOperationException :: public ParsingEvent Current => _current ?? throw new InvalidOperationException("The parser is not positioned on an event.");
- L557 C22: new NotSupportedException :: => throw new NotSupportedException("XRAssetYamlConverter is write-only; reading is handled by XRAssetDeserializer.");
- L602 C26: new MappingStart :: emitter.Emit(new MappingStart(null, null, false, MappingStyle.Block));
- L603 C26: new Scalar :: emitter.Emit(new Scalar("ID"));
- L604 C26: new Scalar :: emitter.Emit(new Scalar(asset.ID.ToString()));
- L605 C26: new MappingEnd :: emitter.Emit(new MappingEnd());


## XRENGINE/Core/Engine/XRMeshBufferCollectionYamlTypeConverter.cs
- L37 C23: new YamlException :: throw new YamlException($"Unexpected scalar while deserializing {nameof(XRMesh)}.{nameof(XRMesh.BufferCollection)}: '{scalar.Value}'.");
- L45 C34: new XRMesh.BufferCollection :: var collection = new XRMesh.BufferCollection
- L65 C34: new Scalar :: emitter.Emit(new Scalar("~"));
- L70 C27: new YamlException :: throw new YamlException($"Expected {nameof(XRMesh)}.{nameof(XRMesh.BufferCollection)} but got '{value.GetType()}'.");


## XRENGINE/Core/Engine/XRTextureYamlTypeConverter.cs
- L38 C23: new YamlException :: throw new YamlException($"Unexpected scalar while deserializing {nameof(XRTexture)}: '{scalar.Value}'.");


## XRENGINE/Core/Extensions/EnumerableExtension.cs
- L7 C20: new ThreadSafeList :: return new ThreadSafeList<T>(enumerable);


## XRENGINE/Core/Extensions/StringExtension.cs
- L45 C28: new InvalidOperationException :: _ => throw new InvalidOperationException(t.ToString() + " is not parsable"),


## XRENGINE/Core/Files/AssetPacker.ArchiveEntryInfo.cs
- L50 C36: new CookedBinaryReader :: using var reader = new CookedBinaryReader((byte*)map.Address, map.Length);


## XRENGINE/Core/Files/AssetPacker.ArchiveInfo.cs
- L52 C33: new FileInfo :: long fileSize = new FileInfo(archiveFilePath).Length;
- L54 C36: new CookedBinaryReader :: using var reader = new CookedBinaryReader((byte*)map.Address.Pointer, map.Length);
- L58 C27: new InvalidOperationException :: throw new InvalidOperationException("Invalid asset archive format — magic number mismatch.");
- L62 C27: new InvalidOperationException :: throw new InvalidOperationException($"Unsupported archive version '{version}'. Only V{CurrentVersion} is supported.");
- L72 C40: new StringCompressor :: var stringCompressor = new StringCompressor(reader);
- L76 C31: new ArchiveEntryInfo :: var entries = new ArchiveEntryInfo[fileCount];
- L83 C34: new ArchiveEntryInfo :: entries[i] = new ArchiveEntryInfo(path, toc.Hash, toc.DataOffset, toc.CompressedSize,
- L88 C24: new ArchiveInfo :: return new ArchiveInfo


## XRENGINE/Core/Files/AssetPacker.cs
- L186 C23: new FileNotFoundException :: throw new FileNotFoundException($"Archive '{archiveFilePath}' not found.", archiveFilePath);
- L195 C44: new CookedBinaryReader :: using var reader = new CookedBinaryReader((byte*)sourceMap.Address, sourceMap.Length);
- L197 C35: new InvalidOperationException :: throw new InvalidOperationException("Invalid asset archive format.");
- L201 C35: new InvalidOperationException :: throw new InvalidOperationException($"Unsupported archive version '{version}'. Only V{CurrentVersion} is supported.");
- L234 C31: new StringCompressor :: var stringTable = new StringCompressor(reader);
- L250 C28: new PackedAsset :: assets.Add(new PackedAsset
- L267 C23: new InvalidOperationException :: throw new InvalidOperationException("Cannot repack archive without any assets.");
- L303 C37: new() :: PackedAsset asset = new()
- L336 C23: new FileNotFoundException :: throw new FileNotFoundException($"Archive '{archiveFilePath}' not found.", archiveFilePath);
- L345 C44: new CookedBinaryReader :: using var reader = new CookedBinaryReader((byte*)sourceMap.Address, sourceMap.Length);
- L347 C35: new InvalidOperationException :: throw new InvalidOperationException("Invalid asset archive format.");
- L351 C35: new InvalidOperationException :: throw new InvalidOperationException($"Compact requires a V{CurrentVersion} archive (found V{version}).");
- L389 C23: new FileNotFoundException :: throw new FileNotFoundException($"Archive '{archiveFilePath}' not found.", archiveFilePath);
- L395 C36: new CookedBinaryReader :: using var reader = new CookedBinaryReader((byte*)map.Address, map.Length);
- L397 C27: new InvalidOperationException :: throw new InvalidOperationException("Invalid asset archive format.");
- L401 C27: new InvalidOperationException :: throw new InvalidOperationException($"GetStalePaths requires a V{CurrentVersion} archive (found V{version}).");
- L411 C40: new StringCompressor :: var stringCompressor = new StringCompressor(reader);
- L454 C23: new DirectoryNotFoundException :: throw new DirectoryNotFoundException($"Input directory '{inputDir}' does not exist.");
- L458 C23: new InvalidOperationException :: throw new InvalidOperationException("No files found to pack.");
- L468 C20: new FileStream :: using (new FileStream(outputFile, FileMode.Create, FileAccess.Write, FileShare.Read)) { }
- L471 C32: new long :: long[] fileSizes = new long[files.Length];
- L473 C32: new FileInfo :: fileSizes[i] = new FileInfo(files[i]).Length;
- L507 C44: new CompressedFileResult :: var chunkResults = new CompressedFileResult[chunkLen];
- L516 C49: new PackProgress :: progress.Invoke(new PackProgress(
- L555 C57: new PackProgress :: progress.Invoke(new PackProgress(
- L575 C47: new CompressedFileResult :: chunkResults[j] = new CompressedFileResult
- L595 C40: new PackedAsset :: assets.Add(new PackedAsset
- L611 C46: new PackProgress :: progress?.Invoke(new PackProgress(
- L651 C23: new InvalidOperationException :: throw new InvalidOperationException("Archive must contain at least one asset.");
- L663 C56: new TocEntry :: var tocEntries = assets.Select(static a => new TocEntry
- L675 C36: new StringCompressor :: var stringCompressor = new StringCompressor(tocEntries.Select(static e => e.Path));
- L698 C32: new CookedBinaryWriter :: using var writer = new CookedBinaryWriter((byte*)map.Address, totalSize, map);
- L701 C19: new FileStream :: : new FileStream(sourceArchivePath, FileMode.Open, FileAccess.Read, FileShare.Read, 1024 * 64, FileOptions.RandomAccess | FileOptions.SequentialScan);
- L702 C71: new byte :: byte[]? copyBuffer = sourceArchiveStream is null ? null : new byte[ArchiveCopyBufferBytes];
- L740 C31: new StringCompressor :: var stringTable = new StringCompressor(reader);
- L751 C28: new PackedAsset :: assets.Add(new PackedAsset
- L805 C27: new List :: var buckets = new List<TocEntry>[bucketCount];
- L815 C28: new int :: int[] starts = new int[bucketCount];
- L816 C28: new int :: int[] counts = new int[bucketCount];
- L832 C30: new BucketLayout :: return (ordered, new BucketLayout(bucketCount, starts, counts));
- L896 C35: new EndOfStreamException :: throw new EndOfStreamException("Unexpected end of source archive while copying existing asset data.");
- L898 C43: new ReadOnlySpan :: writer.WriteBytes(new ReadOnlySpan<byte>(copyBuffer, 0, read));
- L906 C32: new ReadOnlySpan :: var span = new ReadOnlySpan<byte>((byte*)sourceMap.Address + asset.ExistingDataOffset, asset.CompressedSize);
- L911 C23: new InvalidOperationException :: throw new InvalidOperationException("Existing asset data requires a source archive.");
- L928 C36: new CookedBinaryReader :: using var reader = new CookedBinaryReader((byte*)map.Address, map.Length);
- L930 C27: new InvalidOperationException :: throw new InvalidOperationException("Invalid asset archive format.");
- L934 C27: new InvalidOperationException :: throw new InvalidOperationException($"Unsupported archive version '{version}'. Only V{CurrentVersion} is supported.");
- L944 C40: new StringCompressor :: var stringCompressor = new StringCompressor(reader);
- L960 C36: new CookedBinaryReader :: using var reader = new CookedBinaryReader((byte*)map.Address, map.Length);
- L962 C27: new InvalidOperationException :: throw new InvalidOperationException("Invalid asset archive format.");
- L966 C27: new InvalidOperationException :: throw new InvalidOperationException($"Unsupported archive version '{version}'. Only V{CurrentVersion} is supported.");
- L975 C40: new StringCompressor :: var stringCompressor = new StringCompressor(reader);
- L1010 C20: new FooterInfo :: return new FooterInfo(tocPosition, stringTableOffset, dictionaryOffset, indexOffset, deadBytes);
- L1031 C19: new FileNotFoundException :: throw new FileNotFoundException($"Asset {assetPath} not found");
- L1052 C23: new FileNotFoundException :: throw new FileNotFoundException($"Asset {assetPath} not found");
- L1063 C19: new FileNotFoundException :: throw new FileNotFoundException($"Asset {assetPath} not found");
- L1113 C19: new FileNotFoundException :: throw new FileNotFoundException($"Asset {assetPath} not found");
- L1151 C20: new TocEntryData :: return new TocEntryData(hash, stringOffset, dataOffset, compressedSize, uncompressedSize, contentHash, sourceTimestamp, codec);


## XRENGINE/Core/Files/AssetPacker.StringCompressor.cs
- L61 C39: new StringBuilder :: var builder = new StringBuilder();
- L115 C41: new() :: BufferBuilder builder = new();
- L133 C31: new InvalidOperationException :: throw new InvalidOperationException($"String '{str}' exceeds maximum supported length.");
- L158 C68: new() :: private readonly ArrayBufferWriter<byte> _buffer = new();


## XRENGINE/Core/Files/CookedAssetBlob.cs
- L44 C28: new NotSupportedException :: _ => throw new NotSupportedException($"Unsupported cooked asset format '{blob.Format}'.")
- L58 C23: new ArgumentException :: throw new ArgumentException("Cooked data is empty.", nameof(cookedData));
- L64 C28: new NotSupportedException :: _ => throw new NotSupportedException($"Unsupported cooked asset format '{blob.Format}'.")
- L73 C26: new InvalidOperationException :: ?? throw new InvalidOperationException($"Unable to resolve cooked asset type '{blob.TypeName}'.");


## XRENGINE/Core/Files/CookedBinarySerializer.cs
- L75 C23: new ArgumentOutOfRangeException :: throw new ArgumentOutOfRangeException(nameof(value));
- L98 C21: new Span :: data.CopyTo(new Span<byte>(_cursor, data.Length));
- L133 C39: new Span :: Encoding.UTF8.GetBytes(value, new Span<byte>(_cursor, byteCount));
- L142 C39: new Span :: Encoding.UTF8.GetBytes(value, new Span<byte>(_cursor, byteCount));
- L160 C19: new InvalidOperationException :: throw new InvalidOperationException("Cooked binary writer exceeded allocated buffer.");
- L202 C19: new ArgumentOutOfRangeException :: throw new ArgumentOutOfRangeException(nameof(offset));
- L203 C16: new ReadOnlySpan :: return new ReadOnlySpan<byte>(target, length);
- L245 C48: new ReadOnlySpan :: string value = Encoding.UTF8.GetString(new ReadOnlySpan<byte>(_cursor, length));
- L257 C23: new ArgumentOutOfRangeException :: throw new ArgumentOutOfRangeException(nameof(value));
- L267 C25: new byte :: byte[] result = new byte[length];
- L268 C9: new ReadOnlySpan :: new ReadOnlySpan<byte>(_cursor, length).CopyTo(result);
- L298 C23: new FormatException :: throw new FormatException("7-bit encoded int is too large.");
- L312 C19: new EndOfStreamException :: throw new EndOfStreamException("Attempted to read beyond the end of the cooked buffer.");
- L330 C72: new() :: private static readonly AsyncLocal<int> MemoryPackRecursionDepth = new();
- L342 C23: new MemoryPackRecursionScope :: using var _ = new MemoryPackRecursionScope();
- L352 C19: new InvalidOperationException :: throw new InvalidOperationException($"Cooked payload exceeds maximum supported size ({length} bytes).");
- L354 C25: new byte :: byte[] buffer = new byte[(int)length];
- L359 C36: new CookedBinaryWriter :: using var writer = new CookedBinaryWriter(ptr, buffer.Length);
- L375 C36: new CookedBinaryReader :: using var reader = new CookedBinaryReader(ptr, data.Length);
- L401 C101: new() :: private static readonly Dictionary<Type, Action<CookedBinaryWriter, object>> PrimitiveWriters = new()
- L468 C181: new byte :: [typeof(BitArray)] = (w, v) => { var b = (BitArray)v; w.Write((byte)CookedBinaryTypeMarker.BitArray); w.Write(b.Length); int byteCount = (b.Length + 7) / 8; byte[] bytes = new byte[byteCount]; b.CopyTo(bytes, 0); w.Write(bytes); },
- L657 C44: new Guid :: CookedBinaryTypeMarker.Guid => new Guid(reader.ReadBytes(16)),
- L659 C48: new TimeSpan :: CookedBinaryTypeMarker.TimeSpan => new TimeSpan(reader.ReadInt64()),
- L661 C47: new Vector2 :: CookedBinaryTypeMarker.Vector2 => new Vector2(reader.ReadSingle(), reader.ReadSingle()),
- L662 C47: new Vector3 :: CookedBinaryTypeMarker.Vector3 => new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle()),
- L663 C47: new Vector4 :: CookedBinaryTypeMarker.Vector4 => new Vector4(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle()),
- L664 C50: new Quaternion :: CookedBinaryTypeMarker.Quaternion => new Quaternion(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle()),
- L666 C47: new ColorF3 :: CookedBinaryTypeMarker.ColorF3 => new ColorF3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle()),
- L667 C47: new ColorF4 :: CookedBinaryTypeMarker.ColorF4 => new ColorF4(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle()),
- L671 C54: new DateTimeOffset :: CookedBinaryTypeMarker.DateTimeOffset => new DateTimeOffset(reader.ReadInt64(), TimeSpan.FromMinutes(reader.ReadInt16())),
- L673 C48: new TimeOnly :: CookedBinaryTypeMarker.TimeOnly => new TimeOnly(reader.ReadInt64()),
- L674 C45: new System.Numerics.Plane :: CookedBinaryTypeMarker.Plane => new System.Numerics.Plane(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle()),
- L675 C43: new Uri :: CookedBinaryTypeMarker.Uri => new Uri(reader.ReadString()),
- L680 C47: new Segment :: CookedBinaryTypeMarker.Segment => new Segment(new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle()), new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle())),
- L680 C59: new Vector3 :: CookedBinaryTypeMarker.Segment => new Segment(new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle()), new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle())),
- L680 C135: new Vector3 :: CookedBinaryTypeMarker.Segment => new Segment(new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle()), new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle())),
- L681 C43: new Ray :: CookedBinaryTypeMarker.Ray => new Ray(new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle()), new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle())),
- L681 C51: new Vector3 :: CookedBinaryTypeMarker.Ray => new Ray(new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle()), new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle())),
- L681 C127: new Vector3 :: CookedBinaryTypeMarker.Ray => new Ray(new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle()), new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle())),
- L682 C44: new AABB :: CookedBinaryTypeMarker.AABB => new AABB(new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle()), new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle())),
- L682 C53: new Vector3 :: CookedBinaryTypeMarker.AABB => new AABB(new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle()), new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle())),
- L682 C129: new Vector3 :: CookedBinaryTypeMarker.AABB => new AABB(new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle()), new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle())),
- L683 C46: new Sphere :: CookedBinaryTypeMarker.Sphere => new Sphere(new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle()), reader.ReadSingle()),
- L683 C57: new Vector3 :: CookedBinaryTypeMarker.Sphere => new Sphere(new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle()), reader.ReadSingle()),
- L684 C48: new Triangle :: CookedBinaryTypeMarker.Triangle => new Triangle(new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle()), new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle()), new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle())),
- L684 C61: new Vector3 :: CookedBinaryTypeMarker.Triangle => new Triangle(new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle()), new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle()), new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle())),
- L684 C137: new Vector3 :: CookedBinaryTypeMarker.Triangle => new Triangle(new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle()), new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle()), new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle())),
- L684 C213: new Vector3 :: CookedBinaryTypeMarker.Triangle => new Triangle(new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle()), new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle()), new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle())),
- L690 C47: new Complex :: CookedBinaryTypeMarker.Complex => new Complex(reader.ReadDouble(), reader.ReadDouble()),
- L693 C45: new Range :: CookedBinaryTypeMarker.Range => new Range(new Index(reader.ReadInt32(), reader.ReadBoolean()), new Index(reader.ReadInt32(), reader.ReadBoolean())),
- L693 C55: new Index :: CookedBinaryTypeMarker.Range => new Range(new Index(reader.ReadInt32(), reader.ReadBoolean()), new Index(reader.ReadInt32(), reader.ReadBoolean())),
- L693 C108: new Index :: CookedBinaryTypeMarker.Range => new Range(new Index(reader.ReadInt32(), reader.ReadBoolean()), new Index(reader.ReadInt32(), reader.ReadBoolean())),
- L694 C45: new Index :: CookedBinaryTypeMarker.Index => new Index(reader.ReadInt32(), reader.ReadBoolean()),
- L699 C45: new Regex :: CookedBinaryTypeMarker.Regex => new Regex(reader.ReadString(), (RegexOptions)reader.ReadInt32()),
- L713 C24: new NotSupportedException :: _ => throw new NotSupportedException($"Unknown cooked binary marker '{marker}'.")
- L758 C39: new OwningSceneNodeScope :: using var _ = new OwningSceneNodeScope(sceneNode);
- L1098 C31: new InvalidOperationException :: throw new InvalidOperationException($"Unsupported cooked object encoding '{encoding}'.");
- L1102 C23: new NotSupportedException :: throw new NotSupportedException($"Unknown cooked binary marker '{marker}'.");
- L1117 C56: new InvalidOperationException :: Type enumType = ResolveType(typeName) ?? throw new InvalidOperationException($"Failed to resolve enum type '{typeName}'.");
- L1145 C58: new List :: IList list = (IList)(CreateInstance(listType) ?? new List<object?>());
- L1162 C76: new Dictionary :: IDictionary dictionary = (IDictionary)(CreateInstance(dictType) ?? new Dictionary<object, object?>());
- L1179 C74: new InvalidOperationException :: Type targetType = ResolveType(typeName) ?? expectedType ?? throw new InvalidOperationException($"Failed to resolve cooked asset type '{typeName}'.");
- L1181 C19: new InvalidOperationException :: throw new InvalidOperationException($"Type '{targetType}' does not implement {nameof(ICookedBinarySerializable)}.");
- L1192 C58: new InvalidOperationException :: Type targetType = ResolveType(typeName) ?? throw new InvalidOperationException($"Failed to resolve cooked asset type '{typeName}'.");
- L1198 C24: new InvalidOperationException :: _ => throw new InvalidOperationException($"Unsupported cooked object encoding '{encoding}'.")
- L1220 C55: new InvalidOperationException :: LogTypeDeserializationFailure(targetType, new InvalidOperationException($"Unable to create instance of '{targetType}'."));
- L1237 C39: new OwningSceneNodeScope :: using var _ = new OwningSceneNodeScope(sceneNode);
- L1274 C98: new() :: private static readonly ConcurrentDictionary<Type, byte> LoggedTypeDeserializationFailures = new();
- L1275 C102: new() :: private static readonly ConcurrentDictionary<Type, byte> LoggedMemoryPackSerializationFailures = new();
- L1318 C101: new InvalidOperationException :: ? (XRAsset?)(XRAssetMemoryPackAdapter.Deserialize(payload, targetType) ?? throw new InvalidOperationException($"MemoryPack deserialization returned null for asset type '{targetType}'."))
- L1319 C96: new InvalidOperationException :: : (object?)(MemoryPackSerializer.Deserialize(targetType, payload) ?? throw new InvalidOperationException($"MemoryPack deserialization returned null for type '{targetType}'."));
- L1333 C94: new() :: private static readonly ConcurrentDictionary<Type, byte> LoggedPostDeserializeFailures = new();
- L1356 C16: new DataSource :: return new DataSource(data);
- L1361 C16: new Matrix4x4 :: return new Matrix4x4(
- L1368 C85: new() :: private static readonly ConcurrentDictionary<Type, bool> BlittableStructCache = new();
- L1416 C27: new ReadOnlySpan :: writer.WriteBytes(new ReadOnlySpan<byte>(buffer, size));
- L1430 C19: new InvalidOperationException :: throw new InvalidOperationException($"Blittable struct size mismatch: expected {expectedSize}, got {size} for type '{targetType}'.");
- L1494 C12: new XREvent :: => new XREvent { PersistentCalls = ReadXRPersistentCallList(reader) };
- L1519 C21: new List :: var calls = new List<XRPersistentCall>(count);
- L1527 C20: new XRPersistentCall :: var call = new XRPersistentCall
- L1529 C22: new Guid :: NodeId = new Guid(reader.ReadBytes(16)),
- L1530 C30: new Guid :: TargetObjectId = new Guid(reader.ReadBytes(16)),
- L1538 C39: new string :: call.ParameterTypeNames = new string[paramCount];
- L1600 C61: new() :: private static readonly HashSet<Type> ValueTupleTypes = new()
- L1646 C27: new Type :: Type[] typeArgs = new Type[count];
- L1647 C28: new object :: object?[] values = new object?[count];
- L1667 C24: new NotSupportedException :: _ => throw new NotSupportedException($"ValueTuple with {count} elements is not supported.")
- L1741 C16: new Frustum :: return new Frustum(
- L1751 C16: new BigInteger :: return new BigInteger(bytes);
- L1758 C16: new IPAddress :: return new IPAddress(bytes);
- L1766 C16: new IPEndPoint :: return new IPEndPoint(new IPAddress(addressBytes), port);
- L1766 C31: new IPAddress :: return new IPEndPoint(new IPAddress(addressBytes), port);
- L1774 C16: new BitArray :: return new BitArray(bytes) { Length = bitLength };
- L1800 C24: new Guid :: return new Guid(bytes);
- L1850 C19: new InvalidOperationException :: throw new InvalidOperationException("Cooked binary payload is missing a type hint.");
- L1868 C19: new InvalidOperationException :: throw new InvalidOperationException($"Unable to resolve type '{key}'.");
- L1872 C76: new() :: private static readonly ConcurrentDictionary<string, Type> TypeCache = new();
- L1874 C83: new() :: private static readonly AsyncLocal<ReferenceLoopGuard?> ReflectionLoopGuard = new();
- L1878 C77: new() :: private static readonly AsyncLocal<SceneNode?> CurrentOwningSceneNode = new();
- L1912 C24: new[] :: types: new[] { typeof(SceneNode) },
- L1917 C42: new object :: method.Invoke(component, new object?[] { owner });
- L1932 C39: new object :: setter?.Invoke(component, new object?[] { owner });
- L1945 C51: new ReferenceLoopGuard :: var guard = ReflectionLoopGuard.Value ??= new ReferenceLoopGuard();
- L1958 C24: new ReferenceLoopScope :: return new ReferenceLoopScope(this, null);
- L1962 C20: new ReferenceLoopScope :: return new ReferenceLoopScope(this, instance);
- L1993 C23: new MemoryPackRecursionScope :: using var _ = new MemoryPackRecursionScope();
- L2537 C48: new MemberMetadata :: .Select(p => new MemberMetadata(p))
- L2580 C37: new[] :: Setter.Invoke(instance, new[] { value });
- L2586 C82: new() :: private static readonly ConcurrentDictionary<Type, TypeMetadata> Cache = new();
- L2591 C49: new TypeMetadata :: => Cache.GetOrAdd(type, static t => new TypeMetadata(t));


## XRENGINE/Core/Files/DirectStorageIO.cs
- L33 C48: new() :: private static readonly object QueueLock = new();
- L63 C23: new FileInfo :: long length = new FileInfo(filePath).Length;
- L68 C19: new IOException :: throw new IOException($"File '{filePath}' exceeds the maximum supported size for in-memory loading.");
- L75 C23: new FileInfo :: long length = new FileInfo(filePath).Length;
- L80 C19: new IOException :: throw new IOException($"File '{filePath}' exceeds the maximum supported size for in-memory loading.");
- L127 C19: new ArgumentNullException :: throw new ArgumentNullException(nameof(destination));
- L141 C27: new FileInfo :: long fileLength = new FileInfo(filePath).Length;
- L146 C19: new IOException :: throw new IOException($"File '{filePath}' ({fileLength} bytes) exceeds destination buffer size ({destinationSize} bytes).");
- L196 C23: new ArgumentException :: throw new ArgumentException("File path cannot be null or empty.", nameof(filePath));
- L198 C27: new FileInfo :: long length = new FileInfo(filePath).Length;
- L202 C31: new ReadRequest :: _requests.Add(new ReadRequest(filePath, 0, 0));
- L207 C23: new IOException :: throw new IOException($"File '{filePath}' exceeds the maximum supported size for batch loading.");
- L210 C27: new ReadRequest :: _requests.Add(new ReadRequest(filePath, 0, (int)length));
- L222 C27: new ReadRequest :: _requests.Add(new ReadRequest(filePath, offset, length));
- L234 C24: new byte :: _results = new byte[_requests.Count][];
- L261 C24: new byte :: _results = new byte[_requests.Count][];
- L286 C23: new InvalidOperationException :: throw new InvalidOperationException("Batch has not been submitted. Call Execute() first.");
- L289 C23: new ArgumentOutOfRangeException :: throw new ArgumentOutOfRangeException(nameof(index));
- L291 C45: new InvalidOperationException :: return _results[index] ?? throw new InvalidOperationException(
- L328 C27: new GCHandle :: var handles = new GCHandle[_requests.Count];
- L329 C25: new ComPtr :: var files = new ComPtr<IDStorageFile>[_requests.Count];
- L359 C45: new RequestOptions :: dsRequest.Options = new RequestOptions
- L365 C44: new Source :: dsRequest.Source = new Source
- L367 C36: new SourceFile :: File = new SourceFile
- L374 C49: new Destination :: dsRequest.Destination = new Destination
- L376 C38: new DestinationMemory :: Memory = new DestinationMemory
- L388 C48: new EventWaitHandle :: using var completedEvent = new EventWaitHandle(false, EventResetMode.ManualReset);
- L448 C25: new Task :: var tasks = new Task[_requests.Count];
- L473 C23: new InvalidOperationException :: throw new InvalidOperationException("Batch has already been submitted.");
- L495 C23: new EndOfStreamException :: throw new EndOfStreamException($"Unexpected EOF while reading '{filePath}' at offset {offset + totalRead}.");
- L512 C23: new EndOfStreamException :: throw new EndOfStreamException($"Unexpected EOF while reading '{filePath}' at offset {offset + totalRead}.");
- L526 C24: new Span :: var span = new Span<byte>((byte*)destination + totalRead, length - totalRead);
- L529 C23: new EndOfStreamException :: throw new EndOfStreamException($"Unexpected EOF while reading '{filePath}' at offset {offset + totalRead}.");
- L562 C40: new EventWaitHandle :: using var completedEvent = new EventWaitHandle(false, EventResetMode.ManualReset);
- L573 C35: new RequestOptions :: request.Options = new RequestOptions
- L579 C34: new Source :: request.Source = new Source
- L581 C28: new SourceFile :: File = new SourceFile
- L588 C39: new Destination :: request.Destination = new Destination
- L590 C30: new DestinationMemory :: Memory = new DestinationMemory
- L657 C40: new EventWaitHandle :: using var completedEvent = new EventWaitHandle(false, EventResetMode.ManualReset);
- L660 C31: new RequestOptions :: request.Options = new RequestOptions
- L666 C30: new Source :: request.Source = new Source
- L668 C24: new SourceFile :: File = new SourceFile
- L675 C35: new Destination :: request.Destination = new Destination
- L677 C26: new DestinationMemory :: Memory = new DestinationMemory
- L730 C19: new ArgumentException :: throw new ArgumentException("File path cannot be null or empty.", nameof(filePath));
- L733 C19: new ArgumentOutOfRangeException :: throw new ArgumentOutOfRangeException(nameof(offset));
- L736 C19: new ArgumentOutOfRangeException :: throw new ArgumentOutOfRangeException(nameof(length));
- L746 C20: new RuntimeState :: return new RuntimeState(false, "disabled-by-env");
- L750 C20: new RuntimeState :: return new RuntimeState(false, "unsupported-platform");
- L755 C20: new RuntimeState :: return new RuntimeState(true, "dstoragecore");
- L761 C20: new RuntimeState :: return new RuntimeState(true, "dstorage");
- L764 C16: new RuntimeState :: return new RuntimeState(false, "runtime-missing");
- L797 C20: new DirectStorageQueueContext :: return new DirectStorageQueueContext(api, factory, queue);


## XRENGINE/Core/Files/EventRaisingStreamWriter.cs
- L10 C45: new EventArgs :: StringWritten?.Invoke(this, new EventArgs<string>(str));
- L31 C29: new string :: OnStringWritten(new string(buffer));
- L36 C29: new string :: OnStringWritten(new string(buffer, index, count));
- L116 C29: new string :: OnStringWritten(new string(buffer) + NewLine);
- L121 C29: new string :: OnStringWritten(new string(buffer, index, count) + NewLine);


## XRENGINE/Core/Files/FileMap.cs
- L48 C30: new FileStream :: stream = new FileStream(path, FileMode.Open, (prot == FileMapProtect.ReadWrite) ? FileAccess.ReadWrite : FileAccess.Read, FileShare.Read, 8, options);
- L55 C26: new FileStream :: stream = new FileStream(tempPath, FileMode.Open, FileAccess.ReadWrite, FileShare.Read, 8, options | FileOptions.DeleteOnClose);
- L99 C39: new WFileMap :: PlatformID.Win32NT => new WFileMap(stream.SafeFileHandle.DangerousGetHandle(), prot, offset, length) { _path = stream.Name },
- L100 C22: new CFileMap :: _ => new CFileMap(stream, prot, offset, length) { _path = stream.Name },
- L115 C39: new WFileMap :: PlatformID.Win32NT => new WFileMap(stream.SafeFileHandle.DangerousGetHandle(), prot, offset, length) { _baseStream = stream, _path = stream.Name },
- L116 C22: new CFileMap :: _ => new CFileMap(stream, prot, offset, length) { _baseStream = stream, _path = stream.Name },


## XRENGINE/Core/Files/JsonAsset.cs
- L11 C59: new() :: public class JsonAsset<T> : TextFile where T : class, new()
- L15 C21: new T :: _data = new T();
- L21 C21: new T :: _data = new T();
- L61 C53: new T :: Data = string.IsNullOrEmpty(Text) ? new T() : JsonConvert.DeserializeObject<T>(Text) ?? new T();
- L61 C105: new T :: Data = string.IsNullOrEmpty(Text) ? new T() : JsonConvert.DeserializeObject<T>(Text) ?? new T();


## XRENGINE/Core/Files/TextFile.cs
- L82 C16: new() :: => new() { Text = text };
- L127 C30: new byte :: byte[] bom = new byte[4];


## XRENGINE/Core/Files/XRAsset.MemoryPack.cs
- L36 C23: new InvalidOperationException :: throw new InvalidOperationException($"Unable to resolve asset type '{envelope.Value.TypeName}'.");
- L39 C23: new InvalidOperationException :: throw new InvalidOperationException($"MemoryPack asset type '{resolved}' does not match expected type '{expectedType}'.");


## XRENGINE/Core/Files/XRProject.cs
- L200 C27: new XRProject :: var project = new XRProject(projectName)


## XRENGINE/Core/FontGlyphSet.cs
- L60 C33: new() :: using Library lib = new();
- L145 C35: new() :: using SKPaint paint = new()
- L168 C35: new ushort :: ushort[] glyphs = new ushort[character.Length];
- L176 C34: new float :: float[] widths = new float[glyphs.Length];
- L177 C35: new SKRect :: SKRect[] bounds = new SKRect[glyphs.Length];
- L205 C21: new IVector2 :: new IVector2(width, height),
- L206 C21: new Vector2 :: new Vector2(-glyphBounds.Left, -glyphBounds.Top))));
- L242 C51: new Vector2 :: glyphInfos[i].info.Position = new Vector2(x, y);
- L254 C21: new XRTexture2D :: Atlas = new XRTexture2D(outputAtlasPath)
- L326 C23: new InvalidOperationException :: throw new InvalidOperationException("Glyphs are not initialized.");
- L329 C23: new InvalidOperationException :: throw new InvalidOperationException("Atlas is not initialized.");
- L334 C17: new IVector2 :: new IVector2((int)Atlas.Width, (int)Atlas.Height),
- L465 C23: new InvalidOperationException :: throw new InvalidOperationException("Glyphs are not initialized.");
- L468 C23: new InvalidOperationException :: throw new InvalidOperationException("Atlas is not initialized.");
- L473 C17: new IVector2 :: new IVector2((int)Atlas.Width, (int)Atlas.Height),
- L640 C23: new InvalidOperationException :: throw new InvalidOperationException("Glyphs are not initialized.");
- L708 C23: new InvalidOperationException :: throw new InvalidOperationException("Glyphs are not initialized.");
- L734 C20: new Vector2 :: return new Vector2(width, height);


## XRENGINE/Core/ModelImporter.cs
- L45 C23: new AssimpContext :: _assimp = new AssimpContext();
- L96 C30: new JobProgress :: yield return new JobProgress(1f, result);
- L119 C88: new() :: private readonly ConcurrentDictionary<string, XRTexture2D> _texturePathCache = new();
- L141 C23: new XRMaterial :: var mat = new XRMaterial();
- L156 C25: new ShaderFloat :: new ShaderFloat(1.0f, "Opacity"),
- L157 C25: new ShaderFloat :: new ShaderFloat(1.0f, "Specular"),
- L158 C25: new ShaderFloat :: new ShaderFloat(0.9f, "Roughness"),
- L159 C25: new ShaderFloat :: new ShaderFloat(0.0f, "Metallic"),
- L160 C25: new ShaderFloat :: new ShaderFloat(1.0f, "IndexOfRefraction"),
- L171 C21: new ShaderVector3 :: new ShaderVector3(ColorF3.Magenta, "BaseColor"),
- L172 C21: new ShaderFloat :: new ShaderFloat(1.0f, "Opacity"),
- L173 C21: new ShaderFloat :: new ShaderFloat(1.0f, "Specular"),
- L174 C21: new ShaderFloat :: new ShaderFloat(1.0f, "Roughness"),
- L175 C21: new ShaderFloat :: new ShaderFloat(0.0f, "Metallic"),
- L176 C21: new ShaderFloat :: new ShaderFloat(1.0f, "IndexOfRefraction"),
- L182 C33: new RenderingParameters :: mat.RenderOptions = new RenderingParameters()
- L185 C29: new DepthTest :: DepthTest = new DepthTest()
- L212 C39: new XRTexture :: XRTexture[] textureList = new XRTexture[textures.Count];
- L245 C91: new() :: private readonly ConcurrentDictionary<string, bool> _missingTexturePathWarnings = new();
- L310 C39: new() :: XRTexture2D placeholder = new()
- L325 C40: new Mipmap2D :: placeholder.Mipmaps = [new Mipmap2D(new MagickImage(XRTexture2D.FillerImage))];
- L325 C53: new MagickImage :: placeholder.Mipmaps = [new Mipmap2D(new MagickImage(XRTexture2D.FillerImage))];
- L373 C85: new() :: private readonly ConcurrentDictionary<string, MagickImage?> _textureCache = new();
- L405 C34: new ModelImporter :: using var importer = new ModelImporter(path, onCompleted, materialFactory);
- L424 C23: new TaskCompletionSource :: var tcs = new TaskCompletionSource<(SceneNode?, IReadOnlyCollection<XRMaterial>, IReadOnlyCollection<XRMesh>)>(TaskCreationOptions.RunContinuationsAsynchronously);
- L464 C34: new ModelImporter :: using var importer = new ModelImporter(path, onCompleted: null, materialFactory);
- L491 C26: new ModelImporterResult :: var result = new ModelImporterResult(node, importer._materials, importer._meshes);
- L498 C129: new() :: private static readonly ConcurrentDictionary<(string path, string samplerName), XRTexture2D> _uberSamplerTextureCache = new();
- L504 C27: new XRTexture2D :: var tex = new XRTexture2D
- L520 C36: new Mipmap2D :: tex.Mipmaps = [new Mipmap2D(new MagickImage(XRTexture2D.FillerImage))];
- L520 C49: new MagickImage :: tex.Mipmaps = [new Mipmap2D(new MagickImage(XRTexture2D.FillerImage))];
- L605 C25: new ShaderFloat :: new ShaderFloat(1.0f, "Opacity"),
- L606 C25: new ShaderFloat :: new ShaderFloat(1.0f, "Specular"),
- L607 C25: new ShaderFloat :: new ShaderFloat(0.9f, "Roughness"),
- L608 C25: new ShaderFloat :: new ShaderFloat(0.0f, "Metallic"),
- L609 C25: new ShaderFloat :: new ShaderFloat(1.0f, "IndexOfRefraction"),
- L620 C21: new ShaderVector3 :: new ShaderVector3(ColorF3.Magenta, "BaseColor"),
- L621 C21: new ShaderFloat :: new ShaderFloat(1.0f, "Opacity"),
- L622 C21: new ShaderFloat :: new ShaderFloat(1.0f, "Specular"),
- L623 C21: new ShaderFloat :: new ShaderFloat(1.0f, "Roughness"),
- L624 C21: new ShaderFloat :: new ShaderFloat(0.0f, "Metallic"),
- L625 C21: new ShaderFloat :: new ShaderFloat(1.0f, "IndexOfRefraction"),
- L631 C33: new RenderingParameters :: mat.RenderOptions = new RenderingParameters()
- L634 C29: new DepthTest :: DepthTest = new DepthTest()
- L704 C21: new ShaderFloat :: new ShaderFloat(1.0f, "MatSpecularIntensity"),
- L705 C21: new ShaderFloat :: new ShaderFloat(32.0f, "MatShininess"),
- L706 C21: new ShaderFloat :: new ShaderFloat(0.5f, "AlphaCutoff"), // Default alpha cutoff threshold
- L724 C21: new ShaderVector4 :: new ShaderVector4(new Vector4(1, 0, 1, 1), "MatColor"),
- L724 C39: new Vector4 :: new ShaderVector4(new Vector4(1, 0, 1, 1), "MatColor"),
- L725 C21: new ShaderFloat :: new ShaderFloat(1.0f, "MatSpecularIntensity"),
- L726 C21: new ShaderFloat :: new ShaderFloat(32.0f, "MatShininess"),
- L727 C21: new ShaderFloat :: new ShaderFloat(0.5f, "AlphaCutoff"),
- L733 C33: new RenderingParameters :: mat.RenderOptions = new RenderingParameters()
- L736 C29: new DepthTest :: DepthTest = new DepthTest()
- L795 C17: new ShaderVector4 :: new ShaderVector4(new Vector4(1, 1, 1, 1), "_Color"),
- L795 C35: new Vector4 :: new ShaderVector4(new Vector4(1, 1, 1, 1), "_Color"),
- L796 C17: new ShaderVector4 :: new ShaderVector4(new Vector4(1, 1, 0, 0), "_MainTex_ST"),
- L796 C35: new Vector4 :: new ShaderVector4(new Vector4(1, 1, 0, 0), "_MainTex_ST"),
- L797 C17: new ShaderVector2 :: new ShaderVector2(Vector2.Zero, "_MainTexPan"),
- L798 C17: new ShaderInt :: new ShaderInt(0, "_MainTexUV"),
- L800 C17: new ShaderVector4 :: new ShaderVector4(new Vector4(1, 1, 0, 0), "_BumpMap_ST"),
- L800 C35: new Vector4 :: new ShaderVector4(new Vector4(1, 1, 0, 0), "_BumpMap_ST"),
- L801 C17: new ShaderVector2 :: new ShaderVector2(Vector2.Zero, "_BumpMapPan"),
- L802 C17: new ShaderInt :: new ShaderInt(0, "_BumpMapUV"),
- L803 C17: new ShaderFloat :: new ShaderFloat(bumpScale, "_BumpScale"),
- L805 C17: new ShaderFloat :: new ShaderFloat(1.0f, "_ShadingEnabled"),
- L806 C17: new ShaderInt :: new ShaderInt(6, "_LightingMode"),
- L807 C17: new ShaderVector3 :: new ShaderVector3(new Vector3(1, 1, 1), "_LightingShadowColor"),
- L807 C35: new Vector3 :: new ShaderVector3(new Vector3(1, 1, 1), "_LightingShadowColor"),
- L808 C17: new ShaderFloat :: new ShaderFloat(1.0f, "_ShadowStrength"),
- L809 C17: new ShaderFloat :: new ShaderFloat(0.0f, "_LightingMinLightBrightness"),
- L810 C17: new ShaderFloat :: new ShaderFloat(0.0f, "_LightingMonochromatic"),
- L811 C17: new ShaderFloat :: new ShaderFloat(0.0f, "_LightingCapEnabled"),
- L812 C17: new ShaderFloat :: new ShaderFloat(10.0f, "_LightingCap"),
- L814 C17: new ShaderInt :: new ShaderInt(0, "_MainAlphaMaskMode"),
- L815 C17: new ShaderFloat :: new ShaderFloat(0.0f, "_AlphaMod"),
- L816 C17: new ShaderFloat :: new ShaderFloat(1.0f, "_AlphaForceOpaque"),
- L817 C17: new ShaderFloat :: new ShaderFloat(0.5f, "_Cutoff"),
- L818 C17: new ShaderInt :: new ShaderInt(0, "_Mode"),
- L823 C33: new RenderingParameters :: mat.RenderOptions = new RenderingParameters()
- L826 C29: new DepthTest :: DepthTest = new DepthTest()
- L910 C31: new BooleanPropertyConfig :: _assimp.SetConfig(new BooleanPropertyConfig(AiConfigs.AI_CONFIG_IMPORT_FBX_PRESERVE_PIVOTS, preservePivots));
- L911 C31: new BooleanPropertyConfig :: _assimp.SetConfig(new BooleanPropertyConfig(AiConfigs.AI_CONFIG_IMPORT_FBX_READ_MATERIALS, true));
- L912 C31: new BooleanPropertyConfig :: _assimp.SetConfig(new BooleanPropertyConfig(AiConfigs.AI_CONFIG_IMPORT_FBX_READ_TEXTURES, true));
- L913 C31: new BooleanPropertyConfig :: _assimp.SetConfig(new BooleanPropertyConfig(AiConfigs.AI_CONFIG_GLOB_MULTITHREADING, multiThread));
- L1108 C33: new NodeTransformInfo :: _nodeTransforms.Add(new NodeTransformInfo(
- L1204 C27: new() :: Model model = new();
- L1212 C19: new ConcurrentDictionary :: ? new ConcurrentDictionary<int, SubMesh>()
- L1217 C33: new int :: int[] ordered = new int[count];
- L1278 C26: new XRMesh :: var xrMesh = new XRMesh(mesh, _assimp, _nodeCache, dataTransform);


## XRENGINE/Core/Platform/Win32.cs
- L35 C81: new SafeHandle :: public static implicit operator SafeHandle(VoidPtr handle) { return new SafeHandle(handle); }
- L42 C24: new SafeHandle :: return new SafeHandle(hFile);


## XRENGINE/Core/ProjectionMatrixCombiner.cs
- L23 C30: new List :: var allCorners = new List<Vector3>(corners1);
- L35 C40: new Vector3 :: Vector3[] frustumCorners = new Vector3[8];
- L43 C56: new Vector4 :: Vector4 ws = Vector4.Transform(new Vector4(x, y, z, 1.0f), invViewProj);


## XRENGINE/Core/Reflection/AssemblyQualifiedName.cs
- L36 C27: new Version :: Version = new Version(VersionMajor, VersionMinor, VersionBuild, VersionRevision),
- L67 C57: new CultureInfo :: CultureInfo = culture == "neutral" ? null : new CultureInfo(culture);


## XRENGINE/Core/SnapshotAssetReference.cs
- L29 C12: new() :: => new()
- L80 C46: new object :: if (method.Invoke(Engine.Assets, new object[] { AssetPath! }) is XRAsset asset)


## XRENGINE/Core/SnapshotBinarySerializer.cs
- L12 C76: new() :: private static readonly CookedBinarySerializationCallbacks Callbacks = new()


## XRENGINE/Core/SnapshotYamlSerializer.cs
- L23 C27: new SerializerBuilder :: var builder = new SerializerBuilder()
- L27 C50: new DepthTrackingEventEmitter :: .WithEventEmitter(nextEmitter => new DepthTrackingEventEmitter(nextEmitter))
- L28 C45: new SafeComponentTypeInspector :: .WithTypeInspector(inner => new SafeComponentTypeInspector(inner))
- L47 C41: new SafePropertyDescriptor :: yield return wrap ? new SafePropertyDescriptor(descriptor, type) : descriptor;
- L56 C24: new SafePropertyDescriptor :: return new SafePropertyDescriptor(descriptor, type);
- L68 C121: new() :: private static readonly ConcurrentDictionary<(Type DeclaringType, string PropertyName), byte> LoggedSkips = new();
- L120 C28: new ObjectDescriptor :: return new ObjectDescriptor(fallback, propertyType, propertyType);


## XRENGINE/Core/StateObject.cs
- L7 C82: new() :: private static readonly ResourcePool<StateObject> _statePool = new(() => new());


## XRENGINE/Core/Time/EngineTimer.cs
- L116 C45: new() :: private readonly Stopwatch _watch = new();
- L125 C47: new() :: public DeltaManager Render { get; } = new();
- L126 C47: new() :: public DeltaManager Update { get; } = new();
- L127 C48: new() :: public DeltaManager Collect { get; } = new();
- L128 C59: new() :: public DeltaManager FixedUpdateManager { get; } = new();
- L161 C27: new ManualResetEventSlim :: _renderDone = new ManualResetEventSlim(false);
- L162 C25: new ManualResetEventSlim :: _swapDone = new ManualResetEventSlim(true);


## XRENGINE/Core/Tools/DelegateBuilder.cs
- L10 C38: new Queue :: var queueMissingParams = new Queue<object>(missingParamValues);
- L12 C64: new InvalidOperationException :: var dgtMi = typeof(T).GetMethod("Invoke") ?? throw new InvalidOperationException($"Type {typeof(T)} does not have an Invoke method");
- L36 C103: new InvalidOperationException :: var paramThis = Expression.Convert(paramsOfDelegate[0], method.DeclaringType ?? throw new InvalidOperationException("Method has no declaring type"));


## XRENGINE/Core/Tools/ExpressionParser.cs
- L17 C35: new() :: Queue<string> queue = new();
- L18 C35: new() :: Stack<string> stack = new();
- L41 C36: new InvalidCastException :: _ => throw new InvalidCastException(),
- L43 C23: new InvalidCastException :: throw new InvalidCastException();
- L152 C27: new Exception :: throw new Exception("Invalid string: " + token);
- L169 C27: new Exception :: throw new Exception("Invalid method: " + token);
- L188 C27: new Exception :: throw new Exception("Cannot invert numeric types.");
- L221 C23: new Exception :: throw new Exception("Cannot invert non-bool.");
- L277 C39: new InvalidOperationException :: throw new InvalidOperationException("Cannot negate an unsigned integer.");
- L304 C35: new InvalidOperationException :: throw new InvalidOperationException("Cannot negate an unsigned integer.");
- L349 C85: new() :: private static readonly Dictionary<string, string[]> _implicitConversions = new()
- L351 C25: new string :: { "SByte",  new string[] { "Int16", "Int32", "Int64", "Single", "Double", "Decimal" } },
- L352 C25: new string :: { "Byte",   new string[] { "Int16", "UInt16", "Int32", "UInt32", "Int64", "UInt64", "Single", "Double", "Decimal" } },
- L353 C25: new string :: { "Int16",  new string[] { "Int32", "Int64", "Single", "Double", "Decimal" } },
- L354 C25: new string :: { "UInt16", new string[] { "Int32", "UInt32", "Int64", "UInt64", "Single", "Double", "Decimal" } },
- L355 C25: new string :: { "Int32",  new string[] { "Int64", "Single", "Double", "Decimal" } },
- L356 C25: new string :: { "UInt32", new string[] { "Int64", "UInt64", "Single", "Double", "Decimal" } },
- L357 C25: new string :: { "Int64",  new string[] { "Single", "Double", "Decimal" } },
- L358 C25: new string :: { "UInt64", new string[] { "Single", "Double", "Decimal" } },
- L359 C25: new string :: { "Char",   new string[] { "UInt16", "Int32", "UInt32", "Int64", "UInt64", "Single", "Double", "Decimal" } },
- L360 C25: new string :: { "Single", new string[] { "Single", "Double" } },
- L382 C35: new InvalidOperationException :: throw new InvalidOperationException($"Operator {token} needs operands on both sides.");
- L398 C35: new Exception :: throw new Exception();
- L408 C35: new Exception :: throw new Exception();
- L424 C39: new Exception :: throw new Exception("Cannot logical-and non-boolean types.");
- L429 C39: new Exception :: throw new Exception("Cannot logical-or non-boolean types.");
- L450 C35: new Exception :: throw new Exception(string.Format("Token \"{0}\" not supported.", token));
- L473 C23: new Exception :: throw new Exception($"Cannot evaluate {t1.Name} {token} {t2.Name}");
- L494 C27: new Exception :: throw new Exception($"Cannot evaluate {t1.Name} {token} {t2.Name}");
- L497 C23: new Exception :: throw new Exception($"Cannot evaluate {t1.Name} {token} {t2.Name}");
- L559 C28: new Exception :: _ => throw new Exception("Not a numeric primitive type"),
- L576 C28: new Exception :: _ => throw new Exception("Not a numeric primitive type"),
- L593 C28: new Exception :: _ => throw new Exception("Not a numeric primitive type"),
- L610 C28: new Exception :: _ => throw new Exception("Not a numeric primitive type"),
- L627 C28: new Exception :: _ => throw new Exception("Not a numeric primitive type"),
- L641 C60: new Exception :: "Single" or "Double" or "Decimal" => throw new Exception("Cannot left shift " + commonType),
- L642 C28: new Exception :: _ => throw new Exception("Not a numeric primitive type"),
- L656 C60: new Exception :: "Single" or "Double" or "Decimal" => throw new Exception("Cannot right shift " + commonType),
- L657 C28: new Exception :: _ => throw new Exception("Not a numeric primitive type"),
- L671 C60: new Exception :: "Single" or "Double" or "Decimal" => throw new Exception("Cannot bitwise-and " + commonType),
- L672 C28: new Exception :: _ => throw new Exception("Not a numeric primitive type"),
- L686 C60: new Exception :: "Single" or "Double" or "Decimal" => throw new Exception("Cannot bitwise-xor " + commonType),
- L687 C28: new Exception :: _ => throw new Exception("Not a numeric primitive type"),
- L701 C60: new Exception :: "Single" or "Double" or "Decimal" => throw new Exception("Cannot bitwise-or " + commonType),
- L702 C28: new Exception :: _ => throw new Exception("Not a numeric primitive type"),
- L719 C28: new Exception :: _ => throw new Exception("Not a numeric primitive type"),
- L736 C28: new Exception :: _ => throw new Exception("Not a numeric primitive type"),
- L753 C28: new Exception :: _ => throw new Exception("Not a numeric primitive type"),
- L770 C28: new Exception :: _ => throw new Exception("Not a numeric primitive type"),
- L788 C28: new Exception :: _ => throw new Exception("Not a primitive type"),
- L806 C28: new Exception :: _ => throw new Exception("Not a primitive type"),


## XRENGINE/Core/Tools/GLSLParser.cs
- L92 C28: new Variable :: var variable = new Variable
- L124 C24: new Variable :: Consts.Add(new Variable
- L142 C26: new Method :: var method = new Method
- L158 C43: new Parameter :: method.Parameters.Add(new Parameter
- L188 C29: new ParsedInvocation :: invocations.Add(new ParsedInvocation(


## XRENGINE/Core/Tools/Remapper.cs
- L25 C23: new InvalidOperationException :: throw new InvalidOperationException();
- L31 C50: new() :: private static readonly object NullKey = new();
- L38 C45: new() :: Dictionary<object, int> cache = new();
- L40 C27: new int :: _remapTable = new int[count];
- L41 C25: new int :: _impTable = new int[count];
- L72 C28: new int :: int[] sorted = new int[impCount];


## XRENGINE/Core/Tools/Triangle Converter/CacheSimulator.cs
- L17 C22: new Deque :: _cache = new Deque<uint>();


## XRENGINE/Core/Tools/Triangle Converter/GraphArray.cs
- L11 C39: new() :: protected List<Node> _nodes = new();
- L12 C37: new() :: protected List<Arc> _arcs = new();
- L47 C22: new List :: _nodes = new List<Node>();
- L48 C21: new List :: _arcs = new List<Arc>();
- L52 C22: new List :: _nodes = new List<Node>();
- L53 C21: new List :: _arcs = new List<Arc>();
- L55 C28: new Node :: _nodes.Add(new Node(this));
- L76 C21: new Arc :: Arc r = new Arc(_nodes[(int)terminal]);


## XRENGINE/Core/Tools/Triangle Converter/HeapArray.cs
- L35 C21: new List :: _Heap = new List<Linker>();
- L36 C23: new List :: _Finder = new List<uint>();
- L97 C23: new Linker :: _Heap.Add(new Linker(Elem, Id));


## XRENGINE/Core/Tools/Triangle Converter/Policy.cs
- L48 C32: new Strip :: private Strip _Strip = new Strip();


## XRENGINE/Core/Tools/Triangle Converter/TriStripper.cs
- L18 C23: new List :: Indices = new List<uint>();
- L19 C23: new List :: NodeIDs = new List<ushort>();
- L47 C26: new GraphArray :: _Triangles = new GraphArray<Triangle>((uint)TriIndices.Length / 3);
- L50 C33: new List :: _PrimitivesVector = new List<Primitive>();
- L51 C24: new HeapArray :: _TriHeap = new HeapArray(CompareType.Less);
- L52 C27: new List :: _Candidates = new List<uint>();
- L53 C22: new CacheSimulator :: _Cache = new CacheSimulator();
- L54 C26: new CacheSimulator :: _BackCache = new CacheSimulator();
- L174 C27: new Primitive :: Primitive p = new Primitive(PrimType.TriangleList);
- L198 C26: new Policy :: Policy policy = new Policy(_MinStripSize, Cache);
- L246 C29: new List :: _CurrentNodes = new List<ushort>();
- L285 C20: new Strip :: return new Strip(Start, StartOrder, Size);
- L289 C29: new List :: _CurrentNodes = new List<ushort>();
- L344 C20: new Strip :: return new Strip(Node._elem._index, Order, Size);
- L441 C27: new Primitive :: Primitive p = new Primitive(PrimType.TriangleStrip);
- L556 C33: new TriangleEdge :: TriOrder.ABC => new TriangleEdge(Triangle.A, Triangle.B),
- L557 C33: new TriangleEdge :: TriOrder.BCA => new TriangleEdge(Triangle.B, Triangle.C),
- L558 C33: new TriangleEdge :: TriOrder.CAB => new TriangleEdge(Triangle.C, Triangle.A),
- L559 C22: new TriangleEdge :: _ => new TriangleEdge(0, 0),
- L566 C43: new TriangleEdge :: case TriOrder.ABC: return new TriangleEdge(Triangle.B, Triangle.C);
- L567 C43: new TriangleEdge :: case TriOrder.BCA: return new TriangleEdge(Triangle.C, Triangle.A);
- L568 C43: new TriangleEdge :: case TriOrder.CAB: return new TriangleEdge(Triangle.A, Triangle.B);
- L569 C33: new TriangleEdge :: default: return new TriangleEdge(0, 0);
- L595 C44: new Triangle :: Triangles[(uint)i]._elem = new Triangle(
- L601 C37: new List :: List<TriEdge> EdgeMap = new List<TriEdge>();
- L605 C29: new TriEdge :: EdgeMap.Add(new TriEdge(Tri.A, Tri.B, i));
- L606 C29: new TriEdge :: EdgeMap.Add(new TriEdge(Tri.B, Tri.C, i));
- L607 C29: new TriEdge :: EdgeMap.Add(new TriEdge(Tri.C, Tri.A, i));
- L615 C52: new TriEdge :: LinkNeighbours(Triangles, EdgeMap, new TriEdge(Tri.B, Tri.A, i));
- L616 C52: new TriEdge :: LinkNeighbours(Triangles, EdgeMap, new TriEdge(Tri.C, Tri.B, i));
- L617 C52: new TriEdge :: LinkNeighbours(Triangles, EdgeMap, new TriEdge(Tri.A, Tri.C, i));


## XRENGINE/Core/Tools/Unity/UnityConverter.cs
- L25 C25: new List :: var anims = new List<(string? path, string? attrib, BasePropAnim anim)>();
- L28 C28: new PropAnimFloat :: var anim = new PropAnimFloat
- L40 C28: new FloatKeyframe :: return new FloatKeyframe
- L55 C24: new AnimationClip :: var tree = new AnimationClip();


## XRENGINE/Core/WorldStateSnapshot.cs
- L67 C36: new Dictionary :: var serializedScenes = new Dictionary<string, byte[]>(StringComparer.Ordinal);
- L120 C24: new WorldStateSnapshot :: return new WorldStateSnapshot(
- L131 C24: new WorldStateSnapshot :: return new WorldStateSnapshot(
- L210 C42: new HashSet :: var processedSceneKeys = new HashSet<string>(StringComparer.Ordinal);
- L262 C41: new HashSet :: var expectedRoots = new HashSet<SceneNode>(System.Collections.Generic.ReferenceEqualityComparer.Instance);
- L354 C58: new List :: scene.RootNodes = restoredScene.RootNodes ?? new List<SceneNode>();


## XRENGINE/Core/XRTypeRedirectRegistry.cs
- L85 C38: new RedirectTarget :: var target = new RedirectTarget(


## XRENGINE/Engine/Engine.cs
- L86 C84: new() :: private static readonly ConcurrentQueue<Action> _pendingUpdateThreadWork = new();
- L91 C85: new() :: private static readonly ConcurrentQueue<Action> _pendingPhysicsThreadWork = new();
- L135 C108: new() :: private static readonly Dictionary<IOverrideableSetting, string> _overrideableSettingPropertyMap = new();
- L189 C28: new UserSettings :: UserSettings = new UserSettings();
- L190 C28: new GameStartupSettings :: GameSettings = new GameStartupSettings();
- L191 C29: new BuildSettings :: BuildSettings = new BuildSettings();
- L192 C39: new EditorPreferences :: GlobalEditorPreferences = new EditorPreferences();
- L193 C42: new EditorPreferencesOverrides :: EditorPreferencesOverrides = new EditorPreferencesOverrides();
- L194 C34: new EditorPreferences :: _editorPreferences = new EditorPreferences();
- L260 C53: new() :: public static AudioManager Audio { get; } = new();
- L268 C54: new() :: public static AssetManager Assets { get; } = new();
- L273 C48: new() :: public static Random Random { get; } = new();
- L281 C56: new() :: public static CodeProfiler Profiler { get; } = new();
- L340 C30: new TaskCompletionSource :: var completion = new TaskCompletionSource<IReadOnlyList<XRViewport>>(TaskCreationOptions.RunContinuationsAsynchronously);


## XRENGINE/Engine/Engine.MainThreadInvokeLog.cs
- L27 C95: new() :: private static readonly ConcurrentQueue<MainThreadInvokeEntry> _mainThreadInvokeLog = new();
- L32 C25: new MainThreadInvokeEntry :: var entry = new MainThreadInvokeEntry(


## XRENGINE/Engine/Engine.Networking.cs
- L116 C34: new ServerNetworkingManager :: var server = new ServerNetworkingManager();
- L124 C34: new ClientNetworkingManager :: var client = new ClientNetworkingManager();
- L133 C37: new PeerToPeerNetworkingManager :: var p2pClient = new PeerToPeerNetworkingManager();
- L144 C40: new RemoteJobNetworkingTransport :: Jobs.RemoteTransport = new RemoteJobNetworkingTransport(net);
- L225 C40: new Dictionary :: responseMetadata = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
- L231 C24: new RemoteJobResponse :: return new RemoteJobResponse
- L243 C24: new RemoteJobResponse :: return new RemoteJobResponse


## XRENGINE/Engine/Engine.ProfilerSender.cs
- L27 C23: new ProfilerThreadData :: var threads = new ProfilerThreadData[snapshot.Threads.Count];
- L31 C26: new ProfilerThreadData :: threads[i] = new ProfilerThreadData
- L39 C16: new ProfilerFramePacket :: return new ProfilerFramePacket
- L52 C22: new ProfilerNodeData :: var result = new ProfilerNodeData[nodes.Count];
- L56 C25: new ProfilerNodeData :: result[i] = new ProfilerNodeData
- L69 C31: new RenderMatrixListenerEntry :: var listenerEntries = new RenderMatrixListenerEntry[listenerSnapshot.Length];
- L72 C34: new RenderMatrixListenerEntry :: listenerEntries[i] = new RenderMatrixListenerEntry
- L79 C16: new RenderStatsPacket :: return new RenderStatsPacket
- L128 C16: new ThreadAllocationsPacket :: return new ThreadAllocationsPacket
- L138 C12: new() :: => new()
- L150 C16: new BvhMetricsPacket :: return new BvhMetricsPacket
- L167 C26: new JobPriorityStatsEntry :: var priorities = new JobPriorityStatsEntry[priorityCount];
- L172 C29: new JobPriorityStatsEntry :: priorities[i] = new JobPriorityStatsEntry
- L183 C16: new JobSystemStatsPacket :: return new JobSystemStatsPacket
- L200 C23: new MainThreadInvokeEntryData :: var entries = new MainThreadInvokeEntryData[invokes.Count];
- L204 C26: new MainThreadInvokeEntryData :: entries[i] = new MainThreadInvokeEntryData
- L214 C16: new MainThreadInvokesPacket :: return new MainThreadInvokesPacket { Entries = entries };


## XRENGINE/Engine/Engine.Project.cs
- L201 C54: new EditorPreferences :: var created = GlobalEditorPreferences ?? new EditorPreferences();
- L238 C57: new EditorPreferencesOverrides :: var created = EditorPreferencesOverrides ?? new EditorPreferencesOverrides();
- L265 C57: new EditorPreferencesOverrides :: var created = EditorPreferencesOverrides ?? new EditorPreferencesOverrides();
- L391 C44: new BuildSettings :: var created = BuildSettings ?? new BuildSettings();
- L565 C45: new BuildSettings :: var settings = BuildSettings ?? new BuildSettings();
- L578 C45: new BuildSettings :: var settings = BuildSettings ?? new BuildSettings();


## XRENGINE/Engine/Engine.Settings.cs
- L30 C42: new UserSettings :: _userSettings = value ?? new UserSettings();
- L60 C42: new GameStartupSettings :: _gameSettings = value ?? new GameStartupSettings();
- L62 C49: new BuildSettings :: _gameSettings.BuildSettings ??= new BuildSettings();
- L90 C55: new BuildSettings :: GameSettings.BuildSettings = value ?? new BuildSettings();
- L117 C53: new EditorPreferences :: _globalEditorPreferences = value ?? new EditorPreferences();
- L145 C56: new EditorPreferencesOverrides :: _editorPreferencesOverrides = value ?? new EditorPreferencesOverrides();
- L499 C36: new EditorPreferences :: _editorPreferences ??= new EditorPreferences();
- L500 C42: new EditorPreferences :: _globalEditorPreferences ??= new EditorPreferences();
- L501 C45: new EditorPreferencesOverrides :: _editorPreferencesOverrides ??= new EditorPreferencesOverrides();


## XRENGINE/Engine/Engine.Threading.cs
- L75 C30: new ActionJob :: => Jobs.Schedule(new ActionJob(task), JobPriority.Normal, JobAffinity.CollectVisibleSwap);
- L85 C30: new CoroutineJob :: => Jobs.Schedule(new CoroutineJob(task), JobPriority.Normal, JobAffinity.CollectVisibleSwap);
- L96 C30: new ActionJob :: => Jobs.Schedule(new ActionJob(task), JobPriority.Normal, JobAffinity.MainThread);
- L104 C30: new LabeledActionJob :: => Jobs.Schedule(new LabeledActionJob(task, reason), JobPriority.Normal, JobAffinity.MainThread);
- L142 C30: new CoroutineJob :: => Jobs.Schedule(new CoroutineJob(task), JobPriority.Normal, JobAffinity.MainThread);


## XRENGINE/Engine/Engine.TickList.cs
- L34 C81: new() :: private readonly ConcurrentQueue<(bool Add, DelTick Func)> _queue = new();


## XRENGINE/Engine/Engine.ViewportRebind.cs
- L282 C34: new List :: var componentTypes = new List<string>();
- L380 C27: new HashSet :: var visited = new HashSet<SceneNode>();


## XRENGINE/Engine/Engine.VRState.cs
- L51 C58: new VR :: public static VR OpenVRApi => _openVRApi ??= new VR();
- L70 C87: new VRIKCalibrator.Settings :: public static VRIKCalibrator.Settings CalibrationSettings { get; set; } = new VRIKCalibrator.Settings();
- L293 C36: new OpenXRAPI :: _openXRApi ??= new OpenXRAPI();
- L582 C42: new XRRenderPipelineInstance :: _twoPassRenderPipeline = new XRRenderPipelineInstance(new DefaultRenderPipeline(false));
- L582 C71: new DefaultRenderPipeline :: _twoPassRenderPipeline = new XRRenderPipelineInstance(new DefaultRenderPipeline(false));
- L596 C111: new XRViewport :: VRLeftEyeRenderTarget = MakeTwoPassFBO(rW, rH, VRLeftEyeViewTexture = left, LeftEyeViewport = new XRViewport(window)
- L602 C115: new XRViewport :: VRRightEyeRenderTarget = MakeTwoPassFBO(rW, rH, VRRightEyeViewTexture = right, RightEyeViewport = new XRViewport(window)
- L612 C64: new XRViewport :: SetViewportParameters(rW, rH, StereoViewport = new XRViewport(window));
- L613 C49: new DefaultRenderPipeline :: StereoViewport.RenderPipeline = new DefaultRenderPipeline(true);
- L619 C38: new XRTexture2DArray :: var outputTextures = new XRTexture2DArray(left, right)
- L625 C40: new XRFrameBuffer :: VRStereoRenderTarget = new XRFrameBuffer((outputTextures, EFrameBufferAttachment.ColorAttachment0, 0, -1));
- L626 C41: new XRTexture2DArrayView :: StereoLeftViewTexture = new XRTexture2DArrayView(outputTextures, 0u, 1u, 0u, 1u, ESizedInternalFormat.Rgb8, false, false);
- L627 C42: new XRTexture2DArrayView :: StereoRightViewTexture = new XRTexture2DArrayView(outputTextures, 0u, 1u, 1u, 1u, ESizedInternalFormat.Rgb8, false, false);
- L653 C45: new Frustum :: _stereoCullingFrustum = new Frustum((_combinedProjectionMatrix = ProjectionMatrixCombiner.CombineProjectionMatrices(leftProj, rightProj, leftEyeView, rightEyeView)).Inverted());
- L901 C26: new XRMaterialFrameBuffer :: var rt = new XRMaterialFrameBuffer(new XRMaterial([tex], ShaderHelper.UnlitTextureFragForward()!));
- L901 C52: new XRMaterial :: var rt = new XRMaterialFrameBuffer(new XRMaterial([tex], ShaderHelper.UnlitTextureFragForward()!));
- L949 C36: new VrManifest :: applications = new VrManifest[] { vrManifest }
- L958 C70: new() :: private static readonly JsonSerializerOptions JSonOpts = new()
- L1013 C65: new() :: private static VRTextureBounds_t _singleTexBounds = new()
- L1037 C48: new() :: private static Texture_t _eyeTex = new()
- L1191 C55: new() :: Compositor_FrameTiming currentFrame = new();
- L1192 C56: new() :: Compositor_FrameTiming previousFrame = new();
- L1281 C48: new() :: private static VRInputData _data = new();
- L1393 C27: new Exception :: throw new Exception("Failed to duplicate handle.");
- L1432 C32: new IntPtr :: memoryHandle = new IntPtr(memoryHandleValue);
- L1433 C35: new IntPtr :: semaphoreHandle = new IntPtr(semaphoreHandleValue);


## XRENGINE/Engine/Engine.Windows.cs
- L40 C26: new XRWindow :: window = new XRWindow(options, windowSettings.UseNativeTitleBar);
- L45 C31: new GraphicsAPI :: options.API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(4, 6));
- L45 C119: new APIVersion :: options.API = new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(4, 6));
- L46 C26: new XRWindow :: window = new XRWindow(options, windowSettings.UseNativeTitleBar);
- L128 C32: new Vector2D :: position = new Vector2D<int>(0, 0);
- L131 C28: new Vector2D :: size = new Vector2D<int>(primaryX, primaryY);
- L148 C23: new GraphicsAPI :: ? new GraphicsAPI(ContextAPI.Vulkan, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(1, 1))
- L148 C111: new APIVersion :: ? new GraphicsAPI(ContextAPI.Vulkan, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(1, 1))
- L149 C23: new GraphicsAPI :: : new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(4, 6)),
- L149 C111: new APIVersion :: : new GraphicsAPI(ContextAPI.OpenGL, ContextProfile.Core, ContextFlags.ForwardCompatible, new APIVersion(4, 6)),


## XRENGINE/Engine/Networking/Engine.BaseNetworkingManager.cs
- L142 C93: new() :: protected ConcurrentQueue<(ushort sequenceNum, byte[])> UdpSendQueue { get; } = new();
- L157 C68: new() :: private readonly CancellationTokenSource _consumeCts = new();
- L305 C39: new() :: UdpClient udpClient = new() { /*ExclusiveAddressUse = false*/ };
- L307 C37: new IPEndPoint :: MulticastEndPoint = new IPEndPoint(udpMulticastIP, udpMulticastPort);
- L326 C39: new IPEndPoint :: udpClient.Client.Bind(new IPEndPoint(IPAddress.Any, upMulticastServerPort));
- L333 C88: new() :: private readonly ConcurrentDictionary<ushort, PendingAckPacket> _mustAck = new();
- L341 C45: new PendingAckPacket :: _mustAck[sequenceNum] = new PendingAckPacket(ownerId, bytes, firstSend, maxAckWaitSec);
- L396 C92: new() :: private readonly ConcurrentQueue<(float timestamp, int bytes)> _bytesSentLog = new();
- L624 C38: new StateChangeInfo :: ReplicateStateChange(new StateChangeInfo(EStateChangeType.RemoteJobRequest, serialized), compress, resendOnFailedAck, maxAckWaitSec);
- L631 C38: new StateChangeInfo :: ReplicateStateChange(new StateChangeInfo(EStateChangeType.RemoteJobResponse, serialized), compress, resendOnFailedAck, maxAckWaitSec);
- L638 C38: new StateChangeInfo :: ReplicateStateChange(new StateChangeInfo(EStateChangeType.ServerError, serialized), compress, resendOnFailedAck, maxAckWaitSec);
- L645 C38: new StateChangeInfo :: ReplicateStateChange(new StateChangeInfo(EStateChangeType.HumanoidPoseFrame, serialized), compress, resendOnFailedAck, maxAckWaitSec);
- L651 C38: new StateChangeInfo :: ReplicateStateChange(new StateChangeInfo(type, serialized), compress, resendOnFailedAck, maxAckWaitSec);
- L656 C66: new() :: private SevenZip.Compression.LZMA.Encoder _encoder = new();
- L657 C66: new() :: private SevenZip.Compression.LZMA.Decoder _decoder = new();
- L658 C50: new() :: private MemoryStream _compStreamIn = new();
- L659 C51: new() :: private MemoryStream _compStreamOut = new();
- L660 C52: new() :: private MemoryStream _decompStreamIn = new();
- L661 C53: new() :: private MemoryStream _decompStreamOut = new();
- L699 C41: new byte :: byte[] uncompData = new byte[GuidLen + uncompDataLen];
- L706 C31: new byte :: allData = new byte[HeaderLen + compDataLen];
- L713 C31: new byte :: allData = new byte[HeaderLen + GuidLen + uncompDataLen];
- L762 C51: new sequence :: return true; // This is a new sequence we haven't seen before
- L773 C36: new List :: var tempList = new List<ushort>(_receivedRemoteSequences.Cast<ushort>());
- L828 C46: new byte :: protected byte[] _decompBuffer = new byte[400000];
- L837 C39: new byte :: byte[] protocol = new byte[3];
- L972 C21: new Guid :: new Guid([.. inBuf.Skip(dataOffset).Take(GuidLen)]),
- L984 C21: new Guid :: new Guid([.. decompBuffer.Take(GuidLen)]),
- L1062 C48: new byte :: byte[] slice = new byte[dataLen];
- L1125 C40: new RemoteJobResponse :: var enriched = new RemoteJobResponse
- L1140 C48: new RemoteJobResponse :: BroadcastRemoteJobResponse(new RemoteJobResponse
- L1183 C32: new FileInfo :: var fileInfo = new FileInfo(filePath);
- L1186 C42: new() :: using TcpClient client = new();
- L1193 C33: new byte :: byte[] buffer = new byte[8192];
- L1208 C42: new() :: using TcpClient client = new();
- L1213 C33: new byte :: byte[] buffer = new byte[8192];
- L1230 C38: new byte :: byte[] lengthBytes = new byte[8];
- L1233 C33: new byte :: byte[] buffer = new byte[8192];
- L1251 C38: new byte :: byte[] lengthBytes = new byte[8];
- L1254 C33: new byte :: byte[] buffer = new byte[8192];
- L1403 C20: new IdValue :: return new IdValue(value.idStr, value.value);


## XRENGINE/Engine/Networking/Engine.ClientNetworkingManager.cs
- L38 C82: new() :: private readonly Dictionary<int, RemotePlayerState> _remotePlayers = new();
- L39 C65: new() :: private readonly HashSet<int> _localServerIndices = new();
- L87 C29: new UdpClient :: UdpSender = new UdpClient();
- L88 C28: new IPEndPoint :: ServerIP = new IPEndPoint(serverIP, udpMulticastServerPort);
- L183 C45: new() :: PlayerJoinRequest request = new()
- L208 C37: new PlayerHeartbeat :: var heartbeat = new PlayerHeartbeat
- L234 C36: new PlayerInputSnapshot :: var snapshot = new PlayerInputSnapshot
- L261 C48: new() :: PlayerTransformUpdate update = new()
- L286 C33: new PlayerLeaveNotice :: var leave = new PlayerLeaveNotice
- L367 C33: new() :: XRWorld world = new()
- L508 C101: new WorldSyncDescriptor :: XRWorldInstance? worldInstance = ResolvePrimaryWorldInstance() ?? EnsureClientWorld(new WorldSyncDescriptor());
- L516 C34: new RemotePlayerController :: var controller = new RemotePlayerController(serverPlayerIndex)
- L524 C30: new RemotePlayerState :: var remote = new RemotePlayerState(serverPlayerIndex, controller, pawn);
- L536 C28: new SceneNode :: var node = new SceneNode(worldInstance, nodeName);


## XRENGINE/Engine/Networking/Engine.ServerNetworkingManager.cs
- L23 C51: new() :: private readonly object _playerLock = new();
- L24 C89: new() :: private readonly Dictionary<int, NetworkPlayerConnection> _playersByIndex = new();
- L51 C38: new() :: UdpClient listener = new();
- L53 C38: new IPEndPoint :: listener.Client.Bind(new IPEndPoint(IPAddress.Any, udpPort));
- L121 C38: new NetworkPlayerConnection :: connection = new NetworkPlayerConnection
- L149 C34: new PlayerAssignment :: var assignment = new PlayerAssignment
- L181 C44: new CustomGameMode :: worldInstance.GameMode ??= new CustomGameMode { WorldInstance = worldInstance };
- L189 C38: new RemotePlayerController :: var controller = new RemotePlayerController(connection.ServerPlayerIndex)
- L202 C28: new SceneNode :: var node = new SceneNode(worldInstance, nodeName);
- L316 C38: new ServerConnectionInfo :: .Select(p => new ServerConnectionInfo(p.ServerPlayerIndex, p.ClientId, p.LastHeardUtc))
- L341 C28: new WorldSyncDescriptor :: return new WorldSyncDescriptor();
- L344 C24: new WorldSyncDescriptor :: return new WorldSyncDescriptor
- L407 C29: new PlayerLeaveNotice :: var leave = new PlayerLeaveNotice
- L420 C29: new ServerErrorMessage :: var error = new ServerErrorMessage


## XRENGINE/Engine/Networking/HumanoidPoseSync.cs
- L38 C71: new HumanoidQuantizationSettings :: public static HumanoidQuantizationSettings Default { get; } = new HumanoidQuantizationSettings();
- L47 C68: new HumanoidPoseDeltaSettings :: public static HumanoidPoseDeltaSettings Default { get; } = new HumanoidPoseDeltaSettings();
- L129 C47: new QuantizedTrackerPose :: QuantizedTrackerPose[] trackers = new QuantizedTrackerPose[TrackerCount];
- L137 C20: new QuantizedHumanoidPose :: return new QuantizedHumanoidPose(root, trackers);
- L151 C34: new Vector3 :: Vector3[] trackers = new Vector3[TrackerCount];
- L155 C20: new HumanoidPoseSample :: return new HumanoidPoseSample(
- L306 C27: new InvalidOperationException :: throw new InvalidOperationException("Humanoid delta exceeded reserved buffer size.");
- L346 C47: new QuantizedTrackerPose :: QuantizedTrackerPose[] trackers = new QuantizedTrackerPose[TrackerCount];
- L355 C22: new HumanoidPoseAvatarHeader :: header = new HumanoidPoseAvatarHeader(entity, flags, sequence);
- L356 C20: new QuantizedHumanoidPose :: pose = new QuantizedHumanoidPose(root, trackers);
- L385 C22: new HumanoidPoseAvatarHeader :: header = new HumanoidPoseAvatarHeader(entity, flags, 0);
- L420 C24: new QuantizedRootPose :: root = new QuantizedRootPose(baseline.Root.SectorX, baseline.Root.SectorZ, lx, ly, lz, yaw);
- L423 C47: new QuantizedTrackerPose :: QuantizedTrackerPose[] trackers = new QuantizedTrackerPose[TrackerCount];
- L455 C31: new QuantizedTrackerPose :: trackers[i] = new QuantizedTrackerPose(
- L461 C20: new QuantizedHumanoidPose :: pose = new QuantizedHumanoidPose(root, trackers);
- L473 C34: new() :: List<byte> scratch = new();
- L481 C23: new ArgumentException :: throw new ArgumentException($"Quantized pose must include exactly {TrackerCount} tracker positions.", nameof(pose));
- L509 C20: new QuantizedRootPose :: return new QuantizedRootPose(sectorX, sectorZ, localX, localY, localZ, yaw);
- L517 C20: new QuantizedTrackerPose :: return new QuantizedTrackerPose(x, y, z);
- L641 C47: new() :: private readonly List<byte> _buffer = new();
- L691 C23: new InvalidOperationException :: throw new InvalidOperationException("BeginFrame must be called before building a humanoid pose frame.");
- L693 C39: new() :: HumanoidPoseFrame frame = new()
- L708 C23: new InvalidOperationException :: throw new InvalidOperationException($"BeginFrame must be called with kind '{kind}' before adding avatars.");


## XRENGINE/Engine/Networking/RemoteJobNetworkingTransport.cs
- L15 C105: new() :: private readonly ConcurrentDictionary<Guid, TaskCompletionSource<RemoteJobResponse>> _pending = new();
- L20 C47: new ArgumentNullException :: _networking = networking ?? throw new ArgumentNullException(nameof(networking));
- L30 C23: new TaskCompletionSource :: var tcs = new TaskCompletionSource<RemoteJobResponse>(TaskCreationOptions.RunContinuationsAsynchronously);
- L32 C23: new InvalidOperationException :: throw new InvalidOperationException($"A remote request with id {request.JobId} is already pending.");
- L43 C35: new RemoteJobRequest :: var enrichedRequest = new RemoteJobRequest
- L78 C37: new InvalidOperationException :: tcs.TrySetException(new InvalidOperationException(response.Error ?? "Remote job failed."));


## XRENGINE/Engine/Subclasses/Engine.CodeProfiler.cs
- L73 C75: new() :: private readonly ConcurrentQueue<ProfilerEvent> _eventQueue = new();
- L75 C56: new() :: private readonly object _statsThreadLock = new();
- L125 C51: new ProfilerEvent :: _profiler._eventQueue.Enqueue(new ProfilerEvent(
- L192 C28: new PendingTimer :: return new PendingTimer();
- L205 C28: new BuiltTimer :: return new BuiltTimer();
- L272 C39: new CancellationTokenSource :: _statsThreadCts = new CancellationTokenSource();
- L273 C36: new Thread :: _statsThread = new Thread(StatsThreadMain)
- L347 C33: new ThreadBuildState :: state = new ThreadBuildState();
- L393 C45: new List :: roots = new List<BuiltTimer>(32);
- L417 C45: new ProfilerNodeSnapshot :: var rootSnapshots = new ProfilerNodeSnapshot[roots.Count];
- L428 C52: new ProfilerThreadSnapshot :: _threadSnapshotsBuffer.Add(new ProfilerThreadSnapshot(threadId, rootSnapshots));
- L434 C37: new ProfilerFrameSnapshot :: frameSnapshot = new ProfilerFrameSnapshot(frameTime, _threadSnapshotsBuffer.ToArray());
- L442 C86: new Queue :: history = _threadFrameHistory[threadSnapshot.ThreadId] = new Queue<float>(ThreadHistoryCapacity);
- L453 C39: new Dictionary :: historySnapshot = new Dictionary<int, float[]>(_threadFrameHistory.Count);
- L467 C74: new ProfilerNodeSnapshot :: ProfilerNodeSnapshot[] childSnapshots = childCount > 0 ? new ProfilerNodeSnapshot[childCount] : [];
- L472 C24: new ProfilerNodeSnapshot :: return new ProfilerNodeSnapshot(timer.Name, timer.ElapsedMs, childSnapshots);
- L531 C37: new ProfilerEvent :: _eventQueue.Enqueue(new ProfilerEvent(
- L538 C24: new ProfilerScope :: return new ProfilerScope(this, correlationId, threadId);
- L555 C37: new ProfilerEvent :: _eventQueue.Enqueue(new ProfilerEvent(
- L579 C37: new ProfilerEvent :: _eventQueue.Enqueue(new ProfilerEvent(


## XRENGINE/Engine/Subclasses/Engine.Physics.cs
- L10 C71: new IPhysicsGeometry.Sphere :: public static IPhysicsGeometry NewSphere(float radius) => new IPhysicsGeometry.Sphere(radius);
- L12 C75: new IPhysicsGeometry.Box :: public static IPhysicsGeometry NewBox(Vector3 halfExtents) => new IPhysicsGeometry.Box(halfExtents);
- L14 C90: new IPhysicsGeometry.Capsule :: public static IPhysicsGeometry NewCapsule(float radius, float halfHeight) => new IPhysicsGeometry.Capsule(radius, halfHeight);


## XRENGINE/Engine/Subclasses/Engine.PlayMode.cs
- L18 C67: new() :: private static PlayModeConfiguration _configuration = new();
- L20 C57: new() :: private static readonly object _stateLock = new();
- L81 C50: new PlayModeConfiguration :: set => _configuration = value ?? new PlayModeConfiguration();
- L476 C24: new XRWorld :: return new XRWorld("Default");
- L497 C24: new CustomGameMode :: return new CustomGameMode();


## XRENGINE/Engine/Subclasses/Engine.State.cs
- L61 C25: new JobManager :: _jobs = new JobManager();
- L87 C20: new JobManager :: Jobs = new JobManager(
- L100 C71: new GameState :: => LoadOrGenerateAsset(() => generateFactory?.Invoke() ?? new GameState(), assetName, allowLoading);
- L111 C60: new() :: bool allowLoading = true) where T : GameState, new()
- L112 C71: new T :: => LoadOrGenerateAsset(() => generateFactory?.Invoke() ?? new T(), assetName, allowLoading);
- L117 C70: new() :: bool allowLoading = true) where T : GameStartupSettings, new()
- L118 C71: new T :: => LoadOrGenerateAsset(() => generateFactory?.Invoke() ?? new T(), assetName, allowLoading);
- L124 C61: new() :: params string[] folderNames) where T : XRAsset, new()
- L157 C20: new GameStartupSettings :: return new GameStartupSettings()
- L161 C21: new() :: new()
- L164 C39: new Scene.XRWorld :: TargetWorld = new Scene.XRWorld(),
- L172 C39: new UserSettings :: DefaultUserSettings = new UserSettings()
- L194 C76: new LocalPlayerController :: public static LocalPlayerController?[] LocalPlayers { get; } = new LocalPlayerController[4];
- L269 C27: new ArgumentException :: throw new ArgumentException($"Controller type {controllerType.FullName} must inherit from LocalPlayerController", nameof(controllerType));
- L276 C30: new InvalidOperationException :: ?? throw new InvalidOperationException($"Failed to instantiate controller of type {controllerType.FullName}");


## XRENGINE/Engine/Subclasses/Engine.ThreadAllocationTracker.cs
- L8 C66: new() :: public static ThreadAllocationTracker Allocations { get; } = new();
- L32 C45: new() :: private readonly object _lock = new();
- L42 C27: new long :: _values = new long[capacity];
- L79 C28: new AllocationRingSnapshot :: return new AllocationRingSnapshot(_last, avg, _max, _count, _values.Length);


## XRENGINE/Engine/Subclasses/Engine.Time.cs
- L39 C56: new EngineTimer :: public static EngineTimer Timer { get; } = new EngineTimer();
- L41 C38: new EngineTimer :: static Time() => Timer = new EngineTimer();


## XRENGINE/Engine/Subclasses/Rendering/Engine.Rendering.BvhStats.cs
- L15 C56: new() :: private static readonly object _lock = new();


## XRENGINE/Engine/Subclasses/Rendering/Engine.Rendering.cs
- L101 C47: new JitterScene :: EPhysicsLibrary.Jitter => new JitterScene(),
- L102 C45: new JoltScene :: EPhysicsLibrary.Jolt => new JoltScene(),
- L103 C26: new PhysxScene :: _ => new PhysxScene(),
- L107 C20: new() :: => new();
- L111 C23: new DebugOpaqueRenderPipeline :: ? new DebugOpaqueRenderPipeline()
- L112 C23: new DefaultRenderPipeline :: : new DefaultRenderPipeline();
- L130 C55: new DebugOpaqueRenderPipeline :: viewport.RenderPipeline = new DebugOpaqueRenderPipeline();
- L134 C51: new DefaultRenderPipeline :: viewport.RenderPipeline = new DefaultRenderPipeline();


## XRENGINE/Engine/Subclasses/Rendering/Engine.Rendering.Debug.cs
- L58 C94: new() :: private static readonly InstancedDebugVisualizer _instancedDebugVisualizer = new();
- L121 C41: new XRMeshRenderer :: _lineRenderer = new XRMeshRenderer(mesh, mat);
- L135 C42: new XRMeshRenderer :: _pointRenderer = new XRMeshRenderer(mesh, mat);
- L140 C69: new() :: private static readonly Lock _debugShapeQueueLock = new();
- L346 C50: new Vector3 :: Vector3[] circlePoints = new Vector3[segments + 1];
- L368 C50: new Vector3 :: Vector3[] circlePoints = new Vector3[segments + 1];
- L374 C50: new Vector3 :: Vector3 localPoint = new Vector3(x, 0, z);
- L393 C29: new Vector3 :: new Vector3(-extents.X, 0, -extents.Y),
- L394 C29: new Vector3 :: new Vector3(extents.X, 0, -extents.Y),
- L395 C29: new Vector3 :: new Vector3(extents.X, 0, extents.Y),
- L396 C29: new Vector3 :: new Vector3(-extents.X, 0, extents.Y),
- L408 C29: new Vector3 :: new Vector3(-extents.X, 0, -extents.Y),
- L409 C29: new Vector3 :: new Vector3(extents.X, 0, -extents.Y),
- L410 C29: new Vector3 :: new Vector3(extents.X, 0, extents.Y),
- L411 C29: new Vector3 :: new Vector3(-extents.X, 0, extents.Y),
- L432 C46: new Vector3 :: Vector3[] spherePoints = new Vector3[segments * rings];
- L491 C25: new Vector3 :: new Vector3(bounds.Center.X, bounds.Center.Y, 0.0f),
- L493 C25: new Vector2 :: new Vector2(bounds.Extents.X, bounds.Extents.Y),
- L601 C51: new Vector3 :: Vector3[] capsulePoints = new Vector3[segments * rings];
- L649 C50: new Vector3 :: Vector3[] circlePoints = new Vector3[segments];
- L729 C48: new Vector3 :: Vector3[] cylinderPoints = new Vector3[segments * 2];
- L794 C44: new Vector3 :: Vector3[] conePoints = new Vector3[segments + 1];
- L828 C118: new() :: private static readonly ConcurrentDictionary<int, (UIText text, float lastUpdatedTime)> DebugTexts = new();
- L829 C83: new() :: private static readonly ResourcePool<UIText> TextPool = new(() => new());
- L830 C136: new() :: private static readonly ConcurrentQueue<(Vector3 pos, string text, ColorF4 color, float scale)> DebugTextUpdateQueue = new();


## XRENGINE/Engine/Subclasses/Rendering/Engine.Rendering.SecondaryContext.cs
- L22 C84: new() :: private readonly ConcurrentQueue<Action<AbstractRenderer>> _jobs = new();
- L43 C28: new CancellationTokenSource :: _cts = new CancellationTokenSource();
- L44 C31: new Thread :: _thread = new Thread(() => RunContext(templateWindow, _cts.Token))
- L148 C36: new Vector2D :: options.Size = new Vector2D<int>(Math.Max(64, templateWindow.Window.Size.X / 8), Math.Max(64, templateWindow.Window.Size.Y / 8));
- L156 C34: new XRWindow :: var window = new XRWindow(options, templateWindow.UseNativeTitleBar);
- L170 C46: new ManagementObjectSearcher :: using var searcher = new ManagementObjectSearcher(gpuQuery);
- L185 C75: new() :: public static SecondaryGpuContext SecondaryContext { get; } = new();
- L187 C89: new List :: public static IReadOnlyList<string> RecommendedSecondaryGpuTasks { get; } = new List<string>


## XRENGINE/Engine/Subclasses/Rendering/Engine.Rendering.Settings.cs
- L34 C55: new() :: private static EngineSettings _settings = new();
- L59 C42: new EngineSettings :: _settings = value ?? new EngineSettings();
- L1232 C78: new() :: private PhysicsGpuMemorySettings _physicsGpuMemorySettings = new();
- L1244 C78: new() :: private PhysicsVisualizeSettings _physicsVisualizeSettings = new();


## XRENGINE/Engine/Subclasses/Rendering/Engine.Rendering.State.cs
- L154 C98: new() :: private static Stack<XRRenderPipelineInstance> RenderingPipelineStack { get; } = new();
- L342 C72: new() :: private static Stack<uint> TransformIdStack { get; } = new();
- L543 C31: new TaskCompletionSource :: var tcs = new TaskCompletionSource<float>();
- L560 C31: new TaskCompletionSource :: var tcs = new TaskCompletionSource<ColorF4>();


## XRENGINE/Engine/Subclasses/Rendering/Engine.Rendering.Stats.cs
- L171 C73: new() :: private static readonly object _renderMatrixStatsLock = new();
- L737 C36: new KeyValuePair :: var copy = new KeyValuePair<string, int>[_renderMatrixListenerCountsDisplay.Count];


## XRENGINE/Game Modes/CustomGameMode.cs
- L31 C27: new ArgumentException :: throw new ArgumentException("Default player controller must inherit from LocalPlayerController", nameof(value));
- L47 C27: new ArgumentException :: throw new ArgumentException("Default player pawn must inherit from PawnComponent", nameof(value));


## XRENGINE/Game Modes/FlyingCameraGameMode.cs
- L54 C28: new SceneNode :: var pawnNode = new SceneNode(WorldInstance, nodeName);


## XRENGINE/Game Modes/GameMode.cs
- L157 C28: new SceneNode :: var pawnNode = new SceneNode(WorldInstance, pawnNodeName);
- L259 C54: new Queue :: PossessionQueue[pawnComponent] = new Queue<ELocalPlayerIndex>();


## XRENGINE/Game Modes/LocomotionGameMode.cs
- L26 C28: new SceneNode :: var pawnNode = new SceneNode(WorldInstance, pawnNodeName);
- L41 C43: new Vector3 :: cameraOffsetTfm.Translation = new Vector3(0.0f, 1.7f, 0.0f);


## XRENGINE/Game Modes/VRGameMode.cs
- L26 C28: new SceneNode :: var pawnNode = new SceneNode(WorldInstance, pawnNodeName);


## XRENGINE/Input/LocalPlayerController.cs
- L50 C70: new LocalInputInterface :: public LocalPlayerController(ELocalPlayerIndex index) : base(new LocalInputInterface((int)index))
- L55 C47: new LocalInputInterface :: public LocalPlayerController() : base(new LocalInputInterface(0))


## XRENGINE/Input/PawnController.cs
- L13 C72: new() :: protected readonly Queue<PawnComponent> _pawnPossessionQueue = new();


## XRENGINE/Input/PlayerControllerBase.cs
- L9 C42: new() :: private PlayerInfo _playerInfo = new();


## XRENGINE/Input/RemotePlayerController.cs
- L15 C69: new ServerInputInterface :: public RemotePlayerController(int serverPlayerIndex) : base(new ServerInputInterface(serverPlayerIndex))


## XRENGINE/Jobs/ActionJob.cs
- L16 C39: new ArgumentNullException :: _action = action ?? throw new ArgumentNullException(nameof(action));


## XRENGINE/Jobs/CoroutineJob.cs
- L15 C35: new ArgumentNullException :: _tick = tick ?? throw new ArgumentNullException(nameof(tick));


## XRENGINE/Jobs/EnumeratorJob.cs
- L17 C55: new ArgumentNullException :: _routineFactory = routine is null ? throw new ArgumentNullException(nameof(routine)) : () => routine;
- L29 C55: new ArgumentNullException :: _routineFactory = routineFactory ?? throw new ArgumentNullException(nameof(routineFactory));


## XRENGINE/Jobs/Job.cs
- L32 C50: new() :: private readonly object _lifecycleLock = new();
- L104 C24: new CancellationTokenSource :: _cts = new CancellationTokenSource();
- L111 C35: new Stack :: _executionStack = new Stack<IEnumerator>();
- L112 C50: new InvalidOperationException :: var routine = Process() ?? throw new InvalidOperationException("Job routine cannot be null.");
- L171 C22: new JobHandle :: Handle = new JobHandle(_id, completionSource.Task, this);
- L278 C53: new InvalidOperationException :: return AttachTask(task ?? throw new InvalidOperationException("Task factory returned null."));
- L310 C72: new InvalidOperationException :: var ex = aggregate?.GetBaseException() ?? aggregate ?? new InvalidOperationException("Job task faulted without an exception.");


## XRENGINE/Jobs/JobManager.cs
- L33 C13: new() :: new(), // Lowest
- L34 C13: new() :: new(), // Low
- L35 C13: new() :: new(), // Normal
- L36 C13: new() :: new(), // High
- L37 C13: new() :: new(), // Highest
- L41 C13: new() :: new(), // Lowest
- L42 C13: new() :: new(), // Low
- L43 C13: new() :: new(), // Normal
- L44 C13: new() :: new(), // High
- L45 C13: new() :: new(), // Highest
- L49 C13: new() :: new(), // Lowest
- L50 C13: new() :: new(), // Low
- L51 C13: new() :: new(), // Normal
- L52 C13: new() :: new(), // High
- L53 C13: new() :: new(), // Highest
- L57 C13: new() :: new(), // Lowest
- L58 C13: new() :: new(), // Low
- L59 C13: new() :: new(), // Normal
- L60 C13: new() :: new(), // High
- L61 C13: new() :: new(), // Highest
- L63 C46: new() :: private readonly List<Job> _active = new();
- L64 C47: new() :: private readonly object _activeLock = new();
- L66 C49: new int :: private readonly int[] _pendingCounts = new int[PriorityLevels];
- L67 C59: new int :: private readonly int[] _pendingMainThreadCounts = new int[PriorityLevels];
- L68 C56: new int :: private readonly int[] _pendingCollectCounts = new int[PriorityLevels];
- L69 C55: new int :: private readonly int[] _pendingRemoteCounts = new int[PriorityLevels];
- L70 C51: new long :: private readonly long[] _totalWaitTicks = new long[PriorityLevels];
- L71 C48: new long :: private readonly long[] _waitSamples = new long[PriorityLevels];
- L72 C58: new long :: private readonly long[] _lastQueueWarningTicks = new long[PriorityLevels];
- L80 C65: new() :: private readonly ConcurrentQueue<Job> _deferredBySlot = new();
- L81 C57: new() :: private readonly CancellationTokenSource _cts = new();
- L83 C53: new() :: private readonly object _remoteWorkerLock = new();
- L86 C55: new() :: private readonly object _deferredWorkerLock = new();
- L110 C31: new SemaphoreSlim :: _queueSlots = new SemaphoreSlim(_maxQueueSize, _maxQueueSize);
- L112 C24: new Thread :: _workers = new Thread[count];
- L116 C31: new Thread :: _workers[i] = new Thread(WorkerLoop)
- L191 C23: new InvalidOperationException :: throw new InvalidOperationException("Job has already been scheduled or completed.");
- L197 C36: new TaskCompletionSource :: var completionSource = new TaskCompletionSource<bool>(TaskCreationOptions.RunContinuationsAsynchronously);
- L303 C23: new EnumeratorJob :: var job = new EnumeratorJob(routine, progress, completed, error, canceled, progressWithPayload);
- L318 C23: new EnumeratorJob :: var job = new EnumeratorJob(routineFactory, progress, completed, error, canceled, progressWithPayload);
- L327 C54: new InvalidOperationException :: var transport = RemoteTransport ?? throw new InvalidOperationException("Remote transport has not been configured.");
- L328 C23: new TaskCompletionSource :: var tcs = new TaskCompletionSource<RemoteJobResponse>(TaskCreationOptions.RunContinuationsAsynchronously);
- L329 C23: new RemoteDispatchJob :: var job = new RemoteDispatchJob(request, transport, tcs);


## XRENGINE/Jobs/JobProgress.cs
- L17 C20: new JobProgress :: return new JobProgress(progress, payload);


## XRENGINE/Jobs/LabeledActionJob.cs
- L16 C39: new ArgumentNullException :: _action = action ?? throw new ArgumentNullException(nameof(action));


## XRENGINE/Jobs/RemoteJobTypes.cs
- L49 C16: new() :: => new() { JobId = id, Success = false, Error = message };


## XRENGINE/Jobs/WaitForNextDispatch.cs
- L8 C63: new() :: public static readonly WaitForNextDispatch Instance = new();


## XRENGINE/Models/Gaussian/GaussianSplatCloud.cs
- L71 C23: new AABB :: _bounds = new AABB(min, max);
- L75 C43: new AABB :: _bounds = AABB.Union(_bounds, new AABB(min, max));
- L96 C19: new AABB :: _bounds = new AABB(min, max);
- L114 C20: new GaussianSplatCloud :: return new GaussianSplatCloud();
- L142 C56: new Quaternion :: Quaternion rotation = Quaternion.Normalize(new Quaternion(rotationRaw.X, rotationRaw.Y, rotationRaw.Z, rotationRaw.W));
- L150 C24: new GaussianSplat :: splats.Add(new GaussianSplat(position, scale, rotation, color, opacity));
- L153 C21: new GaussianSplatCloud :: var cloud = new GaussianSplatCloud(splats);


## XRENGINE/Models/Materials/Options/BlendMode.cs
- L56 C57: new() :: public static BlendMode EnabledTransparent() => new()
- L66 C52: new() :: public static BlendMode EnabledOpaque() => new()
- L76 C48: new() :: public static BlendMode Unchanged() => new()
- L80 C47: new() :: public static BlendMode Disabled() => new()


## XRENGINE/Models/Materials/Options/RenderingParameters.cs
- L14 C40: new() :: private DepthTest _depthTest = new();
- L15 C44: new() :: private StencilTest _stencilTest = new();


## XRENGINE/Models/Materials/Options/StencilTest.cs
- L10 C26: new() :: _frontFace = new(),
- L11 C25: new() :: _backFace = new();
- L26 C42: new StencilTestFace :: set => _frontFace = value ?? new StencilTestFace();
- L31 C41: new StencilTestFace :: set => _backFace = value ?? new StencilTestFace();


## XRENGINE/Models/Materials/Parameters/ShaderArray.cs
- L37 C44: new ShaderArrayValueHandler :: : base(name, owner) { _value = new ShaderArrayValueHandler<T>(); }
- L52 C22: new T :: Values = new T[count];


## XRENGINE/Models/Materials/Parameters/ShaderBVec2.cs
- L21 C40: new BoolVector2 :: public ShaderBVector2() : this(new BoolVector2(), NoName) { }
- L28 C31: new ShaderBool :: _fields.Add(".x", new ShaderBool(defaultValue.X, "X", this));
- L29 C31: new ShaderBool :: _fields.Add(".y", new ShaderBool(defaultValue.Y, "Y", this));


## XRENGINE/Models/Materials/Parameters/ShaderBVec4.cs
- L25 C40: new BoolVector4 :: public ShaderBVector4() : this(new BoolVector4(), NoName) { }
- L32 C31: new ShaderBool :: _fields.Add(".x", new ShaderBool(defaultValue.X, "X", this));
- L33 C31: new ShaderBool :: _fields.Add(".y", new ShaderBool(defaultValue.Y, "Y", this));
- L34 C31: new ShaderBool :: _fields.Add(".z", new ShaderBool(defaultValue.Z, "Z", this));
- L35 C31: new ShaderBool :: _fields.Add(".w", new ShaderBool(defaultValue.W, "W", this));


## XRENGINE/Models/Materials/Parameters/ShaderBVector3.cs
- L24 C40: new BoolVector3 :: public ShaderBVector3() : this(new BoolVector3(), NoName) { }
- L31 C31: new ShaderBool :: _fields.Add(".x", new ShaderBool(defaultValue.X, "X", this));
- L32 C31: new ShaderBool :: _fields.Add(".y", new ShaderBool(defaultValue.Y, "Y", this));
- L33 C31: new ShaderBool :: _fields.Add(".z", new ShaderBool(defaultValue.Z, "Z", this));


## XRENGINE/Models/Materials/Parameters/ShaderDVector2.cs
- L21 C40: new DVector2 :: public ShaderDVector2() : this(new DVector2(), NoName) { }
- L28 C31: new ShaderDouble :: _fields.Add(".x", new ShaderDouble(defaultValue.X, "X", this));
- L29 C31: new ShaderDouble :: _fields.Add(".y", new ShaderDouble(defaultValue.Y, "Y", this));


## XRENGINE/Models/Materials/Parameters/ShaderDVector3.cs
- L21 C40: new DVector3 :: public ShaderDVector3() : this(new DVector3(), NoName) { }
- L28 C31: new ShaderDouble :: _fields.Add(".x", new ShaderDouble(defaultValue.X, "X", this));
- L29 C31: new ShaderDouble :: _fields.Add(".y", new ShaderDouble(defaultValue.Y, "Y", this));
- L30 C31: new ShaderDouble :: _fields.Add(".z", new ShaderDouble(defaultValue.Z, "Z", this));


## XRENGINE/Models/Materials/Parameters/ShaderDVector4.cs
- L21 C40: new DVector4 :: public ShaderDVector4() : this(new DVector4(), NoName) { }
- L28 C31: new ShaderDouble :: _fields.Add(".x", new ShaderDouble(defaultValue.X, "X", this));
- L29 C31: new ShaderDouble :: _fields.Add(".y", new ShaderDouble(defaultValue.Y, "Y", this));
- L30 C31: new ShaderDouble :: _fields.Add(".z", new ShaderDouble(defaultValue.Z, "Z", this));
- L31 C31: new ShaderDouble :: _fields.Add(".w", new ShaderDouble(defaultValue.W, "W", this));


## XRENGINE/Models/Materials/Parameters/ShaderIVec2.cs
- L21 C40: new IVector2 :: public ShaderIVector2() : this(new IVector2(), NoName) { }
- L28 C31: new ShaderInt :: _fields.Add(".x", new ShaderInt(defaultValue.X, "X", this));
- L29 C31: new ShaderInt :: _fields.Add(".y", new ShaderInt(defaultValue.Y, "Y", this));


## XRENGINE/Models/Materials/Parameters/ShaderIVec4.cs
- L25 C40: new IVector4 :: public ShaderIVector4() : this(new IVector4(), NoName) { }
- L32 C31: new ShaderInt :: _fields.Add(".x", new ShaderInt(defaultValue.X, "X", this));
- L33 C31: new ShaderInt :: _fields.Add(".y", new ShaderInt(defaultValue.Y, "Y", this));
- L34 C31: new ShaderInt :: _fields.Add(".z", new ShaderInt(defaultValue.Z, "Z", this));
- L35 C31: new ShaderInt :: _fields.Add(".w", new ShaderInt(defaultValue.W, "W", this));


## XRENGINE/Models/Materials/Parameters/ShaderIVector3.cs
- L21 C20: new IVector3 :: : this(new IVector3(), NoName) { }
- L28 C31: new ShaderDouble :: _fields.Add(".x", new ShaderDouble(defaultValue.X, "X", this));
- L29 C31: new ShaderDouble :: _fields.Add(".y", new ShaderDouble(defaultValue.Y, "Y", this));
- L30 C31: new ShaderDouble :: _fields.Add(".z", new ShaderDouble(defaultValue.Z, "Z", this));


## XRENGINE/Models/Materials/Parameters/ShaderUVec2.cs
- L21 C40: new UVector2 :: public ShaderUVector2() : this(new UVector2(), NoName) { }
- L28 C31: new ShaderUInt :: _fields.Add(".x", new ShaderUInt(defaultValue.X, "X", this));
- L29 C31: new ShaderUInt :: _fields.Add(".y", new ShaderUInt(defaultValue.Y, "Y", this));


## XRENGINE/Models/Materials/Parameters/ShaderUVec4.cs
- L25 C40: new UVector4 :: public ShaderUVector4() : this(new UVector4(), NoName) { }
- L32 C31: new ShaderUInt :: _fields.Add(".x", new ShaderUInt(defaultValue.X, "X", this));
- L33 C31: new ShaderUInt :: _fields.Add(".y", new ShaderUInt(defaultValue.Y, "Y", this));
- L34 C31: new ShaderUInt :: _fields.Add(".z", new ShaderUInt(defaultValue.Z, "Z", this));
- L35 C31: new ShaderUInt :: _fields.Add(".w", new ShaderUInt(defaultValue.W, "W", this));


## XRENGINE/Models/Materials/Parameters/ShaderUVector3.cs
- L24 C40: new UVector3 :: public ShaderUVector3() : this(new UVector3(), NoName) { }
- L31 C31: new ShaderUInt :: _fields.Add(".x", new ShaderUInt(defaultValue.X, "X", this));
- L32 C31: new ShaderUInt :: _fields.Add(".y", new ShaderUInt(defaultValue.Y, "Y", this));
- L33 C31: new ShaderUInt :: _fields.Add(".z", new ShaderUInt(defaultValue.Z, "Z", this));


## XRENGINE/Models/Materials/Parameters/ShaderVar.cs
- L175 C84: new() :: public static readonly Dictionary<Type, EShaderVarType> TypeAssociations = new()
- L200 C90: new() :: public static readonly Dictionary<EShaderVarType, Type> ShaderTypeAssociations = new()
- L225 C92: new() :: public static readonly Dictionary<EShaderVarType, Type> AssemblyTypeAssociations = new()


## XRENGINE/Models/Materials/Parameters/ShaderVec2.cs
- L18 C20: new Vector2 :: : this(new Vector2(), NoName) { }
- L24 C31: new ShaderFloat :: _fields.Add(".x", new ShaderFloat(defaultValue.X, "X", this));
- L25 C31: new ShaderFloat :: _fields.Add(".y", new ShaderFloat(defaultValue.Y, "Y", this));


## XRENGINE/Models/Materials/Parameters/ShaderVector3.cs
- L21 C20: new Vector3 :: : this(new Vector3(), NoName) { }
- L27 C31: new ShaderFloat :: _fields.Add(".x", new ShaderFloat(defaultValue.X, "X", this));
- L28 C31: new ShaderFloat :: _fields.Add(".y", new ShaderFloat(defaultValue.Y, "Y", this));
- L29 C31: new ShaderFloat :: _fields.Add(".z", new ShaderFloat(defaultValue.Z, "Z", this));
- L43 C20: new Vector3 :: : this(new Vector3(x, y, z), name, owner) { }


## XRENGINE/Models/Materials/Parameters/ShaderVector4.cs
- L21 C20: new Vector4 :: : this(new Vector4(), NoName) { }
- L27 C31: new ShaderFloat :: _fields.Add(".x", new ShaderFloat(defaultValue.X, "X", this));
- L28 C31: new ShaderFloat :: _fields.Add(".y", new ShaderFloat(defaultValue.Y, "Y", this));
- L29 C31: new ShaderFloat :: _fields.Add(".z", new ShaderFloat(defaultValue.Z, "Z", this));
- L30 C31: new ShaderFloat :: _fields.Add(".w", new ShaderFloat(defaultValue.W, "W", this));
- L44 C20: new Vector4 :: : this(new Vector4(x, y, z, w), name, owner) { }


## XRENGINE/Models/Materials/Textures/TextureData.cs
- L32 C44: new Rectangle :: BitmapData data = bmp.LockBits(new Rectangle(0, 0, bmp.Width, bmp.Height), ImageLockMode.ReadOnly, bmp.PixelFormat);
- L34 C21: new DataSource :: _data = new DataSource(length);
- L41 C21: new DataSource :: _data = new DataSource(data, length, true);
- L46 C21: new DataSource :: _data = new DataSource(data, GetLength(width, height, pixelFormat, pixelType), true);


## XRENGINE/Models/Meshes/SubMesh.cs
- L14 C51: new LODSorter :: private SortedSet<SubMeshLOD> _lods = new(new LODSorter());
- L21 C25: new SortedSet :: _lods = new SortedSet<SubMeshLOD>(new LODSorter());
- L21 C51: new LODSorter :: _lods = new SortedSet<SubMeshLOD>(new LODSorter());
- L71 C20: new SubMeshLOD :: : this(new SubMeshLOD(material, primitives, 0.0f)) { }
- L89 C27: new() :: AABB bounds = new();


## XRENGINE/Rendering/API/Rendering/Generic/AbstractRenderer.cs
- L101 C70: new() :: private readonly Stack<BoundingRectangle> _renderAreaStack = new();
- L106 C15: new BoundingRectangle :: : new BoundingRectangle(0, 0, Window.Size.X, Window.Size.Y);
- L115 C52: new() :: private readonly object _imguiRenderLock = new();
- L152 C40: new Vector2 :: framebufferScale = new Vector2(
- L160 C31: new Vector2 :: displaySize = new Vector2(region.Width, region.Height);
- L175 C40: new Vector2 :: framebufferScale = new Vector2(
- L179 C35: new Vector2 :: displaySize = new Vector2(
- L186 C31: new Vector2 :: displaySize = new Vector2(ortho.Width, ortho.Height);
- L291 C46: new() :: private readonly Lock _roCacheLock = new();
- L411 C22: new NotSupportedException :: => throw new NotSupportedException();


## XRENGINE/Rendering/API/Rendering/Objects/Buffers/XRDataBuffer.cs
- L337 C23: new ArgumentException :: throw new ArgumentException("Compression codec must not be None.", nameof(codec));
- L339 C23: new ArgumentException :: throw new ArgumentException("Encoded payload cannot be empty.", nameof(encodedPayload));
- L341 C23: new ArgumentException :: throw new ArgumentException("Decoded length must be greater than zero.", nameof(decodedLength));
- L346 C36: new DataSource :: _gpuCompressedSource = new DataSource(encodedCopy);
- L491 C27: new InvalidOperationException :: throw new InvalidOperationException("Not a proper numeric data type.");
- L511 C23: new InvalidOperationException :: throw new InvalidOperationException($"Cannot set data at index {index}: client-side buffer has not been allocated.");
- L518 C23: new InvalidOperationException :: throw new InvalidOperationException($"Cannot get data at index {index}: client-side buffer has not been allocated.");
- L520 C23: new ArgumentOutOfRangeException :: throw new ArgumentOutOfRangeException(nameof(index), $"Index {index} is out of range. Element count: {_elementCount}");
- L541 C23: new T :: T[] arr = new T[count];
- L635 C27: new InvalidOperationException :: throw new InvalidOperationException("Not a proper numeric data type.");
- L641 C37: new() :: Remapper remapper = new();
- L729 C37: new() :: Remapper remapper = new();
- L765 C37: new() :: Remapper remapper = new();
- L799 C23: new InvalidOperationException :: throw new InvalidOperationException("Data type mismatch.");
- L802 C21: new T :: array = new T[_elementCount];
- L813 C33: new() :: Remapper remapper = new();
- L878 C27: new InvalidOperationException :: throw new InvalidOperationException("Data type mismatch.");
- L886 C21: new T :: array = new T[count];
- L893 C33: new() :: Remapper remapper = new();
- L1024 C32: new() :: StringBuilder sb = new();


## XRENGINE/Rendering/API/Rendering/Objects/Buffers/XRDataBufferView.cs
- L26 C39: new ArgumentNullException :: _buffer = buffer ?? throw new ArgumentNullException(nameof(buffer));
- L38 C57: new ArgumentNullException :: set => SetField(ref _buffer, value ?? throw new ArgumentNullException(nameof(value)));


## XRENGINE/Rendering/API/Rendering/Objects/Materials/XRMaterial.cs
- L219 C19: new XRRenderProgram :: ? new XRRenderProgram(true, true, Shaders.Where(x => x.Type != EShaderType.Vertex))
- L257 C17: new ShaderFloat :: new ShaderFloat(parallaxScale, "ParallaxScale"),
- L258 C17: new ShaderInt :: new ShaderInt(parallaxMinSteps, "ParallaxMinSteps"),
- L259 C17: new ShaderInt :: new ShaderInt(parallaxMaxSteps, "ParallaxMaxSteps"),
- L260 C17: new ShaderInt :: new ShaderInt(parallaxRefineSteps, "ParallaxRefineSteps"),
- L261 C17: new ShaderFloat :: new ShaderFloat(parallaxHeightBias, "ParallaxHeightBias"),
- L262 C17: new ShaderFloat :: new ShaderFloat(parallaxSilhouette ? 1.0f : 0.0f, "ParallaxSilhouette"),
- L265 C17: new ShaderFloat :: new ShaderFloat(forwardSpecularIntensity, "MatSpecularIntensity"),
- L266 C17: new ShaderFloat :: new ShaderFloat(forwardShininess, "MatShininess"),
- L288 C17: new ShaderVector3 :: new ShaderVector3((ColorF3)color, "BaseColor"),
- L289 C17: new ShaderFloat :: new ShaderFloat(color.A, "Opacity"),
- L301 C21: new ShaderVector4 :: => new([new ShaderVector4(color, "MatColor")], ShaderHelper.UnlitColorFragForward()!) { RenderPass = (int)EDefaultRenderPass.OpaqueForward };
- L324 C17: new ShaderVector3 :: new ShaderVector3((ColorF3)color, "BaseColor"),
- L325 C17: new ShaderFloat :: new ShaderFloat(color.A, "Opacity"),
- L326 C17: new ShaderFloat :: new ShaderFloat(1.0f, "Specular"),
- L327 C17: new ShaderFloat :: new ShaderFloat(1.0f, "Roughness"),
- L328 C17: new ShaderFloat :: new ShaderFloat(0.0f, "Metallic"),
- L329 C17: new ShaderFloat :: new ShaderFloat(1.0f, "IndexOfRefraction"),
- L394 C38: new ShaderVar :: ShaderVar[] parameters = new ShaderVar[count + 1];
- L402 C39: new ShaderVector3 :: parameters[count++] = new ShaderVector3(emission.Value, "Emission");
- L410 C39: new ShaderVector3 :: parameters[count++] = new ShaderVector3(ambient.Value, "Ambient");
- L418 C39: new ShaderVector3 :: parameters[count++] = new ShaderVector3(diffuse.Value, "Diffuse");
- L426 C39: new ShaderVector3 :: parameters[count++] = new ShaderVector3(specular.Value, "Specular");
- L432 C35: new ShaderFloat :: parameters[count++] = new ShaderFloat(shininess, "Shininess");
- L488 C36: new XRShader :: return new(parameters, new XRShader(EShaderType.Fragment, source));


## XRENGINE/Rendering/API/Rendering/Objects/Materials/XRMaterialBase.cs
- L58 C54: new() :: private RenderingParameters _renderOptions = new();
- L64 C39: new() :: get => _renderOptions ??= new();
- L65 C46: new() :: set => _renderOptions = value ?? new();


## XRENGINE/Rendering/API/Rendering/Objects/Meshes/TriangleAdapter.cs
- L22 C23: new Exception :: throw new Exception("missing map for a shuffled child");


## XRENGINE/Rendering/API/Rendering/Objects/Meshes/XRMesh.Assimp.cs
- L34 C27: new ConcurrentDictionary :: var vertexCache = new ConcurrentDictionary<int, Vertex>();
- L97 C26: new string :: string[] names = new string[mesh.MeshAnimationAttachmentCount];
- L123 C30: new int :: int[] offsetPoints = new int[faceCount];
- L124 C29: new int :: int[] offsetLines = new int[faceCount];
- L125 C33: new int :: int[] offsetTriangles = new int[faceCount];
- L149 C32: new Vertex :: Vertex[] pointsArray = new Vertex[totalPoints];
- L150 C31: new Vertex :: Vertex[] linesArray = new Vertex[totalLines];
- L151 C35: new Vertex :: Vertex[] trianglesArray = new Vertex[totalTriangles];
- L152 C35: new ConcurrentDictionary :: var concurrentFaceRemap = new ConcurrentDictionary<int, List<int>>();
- L231 C34: new TaskCompletionSource :: var completion = new TaskCompletionSource<bool>(TaskCreationOptions.RunContinuationsAsynchronously);
- L249 C21: new Dictionary :: faceRemap = new Dictionary<int, List<int>>(concurrentFaceRemap);


## XRENGINE/Rendering/API/Rendering/Objects/Meshes/XRMesh.Blendshapes.cs
- L15 C28: new XRDataBuffer :: BlendshapeCounts = new XRDataBuffer(ECommonBufferType.BlendshapeCount.ToString(), EBufferTarget.ArrayBuffer, (uint)sourceList.Length,
- L90 C43: new IVector4 :: blendshapeIndices.Add(new IVector4(bsInd, posInd, nrmInd, tanInd));
- L107 C29: new XRDataBuffer :: BlendshapeIndices = new XRDataBuffer($"{ECommonBufferType.BlendshapeIndices}Buffer", EBufferTarget.ShaderStorageBuffer,
- L121 C28: new XRDataBuffer :: BlendshapeDeltas = new XRDataBuffer($"{ECommonBufferType.BlendshapeDeltas}Buffer", EBufferTarget.ShaderStorageBuffer,
- L164 C31: new() :: Remapper deltaRemap = new();
- L166 C28: new XRDataBuffer :: BlendshapeDeltas = new XRDataBuffer($"{ECommonBufferType.BlendshapeDeltas}Buffer", EBufferTarget.ShaderStorageBuffer,


## XRENGINE/Rendering/API/Rendering/Objects/Meshes/XRMesh.BufferCollection.cs
- L44 C43: new NotImplementedException :: EPrimitiveType.Quads => throw new NotImplementedException(),
- L45 C47: new NotImplementedException :: EPrimitiveType.QuadStrip => throw new NotImplementedException(),
- L46 C45: new NotImplementedException :: EPrimitiveType.Polygon => throw new NotImplementedException(),
- L47 C52: new NotImplementedException :: EPrimitiveType.LinesAdjacency => throw new NotImplementedException(),
- L48 C56: new NotImplementedException :: EPrimitiveType.LineStripAdjacency => throw new NotImplementedException(),
- L49 C56: new NotImplementedException :: EPrimitiveType.TrianglesAdjacency => throw new NotImplementedException(),
- L50 C60: new NotImplementedException :: EPrimitiveType.TriangleStripAdjacency => throw new NotImplementedException(),
- L51 C45: new NotImplementedException :: EPrimitiveType.Patches => throw new NotImplementedException(),
- L52 C24: new NotImplementedException :: _ => throw new NotImplementedException(),


## XRENGINE/Rendering/API/Rendering/Objects/Meshes/XRMesh.BufferInit.cs
- L18 C39: new XRDataBuffer :: InterleavedVertexBuffer = new XRDataBuffer(ECommonBufferType.InterleavedVertex.ToString(), EBufferTarget.ArrayBuffer, false)
- L69 C31: new XRDataBuffer :: PositionsBuffer = new XRDataBuffer(ECommonBufferType.Position.ToString(), EBufferTarget.ArrayBuffer, false);
- L75 C33: new XRDataBuffer :: NormalsBuffer = new XRDataBuffer(ECommonBufferType.Normal.ToString(), EBufferTarget.ArrayBuffer, false);
- L81 C34: new XRDataBuffer :: TangentsBuffer = new XRDataBuffer(ECommonBufferType.Tangent.ToString(), EBufferTarget.ArrayBuffer, false);
- L87 C32: new XRDataBuffer :: ColorBuffers = new XRDataBuffer[colorCount];
- L91 C31: new XRDataBuffer :: var buf = new XRDataBuffer(binding, EBufferTarget.ArrayBuffer, false);
- L99 C35: new XRDataBuffer :: TexCoordBuffers = new XRDataBuffer[texCoordCount];
- L103 C31: new XRDataBuffer :: var buf = new XRDataBuffer(binding, EBufferTarget.ArrayBuffer, false);


## XRENGINE/Rendering/API/Rendering/Objects/Meshes/XRMesh.Clone.cs
- L12 C24: new() :: XRMesh clone = new()
- L28 C25: new Vertex :: _vertices = new Vertex[Vertices.Length]
- L46 C34: new XRDataBuffer :: clone.ColorBuffers = new XRDataBuffer[ColorBuffers.Length];
- L53 C37: new XRDataBuffer :: clone.TexCoordBuffers = new XRDataBuffer[TexCoordBuffers.Length];


## XRENGINE/Rendering/API/Rendering/Objects/Meshes/XRMesh.Constructors.cs
- L16 C46: new VertexTriangle :: => new(positions.SelectEvery(3, x => new VertexTriangle(x[0], x[1], x[2])));
- L18 C46: new VertexTriangle :: => new(positions.SelectEvery(3, x => new VertexTriangle(x[0], x[1], x[2])));
- L20 C46: new VertexLine :: => new(positions.SelectEvery(2, x => new VertexLine(x[0], x[1])));
- L22 C16: new VertexLineStrip :: => new(new VertexLineStrip(closed, [.. positions.Select(x => new Vertex(x))]));
- L22 C70: new Vertex :: => new(new VertexLineStrip(closed, [.. positions.Select(x => new Vertex(x))]));
- L24 C46: new VertexLine :: => new(positions.SelectEvery(2, x => new VertexLine(x[0], x[1])));
- L26 C38: new Vertex :: => new(positions.Select(x => new Vertex(x)));
- L28 C38: new Vertex :: => new(positions.Select(x => new Vertex(x)));
- L46 C63: new AABB :: bounds = bounds?.ExpandedToInclude(v.Position) ?? new AABB(v.Position, v.Position);
- L52 C29: new AABB :: _bounds = bounds ?? new AABB(Vector3.Zero, Vector3.Zero);
- L53 C62: new IndexTriangle :: _triangles = [.. triangleIndices.SelectEvery(3, x => new IndexTriangle(x[0], x[1], x[2]))];
- L85 C71: new AABB :: bounds = bounds?.ExpandedToInclude(v.Position) ?? new AABB(v.Position, v.Position);
- L93 C81: new AABB :: bounds = bounds?.ExpandedToInclude(vtx.Position) ?? new AABB(vtx.Position, vtx.Position);
- L101 C77: new AABB :: bounds = bounds?.ExpandedToInclude(vtx.Position) ?? new AABB(vtx.Position, vtx.Position);
- L110 C81: new AABB :: bounds = bounds?.ExpandedToInclude(vtx.Position) ?? new AABB(vtx.Position, vtx.Position);
- L118 C29: new AABB :: _bounds = bounds ?? new AABB(Vector3.Zero, Vector3.Zero);
- L148 C36: new int :: firstAppearanceArray = new int[count];


## XRENGINE/Rendering/API/Rendering/Objects/Meshes/XRMesh.CookedBinary.cs
- L27 C19: new ArgumentException :: throw new ArgumentException("Stream key cannot be null or whitespace.", nameof(streamKey));
- L69 C33: new() :: MeshMetadata metadata = new()
- L88 C37: new() :: MeshPayloadWritePlan plan = new()
- L212 C18: new AABB :: Bounds = new AABB(metadata.BoundsMin, metadata.BoundsMax);
- L227 C33: new() :: MeshMetadata metadata = new()
- L378 C27: new IndexTriangle :: triangles.Add(new IndexTriangle(p0, p1, p2));
- L393 C23: new IndexLine :: lines.Add(new IndexLine(p0, p1));
- L413 C20: new BufferPlan :: return new BufferPlan
- L427 C19: new InvalidOperationException :: throw new InvalidOperationException($"Buffer '{streamKey}' does not have CPU-side data available.");
- L450 C23: new NotSupportedException :: throw new NotSupportedException($"Unsupported mesh buffer encoding '{encoding}'.");
- L453 C16: new BufferPlan :: return new BufferPlan
- L469 C15: new BufferMetadata :: : new BufferMetadata(buffer.AttributeName ?? string.Empty, buffer.Target, buffer.ComponentType, buffer.ComponentCount, buffer.ElementCount, buffer.Normalize, buffer.Integral, buffer.PadEndingToVec4);
- L535 C27: new InvalidOperationException :: throw new InvalidOperationException($"Raw buffer '{plan.StreamKey}' is missing source data.");
- L554 C23: new InvalidOperationException :: throw new InvalidOperationException("Unexpected buffer metadata for fixed stream.");
- L556 C22: new XRDataBuffer :: buffer = new XRDataBuffer(metadata.AttributeName, metadata.Target, metadata.ElementCount, metadata.ComponentType, metadata.ComponentCount, metadata.Normalize, metadata.Integral)
- L571 C19: new InvalidOperationException :: throw new InvalidOperationException("Dynamic buffer missing metadata in stream.");
- L601 C23: new NotSupportedException :: throw new NotSupportedException($"Unsupported mesh buffer encoding '{encoding}'.");
- L645 C28: new BoneInfo :: BoneInfo[] infos = new BoneInfo[boneCount];
- L653 C24: new BoneInfo :: infos[i] = new BoneInfo { BoneId = id, Name = name, ParentIndex = parentIndex, BindMatrix = bind, InverseBindMatrix = inverse };
- L698 C26: new string :: string[] names = new string[nameCount];
- L714 C16: new SkinningPlan :: return new SkinningPlan
- L735 C28: new BoneInfo :: BoneInfo[] bones = new BoneInfo[utilized.Length];
- L742 C24: new BoneInfo :: bones[i] = new BoneInfo
- L760 C16: new BlendshapePlan :: return new BlendshapePlan
- L805 C16: new Guid :: return new Guid(bytes);
- L830 C16: new BufferMetadata :: return new BufferMetadata(name, target, componentType, componentCount, elementCount, normalize, integral, padEnding);
- L863 C19: new InvalidOperationException :: throw new InvalidOperationException($"Buffer '{buffer.AttributeName}' does not contain {byteLength} bytes of CPU data.");
- L864 C27: new ReadOnlySpan :: writer.WriteBytes(new ReadOnlySpan<byte>(source.Address, (int)byteLength));
- L877 C19: new InvalidOperationException :: throw new InvalidOperationException("Snorm16 encoding requires float3 data.");
- L880 C19: new InvalidOperationException :: throw new InvalidOperationException($"Buffer '{buffer.AttributeName}' does not have CPU data available.");
- L883 C26: new byte :: byte[] encoded = new byte[vertexCount * 3 * sizeof(short)];
- L941 C19: new NotSupportedException :: throw new NotSupportedException("GDeflate encoder is not available. Integrate a GDeflate encoder in Compression.TryCompressGDeflate to emit mesh streams with MeshBufferEncoding.GDeflate.");
- L952 C19: new InvalidOperationException :: throw new InvalidOperationException("Decoded buffer length mismatch.");
- L959 C19: new InvalidOperationException :: throw new InvalidOperationException($"Buffer '{buffer.AttributeName}' does not contain {length} bytes.");
- L960 C16: new ReadOnlySpan :: return new ReadOnlySpan<byte>((void*)source.Address, (int)length);
- L967 C21: new Span :: data.CopyTo(new Span<byte>((void*)buffer.ClientSideSource!.Address, data.Length));
- L977 C57: new() :: public List<BufferPlan> ColorStreams { get; } = new();
- L978 C60: new() :: public List<BufferPlan> TexCoordStreams { get; } = new();
- L1054 C53: new() :: public static readonly SkinningPlan Empty = new() { HasSkinning = false };
- L1090 C55: new() :: public static readonly BlendshapePlan Empty = new() { HasBlendshapes = false, Names = Array.Empty<string>() };
- L1174 C29: new Transform :: Transform[] bones = new Transform[infos.Length];
- L1178 C30: new() :: Transform bone = new();
- L1207 C16: new BufferBlob :: return new BufferBlob
- L1233 C35: new DataSource :: buffer.ClientSideSource = new DataSource(blob.Data);
- L1236 C19: new InvalidOperationException :: throw new InvalidOperationException($"Cooked buffer '{blob.AttributeName ?? "<unnamed>"}' length mismatch.");
- L1246 C21: new BufferCollection :: Buffers ??= new BufferCollection();
- L1291 C16: new MeshCookedPayload :: return new MeshCookedPayload


## XRENGINE/Rendering/API/Rendering/Objects/Meshes/XRMesh.Core.cs
- L194 C41: new() :: private readonly Lock _boundsLock = new();
- L230 C28: new XRDataBuffer :: ColorBuffers = new XRDataBuffer[ColorCount];
- L241 C31: new XRDataBuffer :: TexCoordBuffers = new XRDataBuffer[TexCoordCount];
- L279 C32: new Vertex :: Vertex[] rebuilt = new Vertex[VertexCount];
- L282 C28: new() :: Vertex v = new()
- L294 C47: new List :: v.TextureCoordinateSets = new List<Vector2>((int)TexCoordCount);
- L301 C35: new List :: v.ColorSets = new List<Vector4>((int)ColorCount);
- L319 C30: new List :: _triangles = new List<IndexTriangle>(triangleCount);
- L323 C36: new IndexTriangle :: _triangles.Add(new IndexTriangle(idx++, idx++, idx++));


## XRENGINE/Rendering/API/Rendering/Objects/Meshes/XRMesh.Geometry.cs
- L21 C115: new() :: private readonly Dictionary<EPrimitiveType, (XRDataBuffer buffer, IndexSize elementSize)> _indexBufferCache = new();
- L42 C65: new[] :: EPrimitiveType.Triangles => _triangles?.SelectMany(x => new[] { x.Point0, x.Point1, x.Point2 }).ToArray(),
- L43 C57: new[] :: EPrimitiveType.Lines => _lines?.SelectMany(x => new[] { x.Point0, x.Point1 }).ToArray(),
- L54 C33: new() :: Remapper remapper = new();
- L57 C32: new IndexTriangle :: _triangles.Add(new IndexTriangle(remapper.RemapTable[i++], remapper.RemapTable[i++], remapper.RemapTable[i++]));
- L61 C28: new IndexTriangle :: _triangles.Add(new IndexTriangle(i++, i++, i++));
- L71 C33: new() :: Remapper remapper = new();
- L74 C28: new IndexLine :: _lines.Add(new IndexLine(remapper.RemapTable[i++], remapper.RemapTable[i++]));
- L78 C24: new IndexLine :: _lines.Add(new IndexLine(i++, i++));
- L88 C33: new() :: Remapper remapper = new();
- L145 C28: new TriangleAdapter :: _bvhTree = new(new TriangleAdapter(), triangles);
- L162 C16: new Triangle :: return new Triangle(p0, p1, p2);
- L192 C31: new() :: SignedDistanceField = new();
- L194 C23: new XRRenderProgram :: var program = new XRRenderProgram(true, true, shader);
- L234 C19: new XRDataBuffer :: var buf = new XRDataBuffer(target, true)


## XRENGINE/Rendering/API/Rendering/Objects/Meshes/XRMesh.Modeling.cs
- L14 C23: new AABB :: _bounds = new AABB(Vector3.Zero, Vector3.Zero);
- L28 C19: new AABB :: _bounds = new AABB(min, max);


## XRENGINE/Rendering/API/Rendering/Objects/Meshes/XRMesh.Shapes.cs
- L17 C24: new VertexLineStrip :: return new VertexLineStrip(true, points);
- L22 C27: new Exception :: throw new Exception("A (very low res) circle needs at least 3 sides.");
- L28 C35: new Vertex :: Vertex[] points = new Vertex[sides];
- L38 C40: new Vector2 :: coord * 0.5f + new Vector2(0.5f));
- L58 C46: new Vertex :: Vertex[] stripVertices = new Vertex[((int)precision + 1) * 2];
- L71 C46: new Vertex :: stripVertices[x++] = new Vertex(pos, norm, uv);
- L80 C46: new Vertex :: stripVertices[x++] = new Vertex(pos, norm, uv);
- L82 C32: new VertexTriangleStrip :: strips.Add(new VertexTriangleStrip(stripVertices));
- L115 C31: new Vertex :: v.Add(new Vertex(center + normal * radius, normal, new Vector2(U, V)));
- L115 C76: new Vector2 :: v.Add(new Vertex(center + normal * radius, normal, new Vector2(U, V)));
- L121 C35: new VertexTriangle :: triangles.Add(new VertexTriangle(v[i], v[i + slices + 1], v[i + slices]));
- L122 C35: new VertexTriangle :: triangles.Add(new VertexTriangle(v[i + slices + 1], v[i], v[i + 1]));
- L130 C38: new VertexLine :: VertexLine[] lines = new VertexLine[sides * 3];
- L140 C34: new VertexLine :: lines[x++] = new VertexLine(bottomPoint, sidePoint.Position);
- L141 C34: new VertexLine :: lines[x++] = new VertexLine(topPoint, sidePoint.Position);
- L142 C34: new VertexLine :: lines[x++] = new VertexLine(sidePoints[i + 1 == sides ? 0 : i + 1], sidePoint);
- L167 C33: new Vertex :: topVertex = new Vertex(topPoint, up, new Vector2(0.5f));
- L167 C58: new Vector2 :: topVertex = new Vertex(topPoint, up, new Vector2(0.5f));
- L168 C30: new VertexTriangle :: tris.Add(new VertexTriangle(
- L185 C47: new Vector2 :: new(bottomPoint, -up, new Vector2(0.5f))
- L196 C35: new VertexTriangleFan :: tris.AddRange(new VertexTriangleFan(list).ToTriangles());
- L236 C39: new Vertex :: Vertex[] topPoints1 = new Vertex[pts], topPoints2 = new Vertex[pts];
- L236 C69: new Vertex :: Vertex[] topPoints1 = new Vertex[pts], topPoints2 = new Vertex[pts];
- L237 C39: new Vertex :: Vertex[] botPoints1 = new Vertex[pts], botPoints2 = new Vertex[pts];
- L237 C69: new Vertex :: Vertex[] botPoints1 = new Vertex[pts], botPoints2 = new Vertex[pts];
- L245 C37: new Vertex :: topPoints1[i] = new Vertex(topPoint + radius * v1);
- L246 C37: new Vertex :: topPoints2[i] = new Vertex(topPoint + radius * v2);
- L247 C37: new Vertex :: botPoints1[i] = new Vertex(bottomPoint - radius * v1);
- L248 C37: new Vertex :: botPoints2[i] = new Vertex(bottomPoint - radius * v2);
- L260 C21: new Vertex :: new Vertex(bottomPoint + rightNormal * radius),
- L261 C21: new Vertex :: new Vertex(topPoint + rightNormal * radius));
- L263 C21: new Vertex :: new Vertex(bottomPoint - rightNormal * radius),
- L264 C21: new Vertex :: new Vertex(topPoint - rightNormal * radius));
- L266 C21: new Vertex :: new Vertex(bottomPoint + forwardNormal * radius),
- L267 C21: new Vertex :: new Vertex(topPoint + forwardNormal * radius));
- L269 C21: new Vertex :: new Vertex(bottomPoint - forwardNormal * radius),
- L270 C21: new Vertex :: new Vertex(topPoint - forwardNormal * radius));
- L286 C54: new VertexTriangle :: VertexTriangle[] cylinderTriangles = new VertexTriangle[pointCountHalfCircle * 2];
- L287 C55: new VertexTriangle :: VertexTriangle[] topSphereTriangles = new VertexTriangle[pointCountHalfCircle * pointCountHalfCircle];
- L288 C58: new VertexTriangle :: VertexTriangle[] bottomSphereTriangles = new VertexTriangle[pointCountHalfCircle * pointCountHalfCircle];
- L305 C46: new VertexTriangle :: cylinderTriangles[x++] = new VertexTriangle(top1, top2, bot1);
- L306 C46: new VertexTriangle :: cylinderTriangles[x++] = new VertexTriangle(top2, bot2, bot1);
- L322 C51: new VertexTriangle :: topSphereTriangles[x++] = new VertexTriangle(top1, top2, v);
- L341 C54: new VertexTriangle :: bottomSphereTriangles[x++] = new VertexTriangle(bot1, bot2, v);
- L389 C39: new Vertex :: Vertex[] topPoints1 = new Vertex[pts], topPoints2 = new Vertex[pts];
- L389 C69: new Vertex :: Vertex[] topPoints1 = new Vertex[pts], topPoints2 = new Vertex[pts];
- L390 C39: new Vertex :: Vertex[] botPoints1 = new Vertex[pts], botPoints2 = new Vertex[pts];
- L390 C69: new Vertex :: Vertex[] botPoints1 = new Vertex[pts], botPoints2 = new Vertex[pts];
- L400 C37: new Vertex :: topPoints1[i] = new Vertex(Vector3.Transform(radius * v1, offset));
- L401 C37: new Vertex :: topPoints2[i] = new Vertex(Vector3.Transform(radius * v2, offset));
- L402 C37: new Vertex :: botPoints1[i] = new Vertex(-Vector3.Transform(radius * v1, offset));
- L403 C37: new Vertex :: botPoints2[i] = new Vertex(-Vector3.Transform(radius * v2, offset));
- L415 C21: new Vertex :: new Vertex(bottomPoint + rightNormal * radius),
- L416 C21: new Vertex :: new Vertex(topPoint + rightNormal * radius));
- L418 C21: new Vertex :: new Vertex(bottomPoint - rightNormal * radius),
- L419 C21: new Vertex :: new Vertex(topPoint - rightNormal * radius));
- L421 C21: new Vertex :: new Vertex(bottomPoint + forwardNormal * radius),
- L422 C21: new Vertex :: new Vertex(topPoint + forwardNormal * radius));
- L424 C21: new Vertex :: new Vertex(bottomPoint - forwardNormal * radius),
- L425 C21: new Vertex :: new Vertex(topPoint - forwardNormal * radius));
- L454 C28: new VertexLine :: topFront = new VertexLine(new Vertex(TFL), new Vertex(TFR));
- L454 C43: new Vertex :: topFront = new VertexLine(new Vertex(TFL), new Vertex(TFR));
- L454 C60: new Vertex :: topFront = new VertexLine(new Vertex(TFL), new Vertex(TFR));
- L455 C27: new VertexLine :: topBack = new VertexLine(new Vertex(TBL), new Vertex(TBR));
- L455 C42: new Vertex :: topBack = new VertexLine(new Vertex(TBL), new Vertex(TBR));
- L455 C59: new Vertex :: topBack = new VertexLine(new Vertex(TBL), new Vertex(TBR));
- L456 C27: new VertexLine :: topLeft = new VertexLine(new Vertex(TFL), new Vertex(TBL));
- L456 C42: new Vertex :: topLeft = new VertexLine(new Vertex(TFL), new Vertex(TBL));
- L456 C59: new Vertex :: topLeft = new VertexLine(new Vertex(TFL), new Vertex(TBL));
- L457 C28: new VertexLine :: topRight = new VertexLine(new Vertex(TFR), new Vertex(TBR));
- L457 C43: new Vertex :: topRight = new VertexLine(new Vertex(TFR), new Vertex(TBR));
- L457 C60: new Vertex :: topRight = new VertexLine(new Vertex(TFR), new Vertex(TBR));
- L459 C31: new VertexLine :: bottomFront = new VertexLine(new Vertex(BFL), new Vertex(BFR));
- L459 C46: new Vertex :: bottomFront = new VertexLine(new Vertex(BFL), new Vertex(BFR));
- L459 C63: new Vertex :: bottomFront = new VertexLine(new Vertex(BFL), new Vertex(BFR));
- L460 C30: new VertexLine :: bottomBack = new VertexLine(new Vertex(BBL), new Vertex(BBR));
- L460 C45: new Vertex :: bottomBack = new VertexLine(new Vertex(BBL), new Vertex(BBR));
- L460 C62: new Vertex :: bottomBack = new VertexLine(new Vertex(BBL), new Vertex(BBR));
- L461 C30: new VertexLine :: bottomLeft = new VertexLine(new Vertex(BFL), new Vertex(BBL));
- L461 C45: new Vertex :: bottomLeft = new VertexLine(new Vertex(BFL), new Vertex(BBL));
- L461 C62: new Vertex :: bottomLeft = new VertexLine(new Vertex(BFL), new Vertex(BBL));
- L462 C31: new VertexLine :: bottomRight = new VertexLine(new Vertex(BFR), new Vertex(BBR));
- L462 C46: new Vertex :: bottomRight = new VertexLine(new Vertex(BFR), new Vertex(BBR));
- L462 C63: new Vertex :: bottomRight = new VertexLine(new Vertex(BFR), new Vertex(BBR));
- L464 C29: new VertexLine :: frontLeft = new VertexLine(new Vertex(TFL), new Vertex(BFL));
- L464 C44: new Vertex :: frontLeft = new VertexLine(new Vertex(TFL), new Vertex(BFL));
- L464 C61: new Vertex :: frontLeft = new VertexLine(new Vertex(TFL), new Vertex(BFL));
- L465 C30: new VertexLine :: frontRight = new VertexLine(new Vertex(TFR), new Vertex(BFR));
- L465 C45: new Vertex :: frontRight = new VertexLine(new Vertex(TFR), new Vertex(BFR));
- L465 C62: new Vertex :: frontRight = new VertexLine(new Vertex(TFR), new Vertex(BFR));
- L466 C28: new VertexLine :: backLeft = new VertexLine(new Vertex(TBL), new Vertex(BBL));
- L466 C43: new Vertex :: backLeft = new VertexLine(new Vertex(TBL), new Vertex(BBL));
- L466 C60: new Vertex :: backLeft = new VertexLine(new Vertex(TBL), new Vertex(BBL));
- L467 C29: new VertexLine :: backRight = new VertexLine(new Vertex(TBR), new Vertex(BBR));
- L467 C44: new Vertex :: backRight = new VertexLine(new Vertex(TBR), new Vertex(BBR));
- L467 C61: new Vertex :: backRight = new VertexLine(new Vertex(TBR), new Vertex(BBR));
- L596 C31: new VertexLineStrip :: return Create(new VertexLineStrip(true, bottomLeft, bottomRight, topRight, topLeft));
- L611 C27: new Exception :: throw new Exception("A (very low res) circle needs at least 3 sides.");
- L616 C34: new Vertex :: points.Insert(0, new Vertex(center, normal, new Vector2(0.5f)));
- L616 C61: new Vector2 :: points.Insert(0, new Vertex(center, normal, new Vector2(0.5f)));


## XRENGINE/Rendering/API/Rendering/Objects/Meshes/XRMesh.Skinning.cs
- L46 C33: new Dictionary :: var weightsPerVertex2 = new Dictionary<TransformBase, (float weight, Matrix4x4 invBindMatrix)>?[vertexCount];
- L48 C41: new ConcurrentDictionary :: var concurrentInvBindMatrices = new ConcurrentDictionary<TransformBase, Matrix4x4>();
- L49 C42: new ConcurrentDictionary :: var concurrentBoneToIndexTable = new ConcurrentDictionary<TransformBase, int>();
- L53 C32: new object :: object[] vertexLocks = new object[vertexCount];
- L55 C30: new object :: vertexLocks[i] = new object();
- L140 C33: new XRDataBuffer :: BoneWeightOffsets = new XRDataBuffer(ECommonBufferType.BoneMatrixOffset.ToString(), EBufferTarget.ArrayBuffer, vertCount, indexVarType, 4, false, intVarType);
- L141 C32: new XRDataBuffer :: BoneWeightCounts = new XRDataBuffer(ECommonBufferType.BoneMatrixCount.ToString(), EBufferTarget.ArrayBuffer, vertCount, EComponentType.Float, 4, false, false);
- L145 C33: new XRDataBuffer :: BoneWeightOffsets = new XRDataBuffer(ECommonBufferType.BoneMatrixOffset.ToString(), EBufferTarget.ArrayBuffer, vertCount, indexVarType, 1, false, intVarType);
- L146 C32: new XRDataBuffer :: BoneWeightCounts = new XRDataBuffer(ECommonBufferType.BoneMatrixCount.ToString(), EBufferTarget.ArrayBuffer, vertCount, indexVarType, 1, false, intVarType);
- L148 C33: new XRDataBuffer :: BoneWeightIndices = new XRDataBuffer($"{ECommonBufferType.BoneMatrixIndices}Buffer", EBufferTarget.ShaderStorageBuffer, true);
- L150 C32: new XRDataBuffer :: BoneWeightValues = new XRDataBuffer($"{ECommonBufferType.BoneMatrixWeights}Buffer", EBufferTarget.ShaderStorageBuffer, false);
- L179 C25: new uint :: uint[] counts = new uint[vertexCount];
- L180 C40: new List :: List<int>[] localBoneIndices = new List<int>[vertexCount];
- L181 C42: new List :: List<float>[] localBoneWeights = new List<float>[vertexCount];
- L198 C31: new List :: var indicesList = new List<int>(count);
- L199 C31: new List :: var weightsList = new List<float>(count);


## XRENGINE/Rendering/API/Rendering/Objects/Render Targets/XRCubeFrameBuffer.cs
- L24 C34: new XRMeshRenderer :: FullScreenCubeMesh = new XRMeshRenderer(XRMesh.Shapes.SolidBox(new Vector3(-0.5f), new Vector3(0.5f), true), mat);
- L24 C76: new Vector3 :: FullScreenCubeMesh = new XRMeshRenderer(XRMesh.Shapes.SolidBox(new Vector3(-0.5f), new Vector3(0.5f), true), mat);
- L24 C96: new Vector3 :: FullScreenCubeMesh = new XRMeshRenderer(XRMesh.Shapes.SolidBox(new Vector3(-0.5f), new Vector3(0.5f), true), mat);
- L61 C34: new XRCamera :: XRCamera[] cameras = new XRCamera[6];
- L74 C21: new XRPerspectiveCameraParameters :: p = new XRPerspectiveCameraParameters(90.0f, 1.0f, nearZ, farZ);
- L77 C29: new XROrthographicCameraParameters :: var ortho = new XROrthographicCameraParameters(1.0f, 1.0f, nearZ, farZ);
- L84 C27: new Transform :: var tfm = new Transform()


## XRENGINE/Rendering/API/Rendering/Objects/Render Targets/XRFrameBuffer.cs
- L21 C67: new() :: private static readonly Stack<XRFrameBuffer> _readStack = new();
- L22 C68: new() :: private static readonly Stack<XRFrameBuffer> _writeStack = new();
- L23 C67: new() :: private static readonly Stack<XRFrameBuffer> _bindStack = new();


## XRENGINE/Rendering/API/Rendering/Objects/Render Targets/XRQuadFrameBuffer.cs
- L24 C21: new Vector3 :: new Vector3(-1, -1, 0),
- L25 C21: new Vector3 :: new Vector3( 3, -1, 0),
- L26 C21: new Vector3 :: new Vector3(-1,  3, 0));
- L37 C21: new Vector3 :: new Vector3(-1, -1, 0),
- L38 C21: new Vector3 :: new Vector3( 1, -1, 0),
- L39 C21: new Vector3 :: new Vector3( 1,  1, 0));
- L46 C21: new Vector3 :: new Vector3(-1, -1, 0),
- L47 C21: new Vector3 :: new Vector3( 1,  1, 0),
- L48 C21: new Vector3 :: new Vector3(-1,  1, 0));
- L61 C30: new XRMeshRenderer :: FullScreenMesh = new XRMeshRenderer(Mesh(useTriangle), mat);


## XRENGINE/Rendering/API/Rendering/Objects/Textures/1D/Mipmap1D.cs
- L86 C16: new() :: => new()
- L109 C20: new DataSource :: Data = new DataSource(data);


## XRENGINE/Rendering/API/Rendering/Objects/Textures/1D/XRTexture1D.cs
- L36 C31: new Mipmap1D :: Mipmap1D[] mips = new Mipmap1D[mipCount];
- L40 C27: new Mipmap1D :: mips[i] = new Mipmap1D(Math.Max(1u, currentWidth), internalFormat, format, type, allocateData);
- L144 C37: new Mipmap1D :: Mipmap1D[] newMipmaps = new Mipmap1D[desiredLevels];
- L151 C33: new Mipmap1D :: newMipmaps[i] = new Mipmap1D(currentWidth, baseMip.InternalFormat, baseMip.PixelFormat, baseMip.PixelType, false);


## XRENGINE/Rendering/API/Rendering/Objects/Textures/1D/XRTexture1DArray.cs
- L32 C38: new XRTexture1D :: XRTexture1D[] textures = new XRTexture1D[layerCount];
- L34 C31: new XRTexture1D :: textures[i] = new XRTexture1D(width, internalFormat, format, type, allocateData);


## XRENGINE/Rendering/API/Rendering/Objects/Textures/2D/Mipmap2D.cs
- L54 C39: new DataSource :: Data = allocateData ? new DataSource(XRTexture.AllocateBytes(width, height, pixelFormat, pixelType)) : null;
- L89 C52: new DataSource :: set => _bytes = value is null ? null : new DataSource(value);
- L116 C28: new() :: Mipmap2D mip = new();
- L132 C35: new Rgba32 :: Rgba32[] pixels = new Rgba32[image.Width * image.Height];
- L223 C28: new DataSource :: Data = new DataSource(XRTexture.AllocateBytes(width, height, PixelFormat, PixelType));
- L237 C32: new DataSource :: Data = new DataSource(XRTexture.AllocateBytes(width, height, PixelFormat, PixelType));
- L289 C16: new() :: => new()


## XRENGINE/Rendering/API/Rendering/Objects/Textures/2D/XRTexture2D.cs
- L55 C35: new MagickImage :: var sourceImage = new MagickImage(fileBytes);
- L91 C35: new MagickImage :: var sourceImage = new MagickImage(fileData);
- L117 C31: new DirectStorageIO.ReadBatch :: using var batch = new DirectStorageIO.ReadBatch();
- L118 C27: new int :: var indices = new int[entries.Length];
- L162 C23: new ArgumentException :: throw new ArgumentException("File path must be provided.", nameof(filePath));
- L164 C45: new XRTexture2D :: XRTexture2D target = texture ?? new XRTexture2D();
- L243 C23: new ArgumentException :: throw new ArgumentException("File path must be provided.", nameof(filePath));
- L245 C45: new XRTexture2D :: XRTexture2D target = texture ?? new XRTexture2D();
- L415 C24: new Mipmap2D :: Mipmaps = [new Mipmap2D(new MagickImage(FillerImage))];
- L415 C37: new MagickImage :: Mipmaps = [new Mipmap2D(new MagickImage(FillerImage))];
- L428 C28: new YamlStream :: var yaml = new YamlStream();
- L535 C35: new Mipmap2D :: target.Mipmaps = [new Mipmap2D(previewImage)];
- L587 C35: new Mipmap2D :: target.Mipmaps = [new Mipmap2D(baseImage)];
- L605 C37: new Mipmap2D :: Mipmap2D[] copies = new Mipmap2D[sourceMipmaps.Length];
- L609 C47: new Mipmap2D :: copies[i] = mip is null ? new Mipmap2D() : mip.Clone(cloneImage: deepCopy);
- L620 C31: new Mipmap2D :: target.Mipmaps = [new Mipmap2D(filler)];
- L661 C31: new Mipmap2D :: Mipmap2D[] mips = new Mipmap2D[mipCount];
- L662 C23: new Mipmap2D :: mips[0] = new Mipmap2D(image);
- L671 C27: new Mipmap2D :: mips[i] = new Mipmap2D(clone as MagickImage);
- L683 C24: new MagickImage :: return new MagickImage(path);
- L691 C26: new Drawables :: img.Draw(new Drawables()
- L817 C24: new Mipmap2D :: Mipmaps = [new Mipmap2D(loadTask)];
- L824 C24: new Mipmap2D :: Mipmaps = [new Mipmap2D(width, height, EPixelInternalFormat.Rgba8, EPixelFormat.Rgba, EPixelType.UnsignedByte, true)
- L826 C24: new DataSource :: Data = new DataSource(ColorToBytes(width, height, color))
- L832 C27: new byte :: byte[] data = new byte[width * height * 4];
- L850 C31: new Mipmap2D :: Mipmap2D[] mips = new Mipmap2D[mipmapCount];
- L855 C35: new() :: Mipmap2D mipmap = new()
- L862 C28: new DataSource :: Data = new DataSource(AllocateBytes(clampedWidth, clampedHeight, format, type))
- L873 C31: new Mipmap2D :: Mipmap2D[] mips = new Mipmap2D[mipMapPaths.Length];
- L881 C31: new Mipmap2D :: mips[i] = new Mipmap2D(new MagickImage(path));
- L881 C44: new MagickImage :: mips[i] = new Mipmap2D(new MagickImage(path));
- L900 C24: new Mipmap2D :: Mipmaps = [new Mipmap2D()
- L907 C39: new DataSource :: Data = allocateData ? new DataSource(AllocateBytes(width, height, format, type)) : null
- L912 C31: new Mipmap2D :: Mipmap2D[] mips = new Mipmap2D[mipmaps.Length];
- L919 C27: new Mipmap2D :: mips[i] = new Mipmap2D(image);
- L929 C24: new Mipmap2D :: Mipmaps = [new Mipmap2D(image)];
- L937 C24: new Mipmap2D :: Mipmaps = [new Mipmap2D(image)];
- L1127 C32: new XRDataBuffer :: _pbo = new XRDataBuffer(EBufferTarget.PixelUnpackBuffer, true)
- L1219 C26: new GrabPassInfo :: t.GrabPass = new GrabPassInfo(t, readBuffer, colorBit, depthBit, stencilBit, linearFilter, true, resizeScale);
- L1249 C26: new GrabPassInfo :: t.GrabPass = new GrabPassInfo(t, readBuffer, colorBit, depthBit, stencilBit, linearFilter, false, 1.0f);
- L1378 C34: new Mipmap2D :: Mipmap2D[] mipmaps = new Mipmap2D[mipCount];
- L1388 C32: new() :: Mipmap2D mip = new()
- L1395 C51: new DataSource :: Data = bytes is null ? null : new DataSource(bytes)
- L1436 C20: new GrabPassInfo :: return new GrabPassInfo(owner, readBuffer, colorBit, depthBit, stencilBit, linearFilter, resizeToFit, resizeScale);


## XRENGINE/Rendering/API/Rendering/Objects/Textures/2D/XRTexture2DArray.cs
- L32 C28: new XRTexture2D :: var textures = new XRTexture2D[count];
- L34 C31: new XRTexture2D :: textures[i] = new XRTexture2D(width, height, internalFormat, format, type, allocateData);
- L212 C24: new XRTexture2D :: Textures = new XRTexture2D[collection.Count];


## XRENGINE/Rendering/API/Rendering/Objects/Textures/3D/Mipmap3D.cs
- L106 C16: new() :: => new()
- L131 C20: new DataSource :: Data = new DataSource(data);


## XRENGINE/Rendering/API/Rendering/Objects/Textures/3D/XRTexture3D.cs
- L135 C31: new Mipmap3D :: Mipmap3D[] mips = new Mipmap3D[mipmapCount];
- L141 C27: new Mipmap3D :: mips[i] = new Mipmap3D(Math.Max(1u, w), Math.Max(1u, h), Math.Max(1u, d), internalFormat, format, type, allocateData);
- L187 C37: new Mipmap3D :: Mipmap3D[] newMipmaps = new Mipmap3D[desiredLevels];
- L201 C33: new Mipmap3D :: newMipmaps[i] = new Mipmap3D(w, h, d, baseMip.InternalFormat, baseMip.PixelFormat, baseMip.PixelType, false);
- L323 C28: new DataSource :: baseMip.Data = new DataSource(data);
- L331 C28: new byte :: byte[] bytes = new byte[texels * components * componentSize];


## XRENGINE/Rendering/API/Rendering/Objects/Textures/Cube/XRTextureCube.cs
- L28 C33: new CubeMipmap :: CubeMipmap[] mips = new CubeMipmap[mipCount];
- L31 C27: new CubeMipmap :: mips[i] = new CubeMipmap(sDim);
- L46 C33: new CubeMipmap :: CubeMipmap[] mips = new CubeMipmap[mipCount];
- L49 C27: new CubeMipmap :: mips[i] = new CubeMipmap(sDim, internalFormat, pixelFormat, pixelType, allocateData);


## XRENGINE/Rendering/API/Rendering/Objects/Textures/Cube/XRTextureCubeArray.cs
- L34 C37: new XRTextureCube :: XRTextureCube[] cubes = new XRTextureCube[layerCount];
- L36 C28: new XRTextureCube :: cubes[i] = new XRTextureCube(extent, internalFormat, format, type, allocateData, mipCount);


## XRENGINE/Rendering/API/Rendering/Objects/Textures/XRTexture.cs
- L31 C43: new() :: MagickReadSettings settings = new()
- L62 C43: new() :: MagickReadSettings settings = new()
- L93 C43: new() :: MagickReadSettings settings = new()
- L118 C16: new byte :: => new byte[width * height * depth * ComponentSize(type) * GetComponentCount(format)];
- L148 C32: new NotSupportedException :: _ => throw new NotSupportedException($"Unsupported pixel depth: {depth}"),


## XRENGINE/Rendering/API/Rendering/Objects/Textures/XRTextureView.cs
- L36 C63: new NotSupportedException :: public override ETextureTarget TextureTarget => throw new NotSupportedException("Texture view requires a concrete subtype for target.");


## XRENGINE/Rendering/API/Rendering/Objects/XRRenderProgram.cs
- L108 C13: new Dictionary :: new Dictionary<string, ShaderUniformBinding>(UniformComparer);
- L112 C13: new Dictionary :: new Dictionary<string, ShaderTextureBinding>(UniformComparer);
- L117 C96: new() :: private readonly Dictionary<XRShader, ShaderSubscription> _shaderSourceSubscriptions = new();
- L191 C47: new() :: ShaderSubscription subscription = new()
- L292 C27: new ShaderInterfaceBuilder :: var builder = new ShaderInterfaceBuilder();
- L846 C23: new ArgumentNullException :: throw new ArgumentNullException(nameof(buffer), "Cannot bind a null buffer to the shader program.");
- L893 C34: new() :: List<Token> tokens = new();
- L907 C28: new Token :: tokens.Add(new Token(statement[start..index], start));
- L1065 C30: new UniformDeclaration :: yield return new UniformDeclaration(glslType, name, isArray, arrayLength, arrayExpr);
- L1128 C43: new StructDefinition :: definitions[structName] = new StructDefinition(structName, fields);
- L1231 C34: new HashSet :: var recursionGuard = new HashSet<string>(StringComparer.Ordinal);
- L1321 C37: new Dictionary :: var builtUniforms = new Dictionary<string, ShaderUniformBinding>(_uniforms.Count, UniformComparer);
- L1324 C43: new ShaderUniformBinding :: builtUniforms[name] = new ShaderUniformBinding(
- L1334 C37: new Dictionary :: var builtTextures = new Dictionary<string, ShaderTextureBinding>(_textures.Count, UniformComparer);
- L1337 C43: new ShaderTextureBinding :: builtTextures[name] = new ShaderTextureBinding(
- L1353 C35: new UniformAccumulator :: accumulator = new UniformAccumulator(
- L1373 C35: new TextureAccumulator :: accumulator = new TextureAccumulator(
- L1404 C65: new() :: private readonly HashSet<EShaderType> _stages = new();
- L1442 C65: new() :: private readonly HashSet<EShaderType> _stages = new();
- L1486 C23: new ArgumentOutOfRangeException :: throw new ArgumentOutOfRangeException(nameof(commandCount),


## XRENGINE/Rendering/API/Rendering/Objects/XRShader.cs
- L112 C29: new() :: TextFile file = new();
- L132 C29: new() :: TextFile file = new();
- L227 C71: new() :: public ConcurrentDictionary<string, bool> _existingUniforms = new();


## XRENGINE/Rendering/API/Rendering/OpenGL/OpenGLRenderer.cs
- L117 C26: new ImGuiController :: controller = new ImGuiController(Api, XRWindow.Window, input);
- L133 C38: new OpenGLImGuiBackend :: return _imguiBackend ??= new OpenGLImGuiBackend(controller);
- L165 C36: new string :: var list = new string[extCount];
- L436 C36: new GLMaterial :: XRMaterial data => new GLMaterial(this, data),
- L437 C31: new GLShader :: XRShader s => new GLShader(this, s),
- L441 C52: new GLMeshRenderer :: XRMeshRenderer.BaseVersion data => new GLMeshRenderer(this, data),
- L444 C49: new GLRenderProgramPipeline :: XRRenderProgramPipeline data => new GLRenderProgramPipeline(this, data),
- L445 C41: new GLRenderProgram :: XRRenderProgram data => new GLRenderProgram(this, data),
- L448 C38: new GLDataBuffer :: XRDataBuffer data => new GLDataBuffer(this, data),
- L449 C42: new GLDataBufferView :: XRDataBufferView data => new GLDataBufferView(this, data),
- L452 C40: new GLRenderBuffer :: XRRenderBuffer data => new GLRenderBuffer(this, data),
- L453 C39: new GLFrameBuffer :: XRFrameBuffer data => new GLFrameBuffer(this, data),
- L456 C37: new GLTexture1D :: XRTexture1D data => new GLTexture1D(this, data),
- L457 C42: new GLTexture1DArray :: XRTexture1DArray data => new GLTexture1DArray(this, data),
- L458 C43: new GLTextureView :: XRTextureViewBase data => new GLTextureView(this, data),
- L461 C37: new GLTexture2D :: XRTexture2D data => new GLTexture2D(this, data),
- L462 C42: new GLTexture2DArray :: XRTexture2DArray data => new GLTexture2DArray(this, data),
- L463 C44: new GLTextureRectangle :: XRTextureRectangle data => new GLTextureRectangle(this, data),
- L466 C37: new GLTexture3D :: XRTexture3D data => new GLTexture3D(this, data),
- L469 C39: new GLTextureCube :: XRTextureCube data => new GLTextureCube(this, data),
- L470 C44: new GLTextureCubeArray :: XRTextureCubeArray data => new GLTextureCubeArray(this, data),
- L473 C41: new GLTextureBuffer :: XRTextureBuffer data => new GLTextureBuffer(this, data),
- L476 C32: new GLSampler :: XRSampler s => new GLSampler(this, s),
- L479 C39: new GLRenderQuery :: XRRenderQuery data => new GLRenderQuery(this, data),
- L480 C45: new GLTransformFeedback :: XRTransformFeedback data => new GLTransformFeedback(this, data),
- L482 C28: new InvalidOperationException :: _ => throw new InvalidOperationException($"Render object type {renderObject.GetType()} is not supported.")
- L634 C28: new ArgumentOutOfRangeException :: _ => throw new ArgumentOutOfRangeException(nameof(comparison), comparison, null),
- L705 C28: new ArgumentOutOfRangeException :: _ => throw new ArgumentOutOfRangeException(nameof(mode), mode, null),
- L740 C61: new() :: private readonly HashSet<uint> _fboDetailedDumped = new();
- L835 C37: new[] :: foreach (var att in new[]
- L893 C28: new ArgumentOutOfRangeException :: _ => throw new ArgumentOutOfRangeException(nameof(attachment), attachment, null),
- L1566 C30: new XRShader :: var shader = new XRShader(EShaderType.Compute, LuminanceComputeShaderSource);
- L1567 C44: new XRRenderProgram :: _luminanceComputeProgram = new XRRenderProgram(true, false, shader);
- L1593 C32: new XRShader :: var shader2D = new XRShader(EShaderType.Compute, AutoExposureComputeShaderSource2D);
- L1594 C49: new XRRenderProgram :: _autoExposureComputeProgram2D = new XRRenderProgram(true, false, shader2D);
- L1596 C37: new XRShader :: var shader2DArray = new XRShader(EShaderType.Compute, AutoExposureComputeShaderSource2DArray);
- L1597 C54: new XRRenderProgram :: _autoExposureComputeProgram2DArray = new XRRenderProgram(true, false, shader2DArray);
- L1839 C19: new Vector4 :: : new Vector4[layerCount];
- L2004 C32: new Vector3 :: callback(true, new Vector3(r, g, b).Dot(luminance));
- L2086 C46: new Data.Vectors.IVector2 :: glProgram.Uniform("textureSize", new Data.Vectors.IVector2((int)w, (int)h));
- L2123 C32: new Vector3 :: callback(true, new Vector3(avg.X, avg.Y, avg.Z).Dot(luminance));
- L2419 C30: new byte :: byte[] newData = new byte[pixelCount * 3];
- L2439 C30: new byte :: byte[] newData = new byte[pixelCount * 3];
- L2474 C37: new BoundingRectangle :: uint pbo = ReadFBOToPBO(new BoundingRectangle(x, y, 1, 1), format, pixelType, size, out IntPtr sync);
- L2507 C37: new BoundingRectangle :: uint pbo = ReadFBOToPBO(new BoundingRectangle(x, y, 1, 1), format, pixelType, size, out IntPtr sync);
- L2600 C37: new float :: float[] allLayers = new float[floatCountAll];
- L2608 C30: new float :: rgbaFloats = new float[floatCountLayer];
- L2614 C26: new float :: rgbaFloats = new float[floatCount];
- L2639 C20: new Vector4 :: rgba = new Vector4(rgbaFloats[0], rgbaFloats[1], rgbaFloats[2], rgbaFloats[3]);
- L2693 C33: new uint :: uint[] bindingIds = new uint[objs.Length];
- L2760 C26: new uint :: uint[] ids = new uint[count];
- L2807 C75: new() :: private static EGLObjectType TypeFor<T>() where T : GLObjectBase, new()
- L2845 C28: new InvalidOperationException :: _ => throw new InvalidOperationException($"Type {typeof(T)} is not a valid GLObjectBase type."),
- L3480 C79: new() :: private readonly Dictionary<int, IGLTexture?> _boundTexturesPerUnit = new();


## XRENGINE/Rendering/API/Rendering/OpenGL/OpenGLRenderer.DebugTracking.cs
- L32 C58: new() :: private static readonly object _glErrorTrackerLock = new();
- L33 C90: new() :: private static readonly Dictionary<int, OpenGLDebugErrorAggregate> _glErrorTracker = new();
- L45 C29: new OpenGLDebugErrorAggregate :: aggregate = new OpenGLDebugErrorAggregate
- L69 C28: new OpenGLDebugErrorInfo :: var snapshot = new OpenGLDebugErrorInfo[_glErrorTracker.Count];
- L73 C37: new OpenGLDebugErrorInfo :: snapshot[index++] = new OpenGLDebugErrorInfo


## XRENGINE/Rendering/API/Rendering/OpenGL/Types/Buffers/GLDataBuffer.cs
- L16 C98: new() :: private static readonly ConcurrentDictionary<string, byte> _missingInterleavedLogs = new();
- L304 C39: new byte :: byte[] dataCopy = new byte[dataLength];
- L404 C28: new ArgumentOutOfRangeException :: _ => throw new ArgumentOutOfRangeException(nameof(usage), usage, null),
- L538 C33: new DataSource :: GPUSideSource = new DataSource(addr, length);


## XRENGINE/Rendering/API/Rendering/OpenGL/Types/Buffers/GLUploadQueue.cs
- L15 C79: new() :: private readonly ConcurrentQueue<PendingUpload> _pendingUploads = new();
- L16 C89: new() :: private readonly ConcurrentDictionary<GLDataBuffer, byte> _pendingBuffers = new();
- L59 C41: new PendingUpload :: _pendingUploads.Enqueue(new PendingUpload
- L136 C62: new GLUploadQueue :: public GLUploadQueue UploadQueue => _uploadQueue ??= new GLUploadQueue(this);


## XRENGINE/Rendering/API/Rendering/OpenGL/Types/GLMeshGenerationQueue.cs
- L15 C83: new() :: private readonly ConcurrentQueue<GLMeshRenderer> _pendingGeneration = new();
- L16 C87: new() :: private readonly ConcurrentDictionary<GLMeshRenderer, byte> _pendingSet = new();
- L131 C86: new GLMeshGenerationQueue :: public GLMeshGenerationQueue MeshGenerationQueue => _meshGenerationQueue ??= new GLMeshGenerationQueue(this);


## XRENGINE/Rendering/API/Rendering/OpenGL/Types/GLObjectBase.cs
- L158 C32: new ArgumentOutOfRangeException :: _ => throw new ArgumentOutOfRangeException(nameof(wrap), wrap, null),
- L170 C32: new ArgumentOutOfRangeException :: _ => throw new ArgumentOutOfRangeException(nameof(minFilter), minFilter, null),
- L178 C32: new ArgumentOutOfRangeException :: _ => throw new ArgumentOutOfRangeException(nameof(magFilter), magFilter, null),
- L203 C32: new ArgumentOutOfRangeException :: _ => throw new ArgumentOutOfRangeException(nameof(pixelType), pixelType, null),
- L231 C32: new ArgumentOutOfRangeException :: _ => throw new ArgumentOutOfRangeException(nameof(pixelFormat), pixelFormat, null),
- L290 C32: new ArgumentOutOfRangeException :: _ => throw new ArgumentOutOfRangeException(nameof(internalFormat), internalFormat, null),
- L377 C32: new ArgumentOutOfRangeException :: _ => throw new ArgumentOutOfRangeException(nameof(sizedInternalFormat), sizedInternalFormat, null),
- L398 C32: new ArgumentOutOfRangeException :: _ => throw new ArgumentOutOfRangeException(nameof(target), target, null),
- L533 C32: new NotImplementedException :: _ => throw new NotImplementedException()
- L542 C32: new NotImplementedException :: _ => throw new NotImplementedException()
- L628 C32: new ArgumentOutOfRangeException :: _ => throw new ArgumentOutOfRangeException(nameof(sizedInternalFormat), sizedInternalFormat, null),
- L795 C32: new ArgumentOutOfRangeException :: _ => throw new ArgumentOutOfRangeException(nameof(attachment), attachment, null),


## XRENGINE/Rendering/API/Rendering/OpenGL/Types/Mesh Renderer/GLMeshRenderer.Shaders.cs
- L117 C78: new XRRenderProgramPipeline :: _pipeline ??= Renderer.GenericToAPI<GLRenderProgramPipeline>(new XRRenderProgramPipeline())!;
- L200 C66: new XRRenderProgram :: program = Renderer.GenericToAPI<GLRenderProgram>(new XRRenderProgram(false, false, shaders))!;
- L226 C72: new XRRenderProgram :: vertexProgram = Renderer.GenericToAPI<GLRenderProgram>(new XRRenderProgram(false, true, vertexShader))!;


## XRENGINE/Rendering/API/Rendering/OpenGL/Types/Meshes/GLRenderProgram.cs
- L30 C33: new() :: _uniformCache = new(),
- L31 C32: new() :: _attribCache = new();
- L33 C85: new() :: private readonly ConcurrentDictionary<int, string> _locationNameCache = new();
- L34 C91: new() :: private readonly ConcurrentDictionary<string, UniformInfo> _uniformMetadata = new();
- L35 C92: new() :: private readonly ConcurrentDictionary<string, byte> _loggedUniformMismatches = new();
- L41 C94: new() :: private readonly ConcurrentDictionary<string, byte> _loggedEmptyBindingBatches = new();
- L44 C83: new() :: private readonly ConcurrentDictionary<string, byte> _failedUniforms = new();
- L463 C37: new byte :: byte[] nameBuffer = new byte[maxLength];
- L478 C50: new UniformInfo :: _uniformMetadata[name] = new UniformInfo(type, size);
- L482 C58: new UniformInfo :: _uniformMetadata[baseName] = new UniformInfo(type, size);
- L591 C31: new() :: BinaryCache = new();
- L777 C48: new GLShader :: GLShader?[] attached = new GLShader?[shaderCache.Count];
- L884 C33: new byte :: byte[] binary = new byte[len];
- L1396 C30: new int :: int[] conv = new int[p.Length];
- L1453 C30: new int :: int[] conv = new int[p.Length * 2];
- L1474 C30: new int :: int[] conv = new int[p.Length * 3];
- L1497 C30: new int :: int[] conv = new int[p.Length * 4];


## XRENGINE/Rendering/API/Rendering/OpenGL/Types/Textures/CubeMipmap.cs
- L14 C57: new Mipmap2D :: public Mipmap2D[] Sides { get; private set; } = new Mipmap2D[6];
- L22 C23: new InvalidOperationException :: throw new InvalidOperationException("Cubemap cross dimensions are invalid; width/height be a 4:3 or 3:4 ratio.");
- L34 C32: new Mipmap2D :: => Sides.Fill(i => new Mipmap2D(dim, dim, internalFormat, format, type, allocateData));
- L149 C51: new float :: outPixels.SetPixel((int)i, j, new float[] { (ushort)ri, (ushort)gi, (ushort)bi });
- L262 C24: new Mipmap2D :: return new Mipmap2D((MagickImage)clone);
- L277 C28: new Mipmap2D :: Sides[i] = new Mipmap2D(bmp);
- L281 C32: new Mipmap2D :: => Sides.Fill(i => new Mipmap2D(new MagickImage(color ??= new MagickColor(0, 0, 0, 0), dim, dim)));
- L281 C45: new MagickImage :: => Sides.Fill(i => new Mipmap2D(new MagickImage(color ??= new MagickColor(0, 0, 0, 0), dim, dim)));
- L281 C71: new MagickColor :: => Sides.Fill(i => new Mipmap2D(new MagickImage(color ??= new MagickColor(0, 0, 0, 0), dim, dim)));
- L284 C32: new Mipmap2D :: => Sides.Fill(i => new Mipmap2D(dim, dim, internalFormat, format, type, allocateData));


## XRENGINE/Rendering/API/Rendering/OpenGL/Types/Textures/GLTexture.cs
- L174 C40: new() :: PreBindCallback callback = new();
- L181 C44: new() :: PrePushDataCallback callback = new();


## XRENGINE/Rendering/API/Rendering/OpenGL/Types/Textures/GLTexture1D.cs
- L13 C59: new() :: private readonly List<Mipmap1D> _trackedMipmaps = new();
- L208 C27: new ArgumentException :: throw new ArgumentException("PBO must be bound to PixelUnpackBuffer for texture uploads.");


## XRENGINE/Rendering/API/Rendering/OpenGL/Types/Textures/GLTexture1DArray.cs
- L14 C62: new() :: private readonly List<LayerBinding> _layerBindings = new();
- L61 C36: new LayerBinding :: _layerBindings.Add(new LayerBinding(this, texture));
- L227 C27: new ArgumentException :: throw new ArgumentException("PBO must be bound to PixelUnpackBuffer for texture uploads.");
- L263 C63: new() :: private readonly List<Mipmap1D> _trackedMipmaps = new();


## XRENGINE/Rendering/API/Rendering/OpenGL/Types/Textures/GLTexture2D.cs
- L59 C23: new MipmapInfo :: Mipmaps = new MipmapInfo[Data.Mipmaps.Length];
- L61 C30: new MipmapInfo :: Mipmaps[i] = new MipmapInfo(this, Data.Mipmaps[i]);
- L331 C23: new ArgumentException :: throw new ArgumentException("PBO must be of type PixelUnpackBuffer.");


## XRENGINE/Rendering/API/Rendering/OpenGL/Types/Textures/GLTexture2DArray.cs
- L103 C23: new MipmapInfo :: Mipmaps = new MipmapInfo[Data.Mipmaps.Length];
- L105 C30: new MipmapInfo :: Mipmaps[i] = new MipmapInfo(this, Data.Mipmaps[i]);


## XRENGINE/Rendering/API/Rendering/OpenGL/Types/Textures/GLTextureCube.cs
- L88 C23: new MipmapInfo :: Mipmaps = new MipmapInfo[Data.Mipmaps.Length];
- L90 C30: new MipmapInfo :: Mipmaps[i] = new MipmapInfo(this, Data.Mipmaps[i]);


## XRENGINE/Rendering/API/Rendering/OpenGL/Types/Textures/GLTextureCubeArray.cs
- L15 C60: new() :: private readonly List<CubeLayerInfo> _cubeLayers = new();
- L62 C33: new CubeLayerInfo :: _cubeLayers.Add(new CubeLayerInfo(this, cube));
- L257 C27: new ArgumentException :: throw new ArgumentException("PBO must be bound to PixelUnpackBuffer for texture uploads.");
- L296 C58: new() :: private readonly List<MipmapInfo> _mipmaps = new();
- L352 C34: new MipmapInfo :: _mipmaps.Add(new MipmapInfo(_owner, mip));


## XRENGINE/Rendering/API/Rendering/OpenGL/Types/Textures/GLTextureRectangle.cs
- L71 C27: new ArgumentException :: throw new ArgumentException("StreamingPBO must target PixelUnpackBuffer for rectangle uploads.");


## XRENGINE/Rendering/API/Rendering/OpenXR/Extensions.cs
- L42 C23: new ArgumentOutOfRangeException :: throw new ArgumentOutOfRangeException(nameof(renderer), renderer, null);


## XRENGINE/Rendering/API/Rendering/OpenXR/Instance.cs
- L48 C15: new[] :: ? new[] { "XR_KHR_vulkan_enable", "XR_KHR_vulkan_enable2" }
- L49 C15: new[] :: : new[] { "XR_KHR_opengl_enable" };
- L52 C19: new Exception :: throw new Exception($"OpenXR runtime does not support required renderer extension(s): {string.Join(", ", requiredForRenderer)}");
- L142 C27: new ProcessStartInfo :: Process.Start(new ProcessStartInfo
- L161 C27: new ProcessStartInfo :: Process.Start(new ProcessStartInfo
- L178 C19: new HashSet :: var set = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
- L182 C21: new ExtensionProperties :: var props = new ExtensionProperties[count];
- L211 C21: new ExtensionProperties :: var props = new ExtensionProperties[count];
- L238 C19: new Exception :: throw new Exception(BuildCreateInstanceFailureMessage(result, createInfo));
- L244 C18: new StringBuilder :: var sb = new StringBuilder();
- L295 C20: new List :: var list = new List<string>((int)count);
- L344 C41: new() :: InstanceCreateInfo createInfo = new()
- L369 C30: new Version64 :: appInfo.ApiVersion = new Version64(1, 0, 0);
- L370 C38: new Version32 :: appInfo.ApplicationVersion = new Version32(1, 0, 0);
- L371 C33: new Version32 :: appInfo.EngineVersion = new Version32(1, 0, 0);


## XRENGINE/Rendering/API/Rendering/OpenXR/OpenXRAPI.FrameLifecycle.cs
- L53 C40: new FrameEndInfo :: var frameEndInfoNoLayers = new FrameEndInfo
- L95 C40: new FrameEndInfo :: var frameEndInfoNoLayers = new FrameEndInfo
- L112 C21: new CompositionLayerProjection :: var layer = new CompositionLayerProjection
- L124 C28: new FrameEndInfo :: var frameEndInfo = new FrameEndInfo
- L151 C27: new SwapchainImageAcquireInfo :: var acquireInfo = new SwapchainImageAcquireInfo
- L169 C28: new SwapchainImageWaitInfo :: var waitInfo = new SwapchainImageWaitInfo
- L209 C61: new Rect2Di :: projectionViews[viewIndex].SubImage.ImageRect = new Rect2Di
- L211 C26: new Offset2Di :: Offset = new Offset2Di { X = 0, Y = 0 },
- L212 C26: new Extent2Di :: Extent = new Extent2Di
- L231 C35: new SwapchainImageReleaseInfo :: var releaseInfo = new SwapchainImageReleaseInfo { Type = StructureType.SwapchainImageReleaseInfo };
- L401 C20: new GlStateSnapshot :: return new GlStateSnapshot(
- L682 C41: new AutoResetEvent :: _openXrLeftCollectStart ??= new AutoResetEvent(false);
- L683 C42: new AutoResetEvent :: _openXrRightCollectStart ??= new AutoResetEvent(false);
- L684 C40: new ManualResetEventSlim :: _openXrLeftCollectDone ??= new ManualResetEventSlim(false);
- L685 C41: new ManualResetEventSlim :: _openXrRightCollectDone ??= new ManualResetEventSlim(false);
- L687 C40: new Thread :: _openXrLeftCollectWorker = new Thread(() => OpenXrParallelCollectWorkerLoop(leftEye: true))
- L692 C41: new Thread :: _openXrRightCollectWorker = new Thread(() => OpenXrParallelCollectWorkerLoop(leftEye: false))
- L741 C27: new AggregateException :: throw new AggregateException(_openXrParallelCollectLeftError, _openXrParallelCollectRightError);
- L782 C27: new InvalidOperationException :: throw new InvalidOperationException("OpenXR parallel collect worker missing viewport/world/camera.");
- L1000 C40: new FrameEndInfo :: var frameEndInfoNoLayers = new FrameEndInfo


## XRENGINE/Rendering/API/Rendering/OpenXR/OpenXRAPI.Input.cs
- L118 C19: new Exception :: throw new Exception($"xrStringToPath('{s}') failed: {r}");
- L124 C29: new ActionSetCreateInfo :: var actionSetInfo = new ActionSetCreateInfo
- L135 C19: new Exception :: throw new Exception($"xrCreateActionSet failed: {setResult}");
- L138 C28: new ActionCreateInfo :: var handPoseInfo = new ActionCreateInfo
- L151 C19: new Exception :: throw new Exception($"xrCreateAction(hand_grip_pose) failed: {actionResult}");
- L155 C32: new XrPath :: var trackerPaths = new XrPath[_trackerSubactionPaths.Count];
- L162 C39: new ActionCreateInfo :: var trackerPoseInfo = new ActionCreateInfo
- L182 C24: new Posef :: var identity = new Posef
- L184 C27: new Quaternionf :: Orientation = new Quaternionf { X = 0, Y = 0, Z = 0, W = 1 },
- L185 C24: new Vector3f :: Position = new Vector3f { X = 0, Y = 0, Z = 0 }
- L188 C24: new ActionSpaceCreateInfo :: var leftInfo = new ActionSpaceCreateInfo
- L196 C25: new ActionSpaceCreateInfo :: var rightInfo = new ActionSpaceCreateInfo
- L217 C35: new ActionSpaceCreateInfo :: var trackerInfo = new ActionSpaceCreateInfo
- L239 C26: new SessionActionSetsAttachInfo :: var attachInfo = new SessionActionSetsAttachInfo
- L265 C28: new ActionSuggestedBinding :: var bindings = new ActionSuggestedBinding[2]
- L267 C17: new ActionSuggestedBinding :: new ActionSuggestedBinding { Action = _handGripPoseAction, Binding = leftGrip },
- L268 C17: new ActionSuggestedBinding :: new ActionSuggestedBinding { Action = _handGripPoseAction, Binding = rightGrip },
- L280 C39: new List :: var trackerBindings = new List<ActionSuggestedBinding>(_trackerSubactionPaths.Count);
- L286 C45: new ActionSuggestedBinding :: trackerBindings.Add(new ActionSuggestedBinding { Action = _trackerPoseAction, Binding = binding });
- L314 C29: new InteractionProfileSuggestedBinding :: var suggested = new InteractionProfileSuggestedBinding
- L333 C22: new ActiveActionSet :: var active = new ActiveActionSet
- L339 C24: new ActionsSyncInfo :: var syncInfo = new ActionsSyncInfo
- L360 C23: new ActionStateGetInfo :: var getInfo = new ActionStateGetInfo
- L367 C21: new ActionStatePose :: var state = new ActionStatePose
- L386 C24: new SpaceLocation :: var location = new SpaceLocation { Type = StructureType.SpaceLocation };
- L396 C19: new Vector3 :: var pos = new Vector3(p.Position.X, p.Position.Y, p.Position.Z);
- L397 C40: new Quaternion :: var rot = Quaternion.Normalize(new Quaternion(p.Orientation.X, p.Orientation.Y, p.Orientation.Z, p.Orientation.W));


## XRENGINE/Rendering/API/Rendering/OpenXR/OpenXRAPI.IPD.cs
- L25 C22: new Vector3 :: var lp = new Vector3(l.X, l.Y, l.Z);
- L26 C22: new Vector3 :: var rp = new Vector3(r.X, r.Y, r.Z);


## XRENGINE/Rendering/API/Rendering/OpenXR/OpenXRAPI.OpenGL.cs
- L37 C19: new Exception :: throw new Exception("Window is null");
- L76 C28: new GraphicsRequirementsOpenGLKHR :: var requirements = new GraphicsRequirementsOpenGLKHR
- L82 C19: new Exception :: throw new Exception("Failed to get OpenGL extension");
- L85 C19: new Exception :: throw new Exception("Failed to get OpenGL graphics requirements");
- L118 C19: new Exception :: throw new Exception("Cannot create OpenXR session: no valid OpenGL handles available (both current and window handles are null). Ensure OpenXR OpenGL session creation runs on the window render thread and the GL context is created.");
- L128 C30: new List :: var attemptResults = new List<string>(2);
- L158 C27: new Exception :: throw new Exception(
- L166 C19: new Exception :: throw new Exception($"OpenXR OpenGL preflight failed: {ex.Message}");
- L180 C29: new GraphicsBindingOpenGLWin32KHR :: var glBinding = new GraphicsBindingOpenGLWin32KHR
- L186 C30: new SessionCreateInfo :: var createInfo = new SessionCreateInfo
- L208 C19: new Exception :: throw new Exception(
- L228 C19: new Exception :: throw new Exception("OpenGL context not initialized for OpenXR");
- L234 C19: new Exception :: throw new Exception($"Failed to enumerate OpenXR swapchain formats for OpenGL. Result={formatResult}, Count={formatCount}");
- L236 C23: new long :: var formats = new long[formatCount];
- L242 C19: new Exception :: throw new Exception($"Failed to enumerate OpenXR swapchain formats for OpenGL. Result={formatResult}, Count={formatCount}");
- L271 C19: new Exception :: throw new Exception($"Expected 2 views, got {_viewCount}");
- L273 C18: new View :: _views = new View[_viewCount];
- L293 C23: new Exception :: throw new Exception($"OpenXR runtime reported an invalid recommended image rect size for view {i}: {rw}x{rh}. Cannot create swapchains.");
- L312 C39: new[] :: foreach (var usage in new[] { SwapchainUsageFlags.ColorAttachmentBit | SwapchainUsageFlags.SampledBit, SwapchainUsageFlags.ColorAttachmentBit })
- L314 C97: new[] :: foreach (var samples in recommendedSamples > 1 ? [recommendedSamples, 1u] : new[] { 1u })
- L316 C51: new SwapchainCreateInfo :: var swapchainCreateInfo = new SwapchainCreateInfo
- L351 C23: new Exception :: throw new Exception($"Failed to create swapchain for view {i}. LastResult={lastResult}, RecommendedSamples={recommendedSamples}, Size={width}x{height}, SupportedFormats={supportedFormatsLog}");
- L360 C41: new uint :: _swapchainFramebuffers[i] = new uint[imageCount];
- L670 C33: new XRViewport :: _openXrLeftViewport ??= new XRViewport(Window)
- L677 C34: new XRViewport :: _openXrRightViewport ??= new XRViewport(Window)
- L723 C78: new XRCamera :: _openXrLeftEyeCamera ??= (hasVrRig ? vrInfo.LeftEyeCamera : null) ?? new XRCamera(new Transform());
- L723 C91: new Transform :: _openXrLeftEyeCamera ??= (hasVrRig ? vrInfo.LeftEyeCamera : null) ?? new XRCamera(new Transform());
- L724 C80: new XRCamera :: _openXrRightEyeCamera ??= (hasVrRig ? vrInfo.RightEyeCamera : null) ?? new XRCamera(new Transform());
- L724 C93: new Transform :: _openXrRightEyeCamera ??= (hasVrRig ? vrInfo.RightEyeCamera : null) ?? new XRCamera(new Transform());
- L765 C28: new XROpenXRFovCameraParameters :: openxrParams = new XROpenXRFovCameraParameters(nearZ, farZ);
- L785 C50: new Quaternion :: Quaternion eyeRot = Quaternion.Normalize(new Quaternion(
- L871 C32: new XRRenderBuffer :: _viewportMirrorDepth = new XRRenderBuffer(width, height, ERenderBufferStorage.Depth24Stencil8, EFrameBufferAttachment.DepthStencilAttachment)
- L876 C30: new XRFrameBuffer :: _viewportMirrorFbo = new XRFrameBuffer(


## XRENGINE/Rendering/API/Rendering/OpenXR/OpenXRAPI.RuntimeStateMachine.cs
- L129 C31: new VulkanXrGraphicsBinding :: VulkanRenderer => new VulkanXrGraphicsBinding(),
- L130 C31: new OpenGLXrGraphicsBinding :: OpenGLRenderer => new OpenGLXrGraphicsBinding(),


## XRENGINE/Rendering/API/Rendering/OpenXR/OpenXRAPI.State.cs
- L67 C29: new View :: private View[] _views = new View[2];
- L83 C47: new() :: private readonly object _openXrPoseLock = new();
- L306 C66: new() :: private readonly object _openXrParallelCollectDispatchLock = new();
- L348 C65: new ViewConfigurationView :: private readonly ViewConfigurationView[] _viewConfigViews = new ViewConfigurationView[2];
- L353 C48: new Swapchain :: private readonly Swapchain[] _swapchains = new Swapchain[2];
- L358 C70: new SwapchainImageOpenGLKHR :: private readonly SwapchainImageOpenGLKHR*[] _swapchainImagesGL = new SwapchainImageOpenGLKHR*[2];
- L363 C57: new uint :: private readonly uint[]?[] _swapchainFramebuffers = new uint[]?[2];
- L368 C53: new uint :: private readonly uint[] _swapchainImageCounts = new uint[2];
- L373 C71: new SwapchainImageVulkan2KHR :: private readonly SwapchainImageVulkan2KHR*[] _swapchainImagesVK = new SwapchainImageVulkan2KHR*[2];
- L378 C69: new SwapchainImageD3D12KHR :: private readonly SwapchainImageD3D12KHR*[] _swapchainImagesDX = new SwapchainImageD3D12KHR*[2];
- L403 C28: new DefaultRenderPipeline :: sourcePipeline ??= new DefaultRenderPipeline(stereo: false);
- L413 C31: new DefaultRenderPipeline :: created = new DefaultRenderPipeline(stereo: false)
- L421 C34: new DefaultRenderPipeline :: ?? new DefaultRenderPipeline(stereo: false);
- L427 C27: new DefaultRenderPipeline :: created = new DefaultRenderPipeline(stereo: false);


## XRENGINE/Rendering/API/Rendering/OpenXR/OpenXRAPI.Vulkan.cs
- L19 C19: new Exception :: throw new Exception("Window is null");
- L21 C28: new GraphicsRequirementsVulkanKHR :: var requirements = new GraphicsRequirementsVulkanKHR
- L27 C19: new Exception :: throw new Exception("Failed to get Vulkan extension");
- L30 C19: new Exception :: throw new Exception("Failed to get Vulkan graphics requirements");
- L35 C19: new Exception :: throw new Exception("Renderer is not a VulkanRenderer.");
- L59 C25: new GraphicsBindingVulkanKHR :: var vkBinding = new GraphicsBindingVulkanKHR
- L68 C26: new SessionCreateInfo :: var createInfo = new SessionCreateInfo
- L76 C19: new Exception :: throw new Exception($"Failed to create session: {result}");
- L91 C19: new Exception :: throw new Exception($"Expected 2 views, got {_viewCount}");
- L94 C18: new View :: _views = new View[_viewCount];
- L104 C39: new SwapchainCreateInfo :: var swapchainCreateInfo = new SwapchainCreateInfo
- L121 C27: new Exception :: throw new Exception($"Failed to create swapchain for view {i}");


## XRENGINE/Rendering/API/Rendering/OpenXR/OpenXRAPI.XrCalls.cs
- L15 C29: new SystemGetInfo :: var systemGetInfo = new SystemGetInfo
- L23 C19: new Exception :: throw new Exception($"Failed to get system: {result}");
- L29 C31: new ReferenceSpaceCreateInfo :: var spaceCreateInfo = new ReferenceSpaceCreateInfo
- L33 C36: new Posef :: PoseInReferenceSpace = new Posef
- L35 C31: new Quaternionf :: Orientation = new Quaternionf { X = 0, Y = 0, Z = 0, W = 1 },
- L36 C28: new Vector3f :: Position = new Vector3f { X = 0, Y = 0, Z = 0 }
- L42 C19: new Exception :: throw new Exception("Failed to create reference space");
- L53 C30: new FrameBeginInfo :: var frameBeginInfo = new FrameBeginInfo { Type = StructureType.FrameBeginInfo };
- L69 C29: new FrameWaitInfo :: var frameWaitInfo = new FrameWaitInfo { Type = StructureType.FrameWaitInfo };
- L70 C22: new FrameState :: frameState = new FrameState { Type = StructureType.FrameState };
- L87 C30: new ViewLocateInfo :: var viewLocateInfo = new ViewLocateInfo
- L95 C25: new ViewState :: var viewState = new ViewState { Type = StructureType.ViewState };
- L99 C29: new Span :: var viewsSpan = new Span<View>(viewsPtr, (int)_viewCount);
- L119 C20: new System.Numerics.Vector3 :: var lPos = new System.Numerics.Vector3(l.Position.X, l.Position.Y, l.Position.Z);
- L120 C20: new System.Numerics.Vector3 :: var rPos = new System.Numerics.Vector3(r.Position.X, r.Position.Y, r.Position.Z);
- L123 C57: new System.Numerics.Quaternion :: var lRot = System.Numerics.Quaternion.Normalize(new System.Numerics.Quaternion(
- L135 C57: new System.Numerics.Quaternion :: var rRot = System.Numerics.Quaternion.Normalize(new System.Numerics.Quaternion(
- L177 C25: new EventDataBuffer :: var eventData = new EventDataBuffer
- L206 C45: new SessionBeginInfo :: var beginInfo = new SessionBeginInfo


## XRENGINE/Rendering/API/Rendering/OpenXR/Validation.cs
- L56 C55: new() :: DebugUtilsMessengerCreateInfoEXT createInfo = new();
- L59 C17: new DebugUtilsMessengerEXT :: var d = new DebugUtilsMessengerEXT();
- L61 C19: new Exception :: throw new Exception("Failed to set up OpenXR debug messenger.");
- L68 C31: new ApiLayerProperties :: var availableLayers = new ApiLayerProperties[layerCount];


## XRENGINE/Rendering/API/Rendering/OpenXR/XrGraphicsBindings.cs
- L45 C27: new SwapchainImageAcquireInfo :: var acquireInfo = new SwapchainImageAcquireInfo { Type = StructureType.SwapchainImageAcquireInfo };
- L52 C24: new SwapchainImageWaitInfo :: var waitInfo = new SwapchainImageWaitInfo { Type = StructureType.SwapchainImageWaitInfo, Timeout = timeoutNs };
- L58 C27: new SwapchainImageReleaseInfo :: var releaseInfo = new SwapchainImageReleaseInfo { Type = StructureType.SwapchainImageReleaseInfo };
- L94 C27: new SwapchainImageAcquireInfo :: var acquireInfo = new SwapchainImageAcquireInfo { Type = StructureType.SwapchainImageAcquireInfo };
- L101 C24: new SwapchainImageWaitInfo :: var waitInfo = new SwapchainImageWaitInfo { Type = StructureType.SwapchainImageWaitInfo, Timeout = timeoutNs };
- L107 C27: new SwapchainImageReleaseInfo :: var releaseInfo = new SwapchainImageReleaseInfo { Type = StructureType.SwapchainImageReleaseInfo };


## XRENGINE/Rendering/API/Rendering/ShaderCrossCompiler.cs
- L22 C19: new ArgumentException :: throw new ArgumentException("Shader source is empty.", nameof(source));
- L24 C19: new ArgumentException :: throw new ArgumentException("Entry point is required.", nameof(entryPoint));
- L28 C19: new InvalidOperationException :: throw new InvalidOperationException("Failed to initialize the shaderc compiler instance.");
- L34 C19: new InvalidOperationException :: throw new InvalidOperationException("Failed to allocate shaderc compile options.");
- L62 C23: new InvalidOperationException :: throw new InvalidOperationException("Shader compilation failed due to an unknown error.");
- L68 C23: new InvalidOperationException :: throw new InvalidOperationException($"Shader compilation failed: {message}");
- L73 C23: new InvalidOperationException :: throw new InvalidOperationException("Shader compilation produced an empty SPIR-V module.");
- L75 C28: new byte :: byte[] spirv = new byte[(int)length];
- L118 C24: new ArgumentOutOfRangeException :: _ => throw new ArgumentOutOfRangeException(nameof(type), type, null)


## XRENGINE/Rendering/API/Rendering/Vulkan/Drawing.Blit.cs
- L88 C28: new BlitOp :: EnqueueFrameOp(new BlitOp(
- L205 C28: new BlitImageInfo :: info = new BlitImageInfo(
- L288 C20: new BlitImageInfo :: info = new BlitImageInfo(
- L387 C24: new BlitImageInfo :: return new BlitImageInfo(
- L411 C28: new BlitImageInfo :: return new BlitImageInfo(
- L462 C32: new() :: ImageBlit region = new()
- L464 C34: new ImageSubresourceLayers :: SrcSubresource = new ImageSubresourceLayers
- L471 C34: new ImageSubresourceLayers :: DstSubresource = new ImageSubresourceLayers
- L480 C42: new Offset3D :: region.SrcOffsets.Element0 = new Offset3D { X = inX, Y = inY, Z = 0 };
- L481 C42: new Offset3D :: region.SrcOffsets.Element1 = new Offset3D { X = inX + (int)inW, Y = inY + (int)inH, Z = 1 };
- L482 C42: new Offset3D :: region.DstOffsets.Element0 = new Offset3D { X = outX, Y = outY, Z = 0 };
- L483 C42: new Offset3D :: region.DstOffsets.Element1 = new Offset3D { X = outX + (int)outW, Y = outY + (int)outH, Z = 1 };
- L522 C42: new() :: ImageMemoryBarrier barrier = new()
- L532 C36: new ImageSubresourceRange :: SubresourceRange = new ImageSubresourceRange
- L560 C42: new() :: ImageMemoryBarrier barrier = new()
- L570 C36: new ImageSubresourceRange :: SubresourceRange = new ImageSubresourceRange
- L623 C21: new ColorF4 :: color = new ColorF4(
- L668 C40: new() :: BufferImageCopy copy = new()
- L673 C40: new ImageSubresourceLayers :: ImageSubresource = new ImageSubresourceLayers
- L680 C35: new Offset3D :: ImageOffset = new Offset3D { X = x, Y = y, Z = 0 },
- L681 C35: new Extent3D :: ImageExtent = new Extent3D { Width = (uint)width, Height = (uint)height, Depth = 1 }
- L717 C30: new byte :: rgbaPixels = new byte[width * height * 4];
- L764 C40: new() :: BufferImageCopy copy = new()
- L769 C40: new ImageSubresourceLayers :: ImageSubresource = new ImageSubresourceLayers
- L776 C35: new Offset3D :: ImageOffset = new Offset3D { X = x, Y = y, Z = 0 },
- L777 C35: new Extent3D :: ImageExtent = new Extent3D { Width = (uint)width, Height = (uint)height, Depth = 1 }
- L814 C30: new float :: rgbaFloats = new float[pixelCount * 4];
- L1042 C40: new() :: BufferImageCopy copy = new()
- L1047 C40: new ImageSubresourceLayers :: ImageSubresource = new ImageSubresourceLayers
- L1056 C35: new Offset3D :: ImageOffset = new Offset3D { X = x, Y = y, Z = 0 },
- L1057 C35: new Extent3D :: ImageExtent = new Extent3D { Width = 1, Height = 1, Depth = 1 }


## XRENGINE/Rendering/API/Rendering/Vulkan/Drawing.Core.cs
- L53 C36: new VkMaterial :: XRMaterial data => new VkMaterial(this, data),
- L54 C52: new VkMeshRenderer :: XRMeshRenderer.BaseVersion data => new VkMeshRenderer(this, data),
- L55 C49: new VkRenderProgramPipeline :: XRRenderProgramPipeline data => new VkRenderProgramPipeline(this, data),
- L56 C41: new VkRenderProgram :: XRRenderProgram data => new VkRenderProgram(this, data),
- L57 C38: new VkDataBuffer :: XRDataBuffer data => new VkDataBuffer(this, data),
- L58 C32: new VkSampler :: XRSampler s => new VkSampler(this, s),
- L59 C31: new VkShader :: XRShader s => new VkShader(this, s),
- L62 C40: new VkRenderBuffer :: XRRenderBuffer data => new VkRenderBuffer(this, data),
- L63 C39: new VkFrameBuffer :: XRFrameBuffer data => new VkFrameBuffer(this, data),
- L66 C37: new VkTexture1D :: XRTexture1D data => new VkTexture1D(this, data),
- L67 C42: new VkTexture1DArray :: XRTexture1DArray data => new VkTexture1DArray(this, data),
- L68 C43: new VkTextureView :: XRTextureViewBase data => new VkTextureView(this, data),
- L71 C37: new VkTexture2D :: XRTexture2D data => new VkTexture2D(this, data),
- L72 C42: new VkTexture2DArray :: XRTexture2DArray data => new VkTexture2DArray(this, data),
- L73 C44: new VkTextureRectangle :: XRTextureRectangle data => new VkTextureRectangle(this, data),
- L76 C37: new VkTexture3D :: XRTexture3D data => new VkTexture3D(this, data),
- L79 C39: new VkTextureCube :: XRTextureCube data => new VkTextureCube(this, data),
- L80 C44: new VkTextureCubeArray :: XRTextureCubeArray data => new VkTextureCubeArray(this, data),
- L83 C41: new VkTextureBuffer :: XRTextureBuffer data => new VkTextureBuffer(this, data),
- L86 C39: new VkRenderQuery :: XRRenderQuery data => new VkRenderQuery(this, data),
- L87 C45: new VkTransformFeedback :: XRTransformFeedback data => new VkTransformFeedback(this, data),
- L89 C28: new InvalidOperationException :: _ => throw new InvalidOperationException($"Render object type {renderObject.GetType()} is not supported.")
- L157 C23: new InvalidOperationException :: throw new InvalidOperationException(
- L353 C23: new Exception :: throw new Exception($"Failed to acquire swap chain image ({result}).");
- L368 C69: new() :: TimelineSemaphoreSubmitInfo acquireBridgeTimelineInfo = new()
- L377 C46: new() :: SubmitInfo acquireBridgeSubmit = new()
- L396 C23: new Exception :: throw new Exception($"Failed to bridge swapchain acquire semaphore to timeline ({bridgeResult}).");
- L445 C62: new() :: TimelineSemaphoreSubmitInfo timelineSubmitInfo = new()
- L454 C37: new() :: SubmitInfo submitInfo = new()
- L485 C23: new Exception :: throw new Exception($"Failed to submit draw command buffer ({submitResult}).");
- L508 C42: new() :: PresentInfoKHR presentInfo = new()
- L546 C23: new Exception :: throw new Exception("Failed to present swap chain image.");


## XRENGINE/Rendering/API/Rendering/Vulkan/Drawing.IndirectDraw.cs
- L165 C28: new IndirectDrawOp :: EnqueueFrameOp(new IndirectDrawOp(
- L208 C28: new IndirectDrawOp :: EnqueueFrameOp(new IndirectDrawOp(


## XRENGINE/Rendering/API/Rendering/Vulkan/Drawing.Readback.cs
- L18 C57: new() :: private readonly object _pendingReadbacksLock = new();
- L163 C40: new() :: BufferImageCopy copy = new()
- L168 C40: new ImageSubresourceLayers :: ImageSubresource = new ImageSubresourceLayers
- L175 C35: new Offset3D :: ImageOffset = new Offset3D { X = x, Y = y, Z = 0 },
- L176 C35: new Extent3D :: ImageExtent = new Extent3D { Width = (uint)w, Height = (uint)h, Depth = 1 }
- L260 C56: new() :: ImageMemoryBarrier toTransferBarrier = new()
- L268 C40: new ImageSubresourceRange :: SubresourceRange = new ImageSubresourceRange
- L286 C40: new() :: BufferImageCopy copy = new()
- L291 C40: new ImageSubresourceLayers :: ImageSubresource = new ImageSubresourceLayers
- L298 C35: new Offset3D :: ImageOffset = new Offset3D { X = x, Y = y, Z = 0 },
- L299 C35: new Extent3D :: ImageExtent = new Extent3D { Width = 1, Height = 1, Depth = 1 }
- L400 C54: new() :: CommandBufferAllocateInfo allocateInfo = new()
- L416 C41: new() :: FenceCreateInfo fenceInfo = new()
- L431 C48: new() :: CommandBufferBeginInfo beginInfo = new()
- L440 C52: new() :: ImageMemoryBarrier toTransferBarrier = new()
- L448 C36: new ImageSubresourceRange :: SubresourceRange = new ImageSubresourceRange
- L466 C36: new() :: BufferImageCopy copy = new()
- L471 C36: new ImageSubresourceLayers :: ImageSubresource = new ImageSubresourceLayers
- L478 C31: new Offset3D :: ImageOffset = new Offset3D { X = x, Y = y, Z = 0 },
- L479 C31: new Extent3D :: ImageExtent = new Extent3D { Width = 1, Height = 1, Depth = 1 }
- L508 C37: new() :: SubmitInfo submitInfo = new()
- L648 C40: new() :: BufferImageCopy copy = new()
- L653 C40: new ImageSubresourceLayers :: ImageSubresource = new ImageSubresourceLayers
- L660 C35: new Offset3D :: ImageOffset = new Offset3D { X = x, Y = y, Z = 0 },
- L661 C35: new Extent3D :: ImageExtent = new Extent3D { Width = 1, Height = 1, Depth = 1 }
- L700 C35: new ColorF4 :: colorCallback?.Invoke(new ColorF4(r, g, b, a));
- L726 C43: new MagickImage :: var magickImage = new MagickImage(rgbaPixels, new MagickReadSettings
- L726 C71: new MagickReadSettings :: var magickImage = new MagickImage(rgbaPixels, new MagickReadSettings
- L778 C40: new() :: BufferImageCopy copy = new()
- L783 C40: new ImageSubresourceLayers :: ImageSubresource = new ImageSubresourceLayers
- L790 C35: new Offset3D :: ImageOffset = new Offset3D { X = x, Y = y, Z = 0 },
- L791 C35: new Extent3D :: ImageExtent = new Extent3D { Width = (uint)w, Height = (uint)h, Depth = 1 }
- L821 C33: new byte :: byte[] pixels = new byte[(int)bufferSize];
- L828 C35: new MagickImage :: var magickImage = new MagickImage(pixels, new MagickReadSettings
- L828 C59: new MagickReadSettings :: var magickImage = new MagickImage(pixels, new MagickReadSettings
- L886 C40: new() :: BufferImageCopy copy = new()
- L891 C40: new ImageSubresourceLayers :: ImageSubresource = new ImageSubresourceLayers
- L898 C35: new Offset3D :: ImageOffset = new Offset3D { X = 0, Y = 0, Z = 0 },
- L899 C35: new Extent3D :: ImageExtent = new Extent3D { Width = 1, Height = 1, Depth = 1 }
- L935 C30: new Vector3 :: accum += new Vector3(sample.X, sample.Y, sample.Z);
- L978 C40: new() :: BufferImageCopy copy = new()
- L983 C40: new ImageSubresourceLayers :: ImageSubresource = new ImageSubresourceLayers
- L990 C35: new Offset3D :: ImageOffset = new Offset3D { X = 0, Y = 0, Z = 0 },
- L991 C35: new Extent3D :: ImageExtent = new Extent3D { Width = 1, Height = 1, Depth = 1 }
- L1132 C20: new Vector4 :: rgba = new Vector4(rgbaFloats[0], rgbaFloats[1], rgbaFloats[2], rgbaFloats[3]);


## XRENGINE/Rendering/API/Rendering/Vulkan/Drawing.RenderState.cs
- L230 C16: new() :: => new()


## XRENGINE/Rendering/API/Rendering/Vulkan/Drawing.ResourceRetirement.cs
- L16 C14: new() :: [new(), new()]; // length == MAX_FRAMES_IN_FLIGHT
- L16 C21: new() :: [new(), new()]; // length == MAX_FRAMES_IN_FLIGHT
- L23 C14: new() :: [new(), new()]; // length == MAX_FRAMES_IN_FLIGHT
- L23 C21: new() :: [new(), new()]; // length == MAX_FRAMES_IN_FLIGHT
- L26 C14: new() :: [new(), new()]; // length == MAX_FRAMES_IN_FLIGHT
- L26 C21: new() :: [new(), new()]; // length == MAX_FRAMES_IN_FLIGHT
- L28 C56: new() :: private readonly object _retiredResourceLock = new();
- L38 C14: new() :: [new(), new()]; // length == MAX_FRAMES_IN_FLIGHT
- L38 C21: new() :: [new(), new()]; // length == MAX_FRAMES_IN_FLIGHT
- L41 C14: new() :: [new(), new()]; // length == MAX_FRAMES_IN_FLIGHT
- L41 C21: new() :: [new(), new()]; // length == MAX_FRAMES_IN_FLIGHT
- L148 C36: new HashSet :: var destroyedBuffers = new HashSet<ulong>();
- L149 C33: new HashSet :: var freedMemories = new HashSet<ulong>();
- L181 C14: new() :: [new(), new()]; // length == MAX_FRAMES_IN_FLIGHT
- L181 C21: new() :: [new(), new()]; // length == MAX_FRAMES_IN_FLIGHT


## XRENGINE/Rendering/API/Rendering/Vulkan/Extensions.cs
- L36 C85: new() :: private readonly Dictionary<ulong, uint> _renderPassColorAttachmentCounts = new();


## XRENGINE/Rendering/API/Rendering/Vulkan/FrameBufferRenderPasses.cs
- L9 C87: new() :: private readonly Dictionary<RenderPassKey, RenderPass> _frameBufferRenderPasses = new();
- L26 C48: new AttachmentDescription :: AttachmentDescription[] descriptions = new AttachmentDescription[signature.Length];
- L39 C15: new AttachmentReference :: ? new AttachmentReference[colorCount]
- L66 C42: new() :: SubpassDescription subpass = new()
- L74 C47: new() :: RenderPassCreateInfo createInfo = new()
- L84 C23: new Exception :: throw new Exception("Failed to create framebuffer render pass.");
- L124 C29: new() :: HashCode hash = new();
- L172 C16: new() :: => new()
- L190 C20: new AttachmentReference :: return new AttachmentReference
- L214 C29: new() :: HashCode hash = new();


## XRENGINE/Rendering/API/Rendering/Vulkan/Init.cs
- L20 C23: new Exception :: throw new Exception("Windowing platform doesn't support Vulkan.");
- L138 C45: new() :: AllocationCallbacks callbacks = new()
- L140 C33: new PfnAllocationFunction :: PfnAllocation = new PfnAllocationFunction(Allocated),
- L141 C35: new PfnReallocationFunction :: PfnReallocation = new PfnReallocationFunction(Reallocated),
- L142 C27: new PfnFreeFunction :: PfnFree = new PfnFreeFunction(Freed),
- L143 C41: new PfnInternalAllocationNotification :: PfnInternalAllocation = new PfnInternalAllocationNotification(InternalAllocated),
- L144 C35: new PfnInternalFreeNotification :: PfnInternalFree = new PfnInternalFreeNotification(InternalFreed)
- L147 C23: new Exception :: throw new Exception("Failed to allocate memory.");
- L228 C28: new ComputeDispatchOp :: EnqueueFrameOp(new ComputeDispatchOp(
- L280 C47: new Extent2D :: _state.SetCurrentTargetExtent(new Extent2D(Math.Max(_boundDrawFrameBuffer.Width, 1u), Math.Max(_boundDrawFrameBuffer.Height, 1u)));
- L306 C19: new Rect2D :: : new Rect2D(new Offset2D(0, 0), _state.GetCurrentTargetExtent());
- L306 C30: new Offset2D :: : new Rect2D(new Offset2D(0, 0), _state.GetCurrentTargetExtent());
- L308 C28: new ClearOp :: EnqueueFrameOp(new ClearOp(
- L322 C19: new NotImplementedException :: throw new NotImplementedException();


## XRENGINE/Rendering/API/Rendering/Vulkan/MemoryCopyIndirect.cs
- L15 C40: new() :: BufferDeviceAddressInfo info = new()
- L100 C47: new() :: CopyMemoryIndirectCommandNV command = new()
- L140 C54: new() :: CopyMemoryToImageIndirectCommandNV command = new()


## XRENGINE/Rendering/API/Rendering/Vulkan/MemoryDecompression.cs
- L35 C43: new() :: BufferDeviceAddressInfo srcInfo = new()
- L42 C43: new() :: BufferDeviceAddressInfo dstInfo = new()
- L54 C43: new() :: DecompressMemoryRegionNV region = new()
- L72 C34: new ReadOnlySpan :: => TryDecompressMemoryNv(new ReadOnlySpan<DecompressMemoryRegionNV>(in region));


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/CommandBuffers.cs
- L18 C60: new() :: private readonly object _oneTimeCommandPoolsLock = new();
- L19 C87: new() :: private readonly Dictionary<nint, OneTimeCommandOwner> _oneTimeCommandPools = new();
- L20 C54: new() :: private readonly object _oneTimeSubmitLock = new();
- L22 C57: new() :: private readonly object _commandBindStateLock = new();
- L23 C89: new() :: private readonly Dictionary<ulong, CommandBufferBindState> _commandBindStates = new();
- L161 C29: new() :: HashCode hash = new();
- L213 C29: new() :: HashCode hash = new();
- L345 C63: new DeferredSecondaryCommandBuffer :: _deferredSecondaryCommandBuffers[imageIndex]!.Add(new DeferredSecondaryCommandBuffer(pool, commandBuffer));
- L402 C94: new ComputeTransientResources :: ComputeTransientResources resources = _computeTransientResources[imageIndex] ??= new ComputeTransientResources();
- L406 C24: new DescriptorSet :: sets = new DescriptorSet[setLayouts.Length];
- L410 C59: new() :: DescriptorSetAllocateInfo allocInfo = new()
- L431 C52: new DescriptorPoolSize :: DescriptorPoolSize[] scaledPoolSizes = new DescriptorPoolSize[poolSizes.Length];
- L436 C38: new DescriptorPoolSize :: scaledPoolSizes[i] = new DescriptorPoolSize
- L449 C53: new() :: DescriptorPoolCreateInfo poolInfo = new()
- L489 C94: new ComputeTransientResources :: ComputeTransientResources resources = _computeTransientResources[imageIndex] ??= new ComputeTransientResources();
- L496 C23: new InvalidOperationException :: throw new InvalidOperationException("Framebuffers must be created before allocating command buffers.");
- L498 C31: new CommandBuffer :: _commandBuffers = new CommandBuffer[swapChainFramebuffers.Length];
- L500 C51: new() :: CommandBufferAllocateInfo allocInfo = new()
- L511 C27: new Exception :: throw new Exception("Failed to allocate command buffers.");
- L515 C42: new ComputeTransientResources :: _computeTransientResources = new ComputeTransientResources[_commandBuffers.Length];
- L516 C48: new List :: _deferredSecondaryCommandBuffers = new List<DeferredSecondaryCommandBuffer>[_commandBuffers.Length];
- L548 C23: new InvalidOperationException :: throw new InvalidOperationException("Command buffers are unavailable because swapchain framebuffers are not initialised.");
- L551 C23: new InvalidOperationException :: throw new InvalidOperationException("Command buffers have not been allocated yet.");
- L554 C23: new InvalidOperationException :: throw new InvalidOperationException($"Command buffer index {imageIndex} is out of range for {_commandBuffers.Length} allocated command buffers.");
- L557 C23: new InvalidOperationException :: throw new InvalidOperationException("Command buffer dirty flags are not initialised correctly.");
- L560 C23: new InvalidOperationException :: throw new InvalidOperationException("Command buffer frame-op signatures are not initialised correctly.");
- L563 C23: new InvalidOperationException :: throw new InvalidOperationException("Command buffer planner revisions are not initialised correctly.");
- L601 C48: new() :: CommandBufferBeginInfo beginInfo = new()
- L607 C23: new Exception :: throw new Exception("Failed to begin recording command buffer.");
- L645 C42: new Dictionary :: secondaryBucketByStart = new Dictionary<int, VulkanRenderGraphCompiler.SecondaryRecordingBucket>(secondaryBuckets.Count);
- L842 C61: new() :: ImageMemoryBarrier presentBarrier = new()
- L852 C48: new ImageSubresourceRange :: SubresourceRange = new ImageSubresourceRange
- L951 C59: new() :: ImageMemoryBarrier colorBarrier = new()
- L961 C48: new ImageSubresourceRange :: SubresourceRange = new ImageSubresourceRange
- L971 C59: new() :: ImageMemoryBarrier depthBarrier = new()
- L981 C48: new ImageSubresourceRange :: SubresourceRange = new ImageSubresourceRange
- L1010 C67: new() :: RenderingAttachmentInfo colorAttachment = new()
- L1020 C67: new() :: RenderingAttachmentInfo depthAttachment = new()
- L1030 C55: new() :: RenderingInfo renderingInfo = new()
- L1033 C42: new Rect2D :: RenderArea = new Rect2D
- L1035 C42: new Offset2D :: Offset = new Offset2D(0, 0),
- L1062 C58: new() :: RenderPassBeginInfo renderPassInfo = new()
- L1067 C38: new Rect2D :: RenderArea = new Rect2D
- L1069 C38: new Offset2D :: Offset = new Offset2D(0, 0),
- L1092 C82: new InvalidOperationException :: var vkFrameBuffer = GenericToAPI<VkFrameBuffer>(target) ?? throw new InvalidOperationException("Failed to resolve Vulkan framebuffer for target.");
- L1107 C51: new() :: RenderPassBeginInfo fboPassInfo = new()
- L1112 C34: new Rect2D :: RenderArea = new Rect2D
- L1114 C34: new Offset2D :: Offset = new Offset2D(0, 0),
- L1117 C34: new Extent2D :: Extent = new Extent2D(
- L1179 C51: new() :: MemoryBarrier safetyBarrier = new()
- L1509 C31: new InvalidOperationException :: throw new InvalidOperationException(
- L1533 C41: new() :: Viewport swapViewport = new()
- L1543 C38: new() :: Rect2D swapScissor = new()
- L1545 C30: new Offset2D :: Offset = new Offset2D(0, 0),
- L1570 C57: new() :: ClearAttachment magentaAttachment = new()
- L1574 C38: new ClearValue :: ClearValue = new ClearValue
- L1576 C37: new ClearColorValue :: Color = new ClearColorValue(1f, 0f, 1f, 1f)
- L1580 C43: new() :: ClearRect clearRect = new()
- L1582 C32: new Rect2D :: Rect = new Rect2D
- L1584 C38: new Offset2D :: Offset = new Offset2D(0, 0),
- L1640 C27: new Exception :: throw new Exception("Failed to record command buffer.");
- L1717 C23: new Extent2D :: : new Extent2D(Math.Max(op.Target.Width, 1u), Math.Max(op.Target.Height, 1u)));
- L1723 C35: new() :: ClearRect clearRect = new()
- L1741 C44: new ClearAttachment :: attachments[count++] = new ClearAttachment
- L1745 C38: new ClearValue :: ClearValue = new ClearValue
- L1747 C37: new ClearColorValue :: Color = new ClearColorValue
- L1773 C44: new ClearAttachment :: attachments[count++] = new ClearAttachment
- L1776 C38: new ClearValue :: ClearValue = new ClearValue
- L1778 C44: new ClearDepthStencilValue :: DepthStencil = new ClearDepthStencilValue
- L1820 C20: new Rect2D :: return new Rect2D
- L1822 C26: new Offset2D :: Offset = new Offset2D(x, y),
- L1823 C26: new Extent2D :: Extent = new Extent2D((uint)width, (uint)height)
- L2021 C47: new() :: MemoryBarrier memoryBarrier = new()
- L2184 C43: new() :: MemoryBarrier memoryBarrier = new()
- L2383 C46: new() :: ImageMemoryBarrier barrier = new()
- L2391 C40: new ImageSubresourceRange :: SubresourceRange = new ImageSubresourceRange
- L2433 C47: new() :: ImageSubresourceRange range = new()
- L2442 C46: new() :: ImageMemoryBarrier barrier = new()
- L2486 C47: new() :: BufferMemoryBarrier barrier = new()
- L2576 C55: new() :: CommandBufferAllocateInfo allocInfo = new()
- L2587 C52: new() :: CommandBufferBeginInfo beginInfo = new()
- L2593 C64: new() :: CommandBufferInheritanceInfo inheritanceInfo = new()
- L2607 C27: new Exception :: throw new Exception("Failed to begin Vulkan secondary command buffer.");
- L2614 C27: new Exception :: throw new Exception("Failed to end Vulkan secondary command buffer.");
- L2653 C48: new CommandBuffer :: CommandBuffer[] secondaryBuffers = new CommandBuffer[count];
- L2654 C40: new CommandPool :: CommandPool[] ownerPools = new CommandPool[count];
- L2655 C32: new bool :: bool[] allocated = new bool[count];
- L2657 C32: new() :: object errorLock = new();
- L2662 C32: new Task :: Task[] tasks = new Task[count];
- L2678 C67: new() :: CommandBufferAllocateInfo allocInfo = new()
- L2689 C64: new() :: CommandBufferBeginInfo beginInfo = new()
- L2695 C76: new() :: CommandBufferInheritanceInfo inheritanceInfo = new()
- L2709 C39: new Exception :: throw new Exception("Failed to begin Vulkan secondary command buffer.");
- L2716 C39: new Exception :: throw new Exception("Failed to end Vulkan secondary command buffer.");
- L2807 C54: new() :: CommandBufferAllocateInfo allocateInfo = new()
- L2817 C48: new() :: CommandBufferBeginInfo beginInfo = new()
- L2827 C62: new OneTimeCommandOwner :: _oneTimeCommandPools[commandBuffer.Handle] = new OneTimeCommandOwner(pool, useTransferQueue);
- L2840 C47: new() :: FenceCreateInfo fenceCreateInfo = new()
- L2853 C37: new() :: SubmitInfo submitInfo = new()
- L2940 C40: new bool :: _commandBufferDirtyFlags = new bool[_commandBuffers.Length];
- L2941 C47: new ulong :: _commandBufferFrameOpSignatures = new ulong[_commandBuffers.Length];
- L2942 C46: new ulong :: _commandBufferPlannerRevisions = new ulong[_commandBuffers.Length];


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/CommandPool.cs
- L11 C53: new() :: private readonly object _commandPoolsLock = new();
- L12 C77: new() :: private readonly Dictionary<int, CommandPool> _threadCommandPools = new();
- L13 C85: new() :: private readonly Dictionary<int, CommandPool> _threadTransferCommandPools = new();
- L47 C26: new InvalidOperationException :: ?? throw new InvalidOperationException("Graphics queue family is not available.");
- L75 C26: new InvalidOperationException :: ?? throw new InvalidOperationException("Graphics queue family is not available.");
- L104 C26: new InvalidOperationException :: ?? throw new InvalidOperationException("Graphics queue family is not available.");
- L127 C46: new() :: CommandPoolCreateInfo poolInfo = new()
- L135 C23: new Exception :: throw new Exception("Failed to create Vulkan command pool.");


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/DescriptorPool.cs
- L14 C29: new DescriptorPoolSize :: var poolSizes = new DescriptorPoolSize[]
- L16 C13: new() :: new()
- L21 C13: new() :: new()
- L32 C53: new() :: DescriptorPoolCreateInfo poolInfo = new()
- L41 C27: new Exception :: throw new Exception("Failed to create descriptor pool.");


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/DescriptorSetLayout.cs
- L14 C59: new() :: DescriptorSetLayoutBinding uboLayoutBinding = new()
- L23 C56: new() :: DescriptorSetLayoutCreateInfo layoutInfo = new()
- L33 C27: new Exception :: throw new Exception("failed to create descriptor set layout!");


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/DescriptorSets.cs
- L11 C23: new DescriptorSetLayout :: var layouts = new DescriptorSetLayout[swapChainImages!.Length];
- L16 C54: new() :: DescriptorSetAllocateInfo allocateInfo = new()
- L24 C30: new DescriptorSet :: descriptorSets = new DescriptorSet[swapChainImages.Length];
- L28 C27: new Exception :: throw new Exception("Failed to allocate descriptor sets.");


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/FrameBuffers.cs
- L26 C19: new InvalidOperationException :: throw new InvalidOperationException("Swapchain image views must be created before framebuffers.");
- L28 C33: new Framebuffer :: swapChainFramebuffers = new Framebuffer[swapChainImageViews.Length];
- L29 C35: new ImageView :: ImageView[] attachments = new ImageView[2];
- L38 C57: new() :: FramebufferCreateInfo framebufferInfo = new()
- L50 C27: new Exception :: throw new Exception("Failed to create framebuffer.");


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/ImageViews.cs
- L17 C31: new ImageView :: swapChainImageViews = new ImageView[swapChainImages!.Length];
- L21 C46: new() :: ImageViewCreateInfo createInfo = new()
- L46 C23: new Exception :: throw new Exception("Failed to create image views.");


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/Instance.cs
- L23 C35: new() :: ApplicationInfo appInfo = new()
- L27 C34: new Version32 :: ApplicationVersion = new Version32(1, 0, 0),
- L29 C29: new Version32 :: EngineVersion = new Version32(1, 0, 0),
- L33 C41: new() :: InstanceCreateInfo createInfo = new()
- L48 C64: new() :: DebugUtilsMessengerCreateInfoEXT debugCreateInfo = new();
- L59 C19: new Exception :: throw new Exception("failed to create instance!");


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/LogicalDevice.cs
- L58 C35: new ExtensionProperties :: var availableExtensions = new ExtensionProperties[extensionCount];
- L78 C79: new() :: PhysicalDeviceDescriptorIndexingFeatures descriptorIndexingFeatures = new()
- L84 C45: new() :: PhysicalDeviceFeatures2 features2 = new()
- L114 C83: new() :: PhysicalDeviceMemoryDecompressionFeaturesNV memoryDecompressionFeatures = new()
- L120 C45: new() :: PhysicalDeviceFeatures2 features2 = new()
- L129 C87: new() :: PhysicalDeviceMemoryDecompressionPropertiesNV memoryDecompressionProperties = new()
- L135 C49: new() :: PhysicalDeviceProperties2 properties2 = new()
- L157 C81: new() :: PhysicalDeviceCopyMemoryIndirectFeaturesNV copyMemoryIndirectFeatures = new()
- L163 C45: new() :: PhysicalDeviceFeatures2 features2 = new()
- L172 C85: new() :: PhysicalDeviceCopyMemoryIndirectPropertiesNV copyMemoryIndirectProperties = new()
- L178 C49: new() :: PhysicalDeviceProperties2 properties2 = new()
- L192 C81: new() :: PhysicalDeviceBufferDeviceAddressFeatures bufferDeviceAddressFeatures = new()
- L198 C45: new() :: PhysicalDeviceFeatures2 features2 = new()
- L217 C67: new() :: PhysicalDeviceMaintenance4Features maintenance4Features = new()
- L223 C45: new() :: PhysicalDeviceFeatures2 features2 = new()
- L245 C75: new() :: PhysicalDeviceDynamicRenderingFeatures dynamicRenderingFeatures = new()
- L251 C45: new() :: PhysicalDeviceFeatures2 features2 = new()
- L266 C59: new() :: PhysicalDeviceVulkan11Features vulkan11Features = new()
- L272 C45: new() :: PhysicalDeviceFeatures2 features2 = new()
- L293 C59: new() :: PhysicalDeviceVulkan11Features vulkan11Features = new()
- L299 C45: new() :: PhysicalDeviceFeatures2 features2 = new()
- L313 C74: new() :: PhysicalDeviceIndexTypeUint8FeaturesEXT indexTypeUint8Features = new()
- L319 C45: new() :: PhysicalDeviceFeatures2 features2 = new()
- L333 C68: new() :: PhysicalDeviceTimelineSemaphoreFeatures timelineFeatures = new()
- L339 C45: new() :: PhysicalDeviceFeatures2 features2 = new()
- L371 C29: new QueueFamilyProperties :: var queueFamilies = new QueueFamilyProperties[queueFamilyCount];
- L380 C35: new[] :: var uniqueQueueFamilies = new[]
- L404 C35: new() :: queueCreateInfos[i] = new()
- L414 C52: new() :: PhysicalDeviceFeatures supportedFeatures = new();
- L417 C49: new() :: PhysicalDeviceFeatures deviceFeatures = new();
- L443 C37: new HashSet :: var availableExtensionSet = new HashSet<string>(_availableDeviceExtensions, StringComparer.Ordinal);
- L446 C34: new List :: var extensionsToEnable = new List<string>(deviceExtensions);
- L546 C84: new() :: PhysicalDeviceDescriptorIndexingFeatures descriptorIndexingFeatureEnable = new()
- L558 C88: new() :: PhysicalDeviceMemoryDecompressionFeaturesNV memoryDecompressionFeatureEnable = new()
- L565 C86: new() :: PhysicalDeviceCopyMemoryIndirectFeaturesNV copyMemoryIndirectFeatureEnable = new()
- L572 C86: new() :: PhysicalDeviceBufferDeviceAddressFeatures bufferDeviceAddressFeatureEnable = new()
- L579 C80: new() :: PhysicalDeviceDynamicRenderingFeatures dynamicRenderingFeatureEnable = new()
- L586 C64: new() :: PhysicalDeviceVulkan11Features vulkan11FeatureEnable = new()
- L594 C79: new() :: PhysicalDeviceIndexTypeUint8FeaturesEXT indexTypeUint8FeatureEnable = new()
- L601 C72: new() :: PhysicalDeviceMaintenance4Features maintenance4FeatureEnable = new()
- L608 C82: new() :: PhysicalDeviceTimelineSemaphoreFeatures timelineSemaphoreFeatureEnable = new()
- L670 C48: new() :: PhysicalDeviceFeatures2 featureChain = new()
- L678 C39: new() :: DeviceCreateInfo createInfo = new()
- L703 C19: new Exception :: throw new Exception("Failed to create logical device.");


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/RenderPasses.cs
- L44 C49: new() :: AttachmentDescription colorAttachment = new()
- L57 C49: new() :: AttachmentDescription depthAttachment = new()
- L69 C50: new() :: AttachmentReference colorAttachmentRef = new()
- L75 C50: new() :: AttachmentReference depthAttachmentRef = new()
- L81 C38: new() :: SubpassDescription subpass = new()
- L93 C47: new() :: RenderPassCreateInfo renderPassInfo = new()
- L103 C19: new Exception :: throw new Exception("Failed to create render pass.");


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/Surface.cs
- L16 C19: new NotSupportedException :: throw new NotSupportedException("KHR_surface extension not found.");


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/SyncObjects.cs
- L41 C45: new ulong :: _swapchainImageTimelineValues = new ulong[swapChainImages.Length];
- L51 C38: new() :: SemaphoreWaitInfo waitInfo = new()
- L80 C19: new InvalidOperationException :: throw new InvalidOperationException(
- L85 C19: new InvalidOperationException :: throw new InvalidOperationException($"Failed to wait for timeline semaphore value {value}. Result={waitResult}.");
- L125 C19: new InvalidOperationException :: throw new InvalidOperationException("Vulkan timeline semaphores are required but were not enabled on the logical device.");
- L127 C35: new Semaphore :: acquireBridgeSemaphores = new Semaphore[MAX_FRAMES_IN_FLIGHT];
- L129 C35: new Semaphore :: presentBridgeSemaphores = new Semaphore[presentSemaphoreCount];
- L130 C36: new ulong :: _frameSlotTimelineValues = new ulong[MAX_FRAMES_IN_FLIGHT];
- L133 C45: new() :: SemaphoreCreateInfo semaphoreInfo = new()
- L138 C52: new() :: SemaphoreTypeCreateInfo timelineTypeInfo = new()
- L145 C53: new() :: SemaphoreCreateInfo timelineSemaphoreInfo = new()
- L155 C19: new Exception :: throw new Exception("failed to create timeline synchronization semaphores.");
- L162 C23: new Exception :: throw new Exception("failed to create acquire bridge synchronization semaphores.");
- L170 C23: new Exception :: throw new Exception("failed to create frame bridge synchronization semaphores.");


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/Types/VkDataBuffer.cs
- L13 C65: new() :: private readonly VulkanStagingManager _stagingManager = new();
- L407 C33: new DataSource :: GPUSideSource = new DataSource(_persistentMappedPtr, (uint)_bufferSize);
- L419 C33: new DataSource :: GPUSideSource = new DataSource(_persistentMappedPtr, length);
- L598 C23: new ArgumentNullException :: throw new ArgumentNullException(nameof(vkMemory), "Cannot map null Vulkan memory.");
- L602 C23: new Exception :: throw new Exception("Failed to map Vulkan buffer memory.");
- L610 C23: new ArgumentNullException :: throw new ArgumentNullException("Buffers cannot be null for copy operation.");
- L621 C23: new ArgumentNullException :: throw new ArgumentNullException("Buffer, memory, or address cannot be null for update operation.");
- L625 C23: new Exception :: throw new Exception("Failed to map Vulkan buffer memory.");
- L634 C23: new ArgumentNullException :: throw new ArgumentNullException(nameof(vkMemory), "Cannot unmap null Vulkan memory.");
- L645 C23: new ArgumentNullException :: throw new ArgumentNullException("Buffers cannot be null for copy operation.");
- L672 C58: new() :: BufferMemoryBarrier acquireBarrier = new()
- L697 C41: new() :: BufferCopy copyRegion = new()
- L708 C58: new() :: BufferMemoryBarrier releaseBarrier = new()
- L737 C57: new() :: BufferMemoryBarrier acquireOnGraphics = new()
- L791 C27: new Exception :: throw new Exception("Failed to map Vulkan memory.");
- L810 C43: new() :: BufferCreateInfo bufferInfo = new()
- L819 C23: new Exception :: throw new Exception("Failed to create Vulkan buffer.");
- L822 C45: new() :: MemoryAllocateInfo memoryInfo = new()
- L829 C63: new() :: MemoryAllocateFlagsInfo memoryAllocateFlagsInfo = new()
- L843 C23: new Exception :: throw new Exception("Failed to allocate Vulkan buffer memory.");
- L851 C23: new Exception :: throw new Exception($"Failed to bind Vulkan buffer memory ({bindResult}).");
- L864 C23: new Exception :: throw new Exception("Failed to map Vulkan memory for staging upload.");
- L949 C23: new ArgumentNullException :: throw new ArgumentNullException(nameof(vkMemory), "Cannot flush null Vulkan memory.");
- L951 C21: new MappedMemoryRange :: var v = new MappedMemoryRange
- L960 C23: new Exception :: throw new Exception("Failed to flush Vulkan buffer memory.");


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/Types/VkFrameBuffer.cs
- L134 C37: new ImageLayout :: ImageLayout[] layouts = new ImageLayout[_attachmentSignature.Length];
- L153 C29: new FrameBufferAttachmentSignature :: result[i] = new FrameBufferAttachmentSignature(
- L184 C38: new ClearValue :: destination[i] = new ClearValue
- L186 C33: new ClearColorValue :: Color = new ClearColorValue
- L197 C38: new ClearValue :: destination[i] = new ClearValue
- L199 C40: new ClearDepthStencilValue :: DepthStencil = new ClearDepthStencilValue
- L226 C44: new ClearAttachment :: destination[count++] = new ClearAttachment
- L230 C38: new ClearValue :: ClearValue = new ClearValue
- L232 C37: new ClearColorValue :: Color = new ClearColorValue
- L269 C40: new ClearAttachment :: destination[count++] = new ClearAttachment
- L272 C34: new ClearValue :: ClearValue = new ClearValue
- L274 C40: new ClearDepthStencilValue :: DepthStencil = new ClearDepthStencilValue
- L307 C33: new ImageView :: ImageView[] views = new ImageView[attachments.Length];
- L308 C59: new FrameBufferAttachmentSignature :: FrameBufferAttachmentSignature[] signatures = new FrameBufferAttachmentSignature[attachments.Length];
- L340 C57: new() :: FramebufferCreateInfo framebufferInfo = new()
- L357 C31: new Exception :: throw new Exception("Failed to create framebuffer.");
- L437 C27: new InvalidOperationException :: throw new InvalidOperationException(
- L447 C31: new InvalidOperationException :: throw new InvalidOperationException(
- L469 C27: new InvalidOperationException :: throw new InvalidOperationException(
- L480 C27: new InvalidOperationException :: throw new InvalidOperationException(
- L493 C31: new InvalidOperationException :: throw new InvalidOperationException(
- L500 C23: new InvalidOperationException :: throw new InvalidOperationException(
- L508 C27: new InvalidOperationException :: throw new InvalidOperationException(
- L520 C31: new InvalidOperationException :: throw new InvalidOperationException(
- L527 C23: new InvalidOperationException :: throw new InvalidOperationException(
- L531 C19: new InvalidOperationException :: throw new InvalidOperationException(
- L559 C27: new InvalidOperationException :: throw new InvalidOperationException(
- L615 C23: new InvalidOperationException :: throw new InvalidOperationException("Framebuffer must have at least one attachment.");
- L625 C27: new InvalidOperationException :: throw new InvalidOperationException("Framebuffer attachment target cannot be null.");
- L636 C42: new AttachmentBuildInfo :: colorAttachments.Add(new AttachmentBuildInfo(source.View, signature, slot));
- L641 C27: new InvalidOperationException :: throw new InvalidOperationException($"Framebuffer '{Data.Name ?? "<unnamed>"}' defines multiple depth/stencil attachments which is not supported in Vulkan subpasses.");
- L644 C35: new AttachmentBuildInfo :: depthAttachment = new AttachmentBuildInfo(source.View, depthSignature, 0);
- L655 C23: new InvalidOperationException :: throw new InvalidOperationException($"Framebuffer '{Data.Name ?? "<unnamed>"}' does not define any attachments.");
- L667 C19: new InvalidOperationException :: throw new InvalidOperationException(
- L684 C28: new NotSupportedException :: _ => throw new NotSupportedException($"Framebuffer attachment type '{target.GetType().Name}' is not supported yet.")
- L690 C23: new InvalidOperationException :: throw new InvalidOperationException("Render buffer is not backed by a Vulkan object.");
- L693 C20: new AttachmentSource :: return new AttachmentSource(vkRenderBuffer.View, vkRenderBuffer.Format, vkRenderBuffer.Samples, vkRenderBuffer.Aspect);
- L699 C23: new InvalidOperationException :: throw new InvalidOperationException($"Texture '{texture.Name ?? texture.GetDescribingName()}' is not backed by a Vulkan texture.");
- L707 C20: new AttachmentSource :: return new AttachmentSource(view, source.DescriptorFormat, source.DescriptorSamples, source.DescriptorAspect);
- L727 C27: new InvalidOperationException :: throw new InvalidOperationException($"Color attachment slot {explicitSlot} is already bound for this framebuffer.");
- L766 C20: new FrameBufferAttachmentSignature :: return new FrameBufferAttachmentSignature(


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/Types/VkImageBackedTexture.cs
- L30 C86: new() :: private readonly Dictionary<AttachmentViewKey, ImageView> _attachmentViews = new();
- L177 C23: new AttachmentViewKey :: var key = new AttachmentViewKey(0, ResolvedMipLevels, 0, ResolvedArrayLayers, DefaultViewType, ImageAspectFlags.DepthBit);
- L317 C42: new ImageView :: retiredAttachmentViews = new ImageView[_attachmentViews.Count];
- L327 C43: new RetiredImageResources :: Renderer.RetireImageResources(new RetiredImageResources(
- L386 C20: new TextureLayout :: return new TextureLayout(extent, layers, mips);
- L528 C41: new() :: ImageCreateInfo imageInfo = new()
- L553 C27: new Exception :: throw new Exception($"Failed to create Vulkan image for texture '{ResolveLogicalResourceName() ?? Data.Name ?? "<unnamed>"}'. Result={result}.");
- L559 C44: new() :: MemoryAllocateInfo allocInfo = new()
- L572 C23: new Exception :: throw new Exception("Failed to bind memory for texture image.");
- L608 C19: new AttachmentViewKey :: ? new AttachmentViewKey(0, ResolvedMipLevels, 0, ResolvedArrayLayers, DefaultViewType, normalizedAspect)
- L623 C44: new() :: ImageViewCreateInfo viewInfo = new()
- L629 C30: new ComponentMapping :: Components = new ComponentMapping(ComponentSwizzle.Identity, ComponentSwizzle.Identity, ComponentSwizzle.Identity, ComponentSwizzle.Identity),
- L630 C36: new ImageSubresourceRange :: SubresourceRange = new ImageSubresourceRange
- L641 C23: new Exception :: throw new Exception("Failed to create image view.");
- L746 C20: new AttachmentViewKey :: return new AttachmentViewKey(baseMip, 1, 0, 1, ImageViewType.Type2D, AspectFlags);
- L953 C45: new() :: SamplerCreateInfo samplerInfo = new()
- L974 C23: new Exception :: throw new Exception("Failed to create sampler.");
- L1033 C23: new ImageMemoryBarrier :: barrier = new ImageMemoryBarrier
- L1041 C36: new ImageSubresourceRange :: SubresourceRange = new ImageSubresourceRange
- L1117 C38: new() :: BufferImageCopy region = new()
- L1122 C36: new ImageSubresourceLayers :: ImageSubresource = new ImageSubresourceLayers
- L1129 C31: new Offset3D :: ImageOffset = new Offset3D(0, 0, 0),
- L1159 C57: new() :: ImageMemoryBarrier acquireBarrier = new()
- L1169 C44: new ImageSubresourceRange :: SubresourceRange = new ImageSubresourceRange
- L1196 C57: new() :: ImageMemoryBarrier releaseBarrier = new()
- L1206 C44: new ImageSubresourceRange :: SubresourceRange = new ImageSubresourceRange
- L1233 C56: new() :: ImageMemoryBarrier acquireOnGraphics = new()
- L1243 C40: new ImageSubresourceRange :: SubresourceRange = new ImageSubresourceRange
- L1278 C20: new DescriptorImageInfo :: return new DescriptorImageInfo
- L1588 C42: new() :: ImageMemoryBarrier barrier = new()
- L1594 C36: new ImageSubresourceRange :: SubresourceRange = new ImageSubresourceRange
- L1659 C30: new() :: ImageBlit blit = new()
- L1661 C34: new ImageSubresourceLayers :: SrcSubresource = new ImageSubresourceLayers
- L1668 C34: new ImageSubresourceLayers :: DstSubresource = new ImageSubresourceLayers
- L1677 C40: new Offset3D :: blit.SrcOffsets.Element0 = new Offset3D(0, 0, 0);
- L1678 C40: new Offset3D :: blit.SrcOffsets.Element1 = new Offset3D(mipWidth, mipHeight, 1);
- L1679 C40: new Offset3D :: blit.DstOffsets.Element0 = new Offset3D(0, 0, 0);
- L1680 C40: new Offset3D :: blit.DstOffsets.Element1 = new Offset3D(dstWidth, dstHeight, 1);


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/Types/VkMaterial.cs
- L105 C50: new() :: private readonly object _stateSync = new();
- L111 C88: new() :: private readonly Dictionary<uint, ProgramDescriptorState> _programStates = new();
- L410 C57: new() :: DescriptorPoolCreateInfo poolInfo = new()
- L429 C52: new DescriptorSet :: DescriptorSet[][] descriptorSets = new DescriptorSet[frameCount][];
- L432 C49: new DescriptorSet :: DescriptorSet[] frameSets = new DescriptorSet[setCount];
- L437 C63: new() :: DescriptorSetAllocateInfo allocInfo = new()
- L462 C25: new ProgramDescriptorState :: state = new ProgramDescriptorState
- L570 C59: new() :: Dictionary<DescriptorType, uint> counts = new();
- L580 C46: new DescriptorPoolSize :: DescriptorPoolSize[] sizes = new DescriptorPoolSize[counts.Count];
- L583 C34: new DescriptorPoolSize :: sizes[i++] = new DescriptorPoolSize { Type = type, DescriptorCount = count };
- L594 C33: new() :: HashCode hash = new();
- L640 C51: new() :: List<WriteDescriptorSet> writes = new();
- L641 C58: new() :: List<DescriptorBufferInfo> bufferInfos = new();
- L642 C56: new() :: List<DescriptorImageInfo> imageInfos = new();
- L643 C53: new() :: List<BufferView> texelBufferViews = new();
- L644 C69: new() :: List<(int writeIndex, int bufferIndex)> bufferMap = new();
- L645 C67: new() :: List<(int writeIndex, int imageIndex)> imageMap = new();
- L646 C67: new() :: List<(int writeIndex, int texelIndex)> texelMap = new();
- L663 C45: new DescriptorBufferInfo :: bufferInfos.Add(new DescriptorBufferInfo
- L670 C40: new WriteDescriptorSet :: writes.Add(new WriteDescriptorSet
- L695 C40: new WriteDescriptorSet :: writes.Add(new WriteDescriptorSet
- L718 C40: new WriteDescriptorSet :: writes.Add(new WriteDescriptorSet
- L777 C29: new Dictionary :: resources = new Dictionary<(uint set, uint binding), UniformBindingResource>();
- L801 C56: new Silk.NET.Vulkan.Buffer :: Silk.NET.Vulkan.Buffer[] buffers = new Silk.NET.Vulkan.Buffer[frameCount];
- L802 C47: new DeviceMemory :: DeviceMemory[] memories = new DeviceMemory[frameCount];
- L813 C65: new UniformBindingResource :: resources[(binding.Set, binding.Binding)] = new UniformBindingResource
- L988 C37: new DescriptorImageInfo :: imageInfo = new DescriptorImageInfo
- L1001 C29: new DescriptorImageInfo :: imageInfo = new DescriptorImageInfo
- L1109 C58: new Vector4 :: Unsafe.WriteUnaligned(ref start, new Vector4(v3, 0f));
- L1118 C58: new IVector4 :: Unsafe.WriteUnaligned(ref start, new IVector4(iv3.X, iv3.Y, iv3.Z, 0));
- L1127 C58: new UVector4 :: Unsafe.WriteUnaligned(ref start, new UVector4(uv3.X, uv3.Y, uv3.Z, 0));


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/Types/VkMeshRenderer.Buffers.cs
- L198 C11: new XRMaterial :: ?? new XRMaterial();


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/Types/VkMeshRenderer.cs
- L21 C43: new() :: private readonly Lock _frameOpsLock = new();
- L145 C25: new() :: HashCode hash = new();
- L302 C73: new() :: private readonly Dictionary<PipelineKey, Pipeline> _pipelines = new();
- L333 C83: new() :: private readonly Dictionary<uint, VkDataBuffer> _vertexBuffersByBinding = new();
- L539 C24: new PendingMeshDraw :: var draw = new PendingMeshDraw(
- L570 C37: new MeshDrawOp :: Renderer.EnqueueFrameOp(new MeshDrawOp(


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/Types/VkMeshRenderer.Descriptors.cs
- L84 C41: new() :: DescriptorPoolCreateInfo poolInfo = new()
- L103 C22: new DescriptorSet :: _descriptorSets = new DescriptorSet[frameCount][];
- L107 C33: new DescriptorSet :: DescriptorSet[] frameSets = new DescriptorSet[layoutArray.Length];
- L112 C44: new() :: DescriptorSetAllocateInfo allocInfo = new()
- L145 C20: new() :: HashCode hash = new();
- L221 C37: new DescriptorPoolSize :: DescriptorPoolSize[] poolSizes = new DescriptorPoolSize[counts.Count];
- L224 C22: new DescriptorPoolSize :: poolSizes[i++] = new DescriptorPoolSize { Type = pair.Key, DescriptorCount = pair.Value };
- L265 C18: new WriteDescriptorSet :: writes.Add(new WriteDescriptorSet
- L287 C18: new WriteDescriptorSet :: writes.Add(new WriteDescriptorSet
- L303 C18: new WriteDescriptorSet :: writes.Add(new WriteDescriptorSet
- L415 C17: new DescriptorBufferInfo :: bufferInfo = new DescriptorBufferInfo
- L442 C17: new DescriptorBufferInfo :: bufferInfo = new DescriptorBufferInfo
- L507 C18: new DescriptorImageInfo :: imageInfo = new DescriptorImageInfo
- L520 C16: new DescriptorImageInfo :: imageInfo = new DescriptorImageInfo
- L596 C18: new DescriptorBufferInfo :: bufferInfo = new DescriptorBufferInfo
- L631 C18: new DescriptorBufferInfo :: bufferInfo = new DescriptorBufferInfo


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/Types/VkMeshRenderer.Drawing.cs
- L284 C20: new() :: HashCode hash = new();


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/Types/VkMeshRenderer.Pipeline.cs
- L38 C18: new List :: var shaders = new List<XRShader>();
- L64 C17: new XRShader :: shaders.Add(new XRShader(EShaderType.Vertex, vsSource));
- L68 C24: new XRRenderProgram :: _generatedProgram = new XRRenderProgram(linkNow: false, separable: false, shaders);
- L123 C18: new VertexInputBindingDescription :: bindings.Add(new VertexInputBindingDescription
- L136 C22: new VertexInputAttributeDescription :: attributes.Add(new VertexInputAttributeDescription
- L148 C21: new VertexInputAttributeDescription :: attributes.Add(new VertexInputAttributeDescription
- L242 C22: new PipelineVertexInputStateCreateInfo :: var vertexInput = new PipelineVertexInputStateCreateInfo
- L257 C58: new() :: PipelineInputAssemblyStateCreateInfo inputAssembly = new()
- L264 C53: new() :: PipelineViewportStateCreateInfo viewportState = new()
- L271 C55: new() :: PipelineRasterizationStateCreateInfo rasterizer = new()
- L283 C56: new() :: PipelineMultisampleStateCreateInfo multisampling = new()
- L290 C56: new() :: PipelineDepthStencilStateCreateInfo depthStencil = new()
- L302 C62: new() :: PipelineColorBlendAttachmentState colorBlendAttachment = new()
- L319 C8: new PipelineColorBlendAttachmentState :: : new PipelineColorBlendAttachmentState[colorAttachmentCount];
- L324 C55: new() :: PipelineColorBlendStateCreateInfo colorBlending = new()
- L344 C53: new() :: PipelineDynamicStateCreateInfo dynamicState = new()
- L351 C49: new() :: GraphicsPipelineCreateInfo pipelineInfo = new()
- L372 C52: new() :: PipelineRenderingCreateInfo renderingInfo = new()


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/Types/VkMeshRenderer.Uniforms.cs
- L28 C56: new() :: private readonly object _liveMeshUniformBuffersLock = new();
- L29 C77: new() :: private readonly Dictionary<ulong, DeviceMemory> _liveMeshUniformBuffers = new();
- L72 C36: new() :: Silk.NET.Vulkan.Buffer buffer = new() { Handle = entry.Key };
- L99 C36: new EngineUniformBuffer :: EngineUniformBuffer[] buffers = new EngineUniformBuffer[frames];
- L108 C18: new EngineUniformBuffer :: buffers[i] = new EngineUniformBuffer(buffer, memory, size);
- L131 C34: new AutoUniformBuffer :: AutoUniformBuffer[] buffers = new AutoUniformBuffer[frames];
- L137 C18: new AutoUniformBuffer :: buffers[i] = new AutoUniformBuffer(buffer, memory, size);
- L154 C34: new() :: BufferCreateInfo bufferInfo = new()
- L170 C35: new() :: MemoryAllocateInfo allocInfo = new()
- L526 C14: new Vector2 :: value = new Vector2(0f, 0f);
- L901 C35: new Vector2 :: return UploadUniform(buffer, new Vector2(0f, 0f));
- L1009 C5: new Span :: new Span<byte>(mapped, (int)buffer.Size).Clear();
- L1028 C82: new Vector4 :: EShaderVarType._vec3 when value.Value is Vector3 v3 => UploadUniform(buffer, new Vector4(v3, 0f)),
- L1031 C85: new IVector4 :: EShaderVarType._ivec3 when value.Value is IVector3 iv3 => UploadUniform(buffer, new IVector4(iv3.X, iv3.Y, iv3.Z, 0)),
- L1034 C85: new UVector4 :: EShaderVarType._uvec3 when value.Value is UVector3 uv3 => UploadUniform(buffer, new UVector4(uv3.X, uv3.Y, uv3.Z, 0)),


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/Types/VkObjectBase.cs
- L65 C27: new Exception :: throw new Exception($"Failed to generate object of type {Type}.");


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/Types/VkRenderBuffer.cs
- L162 C36: new() :: ImageCreateInfo info = new()
- L166 C26: new Extent3D :: Extent = new Extent3D(Math.Max(Data.Width, 1u), Math.Max(Data.Height, 1u), 1),
- L180 C27: new Exception :: throw new Exception("Failed to create Vulkan render buffer image.");
- L185 C44: new() :: MemoryAllocateInfo allocInfo = new()
- L198 C23: new Exception :: throw new Exception("Failed to bind memory for render buffer image.");
- L224 C44: new() :: ImageViewCreateInfo viewInfo = new()
- L230 C36: new ImageSubresourceRange :: SubresourceRange = new ImageSubresourceRange
- L241 C23: new Exception :: throw new Exception("Failed to create render buffer image view.");


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/Types/VkRenderProgram.cs
- L28 C72: new() :: private readonly Dictionary<XRShader, VkShader> _shaderCache = new();
- L29 C81: new() :: private readonly Dictionary<EProgramStageMask, VkShader> _stageLookup = new();
- L32 C83: new() :: private readonly List<DescriptorBindingInfo> _programDescriptorBindings = new();
- L34 C48: new() :: private readonly object _bindingLock = new();
- L36 C72: new() :: private readonly Dictionary<uint, XRTexture> _samplersByUnit = new();
- L37 C80: new() :: private readonly Dictionary<uint, ProgramImageBinding> _imagesByUnit = new();
- L38 C77: new() :: private readonly Dictionary<uint, XRDataBuffer> _buffersByBinding = new();
- L254 C40: new ProgramUniformValue :: _uniformValues[name] = new ProgramUniformValue(type, value, isArray);
- L285 C24: new ComputeDispatchSnapshot :: return new ComputeDispatchSnapshot(
- L286 C21: new Dictionary :: new Dictionary<string, ProgramUniformValue>(_uniformValues, StringComparer.Ordinal),
- L287 C21: new Dictionary :: new Dictionary<uint, XRTexture>(_samplersByUnit),
- L288 C21: new Dictionary :: new Dictionary<uint, ProgramImageBinding>(_imagesByUnit),
- L289 C21: new Dictionary :: new Dictionary<uint, XRDataBuffer>(_buffersByBinding));
- L294 C108: new Vector4 :: private void Uniform(string name, Quaternion value) => SetUniformValue(name, EShaderVarType._vec4, new Vector4(value.X, value.Y, value.Z, value.W));
- L298 C53: new Vector4 :: Vector4[] converted = value.Select(q => new Vector4(q.X, q.Y, q.Z, q.W)).ToArray();
- L367 C39: new ProgramImageBinding :: _imagesByUnit[unit] = new ProgramImageBinding(texture, level, layered, layer, access, format);
- L513 C49: new() :: PipelineLayoutCreateInfo info = new() { SType = StructureType.PipelineLayoutCreateInfo };
- L515 C27: new InvalidOperationException :: throw new InvalidOperationException($"Failed to create pipeline layout for program '{Data.Name ?? "UnnamedProgram"}'.");
- L522 C49: new() :: PipelineLayoutCreateInfo info = new()
- L530 C27: new InvalidOperationException :: throw new InvalidOperationException($"Failed to create pipeline layout for program '{Data.Name ?? "UnnamedProgram"}'.");
- L589 C23: new InvalidOperationException :: throw new InvalidOperationException($"Program '{Data.Name ?? "UnnamedProgram"}' is not linkable.");
- L611 C23: new InvalidOperationException :: throw new InvalidOperationException("Graphics pipeline creation requires at least one graphics shader stage.");
- L638 C43: new string :: var formats = new string[colorAttachmentCount];
- L667 C27: new InvalidOperationException :: throw new InvalidOperationException($"Failed to create graphics pipeline ({result}).");
- L676 C23: new InvalidOperationException :: throw new InvalidOperationException($"Program '{Data.Name ?? "UnnamedProgram"}' is not linkable.");
- L683 C23: new InvalidOperationException :: throw new InvalidOperationException("Compute pipeline creation requires a compute shader stage.");
- L690 C23: new InvalidOperationException :: throw new InvalidOperationException($"Failed to create compute pipeline ({result}).");
- L697 C29: new() :: HashCode hash = new();
- L726 C29: new() :: HashCode hash = new();
- L746 C54: new() :: ComputePipelineCreateInfo pipelineInfo = new()
- L768 C63: new() :: Dictionary<DescriptorType, uint> poolSizeCounts = new();
- L782 C30: new DescriptorPoolSize :: .Select(p => new DescriptorPoolSize { Type = p.Key, DescriptorCount = p.Value })
- L918 C53: new() :: DescriptorPoolCreateInfo poolInfo = new()
- L936 C30: new DescriptorSet :: descriptorSets = new DescriptorSet[_descriptorSetLayouts.Length];
- L940 C55: new() :: DescriptorSetAllocateInfo allocInfo = new()
- L968 C47: new WriteDescriptorSet :: WriteDescriptorSet[] writeArray = new WriteDescriptorSet[pendingWrites.Length];
- L972 C33: new WriteDescriptorSet :: writeArray[i] = new WriteDescriptorSet
- L1132 C34: new DescriptorBufferInfo :: bufferInfo = new DescriptorBufferInfo
- L1163 C26: new DescriptorBufferInfo :: bufferInfo = new DescriptorBufferInfo
- L1273 C25: new DescriptorImageInfo :: imageInfo = new DescriptorImageInfo
- L1377 C29: new ProgramUniformValue :: value = new ProgramUniformValue(EShaderVarType._float, Engine.Time.Timer.Update.Delta, false);
- L1383 C29: new ProgramUniformValue :: value = new ProgramUniformValue(EShaderVarType._mat4, camera?.Transform.InverseRenderMatrix ?? Matrix4x4.Identity, false);
- L1388 C29: new ProgramUniformValue :: value = new ProgramUniformValue(EShaderVarType._mat4, camera?.Transform.RenderMatrix ?? Matrix4x4.Identity, false);
- L1396 C29: new ProgramUniformValue :: value = new ProgramUniformValue(EShaderVarType._mat4, camera?.ProjectionMatrix ?? Matrix4x4.Identity, false);
- L1399 C29: new ProgramUniformValue :: value = new ProgramUniformValue(EShaderVarType._vec3, camera?.Transform.RenderTranslation ?? Vector3.Zero, false);
- L1402 C29: new ProgramUniformValue :: value = new ProgramUniformValue(EShaderVarType._vec3, camera?.Transform.RenderForward ?? Vector3.UnitZ, false);
- L1405 C29: new ProgramUniformValue :: value = new ProgramUniformValue(EShaderVarType._vec3, camera?.Transform.RenderUp ?? Vector3.UnitY, false);
- L1408 C29: new ProgramUniformValue :: value = new ProgramUniformValue(EShaderVarType._vec3, camera?.Transform.RenderRight ?? Vector3.UnitX, false);
- L1411 C29: new ProgramUniformValue :: value = new ProgramUniformValue(EShaderVarType._float, camera?.NearZ ?? 0f, false);
- L1414 C29: new ProgramUniformValue :: value = new ProgramUniformValue(EShaderVarType._float, camera?.FarZ ?? 0f, false);
- L1417 C29: new ProgramUniformValue :: value = new ProgramUniformValue(EShaderVarType._float, (float)area.Width, false);
- L1420 C29: new ProgramUniformValue :: value = new ProgramUniformValue(EShaderVarType._float, (float)area.Height, false);
- L1423 C29: new ProgramUniformValue :: value = new ProgramUniformValue(EShaderVarType._vec2, Vector2.Zero, false);
- L1426 C29: new ProgramUniformValue :: value = new ProgramUniformValue(EShaderVarType._int, (int)(camera?.DepthMode ?? XRCamera.EDepthMode.Normal), false);
- L1429 C29: new ProgramUniformValue :: value = new ProgramUniformValue(EShaderVarType._int, stereo ? 1 : 0, false);
- L1497 C58: new Vector4 :: Unsafe.WriteUnaligned(ref start, new Vector4(v3, 0f));
- L1518 C58: new IVector4 :: Unsafe.WriteUnaligned(ref start, new IVector4(iv3.X, iv3.Y, iv3.Z, 0));
- L1539 C58: new UVector4 :: Unsafe.WriteUnaligned(ref start, new UVector4(uv3.X, uv3.Y, uv3.Z, 0));
- L1567 C58: new DVector4 :: Unsafe.WriteUnaligned(ref start, new DVector4(dv3.X, dv3.Y, dv3.Z, 0.0));
- L1614 C23: new InvalidOperationException :: throw new InvalidOperationException($"Descriptor contract validation failed for program '{programName}': {contractError}");
- L1617 C96: new() :: Dictionary<(uint set, uint binding), DescriptorSetLayoutBindingBuilder> builders = new();
- L1623 C31: new DescriptorSetLayoutBindingBuilder :: builder = new DescriptorSetLayoutBindingBuilder(binding);
- L1633 C24: new DescriptorLayoutBuildResult :: return new DescriptorLayoutBuildResult(Array.Empty<DescriptorSetLayout>(), new List<DescriptorBindingInfo>(), false);
- L1633 C92: new List :: return new DescriptorLayoutBuildResult(Array.Empty<DescriptorSetLayout>(), new List<DescriptorBindingInfo>(), false);
- L1635 C49: new() :: List<DescriptorSetLayout> layouts = new();
- L1651 C27: new InvalidOperationException :: throw new InvalidOperationException($"Failed to create descriptor set layout for program '{programName}'.");
- L1663 C20: new DescriptorLayoutBuildResult :: return new DescriptorLayoutBuildResult(layouts.ToArray(), mergedBindings, requiresUpdateAfterBind);
- L1700 C20: new() :: => new()


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/Types/VkRenderProgramPipeline.cs
- L13 C90: new() :: private readonly Dictionary<EProgramStageMask, VkRenderProgram> _stagePrograms = new();
- L16 C76: new() :: private readonly List<DescriptorBindingInfo> _descriptorBindings = new();
- L64 C23: new InvalidOperationException :: throw new InvalidOperationException($"Program '{program.Data.Name ?? "UnnamedProgram"}' is not linkable.");
- L96 C23: new InvalidOperationException :: throw new InvalidOperationException("Graphics pipeline creation requires configured shader stages.");
- L106 C27: new InvalidOperationException :: throw new InvalidOperationException($"Failed to create graphics pipeline ({result}).");
- L121 C23: new InvalidOperationException :: throw new InvalidOperationException("Compute pipeline creation requires a compute shader stage.");
- L128 C23: new InvalidOperationException :: throw new InvalidOperationException($"Failed to create compute pipeline ({result}).");
- L189 C49: new() :: PipelineLayoutCreateInfo info = new() { SType = StructureType.PipelineLayoutCreateInfo };
- L191 C27: new InvalidOperationException :: throw new InvalidOperationException("Failed to create pipeline layout for pipeline object.");
- L198 C49: new() :: PipelineLayoutCreateInfo info = new()
- L206 C27: new InvalidOperationException :: throw new InvalidOperationException("Failed to create pipeline layout for pipeline object.");


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/Types/VkRenderQuery.cs
- L117 C32: new ulong :: ulong[] data = new ulong[2];
- L147 C50: new() :: QueryPoolCreateInfo createInfo = new()


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/Types/VKSampler.cs
- L76 C49: new() :: SamplerCreateInfo samplerInfo = new()
- L103 C27: new Exception :: throw new Exception("Failed to create Vulkan sampler.");


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/Types/VkShader.cs
- L16 C76: new() :: private readonly List<DescriptorBindingInfo> _descriptorBindings = new();
- L47 C53: new() :: ShaderModuleCreateInfo createInfo = new()
- L57 C31: new InvalidOperationException :: throw new InvalidOperationException($"Failed to create shader module for '{Data.Name ?? "UnnamedShader"}'.");
- L60 C42: new() :: _shaderStageCreateInfo = new()
- L86 C28: new ArgumentOutOfRangeException :: _ => throw new ArgumentOutOfRangeException(nameof(type), type, null)


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/Types/VkTexture1D.cs
- L22 C20: new TextureLayout :: return new TextureLayout(new Extent3D(width, 1, 1), 1, mipLevels);
- L22 C38: new Extent3D :: return new TextureLayout(new Extent3D(width, 1, 1), 1, mipLevels);
- L31 C20: new AttachmentViewKey :: return new AttachmentViewKey(baseMip, 1, 0, 1, ImageViewType.Type1D, AspectFlags);


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/Types/VkTexture1DArray.cs
- L26 C20: new TextureLayout :: return new TextureLayout(new Extent3D(width, 1, 1), layers, mipLevels);
- L26 C38: new Extent3D :: return new TextureLayout(new Extent3D(width, 1, 1), layers, mipLevels);
- L36 C20: new AttachmentViewKey :: return new AttachmentViewKey(baseMip, 1, baseLayer, 1, ImageViewType.Type1D, AspectFlags);


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/Types/VkTexture2D.cs
- L28 C20: new TextureLayout :: return new TextureLayout(new Extent3D(width, height, 1), 1, mipLevels);
- L28 C38: new Extent3D :: return new TextureLayout(new Extent3D(width, height, 1), 1, mipLevels);


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/Types/VkTexture2DArray.cs
- L30 C20: new TextureLayout :: return new TextureLayout(new Extent3D(width, height, 1), layers, mipLevels);
- L30 C38: new Extent3D :: return new TextureLayout(new Extent3D(width, height, 1), layers, mipLevels);
- L39 C24: new AttachmentViewKey :: return new AttachmentViewKey(baseMip, 1, baseLayer, 1, ImageViewType.Type2D, AspectFlags);


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/Types/VkTexture3D.cs
- L24 C20: new TextureLayout :: return new TextureLayout(new Extent3D(width, height, depth), 1, mipLevels);
- L24 C38: new Extent3D :: return new TextureLayout(new Extent3D(width, height, depth), 1, mipLevels);


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/Types/VkTextureBuffer.cs
- L103 C23: new InvalidOperationException :: throw new InvalidOperationException("Texture buffer source is not backed by a Vulkan data buffer.");
- L120 C47: new() :: BufferViewCreateInfo createInfo = new()
- L130 C23: new Exception :: throw new Exception($"Failed to create Vulkan buffer view for texture buffer '{Data.Name ?? "<unnamed>"}'.");


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/Types/VkTextureCube.cs
- L20 C20: new TextureLayout :: return new TextureLayout(new Extent3D(extent, extent, 1), 6, mipLevels);
- L20 C38: new Extent3D :: return new TextureLayout(new Extent3D(extent, extent, 1), 6, mipLevels);
- L28 C24: new AttachmentViewKey :: return new AttachmentViewKey(baseMip, 1, (uint)layerIndex, 1, ImageViewType.Type2D, AspectFlags);


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/Types/VkTextureCubeArray.cs
- L29 C20: new TextureLayout :: return new TextureLayout(new Extent3D(extent, extent, 1), layers, mipLevels);
- L29 C38: new Extent3D :: return new TextureLayout(new Extent3D(extent, extent, 1), layers, mipLevels);
- L39 C20: new AttachmentViewKey :: return new AttachmentViewKey(baseMip, 1, baseLayer, 1, ImageViewType.Type2D, AspectFlags);


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/Types/VkTextureRectangle.cs
- L19 C20: new TextureLayout :: return new TextureLayout(new Extent3D(width, height, 1), 1, 1);
- L19 C38: new Extent3D :: return new TextureLayout(new Extent3D(width, height, 1), 1, 1);


## XRENGINE/Rendering/API/Rendering/Vulkan/Objects/Types/VkTextureView.cs
- L107 C58: new() :: ImageSubresourceRange subresourceRange = new()
- L116 C53: new() :: ImageViewCreateInfo depthViewInfo = new()
- L229 C27: new InvalidOperationException :: throw new InvalidOperationException("Texture view requires a valid viewed texture.");
- L235 C31: new InvalidOperationException :: throw new InvalidOperationException($"Texture view target '{Data.TextureTarget}' is incompatible with buffer texture '{viewedTexture.GetType().Name}'.");
- L249 C31: new InvalidOperationException :: throw new InvalidOperationException("Failed to resolve Vulkan texel buffer view handle.");
- L254 C27: new InvalidOperationException :: throw new InvalidOperationException($"Viewed texture '{viewedTexture.GetType().Name}' is not backed by a Vulkan image.");
- L267 C27: new InvalidOperationException :: throw new InvalidOperationException($"Viewed texture '{viewedTexture.GetDescribingName()}' has no Vulkan image handle.");
- L270 C58: new() :: ImageSubresourceRange subresourceRange = new()
- L279 C48: new() :: ImageViewCreateInfo viewInfo = new()
- L289 C27: new InvalidOperationException :: throw new InvalidOperationException("Failed to create Vulkan texture view.");
- L304 C31: new InvalidOperationException :: throw new InvalidOperationException("Failed to create depth-only descriptor view for texture view.");
- L348 C58: new() :: ImageSubresourceRange subresourceRange = new()
- L357 C48: new() :: ImageViewCreateInfo viewInfo = new()


## XRENGINE/Rendering/API/Rendering/Vulkan/PhysicalDevice.cs
- L17 C19: new Exception :: throw new Exception("Failed to find GPUs with Vulkan support.");
- L19 C23: new PhysicalDevice :: var devices = new PhysicalDevice[devicedCount];
- L34 C19: new Exception :: throw new Exception("Failed to find a suitable GPU for Vulkan.");
- L54 C39: new ExtensionProperties :: var availableExtensions = new ExtensionProperties[extensionsCount];
- L110 C35: new ExtensionProperties :: var availableExtensions = new ExtensionProperties[extentionsCount];
- L130 C15: new Exception :: throw new Exception("Failed to find suitable memory type.");


## XRENGINE/Rendering/API/Rendering/Vulkan/SwapChain.cs
- L156 C37: new() :: ImageCreateInfo imageInfo = new()
- L160 C22: new Extent3D :: Extent = new Extent3D(swapChainExtent.Width, swapChainExtent.Height, 1),
- L172 C19: new Exception :: throw new Exception("Failed to create swapchain depth image.");
- L176 C40: new() :: MemoryAllocateInfo allocInfo = new()
- L184 C19: new Exception :: throw new Exception("Failed to allocate swapchain depth memory.");
- L187 C19: new Exception :: throw new Exception("Failed to bind swapchain depth memory.");
- L189 C40: new() :: ImageViewCreateInfo viewInfo = new()
- L195 C32: new ImageSubresourceRange :: SubresourceRange = new ImageSubresourceRange
- L206 C19: new Exception :: throw new Exception("Failed to create swapchain depth view.");
- L222 C15: new Exception :: throw new Exception("failed to find supported format!");
- L242 C45: new() :: SwapchainCreateInfoKHR createInfo = new()
- L281 C19: new NotSupportedException :: throw new NotSupportedException("VK_KHR_swapchain extension not found.");
- L284 C19: new Exception :: throw new Exception("Failed to create swap chain.");
- L287 C27: new Image :: swapChainImages = new Image[imageCount];
- L288 C40: new bool :: _swapchainImageEverPresented = new bool[imageCount];
- L362 C37: new() :: Extent2D actualExtent = new()
- L377 C23: new SwapChainSupportDetails :: var details = new SwapChainSupportDetails();
- L386 C31: new SurfaceFormatKHR :: details.Formats = new SurfaceFormatKHR[formatCount];
- L402 C36: new PresentModeKHR :: details.PresentModes = new PresentModeKHR[presentModeCount];


## XRENGINE/Rendering/API/Rendering/Vulkan/Types/QueueFamilyIndices.cs
- L22 C23: new QueueFamilyIndices :: var indices = new QueueFamilyIndices();
- L27 C29: new QueueFamilyProperties :: var queueFamilies = new QueueFamilyProperties[queueFamilityCount];


## XRENGINE/Rendering/API/Rendering/Vulkan/Validation.cs
- L28 C40: new() :: DebugUtilsLabelEXT label = new()
- L81 C55: new() :: DebugUtilsMessengerCreateInfoEXT createInfo = new();
- L85 C19: new Exception :: throw new Exception("failed to set up debug messenger!");
- L91 C31: new LayerProperties :: var availableLayers = new LayerProperties[layerCount];


## XRENGINE/Rendering/API/Rendering/Vulkan/VulkanAutoExposure.cs
- L214 C45: new XRRenderProgram :: _autoExposureComputeProgram2D = new XRRenderProgram(
- L217 C17: new XRShader :: new XRShader(EShaderType.Compute, AutoExposureComputeShaderSource2D)
- L222 C50: new XRRenderProgram :: _autoExposureComputeProgram2DArray = new XRRenderProgram(
- L225 C17: new XRShader :: new XRShader(EShaderType.Compute, AutoExposureComputeShaderSource2DArray)


## XRENGINE/Rendering/API/Rendering/Vulkan/VulkanBarrierPlanner.cs
- L107 C60: new QueueOwnershipConfig :: QueueOwnershipConfig ownership = queueOwnership ?? new QueueOwnershipConfig(0u);
- L167 C38: new PlannedImageBarrier :: plannedBarrier = new PlannedImageBarrier(pass.PassIndex, logicalResource, group, previousState, desiredState, srcQueueFamily, dstQueueFamily);
- L171 C34: new PlannedImageBarrier :: plannedBarrier = new PlannedImageBarrier(
- L219 C38: new PlannedBufferBarrier :: plannedBarrier = new PlannedBufferBarrier(pass.PassIndex, logicalResource, previousState, desiredState, srcQueueFamily, dstQueueFamily);
- L223 C34: new PlannedBufferBarrier :: plannedBarrier = new PlannedBufferBarrier(


## XRENGINE/Rendering/API/Rendering/Vulkan/VulkanComputeDescriptors.cs
- L9 C59: new() :: private readonly object _computeDescriptorCacheLock = new();
- L14 C93: new() :: public Dictionary<ComputeDescriptorCacheKey, DescriptorSet[]> CachedSets { get; } = new();
- L15 C93: new() :: public Dictionary<ulong, List<ComputeDescriptorPoolBlock>> PoolsBySchema { get; } = new();
- L34 C40: new ComputeDescriptorImageCache :: _computeDescriptorCaches = new ComputeDescriptorImageCache[imageCount];
- L36 C47: new ComputeDescriptorImageCache :: _computeDescriptorCaches[i] = new ComputeDescriptorImageCache();
- L177 C42: new DescriptorPoolSize :: DescriptorPoolSize[] poolSizes = new DescriptorPoolSize[perAllocationPoolSizes.Length];
- L182 C28: new DescriptorPoolSize :: poolSizes[i] = new DescriptorPoolSize
- L191 C49: new() :: DescriptorPoolCreateInfo poolInfo = new()
- L205 C21: new ComputeDescriptorPoolBlock :: block = new ComputeDescriptorPoolBlock
- L222 C26: new DescriptorSet :: descriptorSets = new DescriptorSet[layouts.Length];
- L227 C51: new() :: DescriptorSetAllocateInfo allocInfo = new()


## XRENGINE/Rendering/API/Rendering/Vulkan/VulkanDescriptorLayoutCache.cs
- L15 C61: new() :: private readonly object _descriptorSetLayoutCacheLock = new();
- L16 C103: new() :: private readonly Dictionary<ulong, List<CachedDescriptorSetLayout>> _descriptorSetLayoutsByHash = new();
- L17 C99: new() :: private readonly Dictionary<ulong, CachedDescriptorSetLayout> _descriptorSetLayoutsByHandle = new();
- L66 C49: new() :: CachedDescriptorSetLayout created = new()
- L129 C56: new DescriptorLayoutBindingSignature :: DescriptorLayoutBindingSignature[] signature = new DescriptorLayoutBindingSignature[bindings.Length];
- L133 C28: new DescriptorLayoutBindingSignature :: signature[i] = new DescriptorLayoutBindingSignature(
- L187 C70: new() :: DescriptorSetLayoutBindingFlagsCreateInfo bindingFlagsInfo = new()
- L195 C28: new DescriptorBindingFlags :: bindingFlags = new DescriptorBindingFlags[bindings.Length];
- L225 C64: new() :: DescriptorSetLayoutCreateInfo layoutInfo = new()
- L244 C56: new() :: DescriptorSetLayoutCreateInfo layoutInfo = new()


## XRENGINE/Rendering/API/Rendering/Vulkan/VulkanPipelineCache.cs
- L48 C44: new() :: PipelineCacheCreateInfo info = new()
- L82 C33: new byte :: byte[] cacheBytes = new byte[(int)cacheSize];


## XRENGINE/Rendering/API/Rendering/Vulkan/VulkanRenderer.FrameTiming.cs
- L24 C34: new QueryPool :: _frameTimingQueryPools = new QueryPool[MAX_FRAMES_IN_FLIGHT];
- L25 C34: new bool :: _frameTimingQueryReady = new bool[MAX_FRAMES_IN_FLIGHT];
- L27 C42: new() :: QueryPoolCreateInfo createInfo = new()


## XRENGINE/Rendering/API/Rendering/Vulkan/VulkanRenderer.ImGui.cs
- L22 C58: new() :: private readonly ImGuiDrawDataCache _imguiDrawData = new();
- L57 C53: new() :: private readonly object _pendingInputLock = new();
- L58 C74: new() :: private readonly Queue<Action<ImGuiIOPtr>> _pendingInputEvents = new();
- L154 C30: new Vector2 :: io.DisplaySize = new Vector2(width, height);
- L511 C34: new VulkanImGuiBackend :: return _imguiBackend ??= new VulkanImGuiBackend(this);
- L616 C19: new InvalidOperationException :: throw new InvalidOperationException("Failed to get ImGui font atlas pixels.");
- L634 C46: new() :: BufferImageCopy copyRegion = new()
- L639 C40: new ImageSubresourceLayers :: ImageSubresource = new ImageSubresourceLayers
- L646 C35: new Offset3D :: ImageOffset = new Offset3D(0, 0, 0),
- L647 C35: new Extent3D :: ImageExtent = new Extent3D((uint)width, (uint)height, 1)
- L666 C37: new() :: ImageCreateInfo imageInfo = new()
- L670 C22: new Extent3D :: Extent = new Extent3D(width, height, 1),
- L682 C19: new InvalidOperationException :: throw new InvalidOperationException("Failed to create ImGui font image.");
- L685 C40: new() :: MemoryAllocateInfo allocInfo = new()
- L693 C19: new InvalidOperationException :: throw new InvalidOperationException("Failed to allocate ImGui font image memory.");
- L696 C19: new InvalidOperationException :: throw new InvalidOperationException("Failed to bind ImGui font image memory.");
- L698 C40: new() :: ImageViewCreateInfo viewInfo = new()
- L704 C32: new ImageSubresourceRange :: SubresourceRange = new ImageSubresourceRange
- L715 C19: new InvalidOperationException :: throw new InvalidOperationException("Failed to create ImGui font image view.");
- L717 C41: new() :: SamplerCreateInfo samplerInfo = new()
- L738 C19: new InvalidOperationException :: throw new InvalidOperationException("Failed to create ImGui font sampler.");
- L743 C53: new() :: DescriptorSetLayoutBinding samplerBinding = new()
- L752 C52: new() :: DescriptorSetLayoutCreateInfo layoutInfo = new()
- L760 C19: new InvalidOperationException :: throw new InvalidOperationException("Failed to create ImGui descriptor set layout.");
- L762 C39: new() :: DescriptorPoolSize poolSize = new()
- L768 C45: new() :: DescriptorPoolCreateInfo poolInfo = new()
- L778 C19: new InvalidOperationException :: throw new InvalidOperationException("Failed to create ImGui descriptor pool.");
- L781 C47: new() :: DescriptorSetAllocateInfo allocInfo = new()
- L790 C19: new InvalidOperationException :: throw new InvalidOperationException("Failed to allocate ImGui descriptor set.");
- L794 C41: new() :: DescriptorImageInfo imageInfo = new()
- L801 C36: new() :: WriteDescriptorSet write = new()
- L817 C38: new() :: ImageMemoryBarrier barrier = new()
- L825 C32: new ImageSubresourceRange :: SubresourceRange = new ImageSubresourceRange
- L854 C19: new InvalidOperationException :: throw new InvalidOperationException($"Unsupported ImGui image layout transition {oldLayout} -> {newLayout}.");
- L862 C36: new() :: HashCode pipelineKeyHash = new();
- L908 C45: new() :: ShaderModuleCreateInfo vsInfo = new()
- L915 C45: new() :: ShaderModuleCreateInfo fsInfo = new()
- L923 C23: new InvalidOperationException :: throw new InvalidOperationException("Failed to create ImGui vertex shader module.");
- L925 C23: new InvalidOperationException :: throw new InvalidOperationException("Failed to create ImGui fragment shader module.");
- L928 C39: new() :: PushConstantRange pushRange = new()
- L936 C47: new() :: PipelineLayoutCreateInfo layoutInfo = new()
- L946 C19: new InvalidOperationException :: throw new InvalidOperationException("Failed to create ImGui pipeline layout.");
- L949 C21: new PipelineShaderStageCreateInfo :: stages[0] = new PipelineShaderStageCreateInfo
- L956 C21: new PipelineShaderStageCreateInfo :: stages[1] = new PipelineShaderStageCreateInfo
- L966 C53: new() :: VertexInputBindingDescription binding = new()
- L974 C29: new VertexInputAttributeDescription :: attributes[0] = new VertexInputAttributeDescription
- L981 C29: new VertexInputAttributeDescription :: attributes[1] = new VertexInputAttributeDescription
- L988 C29: new VertexInputAttributeDescription :: attributes[2] = new VertexInputAttributeDescription
- L996 C62: new() :: PipelineVertexInputStateCreateInfo vertexInput = new()
- L1005 C66: new() :: PipelineInputAssemblyStateCreateInfo inputAssembly = new()
- L1012 C61: new() :: PipelineViewportStateCreateInfo viewportState = new()
- L1019 C63: new() :: PipelineRasterizationStateCreateInfo rasterizer = new()
- L1031 C64: new() :: PipelineMultisampleStateCreateInfo multisampling = new()
- L1038 C64: new() :: PipelineDepthStencilStateCreateInfo depthStencil = new()
- L1048 C65: new() :: PipelineColorBlendAttachmentState colorAttachment = new()
- L1066 C65: new() :: PipelineColorBlendStateCreateInfo colorBlendState = new()
- L1078 C59: new() :: PipelineDynamicStateCreateInfo dynamicState = new()
- L1085 C55: new() :: GraphicsPipelineCreateInfo pipelineInfo = new()
- L1108 C61: new() :: PipelineRenderingCreateInfo renderingInfo = new()
- L1123 C23: new InvalidOperationException :: throw new InvalidOperationException("Failed to create ImGui graphics pipeline.");
- L1205 C19: new InvalidOperationException :: throw new InvalidOperationException("Failed to map ImGui vertex buffer.");
- L1210 C19: new InvalidOperationException :: throw new InvalidOperationException("Failed to map ImGui index buffer.");
- L1240 C44: new() :: ImGuiPushConstants pushConstants = new()
- L1242 C21: new Vector2 :: Scale = new Vector2(2.0f / displaySize.X, 2.0f / displaySize.Y),
- L1243 C25: new Vector2 :: Translate = new Vector2(
- L1291 C34: new() :: Rect2D scissor = new()
- L1293 C30: new Offset2D :: Offset = new Offset2D((int)clipMinX, (int)clipMinY),
- L1294 C30: new Extent2D :: Extent = new Extent2D((uint)(clipMaxX - clipMinX), (uint)(clipMaxY - clipMinY))
- L1382 C47: new() :: DescriptorSetAllocateInfo allocInfo = new()
- L1393 C41: new() :: DescriptorImageInfo imageInfo = new()
- L1400 C36: new() :: WriteDescriptorSet write = new()
- L1464 C41: new ImDrawVert :: ImDrawVert[] vertices = new ImDrawVert[cmdList.VtxBuffer.Size];
- L1465 C36: new ushort :: ushort[] indices = new ushort[cmdList.IdxBuffer.Size];
- L1485 C51: new ImGuiCommandSnapshot :: ImGuiCommandSnapshot[] commands = new ImGuiCommandSnapshot[cmdList.CmdBuffer.Size];
- L1489 C42: new ImGuiCommandSnapshot :: commands[cmdIndex] = new ImGuiCommandSnapshot
- L1500 C34: new ImGuiCommandListSnapshot :: commandLists.Add(new ImGuiCommandListSnapshot
- L1511 C20: new ImGuiFrameSnapshot :: return new ImGuiFrameSnapshot


## XRENGINE/Rendering/API/Rendering/Vulkan/VulkanRenderer.PlaceholderTexture.cs
- L37 C16: new DescriptorImageInfo :: return new DescriptorImageInfo
- L64 C37: new() :: ImageCreateInfo imageInfo = new()
- L68 C22: new Extent3D :: Extent = new Extent3D(width, height, 1),
- L86 C40: new() :: MemoryAllocateInfo allocInfo = new()
- L125 C40: new() :: BufferImageCopy copy = new()
- L130 C40: new ImageSubresourceLayers :: ImageSubresource = new ImageSubresourceLayers
- L138 C35: new Extent3D :: ImageExtent = new Extent3D(width, height, 1),
- L155 C40: new() :: ImageViewCreateInfo viewInfo = new()
- L161 C32: new ImageSubresourceRange :: SubresourceRange = new ImageSubresourceRange
- L178 C41: new() :: SamplerCreateInfo samplerInfo = new()
- L211 C38: new() :: ImageMemoryBarrier barrier = new()
- L219 C32: new ImageSubresourceRange :: SubresourceRange = new ImageSubresourceRange


## XRENGINE/Rendering/API/Rendering/Vulkan/VulkanRenderer.State.cs
- L18 C50: new() :: private readonly VulkanStateTracker _state = new();
- L19 C63: new() :: private readonly VulkanResourcePlanner _resourcePlanner = new();
- L20 C67: new() :: private readonly VulkanResourceAllocator _resourceAllocator = new();
- L21 C61: new() :: private readonly VulkanBarrierPlanner _barrierPlanner = new();
- L144 C26: new ColorF4 :: ClearColor = new ColorF4(0, 0, 0, 1);
- L186 C87: new() :: private readonly Dictionary<int, EMemoryBarrierMask> _perPassMemoryBarriers = new();
- L261 C25: new Viewport :: _viewport = new Viewport
- L292 C24: new Rect2D :: _scissor = new Rect2D
- L294 C26: new Offset2D :: Offset = new Offset2D(clampedX, Math.Max(yTopLeft, 0)),
- L295 C26: new Extent2D :: Extent = new Extent2D((uint)clampedWidth, (uint)clampedHeight)
- L329 C16: new() :: => new()
- L340 C16: new() :: => new()
- L342 C26: new Offset2D :: Offset = new Offset2D(0, 0),
- L343 C26: new Extent2D :: Extent = new Extent2D(extent.Width, extent.Height)
- L425 C30: new ClearValue :: destination[0] = new ClearValue
- L427 C25: new ClearColorValue :: Color = new ClearColorValue
- L438 C34: new ClearValue :: destination[1] = new ClearValue
- L440 C36: new ClearDepthStencilValue :: DepthStencil = new ClearDepthStencilValue
- L477 C16: new FrameOpContext :: return new FrameOpContext(
- L546 C25: new() :: HashCode hash = new();
- L596 C25: new() :: HashCode hash = new();
- L654 C25: new() :: HashCode hash = new();
- L689 C25: new() :: HashCode hash = new();
- L786 C16: new VulkanBarrierPlanner.QueueOwnershipConfig :: return new VulkanBarrierPlanner.QueueOwnershipConfig(
- L823 C16: new QueueOverlapMetrics :: return new QueueOverlapMetrics(
- L951 C26: new() :: overflow ??= new();
- L963 C42: new() :: ImageMemoryBarrier barrier = new()
- L971 C36: new ImageSubresourceRange :: SubresourceRange = new ImageSubresourceRange
- L1034 C37: new() :: ImageCreateInfo imageInfo = new()
- L1054 C23: new Exception :: throw new Exception($"Failed to create Vulkan image for resource group '{group.Key}'. Result={result}.");
- L1073 C44: new() :: MemoryAllocateInfo allocInfo = new()
- L1087 C23: new Exception :: throw new Exception($"Failed to bind device memory for Vulkan image group '{group.Key}'. Result={bindResult}.");
- L1113 C30: new RetiredImageResources :: RetireImageResources(new RetiredImageResources(
- L1129 C39: new() :: BufferCreateInfo bufferInfo = new()
- L1141 C23: new Exception :: throw new Exception($"Failed to create Vulkan buffer for resource group '{group.Key}'. Result={createResult}.");
- L1148 C44: new() :: MemoryAllocateInfo allocInfo = new()
- L1160 C23: new Exception :: throw new Exception($"Failed to bind device memory for Vulkan buffer group '{group.Key}'. Result={bindResult}.");


## XRENGINE/Rendering/API/Rendering/Vulkan/VulkanRenderGraphCompiler.cs
- L11 C71: new() :: private readonly VulkanRenderGraphCompiler _renderGraphCompiler = new();
- L78 C20: new VulkanCompiledRenderGraph :: return new VulkanCompiledRenderGraph(
- L251 C33: new SecondaryRecordingBucket :: buckets.Add(new SecondaryRecordingBucket(
- L316 C13: new Dictionary :: new Dictionary<int, int>(),


## XRENGINE/Rendering/API/Rendering/Vulkan/VulkanResourceAllocator.cs
- L18 C92: new() :: private readonly Dictionary<VulkanAliasGroupKey, VulkanImageAliasGroup> _aliasGroups = new();
- L19 C98: new() :: private readonly Dictionary<VulkanAliasGroupKey, VulkanPhysicalImageGroup> _physicalGroups = new();
- L23 C105: new() :: private readonly Dictionary<VulkanBufferAliasGroupKey, VulkanBufferAliasGroup> _bufferAliasGroups = new();
- L24 C111: new() :: private readonly Dictionary<VulkanBufferAliasGroupKey, VulkanPhysicalBufferGroup> _physicalBufferGroups = new();
- L67 C25: new VulkanImageAliasGroup :: group = new VulkanImageAliasGroup(key);
- L80 C25: new VulkanBufferAliasGroup :: group = new VulkanBufferAliasGroup(key);
- L247 C35: new VulkanUsageProfile :: profile = new VulkanUsageProfile();
- L389 C16: new Extent3D :: return new Extent3D(width, height, 1);
- L593 C65: new() :: private readonly List<VulkanImageAllocation> _allocations = new();
- L618 C66: new() :: private readonly List<VulkanBufferAllocation> _allocations = new();
- L676 C16: new VulkanAliasGroupKey :: return new VulkanAliasGroupKey(request.AliasKey, request.Lifetime, discriminator);
- L689 C16: new VulkanBufferAliasGroupKey :: return new VulkanBufferAliasGroupKey(request.AliasKey, request.Lifetime, discriminator);
- L713 C70: new() :: private readonly List<VulkanImageAllocation> _logicalResources = new();
- L781 C71: new() :: private readonly List<VulkanBufferAllocation> _logicalResources = new();


## XRENGINE/Rendering/API/Rendering/Vulkan/VulkanResourcePlanner.cs
- L63 C52: new() :: List<VulkanAllocationRequest> persistent = new();
- L64 C51: new() :: List<VulkanAllocationRequest> transient = new();
- L65 C50: new() :: List<VulkanAllocationRequest> external = new();
- L66 C65: new() :: List<VulkanBufferAllocationRequest> persistentBuffers = new();
- L67 C64: new() :: List<VulkanBufferAllocationRequest> transientBuffers = new();
- L68 C63: new() :: List<VulkanBufferAllocationRequest> externalBuffers = new();
- L72 C27: new VulkanAllocationRequest :: var request = new VulkanAllocationRequest(descriptor);
- L87 C24: new Dictionary :: var fboPlans = new Dictionary<string, VulkanFrameBufferPlan>(_frameBuffers.Count, StringComparer.OrdinalIgnoreCase);
- L89 C30: new VulkanFrameBufferPlan :: fboPlans[name] = new VulkanFrameBufferPlan(descriptor);
- L93 C27: new VulkanBufferAllocationRequest :: var request = new VulkanBufferAllocationRequest(descriptor);
- L108 C17: new VulkanResourcePlan :: _plan = new VulkanResourcePlan(
- L168 C9: new Dictionary :: new Dictionary<string, VulkanFrameBufferPlan>(StringComparer.OrdinalIgnoreCase));


## XRENGINE/Rendering/API/Rendering/Vulkan/VulkanShaderTools.cs
- L164 C20: new AutoUniformRewriteResult :: return new AutoUniformRewriteResult(source, null);
- L174 C20: new AutoUniformRewriteResult :: return new AutoUniformRewriteResult(RewriteOpaqueUniformBindings(source, shaderType), null);
- L178 C187: new() :: List<(string GlslType, string Name, bool IsArray, uint ArrayLength, AutoUniformDefaultValue? DefaultValue, IReadOnlyList<AutoUniformDefaultValue>? DefaultArrayValues)> members = new();
- L192 C36: new List :: var statementMembers = new List<(string GlslType, string Name, bool IsArray, uint ArrayLength, AutoUniformDefaultValue? DefaultValue, IReadOnlyList<AutoUniformDefaultValue>? DefaultArrayValues)>();
- L244 C20: new AutoUniformRewriteResult :: return new AutoUniformRewriteResult(rewritten, null);
- L250 C20: new AutoUniformRewriteResult :: return new AutoUniformRewriteResult(source, null);
- L282 C16: new AutoUniformRewriteResult :: return new AutoUniformRewriteResult(rewritten, blockInfo);
- L358 C33: new() :: StringBuilder builder = new();
- L458 C47: new[] :: string[] tokens = withoutLayout.Split(new[] { ' ', '\t' }, StringSplitOptions.RemoveEmptyEntries);
- L535 C41: new[] :: string[] tokens = trimmed.Split(new[] { ' ', '\t' }, StringSplitOptions.RemoveEmptyEntries);
- L581 C42: new() :: HashSet<int> functionBodyLines = new();
- L729 C25: new Dictionary :: var constants = new Dictionary<string, uint>(StringComparer.Ordinal);
- L811 C25: new List :: layoutMembers = new List<AutoUniformMember>(members.Count);
- L821 C31: new AutoUniformMember :: layoutMembers.Add(new AutoUniformMember(Name, GlslType, engineType, IsArray, ArrayLength, arrayStride, offset, size, DefaultValue, DefaultArrayValues));
- L873 C29: new AutoUniformDefaultValue :: value = new AutoUniformDefaultValue(EShaderVarType._float, f);
- L880 C29: new AutoUniformDefaultValue :: value = new AutoUniformDefaultValue(EShaderVarType._int, i);
- L887 C29: new AutoUniformDefaultValue :: value = new AutoUniformDefaultValue(EShaderVarType._uint, u);
- L894 C29: new AutoUniformDefaultValue :: value = new AutoUniformDefaultValue(EShaderVarType._bool, b ? 1 : 0);
- L899 C29: new AutoUniformDefaultValue :: value = new AutoUniformDefaultValue(EShaderVarType._bool, bi != 0 ? 1 : 0);
- L906 C29: new AutoUniformDefaultValue :: value = new AutoUniformDefaultValue(EShaderVarType._vec2, new Vector2(v2[0], v2[1]));
- L906 C79: new Vector2 :: value = new AutoUniformDefaultValue(EShaderVarType._vec2, new Vector2(v2[0], v2[1]));
- L913 C29: new AutoUniformDefaultValue :: value = new AutoUniformDefaultValue(EShaderVarType._vec3, new Vector3(v3[0], v3[1], v3[2]));
- L913 C79: new Vector3 :: value = new AutoUniformDefaultValue(EShaderVarType._vec3, new Vector3(v3[0], v3[1], v3[2]));
- L920 C29: new AutoUniformDefaultValue :: value = new AutoUniformDefaultValue(EShaderVarType._vec4, new Vector4(v4[0], v4[1], v4[2], v4[3]));
- L920 C79: new Vector4 :: value = new AutoUniformDefaultValue(EShaderVarType._vec4, new Vector4(v4[0], v4[1], v4[2], v4[3]));
- L927 C29: new AutoUniformDefaultValue :: value = new AutoUniformDefaultValue(EShaderVarType._mat4, m4);
- L1037 C26: new float :: float[] parsed = new float[length];
- L1071 C21: new Matrix4x4 :: value = new Matrix4x4(
- L1082 C24: new float :: float[] vals = new float[dimension * dimension];
- L1090 C17: new Matrix4x4 :: value = new Matrix4x4(
- L1208 C19: new InvalidOperationException :: throw new InvalidOperationException($"Shader '{shader.Name ?? "UnnamedShader"}' does not contain GLSL source code.");
- L1216 C19: new InvalidOperationException :: throw new InvalidOperationException("Failed to initialize the shaderc compiler instance.");
- L1222 C19: new InvalidOperationException :: throw new InvalidOperationException("Failed to allocate shaderc compile options.");
- L1250 C23: new InvalidOperationException :: throw new InvalidOperationException($"Shader '{shader.Name ?? "UnnamedShader"}' failed to compile due to an unknown error.");
- L1264 C27: new InvalidOperationException :: throw new InvalidOperationException($"Shader '{shader.Name ?? "UnnamedShader"}' failed to compile: {message}{Environment.NewLine}{preview}");
- L1267 C23: new InvalidOperationException :: throw new InvalidOperationException($"Shader '{shader.Name ?? "UnnamedShader"}' failed to compile: {message}");
- L1272 C23: new InvalidOperationException :: throw new InvalidOperationException($"Shader '{shader.Name ?? "UnnamedShader"}' produced an empty SPIR-V module.");
- L1274 C28: new byte :: byte[] spirv = new byte[(int)length];
- L1311 C24: new ArgumentOutOfRangeException :: _ => throw new ArgumentOutOfRangeException(nameof(type), type, null)
- L1323 C65: new HashSet :: return ExpandIncludesRecursive(source, sourceDirectory, new HashSet<string>(StringComparer.OrdinalIgnoreCase));
- L1330 C33: new() :: StringBuilder builder = new();
- L1355 C26: new InvalidOperationException :: ?? throw new InvalidOperationException($"Failed to resolve shader include '{includePath}'.");
- L1359 C23: new InvalidOperationException :: throw new InvalidOperationException($"Recursive shader include detected for '{normalizedPath}'.");
- L1437 C19: new InvalidOperationException :: throw new InvalidOperationException(
- L1541 C48: new() :: List<DescriptorBindingInfo> bindings = new();
- L1563 C26: new DescriptorBindingInfo :: bindings.Add(new DescriptorBindingInfo(set, binding, descriptorType, stage, arraySize == 0 ? 1u : arraySize, name));
- L1641 C43: new[] :: string[] tokens = sanitized.Split(new[] { ' ', '\t' }, StringSplitOptions.RemoveEmptyEntries);
- L1649 C63: new() :: private readonly Dictionary<uint, SpirvType> _types = new();
- L1650 C71: new() :: private readonly Dictionary<uint, SpirvVariable> _variables = new();
- L1651 C76: new() :: private readonly Dictionary<uint, SpirvDecorations> _decorations = new();
- L1652 C60: new() :: private readonly Dictionary<uint, string> _names = new();
- L1653 C63: new() :: private readonly Dictionary<uint, ulong> _constants = new();
- L1660 C23: new InvalidOperationException :: throw new InvalidOperationException("SPIR-V bytecode length must be divisible by 4.");
- L1669 C52: new() :: List<DescriptorBindingInfo> bindings = new();
- L1693 C30: new DescriptorBindingInfo :: bindings.Add(new DescriptorBindingInfo(set, binding, descriptorType, _stage, descriptorCount == 0 ? 1u : descriptorCount, name));
- L1702 C23: new InvalidOperationException :: throw new InvalidOperationException("SPIR-V module header is incomplete.");
- L1712 C27: new InvalidOperationException :: throw new InvalidOperationException($"Invalid SPIR-V word count for opcode {opCode}.");
- L1715 C27: new InvalidOperationException :: throw new InvalidOperationException("SPIR-V instruction extends beyond buffer.");
- L1821 C36: new SpirvVariable :: _variables[resultId] = new SpirvVariable(resultId, resultTypeId, storageClass);
- L1895 C29: new SpirvImageInfo :: ImageType = new SpirvImageInfo
- L1932 C32: new SpirvType :: _types[resultId] = new SpirvType(resultId) { Kind = SpirvTypeKind.Sampler };
- L2021 C25: new SpirvDecorations :: decor = new SpirvDecorations();


## XRENGINE/Rendering/API/Rendering/Vulkan/VulkanStagingManager.cs
- L11 C37: new() :: private readonly object _sync = new();
- L63 C19: new ArgumentOutOfRangeException :: throw new ArgumentOutOfRangeException(nameof(requestedSize), "Staging buffers must be at least 1 byte.");
- L71 C25: new StagingBufferEntry :: entry = new StagingBufferEntry


## XRENGINE/Rendering/API/XRWindow.cs
- L57 C73: new() :: private readonly XRWindowScenePanelAdapter _scenePanelAdapter = new();
- L197 C38: new OpenGLRenderer :: ContextAPI.OpenGL => new OpenGLRenderer(this, true),
- L198 C38: new VulkanRenderer :: ContextAPI.Vulkan => new VulkanRenderer(this, true),
- L199 C28: new Exception :: _ => throw new Exception($"Unsupported API: {Window.API.API}"),
- L216 C29: new Engine.StateChangeInfo :: new Engine.StateChangeInfo(
- L469 C181: new[] :: var method = type.GetMethod(name, System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic, null, new[] { typeof(bool) }, null);
- L472 C45: new object :: method.Invoke(instance, new object[] { value });
- L862 C43: new DebugOpaqueRenderPipeline :: viewport.RenderPipeline = new DebugOpaqueRenderPipeline();
- L1065 C20: new WorldHierarchy :: return new WorldHierarchy
- L1077 C20: new NodeRepresentation :: return new NodeRepresentation


## XRENGINE/Rendering/API/XRWindowScenePanelAdapter.cs
- L240 C34: new XRFrameBuffer :: _scenePanelFBO = new XRFrameBuffer((_scenePanelTexture, EFrameBufferAttachment.ColorAttachment0, 0, -1))


## XRENGINE/Rendering/Camera/CameraProjectionTransition.cs
- L65 C35: new ArgumentNullException :: _camera = camera ?? throw new ArgumentNullException(nameof(camera));
- L120 C27: new XROrthographicCameraParameters :: var orthoParams = new XROrthographicCameraParameters(
- L164 C31: new Vector2 :: _frustumSizeAtFocus = new Vector2(ortho.Width, ortho.Height);
- L178 C27: new XRPerspectiveCameraParameters :: var perspParams = new XRPerspectiveCameraParameters(_startFov, null, _startNearZ, _startFarZ);


## XRENGINE/Rendering/Camera/ColorGradingSettings.cs
- L500 C17: new Vector3 :: w = new Vector3(Sanitize(w.X), Sanitize(w.Y), Sanitize(w.Z));


## XRENGINE/Rendering/Camera/ICameraParameterCustomEditor.cs
- L51 C48: new() :: private static readonly object _lock = new();


## XRENGINE/Rendering/Camera/LensDistortionSettings.cs
- L153 C54: new Vector2 :: program.Uniform("PaniniViewExtents", new Vector2(1.0f, 1.0f));
- L159 C55: new Vector3 :: program.Uniform("BrownConradyRadial", new Vector3(_brownConradyK1, _brownConradyK2, _brownConradyK3));
- L160 C59: new Vector2 :: program.Uniform("BrownConradyTangential", new Vector2(_brownConradyP1, _brownConradyP2));
- L176 C20: new Vector2 :: return new Vector2(viewExtX, viewExtY);


## XRENGINE/Rendering/Camera/VignetteSettings.cs
- L13 C46: new ColorF3 :: public ColorF3 Color { get; set; } = new ColorF3();


## XRENGINE/Rendering/Camera/XRCamera.cs
- L70 C20: new Vector2 :: return new Vector2(
- L183 C71: new() :: private CameraPostProcessStateCollection _postProcessStates = new();
- L215 C66: new() :: private readonly Stack<Vector2> _projectionJitterStack = new();
- L296 C65: new Transform :: get => _transform ?? SetFieldReturn(ref _transform, new Transform())!;
- L331 C62: new CameraPostProcessStateCollection :: set => SetField(ref _postProcessStates, value ?? new CameraPostProcessStateCollection());
- L784 C27: new Vector2 :: screenPoint = new Vector2(xyd.X, xyd.Y);
- L805 C145: new Vector3 :: Vector3 clip01 = (Vector3.Transform(Vector3.Transform(worldPoint, Transform.InverseWorldMatrix), ProjectionMatrix) + Vector3.One) * new Vector3(0.5f);
- L810 C26: new Vector3 :: clip01 = new Vector3(ApplyLensDistortionInverse(clip01.XY(), lens), clip01.Z);
- L824 C52: new Vector3 :: => NormalizedViewportToWorldCoordinate(new Vector3(normalizedX, normalizedY, depth));
- L912 C24: new LensParams :: return new LensParams(ELensDistortionMode.None, 0.0f, 0.0f, 1.0f, Vector2.One);
- L916 C24: new LensParams :: return new LensParams(ELensDistortionMode.None, 0.0f, 0.0f, 1.0f, Vector2.One);
- L920 C24: new LensParams :: return new LensParams(ELensDistortionMode.None, 0.0f, 0.0f, 1.0f, Vector2.One);
- L947 C20: new LensParams :: return new LensParams(mode, intensity, paniniDistance, paniniCrop, paniniViewExtents);
- L999 C39: new Vector2 :: Vector2 centered = uv01 - new Vector2(0.5f, 0.5f);
- L1007 C32: new Vector2 :: return distorted + new Vector2(0.5f, 0.5f);
- L1022 C39: new Vector2 :: Vector2 centered = uv01 - new Vector2(0.5f, 0.5f);
- L1025 C24: new Vector2 :: return new Vector2(0.5f, 0.5f);
- L1039 C30: new Vector2 :: return dir * r + new Vector2(0.5f, 0.5f);
- L1057 C37: new Vector2 :: return projNdc * 0.5f + new Vector2(0.5f, 0.5f);
- L1087 C59: new Vector2 :: Vector2 uvDx = ApplyPaniniFromView(view + new Vector2(delta, 0.0f), lens);
- L1088 C59: new Vector2 :: Vector2 uvDy = ApplyPaniniFromView(view + new Vector2(0.0f, delta), lens);
- L1105 C98: new Vector2 :: Vector2 uvUndistorted = (view / (lens.PaniniViewExtents * lens.PaniniCrop)) * 0.5f + new Vector2(0.5f, 0.5f);
- L1120 C37: new Vector2 :: return projNdc * 0.5f + new Vector2(0.5f, 0.5f);
- L1161 C20: new Segment :: return new Segment(start, end);
- L1176 C20: new Ray :: return new Ray(start, end - start);
- L1356 C44: new Plane :: => _obliqueNearClippingPlane = new Plane(planeNormalWorld, planeDistance);


## XRENGINE/Rendering/Camera/XRCameraParameters.cs
- L94 C52: new() :: private object _untransformedFrustumLock = new();
- L113 C69: new Vector2 :: program.Uniform(EEngineUniform.ScreenOrigin.ToString(), new Vector2(0.0f, 0.0f));
- L193 C20: new XRPerspectiveCameraParameters :: return new XRPerspectiveCameraParameters(0.1f, 10000f);
- L229 C23: new ArgumentException :: throw new ArgumentException($"Type must derive from {nameof(XRCameraParameters)}", nameof(targetType));
- L271 C23: new XRPerspectiveCameraParameters :: ? new XRPerspectiveCameraParameters(previous.NearZ, previous.FarZ)
- L272 C23: new XRPerspectiveCameraParameters :: : new XRPerspectiveCameraParameters(0.1f, 10000f);


## XRENGINE/Rendering/Camera/XROpenXRFovCameraParameters.cs
- L80 C20: new Frustum :: return new Frustum(invProj);
- L87 C20: new Vector2 :: return new Vector2(w, h);
- L122 C26: new XROpenXRFovCameraParameters :: var result = new XROpenXRFovCameraParameters(previous?.NearZ ?? 0.1f, previous?.FarZ ?? 10000f);
- L148 C16: new XROpenXRFovCameraParameters :: => new XROpenXRFovCameraParameters(0.1f, 10000f);


## XRENGINE/Rendering/Camera/XROrthographicCameraParameters.cs
- L162 C23: new Vector2 :: _origin = new Vector2(_orthoLeft, _orthoBottom) + _originPercentages * new Vector2(Width, Height);
- L162 C84: new Vector2 :: _origin = new Vector2(_orthoLeft, _orthoBottom) + _originPercentages * new Vector2(Width, Height);
- L239 C24: new XROrthographicCameraParameters :: return new XROrthographicCameraParameters();
- L243 C30: new XROrthographicCameraParameters :: var result = new XROrthographicCameraParameters(ortho.Width, ortho.Height, ortho.NearZ, ortho.FarZ)
- L256 C28: new XROrthographicCameraParameters :: var newOrtho = new XROrthographicCameraParameters(
- L277 C25: new XROrthographicCameraParameters :: var ortho = new XROrthographicCameraParameters(
- L288 C16: new XROrthographicCameraParameters :: => new XROrthographicCameraParameters();


## XRENGINE/Rendering/Camera/XROVRCameraParameters.cs
- L41 C52: new Vector3 :: Vector3 bottomLeft = Vector3.Transform(new Vector3(-1, -1, normDist), invProj);
- L42 C53: new Vector3 :: Vector3 bottomRight = Vector3.Transform(new Vector3(1, -1, normDist), invProj);
- L43 C49: new Vector3 :: Vector3 topLeft = Vector3.Transform(new Vector3(-1, 1, normDist), invProj);
- L45 C20: new Vector2 :: return new Vector2((bottomRight - bottomLeft).Length(), (topLeft - bottomLeft).Length());
- L102 C24: new XROVRCameraParameters :: return new XROVRCameraParameters(ovr.LeftEye, ovr.NearZ, ovr.FarZ);
- L104 C20: new XROVRCameraParameters :: return new XROVRCameraParameters(true, previous?.NearZ ?? 0.1f, previous?.FarZ ?? 10000f);
- L108 C16: new XROVRCameraParameters :: => new XROVRCameraParameters(true, 0.1f, 10000f);


## XRENGINE/Rendering/Camera/XRPerspectiveCameraParameters.cs
- L104 C20: new Vector2 :: return new Vector2(width, height);
- L143 C24: new XRPerspectiveCameraParameters :: return new XRPerspectiveCameraParameters();
- L147 C24: new XRPerspectiveCameraParameters :: return new XRPerspectiveCameraParameters(
- L163 C24: new XRPerspectiveCameraParameters :: return new XRPerspectiveCameraParameters(fov, aspect, ortho.NearZ, ortho.FarZ)
- L171 C20: new XRPerspectiveCameraParameters :: return new XRPerspectiveCameraParameters(approxFov, null, previous.NearZ, previous.FarZ)
- L192 C25: new XRPerspectiveCameraParameters :: var persp = new XRPerspectiveCameraParameters(targetFov, aspect, ortho.NearZ, ortho.FarZ)
- L201 C16: new XRPerspectiveCameraParameters :: => new XRPerspectiveCameraParameters();


## XRENGINE/Rendering/Camera/XRPhysicalCameraParameters.cs
- L227 C20: new Frustum :: return new Frustum(invProj);
- L268 C20: new Vector2 :: return new Vector2(width, height);
- L289 C24: new XRPhysicalCameraParameters :: return new XRPhysicalCameraParameters();
- L293 C24: new XRPhysicalCameraParameters :: return new XRPhysicalCameraParameters(
- L313 C20: new XRPhysicalCameraParameters :: return new XRPhysicalCameraParameters(
- L324 C16: new XRPhysicalCameraParameters :: => new XRPhysicalCameraParameters();


## XRENGINE/Rendering/Commands/GPUIndirectRenderCommand.cs
- L49 C33: new Vector4 :: => BoundingSphere = new Vector4(center, radius);
- L52 C16: new() :: => new()
- L70 C16: new() :: => new()
- L81 C16: new() :: => new()


## XRENGINE/Rendering/Commands/GPURendering/Validation/GpuBackendParityValidator.cs
- L43 C30: new GpuCommandSignature :: var signatures = new GpuCommandSignature[targetSamples];
- L47 C33: new GpuCommandSignature :: signatures[i] = new GpuCommandSignature(command.MeshID, command.MaterialID, command.RenderPass);
- L50 C20: new GpuBackendParitySnapshot :: return new GpuBackendParitySnapshot(backendName, visibleCount, drawCount, signatures);


## XRENGINE/Rendering/Commands/GPURenderPassCollection.Core.cs
- L38 C23: new InvalidOperationException :: throw new InvalidOperationException(
- L152 C72: new() :: private static readonly IndirectDebugSettings _indirectDebug = new();
- L404 C39: new() :: private readonly Lock _lock = new();
- L571 C66: new() :: private readonly HybridRenderingManager _renderManager = new() { UseMeshletPipeline = false };


## XRENGINE/Rendering/Commands/GPURenderPassCollection.CullingAndSoA.cs
- L100 C23: new InvalidOperationException :: throw new InvalidOperationException("ReadUints failed - buffer mapped address is null");
- L143 C23: new InvalidOperationException :: throw new InvalidOperationException("WriteUints failed - buffer mapped address is null");
- L181 C27: new InvalidOperationException :: throw new InvalidOperationException("ReadUIntAt failed - buffer mapped address is null");
- L217 C23: new InvalidOperationException :: throw new InvalidOperationException("WriteUIntAt failed - buffer mapped address is null");
- L249 C27: new InvalidOperationException :: throw new InvalidOperationException("ReadUInt failed - buffer mapped address is null");
- L280 C27: new InvalidOperationException :: throw new InvalidOperationException("WriteUInt failed - buffer mapped address is null");
- L347 C42: new XRDataBuffer :: _passFilterDebugBuffer = new XRDataBuffer("PassFilterDebug", EBufferTarget.ShaderStorageBuffer, requiredElements, EComponentType.UInt, 1, false, true)
- L397 C26: new StringBuilder :: var sb = new StringBuilder();
- L826 C32: new Vector4 :: Vector4[] result = new Vector4[6];
- L830 C29: new Vector4 :: result[i] = new Vector4(plane.Normal.X, plane.Normal.Y, plane.Normal.Z, plane.D);
- L1369 C26: new StringBuilder :: var sb = new StringBuilder();
- L1395 C26: new StringBuilder :: var sb = new StringBuilder();
- L1477 C31: new SoftIssueInfo :: map[reason] = new SoftIssueInfo
- L1510 C35: new List :: var invalidCommands = new List<(uint index, GPUIndirectRenderCommand command, string reason)>();
- L1511 C30: new Dictionary :: var softIssues = new Dictionary<string, SoftIssueInfo>(StringComparer.OrdinalIgnoreCase);
- L1512 C38: new HashSet :: var missingMaterialIds = new HashSet<uint>();
- L1628 C30: new List :: var signatures = new List<(uint MeshId, uint MaterialId, uint Pass)>(Math.Min((int)copyCount, ValidationSignatureLogLimit));
- L1646 C30: new List :: var signatures = new List<(uint MeshId, uint MaterialId, uint Pass)>(Math.Min((int)gpuVisibleCount, ValidationSignatureLogLimit));
- L1672 C26: new HashSet :: var cpuSet = new HashSet<(uint MeshId, uint MaterialId, uint Pass)>(cpu);
- L1673 C26: new HashSet :: var gpuSet = new HashSet<(uint MeshId, uint MaterialId, uint Pass)>(gpu);
- L1682 C26: new StringBuilder :: var sb = new StringBuilder();
- L1690 C26: new StringBuilder :: var sb = new StringBuilder();
- L1742 C22: new StringBuilder :: var sb = new StringBuilder();
- L1747 C36: new Dictionary :: var reasonCounts = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
- L1777 C22: new StringBuilder :: var sb = new StringBuilder();
- L1789 C25: new List :: var parts = new List<string>(softIssues.Count);
- L1850 C22: new StringBuilder :: var sb = new StringBuilder();


## XRENGINE/Rendering/Commands/GPURenderPassCollection.IndirectAndMaterials.cs
- L519 C31: new List :: var batches = new List<HybridRenderingManager.DrawBatch>((int)batchCount);
- L530 C37: new HybridRenderingManager.DrawBatch :: batches.Add(new HybridRenderingManager.DrawBatch(range.DrawOffset, range.DrawCount, range.MaterialID));
- L552 C32: new GPUMaterialTable :: _materialTable ??= new GPUMaterialTable(128);
- L610 C24: new GPUMaterialEntry :: return new GPUMaterialEntry { Flags = flags };
- L638 C20: new GPUMaterialEntry :: return new GPUMaterialEntry
- L706 C27: new List :: var batches = new List<HybridRenderingManager.DrawBatch>((int)Math.Min(count, 64));
- L719 C57: new MappedBufferScope :: => _culledSceneToRenderBuffer is not null ? new MappedBufferScope(_culledSceneToRenderBuffer) : default;
- L777 C38: new MaterialSortEntry :: sortEntries[i] = new MaterialSortEntry(i, materialId);
- L812 C33: new HybridRenderingManager.DrawBatch :: batches.Add(new HybridRenderingManager.DrawBatch(batchStartIndex, batchCount, currentMaterial));
- L821 C33: new HybridRenderingManager.DrawBatch :: batches.Add(new HybridRenderingManager.DrawBatch(batchStartIndex, batchCount, currentMaterial));
- L909 C33: new HybridRenderingManager.DrawBatch :: batches.Add(new HybridRenderingManager.DrawBatch(batchStart, batchCount, currentMaterial));
- L917 C29: new HybridRenderingManager.DrawBatch :: batches.Add(new HybridRenderingManager.DrawBatch(batchStart, batchCount, currentMaterial));
- L1112 C25: new GpuRenderStats :: var stats = new GpuRenderStats(values);
- L1156 C22: new StringBuilder :: var sb = new StringBuilder($"BuildMaterialBatches produced {batches.Count} batches:");


## XRENGINE/Rendering/Commands/GPURenderPassCollection.Occlusion.cs
- L27 C114: new() :: private static readonly ConditionalWeakTable<XRRenderPipelineInstance, HiZSharedState> _hiZSharedCache = new();
- L34 C89: new() :: private static readonly AsyncOcclusionQueryManager s_cpuOcclusionQueryManager = new();
- L36 C77: new() :: private readonly Dictionary<uint, bool> _cpuOcclusionLastResolved = new();
- L272 C77: new HiZSharedState :: var shared = _hiZSharedCache.GetValue(pipeline, static _ => new HiZSharedState());
- L362 C24: new Mipmap2D :: var mips = new Mipmap2D[_hiZMaxMip + 1];
- L367 C27: new Mipmap2D :: mips[i] = new Mipmap2D(w, h, EPixelInternalFormat.Rgba32f, EPixelFormat.Rgba, EPixelType.Float, allocateData: false);
- L372 C37: new XRTexture2D :: _hiZDepthPyramidOwned = new XRTexture2D
- L415 C24: new Mipmap2D :: var mips = new Mipmap2D[maxMip + 1];
- L420 C27: new Mipmap2D :: mips[i] = new Mipmap2D(w, h, EPixelInternalFormat.Rgba32f, EPixelFormat.Rgba, EPixelType.Float, allocateData: false);
- L425 C30: new XRTexture2D :: shared.Pyramid = new XRTexture2D
- L448 C53: new IVector2 :: _hiZInitProgram.Uniform("mipLevelSize", new IVector2((int)_hiZDepthPyramid.Mipmaps[0].Width, (int)_hiZDepthPyramid.Mipmaps[0].Height));
- L469 C56: new IVector2 :: _hiZGenProgram.Uniform("mipLevelSize", new IVector2((int)mip.Width, (int)mip.Height));


## XRENGINE/Rendering/Commands/GPURenderPassCollection.ShadersAndInit.cs
- L151 C37: new XRRenderProgram :: _cullingComputeShader = new XRRenderProgram(true, false, ShaderHelper.LoadEngineShader("Compute/Culling/GPURenderCulling.comp", EShaderType.Compute));
- L152 C39: new XRRenderProgram :: _buildKeysComputeShader = new XRRenderProgram(true, false, ShaderHelper.LoadEngineShader("Compute/Indirect/GPURenderBuildKeys.comp", EShaderType.Compute));
- L153 C45: new XRRenderProgram :: _buildGpuBatchesComputeShader = new XRRenderProgram(true, false, ShaderHelper.LoadEngineShader("Compute/Indirect/GPURenderBuildBatches.comp", EShaderType.Compute));
- L155 C41: new XRRenderProgram :: _indirectRenderTaskShader = new XRRenderProgram(true, false, ShaderHelper.LoadEngineShader("Compute/Indirect/GPURenderIndirect.comp", EShaderType.Compute));
- L156 C40: new XRRenderProgram :: _buildHotCommandsProgram = new XRRenderProgram(true, false, ShaderHelper.LoadEngineShader("Compute/Indirect/GPURenderBuildHotCommands.comp", EShaderType.Compute));
- L157 C43: new XRRenderProgram :: _resetCountersComputeShader = new XRRenderProgram(true, false, ShaderHelper.LoadEngineShader("Compute/Indirect/GPURenderResetCounters.comp", EShaderType.Compute));
- L158 C40: new XRRenderProgram :: _extractSoAComputeShader = new XRRenderProgram(true, false, ShaderHelper.LoadEngineShader("Compute/Culling/GPURenderExtractSoA.comp", EShaderType.Compute));
- L159 C40: new XRRenderProgram :: _soACullingComputeShader = new XRRenderProgram(true, false, ShaderHelper.LoadEngineShader("Compute/Culling/GPURenderCullingSoA.comp", EShaderType.Compute));
- L162 C36: new XRRenderProgram :: _copyCommandsProgram = new XRRenderProgram(true, false, ShaderHelper.LoadEngineShader("Compute/Indirect/GPURenderCopyCommands.comp", EShaderType.Compute));
- L163 C38: new XRRenderProgram :: _bvhFrustumCullProgram = new XRRenderProgram(true, false, ShaderHelper.LoadEngineShader("Scene3D/RenderPipeline/bvh_frustum_cull.comp", EShaderType.Compute));
- L166 C31: new XRRenderProgram :: _hiZInitProgram = new XRRenderProgram(true, false, ShaderHelper.LoadEngineShader("Compute/Occlusion/GPURenderHiZInit.comp", EShaderType.Compute));
- L167 C30: new XRRenderProgram :: _hiZGenProgram = new XRRenderProgram(true, false, ShaderHelper.LoadEngineShader("Compute/Occlusion/HiZGen.comp", EShaderType.Compute));
- L168 C36: new XRRenderProgram :: _hiZOcclusionProgram = new XRRenderProgram(true, false, ShaderHelper.LoadEngineShader("Compute/Occlusion/GPURenderOcclusionHiZ.comp", EShaderType.Compute));
- L169 C34: new XRRenderProgram :: _copyCount3Program = new XRRenderProgram(true, false, ShaderHelper.LoadEngineShader("Compute/Indirect/GPURenderCopyCount3.comp", EShaderType.Compute));
- L229 C59: new[] :: => scene.IndirectFaceIndices?.SelectMany(x => new[] { x.Point0, x.Point1, x.Point2 }).ToArray();
- L239 C23: new XRDataBuffer :: var buf = new XRDataBuffer(EBufferTarget.ElementArrayBuffer, true)
- L271 C33: new XRMeshRenderer :: _indirectRenderer = new XRMeshRenderer();
- L421 C40: new XRDataBuffer :: _sortedCommandBuffer = new XRDataBuffer("SortedCommands_Pass", EBufferTarget.ShaderStorageBuffer, capacity, EComponentType.Float, 32, false, false)
- L449 C42: new XRDataBuffer :: _occlusionCulledBuffer = new XRDataBuffer(
- L507 C39: new XRDataBuffer :: _indirectDrawBuffer = new XRDataBuffer("IndirectDraw_Pass", EBufferTarget.DrawIndirectBuffer, capacity, EComponentType.UInt, _indirectCommandComponentCount, false, true)
- L543 C26: new XRDataBuffer :: buffer = new XRDataBuffer(name, EBufferTarget.ParameterBuffer, elementCount, EComponentType.UInt, componentCount, false, true)
- L593 C26: new XRDataBuffer :: buffer = new XRDataBuffer(name, EBufferTarget.ShaderStorageBuffer, 1, EComponentType.UInt, 1, false, true)
- L643 C32: new XRDataBuffer :: _statsBuffer = new XRDataBuffer("RenderStats", EBufferTarget.ShaderStorageBuffer, requiredElements, EComponentType.UInt, 1, false, true)
- L653 C41: new uint :: _statsBuffer.SetDataRaw(new uint[requiredElements], (int)requiredElements);
- L766 C40: new XRDataBuffer :: _soaBoundingSpheresA = new XRDataBuffer("SoA_Spheres_A", EBufferTarget.ShaderStorageBuffer, capacity, EComponentType.Float, sphereStride, false, false)
- L776 C33: new XRDataBuffer :: _soaMetadataA = new XRDataBuffer("SoA_Metadata_A", EBufferTarget.ShaderStorageBuffer, capacity, EComponentType.UInt, metaStride, false, false)
- L786 C40: new XRDataBuffer :: _soaBoundingSpheresB = new XRDataBuffer("SoA_Spheres_B", EBufferTarget.ShaderStorageBuffer, capacity, EComponentType.Float, sphereStride, false, false)
- L796 C33: new XRDataBuffer :: _soaMetadataB = new XRDataBuffer("SoA_Metadata_B", EBufferTarget.ShaderStorageBuffer, capacity, EComponentType.UInt, metaStride, false, false)
- L812 C29: new XRDataBuffer :: _soaIndexList = new XRDataBuffer("SoA_IndexList", EBufferTarget.ShaderStorageBuffer, capacity + 1, EComponentType.UInt, 1, false, true)
- L827 C38: new XRDataBuffer :: _materialIDsBuffer = new XRDataBuffer("MaterialIDs", EBufferTarget.ShaderStorageBuffer, capacity, EComponentType.UInt, 1, false, true)
- L862 C42: new XRDataBuffer :: _keyIndexScratchBuffer = new XRDataBuffer(
- L892 C36: new XRDataBuffer :: _keyIndexBufferA = new XRDataBuffer(
- L922 C40: new XRDataBuffer :: _gpuBatchRangeBuffer = new XRDataBuffer(
- L951 C36: new XRDataBuffer :: _gpuBatchCountBuffer = new XRDataBuffer(
- L979 C44: new XRDataBuffer :: _instanceTransformBuffer = new XRDataBuffer(
- L1003 C46: new XRDataBuffer :: _instanceSourceIndexBuffer = new XRDataBuffer(
- L1031 C46: new XRDataBuffer :: _materialAggregationBuffer = new XRDataBuffer(


## XRENGINE/Rendering/Commands/GPURenderPassCollection.ViewSet.cs
- L12 C63: new XRDataBuffer :: private readonly XRDataBuffer?[] _viewConstantsRing = new XRDataBuffer?[ViewConstantsRingSize];
- L42 C23: new ArgumentException :: throw new ArgumentException(
- L49 C23: new ArgumentOutOfRangeException :: throw new ArgumentOutOfRangeException(
- L171 C20: new GPUViewMask :: return new GPUViewMask(bitsLo, bitsHi);
- L343 C26: new XRDataBuffer :: var buffer = new XRDataBuffer(name, EBufferTarget.ShaderStorageBuffer, elementCount, EComponentType.Struct, strideBytes, false, false)
- L358 C26: new XRDataBuffer :: var buffer = new XRDataBuffer(name, EBufferTarget.ShaderStorageBuffer, elementCount, EComponentType.UInt, 1, false, true)
- L432 C23: new InvalidOperationException :: throw new InvalidOperationException($"Active view count {_activeViewCount} exceeds view set capacity {_viewSetCapacity}.");
- L435 C23: new InvalidOperationException :: throw new InvalidOperationException($"Cached view descriptor count {_cachedViewDescriptorCount} is smaller than active view count {_activeViewCount}.");
- L438 C23: new InvalidOperationException :: throw new InvalidOperationException($"Indirect source view {_indirectSourceViewId} is outside active view range [0, {_activeViewCount - 1u}].");
- L441 C23: new InvalidOperationException :: throw new InvalidOperationException("Per-view draw count buffer is missing or undersized for active view count.");
- L447 C23: new InvalidOperationException :: throw new InvalidOperationException(
- L456 C27: new InvalidOperationException :: throw new InvalidOperationException($"View descriptor index {i} has mismatched ViewId {descriptor.ViewId}.");
- L460 C27: new InvalidOperationException :: throw new InvalidOperationException(
- L465 C27: new InvalidOperationException :: throw new InvalidOperationException($"View {i} has zero visible capacity.");
- L470 C27: new InvalidOperationException :: throw new InvalidOperationException(
- L475 C27: new InvalidOperationException :: throw new InvalidOperationException($"View {i} has an empty render pass mask.");


## XRENGINE/Rendering/Commands/GPUScene.cs
- L237 C82: new() :: private readonly ConcurrentDictionary<XRMaterial, uint> _materialIDMap = new();
- L240 C81: new() :: private readonly ConcurrentDictionary<uint, XRMaterial> _idToMaterial = new();
- L243 C73: new() :: private readonly ConcurrentDictionary<uint, XRMesh> _idToMesh = new();
- L413 C33: new XRDataBuffer :: _atlasPositions ??= new XRDataBuffer(ECommonBufferType.Position.ToString(), EBufferTarget.ArrayBuffer, 0, EComponentType.Float, 3, false, false)
- L420 C31: new XRDataBuffer :: _atlasNormals ??= new XRDataBuffer(ECommonBufferType.Normal.ToString(), EBufferTarget.ArrayBuffer, 0, EComponentType.Float, 3, false, false)
- L427 C32: new XRDataBuffer :: _atlasTangents ??= new XRDataBuffer(ECommonBufferType.Tangent.ToString(), EBufferTarget.ArrayBuffer, 0, EComponentType.Float, 4, false, false)
- L434 C27: new XRDataBuffer :: _atlasUV0 ??= new XRDataBuffer($"{ECommonBufferType.TexCoord}0", EBufferTarget.ArrayBuffer, 0, EComponentType.Float, 2, false, false)
- L441 C31: new XRDataBuffer :: _atlasIndices ??= new XRDataBuffer("MeshAtlas_Indices", EBufferTarget.ElementArrayBuffer, 0, EComponentType.UInt, 1, false, true)
- L482 C35: new Vector3 :: Vector3[] positions = new Vector3[vertexCount];
- L483 C33: new Vector3 :: Vector3[] normals = new Vector3[vertexCount];
- L484 C34: new Vector4 :: Vector4[] tangents = new Vector4[vertexCount];
- L485 C29: new Vector2 :: Vector2[] uv0 = new Vector2[vertexCount];
- L491 C31: new Vector4 :: tangents[v] = new Vector4(tan, 1.0f);
- L502 C46: new IndexTriangle :: _indirectFaceIndices.Add(new IndexTriangle(
- L523 C46: new IndexTriangle :: _indirectFaceIndices.Add(new IndexTriangle(
- L717 C39: new() :: MeshDataEntry entry = new()
- L795 C23: new AABB :: _bounds = new AABB();
- L888 C26: new XRDataBuffer :: var buffer = new XRDataBuffer(
- L909 C26: new XRDataBuffer :: var buffer = new XRDataBuffer(
- L961 C74: new() :: private readonly ConcurrentDictionary<XRMesh, uint> _meshIDMap = new();
- L967 C39: new() :: private readonly Lock _lock = new();
- L970 C82: new() :: private readonly ConcurrentDictionary<XRMesh, string> _meshDebugLabels = new();
- L973 C90: new() :: private readonly ConcurrentDictionary<XRMesh, string> _unsupportedMeshMessages = new();
- L1021 C56: new() :: private readonly MeshletCollection _meshlets = new();
- L1145 C35: new List :: indices = new List<uint>(subMeshes.Length);
- L1400 C35: new() :: MeshDataEntry entry = new()
- L1743 C30: new GPUIndirectRenderCommand :: var gpuCommand = new GPUIndirectRenderCommand
- L2298 C29: new GpuBvhTree :: _gpuBvhTree ??= new GpuBvhTree();
- L2307 C38: new XRDataBuffer :: _commandAabbBuffer = new XRDataBuffer(
- L2335 C35: new XRRenderProgram :: _commandAabbProgram = new XRRenderProgram(true, false, _commandAabbShader);


## XRENGINE/Rendering/Commands/GPUViewSet.cs
- L36 C24: new GPUViewMask :: return new GPUViewMask(0u, 0u);
- L52 C20: new GPUViewMask :: return new GPUViewMask(lo, hi);
- L135 C23: new InvalidOperationException :: throw new InvalidOperationException(
- L141 C23: new InvalidOperationException :: throw new InvalidOperationException(
- L147 C23: new InvalidOperationException :: throw new InvalidOperationException(


## XRENGINE/Rendering/Commands/RenderCommandCollection.cs
- L30 C91: new() :: private static readonly CpuRenderOcclusionCoordinator s_cpuOcclusionCoordinator = new();
- L38 C138: new SortedSet :: _updatingPasses = passIndicesAndSorters.ToDictionary(x => x.Key, x => x.Value is null ? [] : (ICollection<RenderCommand>)new SortedSet<RenderCommand>(x.Value));
- L73 C39: new GPURenderPassCollection :: var gpuPass = new GPURenderPassCollection(pass.Key);
- L79 C51: new RenderPassMetadata :: _passMetadata[pass.Key] = new RenderPassMetadata(pass.Key, $"Pass{pass.Key}", ERenderGraphPassStage.Graphics);
- L103 C39: new() :: private readonly Lock _lock = new();
- L336 C55: new Vector4 :: descriptors[(int)cursor].FoveationA = new Vector4(
- L340 C55: new Vector4 :: descriptors[(int)cursor].FoveationB = new Vector4(
- L360 C59: new Vector4 :: descriptors[(int)cursor].FoveationA = new Vector4(
- L364 C59: new Vector4 :: descriptors[(int)cursor].FoveationB = new Vector4(
- L397 C23: new InvalidOperationException :: throw new InvalidOperationException(
- L409 C27: new InvalidOperationException :: throw new InvalidOperationException($"View descriptor order mismatch at index {i}; found ViewId={descriptor.ViewId}.");
- L413 C27: new InvalidOperationException :: throw new InvalidOperationException(
- L419 C27: new InvalidOperationException :: throw new InvalidOperationException(
- L457 C20: new GPUViewDescriptor :: return new GPUViewDescriptor
- L484 C20: new GPUViewConstants :: return new GPUViewConstants
- L490 C41: new Vector4 :: CameraPositionAndNear = new Vector4(cameraPos, camera.NearZ),
- L491 C39: new Vector4 :: CameraForwardAndFar = new Vector4(cameraForward, camera.FarZ)


## XRENGINE/Rendering/Compute/BvhGpuProfiler.cs
- L14 C58: new() :: public static BvhGpuProfiler Instance { get; } = new();
- L135 C41: new() :: private readonly object _lock = new();
- L136 C60: new() :: private readonly Queue<XRRenderQuery> _queryPool = new();
- L199 C20: new TimingHandle :: return new TimingHandle(stage, workCount, start, gl);
- L212 C30: new PendingQuery :: _pending.Add(new PendingQuery(handle.Stage, handle.WorkCount, handle.StartQuery, end));
- L237 C71: new XRRenderQuery :: query = _queryPool.Count > 0 ? _queryPool.Dequeue() : new XRRenderQuery();
- L243 C26: new InvalidOperationException :: ?? throw new InvalidOperationException("Failed to acquire GLRenderQuery wrapper.");


## XRENGINE/Rendering/Compute/BvhRaycastDispatcher.cs
- L26 C76: new() :: private readonly ConcurrentQueue<BvhRaycastRequest> _pendingRequests = new();
- L27 C76: new() :: private readonly ConcurrentQueue<BvhRaycastResult> _completedResults = new();
- L28 C68: new() :: private readonly ConcurrentQueue<Action> _completedCallbacks = new();
- L120 C26: new BvhRaycastResult :: var result = new BvhRaycastResult(entry.Request, hits, raw);
- L236 C23: new InFlightRaycast :: _inFlight.Add(new InFlightRaycast(request, fence, clampedBytes));
- L243 C60: new XRRenderProgram :: BvhRaycastVariant.AnyHit => _anyHitProgram ??= new XRRenderProgram(true, false, _anyHitShader ??= ShaderHelper.LoadEngineShader("Compute/BVH/bvh_anyhit.comp", EShaderType.Compute)),
- L244 C68: new XRRenderProgram :: BvhRaycastVariant.ClosestHit => _closestHitProgram ??= new XRRenderProgram(true, false, _closestHitShader ??= ShaderHelper.LoadEngineShader("Compute/BVH/bvh_closesthit.comp", EShaderType.Compute)),
- L245 C38: new XRRenderProgram :: _ => _raycastProgram ??= new XRRenderProgram(true, false, _raycastShader ??= ShaderHelper.LoadEngineShader("Compute/BVH/bvh_raycast.comp", EShaderType.Compute))
- L274 C23: new byte :: byte[] data = new byte[byteLength];


## XRENGINE/Rendering/Compute/GlobalAnimationInputBuffers.cs
- L86 C21: new Entry :: entry = new Entry();
- L199 C35: new XRDataBuffer :: _globalBoneMatrices = new XRDataBuffer(
- L219 C42: new XRDataBuffer :: _globalBoneInvBindMatrices = new XRDataBuffer(
- L247 C40: new XRDataBuffer :: _globalBlendshapeWeights = new XRDataBuffer(


## XRENGINE/Rendering/Compute/GpuBvhTree.cs
- L40 C41: new() :: private readonly object _syncRoot = new();
- L181 C29: new Vector3 :: sceneMin -= new Vector3(0.5f);
- L182 C29: new Vector3 :: sceneMax += new Vector3(0.5f);
- L296 C22: new XRDataBuffer :: buffer = new XRDataBuffer(name, EBufferTarget.ShaderStorageBuffer, scalarCount, EComponentType.UInt, 1, false, true)
- L322 C31: new uint :: buffer.SetDataRaw(new uint[count], (int)count);
- L400 C31: new XRDataBuffer :: _overflowFlagBuffer = new XRDataBuffer("GpuBvhTree.OverflowFlag", EBufferTarget.ShaderStorageBuffer, 1, EComponentType.UInt, 1, false, true)
- L411 C40: new uint :: _overflowFlagBuffer.SetDataRaw(new uint[] { 0u }, 1);
- L422 C44: new uint :: _overflowFlagBuffer.SetDataRaw(new uint[] { 0u }, 1);
- L488 C32: new() :: List<string> reasons = new();
- L606 C16: new XRRenderProgram :: return new XRRenderProgram(true, false, shader);


## XRENGINE/Rendering/Compute/GPUPhysicsChainDispatcher.cs
- L23 C71: new GPUPhysicsChainDispatcher :: public static GPUPhysicsChainDispatcher Instance => _instance ??= new GPUPhysicsChainDispatcher();
- L29 C96: new() :: private readonly ConcurrentDictionary<int, GPUPhysicsChainRequest> _registeredComponents = new();
- L144 C23: new GPUPhysicsChainRequest :: var request = new GPUPhysicsChainRequest(component);
- L285 C31: new XRRenderProgram :: _mainPhysicsProgram = new XRRenderProgram(true, false, _mainPhysicsShader);
- L286 C30: new XRRenderProgram :: _skipUpdateProgram = new XRRenderProgram(true, false, _skipUpdateShader);
- L364 C22: new XRDataBuffer :: buffer = new XRDataBuffer(name, EBufferTarget.ShaderStorageBuffer, elementCount, EComponentType.Float, componentCount, false, false);
- L393 C46: new Vector4 :: _mainPhysicsProgram.Uniform("Force", new Vector4(firstReq.Force, 0));
- L394 C48: new Vector4 :: _mainPhysicsProgram.Uniform("Gravity", new Vector4(firstReq.Gravity, 0));
- L395 C69: new Vector4 :: _mainPhysicsProgram.Uniform("ObjectMove", applyObjectMove ? new Vector4(firstReq.ObjectMove, 0) : Vector4.Zero);
- L417 C50: new Vector4 :: _skipUpdateProgram.Uniform("ObjectMove", new Vector4(firstReq.ObjectMove, 0));
- L450 C29: new GPUParticleData :: _readbackData = new GPUParticleData[TotalParticleCount];
- L515 C27: new ArraySegment :: var segment = new ArraySegment<GPUParticleData>(_readbackData, start, count);


## XRENGINE/Rendering/Compute/MeshSDFExample.cs
- L20 C38: new MeshSDFGenerator :: using var sdfGenerator = new MeshSDFGenerator();
- L27 C30: new IVector3 :: var resolution = new IVector3(128, 128, 128);
- L54 C38: new MeshSDFGenerator :: using var sdfGenerator = new MeshSDFGenerator();
- L60 C30: new IVector3 :: var resolution = new IVector3(256, 256, 256);
- L81 C38: new MeshSDFGenerator :: using var sdfGenerator = new MeshSDFGenerator();
- L87 C30: new IVector3 :: var resolution = new IVector3(512, 512, 512);
- L108 C31: new XRTexture3D :: var sdfTextures = new XRTexture3D[3];
- L111 C38: new MeshSDFGenerator :: using var sdfGenerator = new MeshSDFGenerator();
- L117 C31: new[] :: var resolutions = new[]
- L119 C17: new IVector3 :: new IVector3(64, 64, 64),   // Low resolution for distant objects
- L120 C17: new IVector3 :: new IVector3(128, 128, 128), // Medium resolution for normal distance
- L121 C17: new IVector3 :: new IVector3(256, 256, 256)  // High resolution for close objects
- L149 C32: new MeshSDFGenerator :: var sdfGenerator = new MeshSDFGenerator();


## XRENGINE/Rendering/Compute/MeshSDFGenerator.cs
- L105 C35: new XRRenderProgram :: _computeProgram = new XRRenderProgram(true, false, _meshSDFShader);
- L229 C30: new AABB :: var bounds = new AABB(minBounds, maxBounds);
- L252 C33: new Vector3 :: var paddingVector = new Vector3(padding);
- L253 C20: new AABB :: return new AABB(
- L265 C27: new XRTexture3D :: _sdfTexture = new XRTexture3D((uint)resolution.X, (uint)resolution.Y, (uint)resolution.Z) { Resizable = false };
- L274 C96: new InvalidOperationException :: var positionsBuffer = mesh.Buffers[ECommonBufferType.Position.ToString()] ?? throw new InvalidOperationException("Mesh does not have position buffer");
- L283 C128: new InvalidOperationException :: var indexBuffer = mesh.GetIndexBuffer(EPrimitiveType.Triangles, out _, EBufferTarget.ShaderStorageBuffer) ?? throw new InvalidOperationException("Mesh does not have index buffer");
- L311 C32: new List :: var spatialNodes = new List<Vector4>();
- L312 C34: new List :: var triangleToNode = new List<uint>();
- L330 C34: new Vector4 :: spatialNodes.Add(new Vector4(center, radius));
- L336 C35: new XRDataBuffer :: _spatialNodesBuffer = new XRDataBuffer("SpatialNodes", EBufferTarget.ShaderStorageBuffer, (uint)spatialNodes.Count, EComponentType.Float, 4, false, false);
- L342 C37: new XRDataBuffer :: _triangleToNodeBuffer = new XRDataBuffer("TriangleToNode", EBufferTarget.ShaderStorageBuffer, (uint)triangleToNode.Count, EComponentType.UInt, 1, false, false);
- L354 C23: new InvalidOperationException :: throw new InvalidOperationException("Compute program or SDF texture not initialized");


## XRENGINE/Rendering/Compute/SkinnedMeshBoundsCalculator.cs
- L18 C85: new SkinnedMeshBoundsCalculator :: private static readonly Lazy<SkinnedMeshBoundsCalculator> _instance = new(() => new SkinnedMeshBoundsCalculator());
- L22 C41: new() :: private readonly object _syncRoot = new();
- L124 C34: new Vector3 :: var localPositions = new Vector3[worldPositions.Length];
- L129 C22: new Result :: result = new Result(localPositions, bounds, basis);
- L140 C20: new XRRenderProgram :: _program = new XRRenderProgram(true, false, _shader);
- L176 C16: new AABB :: return new AABB(min, max);
- L223 C81: new Vector4 :: private static readonly UInt4 PositiveInfinityPacked = UInt4.FromVector(new Vector4(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity, 1f));
- L224 C81: new Vector4 :: private static readonly UInt4 NegativeInfinityPacked = UInt4.FromVector(new Vector4(float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity, -1f));
- L238 C32: new XRDataBuffer :: _outputPositions = new XRDataBuffer($"{meshName}_SkinnedBoundsOutput", EBufferTarget.ShaderStorageBuffer, (uint)Math.Max(1, mesh.VertexCount), EComponentType.Float, 4, false, false)
- L243 C23: new XRDataBuffer :: _bounds = new XRDataBuffer($"{meshName}_SkinnedBoundsReduction", EBufferTarget.ShaderStorageBuffer, 2, EComponentType.UInt, 4, false, false)
- L276 C25: new Vector3 :: positions = new Vector3[vertexCount];
- L289 C36: new Vector3 :: positions[i] = new Vector3(v.X, v.Y, v.Z);
- L323 C22: new AABB :: bounds = new AABB(min, max);
- L356 C20: new() :: => new()


## XRENGINE/Rendering/Compute/SkinnedMeshBvhScheduler.cs
- L22 C63: new() :: public static SkinnedMeshBvhScheduler Instance { get; } = new();
- L35 C99: new() :: private readonly ConditionalWeakTable<RenderableMesh, SkinnedBvhRefitCache> _cpuRefitCaches = new();
- L43 C19: new TaskCompletionSource :: var tcs = new TaskCompletionSource<Result>(TaskCreationOptions.RunContinuationsAsynchronously);
- L57 C19: new TaskCompletionSource :: var tcs = new TaskCompletionSource<Result>(TaskCreationOptions.RunContinuationsAsynchronously);
- L64 C52: new SkinnedMeshBoundsCalculator.Result :: var localized = mesh.EnsureLocalBounds(new SkinnedMeshBoundsCalculator.Result(positions, bounds, basis));
- L65 C30: new Result :: tcs.TrySetResult(new Result(version, null, localized));
- L69 C51: new SkinnedMeshBoundsCalculator.Result :: var boundsResult = mesh.EnsureLocalBounds(new SkinnedMeshBoundsCalculator.Result(positions, bounds, basis));
- L74 C30: new Result :: tcs.TrySetResult(new Result(version, null, boundsResult));
- L103 C34: new Result :: tcs.TrySetResult(new Result(version, null, boundsResult));
- L110 C34: new Result :: tcs.TrySetResult(new Result(version, null, boundsResult));
- L136 C26: new Result :: tcs.TrySetResult(new Result(version, task.Result, boundsResult));
- L145 C30: new List :: var worldTriangles = new List<Triangle>(triangles.Count);
- L154 C36: new Triangle :: worldTriangles.Add(new Triangle(
- L161 C63: new BVH :: ? CacheSkinnedBvh(mesh, triangles, positions, new BVH<Triangle>(new TriangleAdapter(), worldTriangles))
- L161 C81: new TriangleAdapter :: ? CacheSkinnedBvh(mesh, triangles, positions, new BVH<Triangle>(new TriangleAdapter(), worldTriangles))
- L202 C66: new SkinnedBvhRefitCache :: var cache = Instance._cpuRefitCaches.GetValue(mesh, _ => new SkinnedBvhRefitCache());
- L223 C27: new Dictionary :: var triangleMap = new Dictionary<Triangle, Stack<int>>();
- L230 C28: new Triangle :: var triangle = new Triangle(
- L237 C24: new Stack :: list = new Stack<int>();
- L244 C21: new Stack :: var stack = new Stack<BVHNode<Triangle>>();
- L257 C27: new int :: var indices = new int[node.gobjects.Count];
- L267 C26: new LeafRef :: leafRefs.Add(new LeafRef(node, indices));
- L299 C31: new Triangle :: var updated = new Triangle(
- L315 C24: new AABB :: node.box = new AABB(min, max);
- L323 C21: new Stack :: var stack = new Stack<BVHNode<Triangle>>();
- L324 C25: new List :: var postOrder = new List<BVHNode<Triangle>>();
- L374 C35: new SkinnedMeshBoundsCalculator.Result :: => new(version, null, new SkinnedMeshBoundsCalculator.Result(Array.Empty<Vector3>(), default, Matrix4x4.Identity));


## XRENGINE/Rendering/Compute/SkinningPrepassDispatcher.cs
- L21 C83: new SkinningPrepassDispatcher :: private static readonly Lazy<SkinningPrepassDispatcher> _instance = new(() => new SkinningPrepassDispatcher());
- L24 C41: new() :: private readonly object _syncRoot = new();
- L25 C91: new() :: private readonly ConditionalWeakTable<XRMeshRenderer, RendererResources> _resources = new();
- L32 C66: new() :: private readonly GlobalAnimationInputBuffers _globalInputs = new();
- L128 C78: new RendererResources :: RendererResources resources = _resources.GetValue(renderer, r => new RendererResources(r));
- L211 C26: new HashSet :: var dispatched = new HashSet<XRMeshRenderer>(System.Collections.Generic.ReferenceEqualityComparer.Instance);
- L212 C25: new List :: var renderers = new List<XRMeshRenderer>();
- L265 C45: new XRRenderProgram :: _program = _shader is null ? null : new XRRenderProgram(true, false, _shader);
- L274 C67: new XRRenderProgram :: _interleavedProgram = _interleavedShader is null ? null : new XRRenderProgram(true, false, _interleavedShader);
- L367 C54: new XRDataBuffer :: _renderer.SkinnedInterleavedBuffer = new XRDataBuffer(
- L384 C52: new XRDataBuffer :: _renderer.SkinnedPositionsBuffer = new XRDataBuffer(
- L399 C54: new XRDataBuffer :: _renderer.SkinnedNormalsBuffer = new XRDataBuffer(
- L415 C55: new XRDataBuffer :: _renderer.SkinnedTangentsBuffer = new XRDataBuffer(


## XRENGINE/Rendering/DLSS/NvidiaDlssManager.cs
- L22 C94: new() :: private static readonly ConcurrentDictionary<XRViewport, float> _lastViewportScale = new();


## XRENGINE/Rendering/DLSS/StreamlineNative.cs
- L130 C45: new() :: StreamlineDlssOptions options = new()
- L160 C59: new() :: StreamlineViewportHandle viewportHandle = new()


## XRENGINE/Rendering/Generator/ShaderGenerator.cs
- L520 C28: new ArgumentOutOfRangeException :: _ => throw new ArgumentOutOfRangeException(nameof(type), type, null)


## XRENGINE/Rendering/Generator/ShaderGraph.cs
- L85 C22: new GLSLManager :: var parser = new GLSLManager();
- L87 C16: new ShaderGraph :: return new ShaderGraph(parser);
- L92 C20: new ShaderGraphNode :: var node = new ShaderGraphNode(NewId(), method.Name, ShaderGraphNodeKind.MethodInvocation)
- L102 C29: new ShaderGraphInput :: node.Inputs.Add(new ShaderGraphInput(param.Name, param.Type, null));
- L125 C34: new ShaderGraphEdge :: yield return new ShaderGraphEdge(from.Id, node.Id, input.Name, input.SourceVariable!);
- L132 C19: new HashSet :: var set = new HashSet<string>(StringComparer.Ordinal);
- L222 C16: new ShaderGraphNode :: return new ShaderGraphNode(NewId(), variable.Name, kind)
- L234 C24: new ShaderGraphNode :: var node = new ShaderGraphNode(NewId(), method.Name, ShaderGraphNodeKind.MethodDefinition)
- L242 C33: new ShaderGraphInput :: node.Inputs.Add(new ShaderGraphInput(param.Name, param.Type, null));
- L252 C24: new ShaderGraphNode :: var node = new ShaderGraphNode(NewId(), invocation.MethodName, ShaderGraphNodeKind.MethodInvocation)
- L265 C33: new ShaderGraphInput :: node.Inputs.Add(new ShaderGraphInput(inputName, inputType, arguments[i]));


## XRENGINE/Rendering/Generator/ShaderGraphGenerator.cs
- L14 C24: new XRMesh :: : base(mesh ?? new XRMesh())
- L16 C32: new ArgumentNullException :: Graph = graph ?? throw new ArgumentNullException(nameof(graph));


## XRENGINE/Rendering/Generator/VarNameGen.cs
- L8 C23: New() :: public string New()


## XRENGINE/Rendering/GI/LightVolumeRegistry.cs
- L12 C102: new() :: private static readonly Dictionary<XRWorldInstance, List<LightVolumeComponent>> s_perWorld = new();
- L13 C49: new() :: private static readonly object s_lock = new();
- L21 C28: new List :: list = new List<LightVolumeComponent>();


## XRENGINE/Rendering/GI/RadianceCascadeRegistry.cs
- L13 C49: new() :: private static readonly object s_lock = new();


## XRENGINE/Rendering/GI/RestirGI.cs
- L92 C19: new InvalidOperationException :: throw new InvalidOperationException("GL_NV_ray_tracing is not available on the current OpenGL device/context.");
- L106 C19: new InvalidOperationException :: throw new InvalidOperationException("Failed to bind the ReSTIR ray tracing pipeline.");
- L125 C19: new InvalidOperationException :: throw new InvalidOperationException("Failed to dispatch ReSTIR ray tracing rays.");
- L167 C20: new TraceParameters :: return new TraceParameters


## XRENGINE/Rendering/GpuDispatchLogger.cs
- L164 C93: new() :: private static readonly ConcurrentDictionary<string, long> _categoryMessageCounts = new();
- L165 C92: new() :: private static readonly ConcurrentDictionary<string, double> _timingAccumulators = new();
- L244 C22: new StringBuilder :: var sb = new StringBuilder(256);
- L260 C22: new StringBuilder :: var sb = new StringBuilder(256);
- L294 C22: new StringBuilder :: var sb = new StringBuilder(512);
- L600 C26: new StringBuilder :: var sb = new StringBuilder(512);
- L661 C26: new StringBuilder :: var sb = new StringBuilder(512);
- L815 C22: new StringBuilder :: var sb = new StringBuilder(256);
- L873 C22: new StringBuilder :: var sb = new StringBuilder(256);
- L939 C20: new TimingScope :: return new TimingScope(name);


## XRENGINE/Rendering/HybridRenderingManager.cs
- L113 C36: new XRRenderProgram :: _indirectCompProgram = new XRRenderProgram(
- L309 C31: new DrawBatch :: current = new DrawBatch(current.Offset, current.Count + next.Count, current.MaterialID);
- L614 C26: new StringBuilder :: var sb = new StringBuilder();
- L750 C34: new StringBuilder :: var sb = new StringBuilder();
- L1387 C31: new DrawElementsIndirectCommand :: var drawCmd = new DrawElementsIndirectCommand
- L1460 C30: new List :: var shaderList = new List<XRShader>(material.Shaders.Where(shader => shader is not null));
- L1496 C27: new XRRenderProgram :: var program = new XRRenderProgram(linkNow: false, separable: false, shaderList);
- L1506 C60: new MaterialProgramCache :: _materialPrograms[(materialID, rendererKey)] = new MaterialProgramCache(program, generatedVertexShader);
- L1516 C22: new StringBuilder :: var sb = new StringBuilder();
- L1662 C20: new XRShader :: return new XRShader(EShaderType.Vertex, sb.ToString())
- L1670 C22: new StringBuilder :: var sb = new StringBuilder();
- L1762 C20: new XRShader :: return new XRShader(EShaderType.Vertex, sb.ToString())
- L1831 C49: new XRDataBuffer :: _indirectTextTransformsBuffer = new XRDataBuffer(
- L1854 C48: new XRDataBuffer :: _indirectTextTexCoordsBuffer = new XRDataBuffer(
- L1879 C52: new XRDataBuffer :: _indirectTextRotationsBuffer = new XRDataBuffer(
- L1930 C27: new List :: var sources = new List<(uint culledIndex, uint glyphCount, XRDataBuffer transforms, XRDataBuffer texCoords, XRDataBuffer? rotations)>((int)batchCount);
- L2078 C27: new DefaultVertexShaderGenerator :: var gen = new DefaultVertexShaderGenerator(mesh)
- L2084 C31: new XRShader :: generatedVS = new XRShader(EShaderType.Vertex, vertexShaderSource)
- L2094 C31: new XRShader :: generatedVS = new XRShader(EShaderType.Vertex, fallbackSource)
- L2106 C22: new StringBuilder :: var sb = new StringBuilder();


## XRENGINE/Rendering/Info/RenderInfo2D.cs
- L27 C70: new RenderInfo2D :: => ConstructorOverride?.Invoke(owner, renderCommands) ?? new RenderInfo2D(owner, renderCommands);


## XRENGINE/Rendering/Info/RenderInfo3D.cs
- L23 C58: new RenderInfo3D :: => ConstructorOverride?.Invoke(owner, []) ?? new RenderInfo3D(owner);
- L25 C70: new RenderInfo3D :: => ConstructorOverride?.Invoke(owner, renderCommands) ?? new RenderInfo3D(owner, renderCommands);
- L28 C27: new RenderCommandMethod3D :: => New(owner, new RenderCommandMethod3D(renderPass, renderMethod));
- L30 C27: new RenderCommandMethod3D :: => New(owner, new RenderCommandMethod3D((int)renderPass, renderMethod));
- L33 C52: new RenderCommandMethod3D :: => New(owner, methods.Select((x, y) => new RenderCommandMethod3D(x.renderPass, x.renderMethod)).ToArray());
- L35 C52: new RenderCommandMethod3D :: => New(owner, methods.Select((x, y) => new RenderCommandMethod3D((int)x.renderPass, x.renderMethod)).ToArray());
- L38 C27: new RenderCommandMesh3D :: => New(owner, new RenderCommandMesh3D(renderPass, manager, worldMatrix, materialOverride));
- L40 C27: new RenderCommandMesh3D :: => New(owner, new RenderCommandMesh3D((int)renderPass, manager, worldMatrix, materialOverride));
- L43 C51: new RenderCommandMesh3D :: => New(owner, meshes.Select((x, y) => new RenderCommandMesh3D(x.renderPass, x.manager, x.worldMatrix, x.materialOverride)).ToArray());
- L45 C51: new RenderCommandMesh3D :: => New(owner, meshes.Select((x, y) => new RenderCommandMesh3D((int)x.renderPass, x.manager, x.worldMatrix, x.materialOverride)).ToArray());


## XRENGINE/Rendering/Lightmapping/LightmapBakeManager.cs
- L27 C76: new() :: private readonly ConcurrentQueue<LightComponent> _manualBakeRequests = new();
- L144 C27: new LightmapBakeRequest :: var request = new LightmapBakeRequest(
- L145 C34: new LayerMask :: StaticLayerMask: new LayerMask(1 << DefaultLayers.StaticIndex),
- L164 C20: new LightmapBakeResult :: return new LightmapBakeResult(
- L174 C20: new LightmapBakeResult :: return new LightmapBakeResult(
- L188 C31: new Transform :: XRCamera camera = new(new Transform());
- L189 C24: new XRRenderPipelineInstance :: var pipeline = new XRRenderPipelineInstance();
- L207 C24: new List :: var bakeList = new List<(LightmapBakeTarget Target, XRMeshRenderer Renderer)>();
- L217 C20: new LightmapBakeResult :: return new LightmapBakeResult(light, targets, ELightmapBakeStatus.Failed, "No valid mesh renderers found for bake targets.");
- L244 C25: new XRRenderBuffer :: var depth = new XRRenderBuffer((uint)page.Size, (uint)page.Size, ERenderBufferStorage.Depth24Stencil8);
- L247 C23: new XRFrameBuffer :: var fbo = new XRFrameBuffer();
- L276 C33: new Vector2 :: var scale = new Vector2(innerW * inv, innerH * inv);
- L277 C34: new Vector2 :: var offset = new Vector2(innerX * inv, innerY * inv);
- L278 C32: new BakedLightmapInfo :: var info = new BakedLightmapInfo(atlasTex, scale, offset, request.LightmapUvChannel, pageIndex);
- L291 C16: new LightmapBakeResult :: return new LightmapBakeResult(light, targets, ELightmapBakeStatus.Completed, null);
- L367 C19: new InvalidOperationException :: throw new InvalidOperationException($"Atlas too small: atlas={atlasSize}, tile={tileSize}, padding={padding}.");
- L369 C21: new List :: var pages = new List<AtlasPage>();
- L370 C21: new List :: var tiles = new List<AtlasTile>();
- L380 C27: new AtlasPage :: pages.Add(new AtlasPage(atlasSize, tiles));
- L401 C23: new AtlasTile :: tiles.Add(new AtlasTile(i, cursorX, cursorY, tileSize, padding));
- L406 C23: new AtlasPage :: pages.Add(new AtlasPage(atlasSize, tiles));
- L408 C16: new AtlasPackResult :: return new AtlasPackResult(pages);
- L583 C13: new ShaderInt :: new ShaderInt(0, ParamLightKind),
- L584 C13: new ShaderVector3 :: new ShaderVector3(Vector3.One, ParamLightColor),
- L585 C13: new ShaderFloat :: new ShaderFloat(1.0f, ParamLightIntensity),
- L586 C13: new ShaderVector3 :: new ShaderVector3(Vector3.Zero, ParamLightPosition),
- L587 C13: new ShaderVector3 :: new ShaderVector3(Globals.Forward, ParamLightDirection),
- L588 C13: new ShaderFloat :: new ShaderFloat(10.0f, ParamLightRadius),
- L589 C13: new ShaderFloat :: new ShaderFloat(1.0f, ParamLightBrightness),
- L590 C13: new ShaderFloat :: new ShaderFloat(0.9f, ParamSpotInnerCutoff),
- L591 C13: new ShaderFloat :: new ShaderFloat(0.8f, ParamSpotOuterCutoff),
- L592 C13: new ShaderFloat :: new ShaderFloat(1.0f, ParamSpotExponent),
- L594 C13: new ShaderInt :: new ShaderInt(0, ParamShadowsEnabled),
- L595 C13: new ShaderMat4 :: new ShaderMat4(Matrix4x4.Identity, ParamWorldToLightInvViewMatrix),
- L596 C13: new ShaderMat4 :: new ShaderMat4(Matrix4x4.Identity, ParamWorldToLightProjMatrix),
- L597 C13: new ShaderFloat :: new ShaderFloat(1.0f, ParamShadowBase),
- L598 C13: new ShaderFloat :: new ShaderFloat(1.0f, ParamShadowMult),
- L599 C13: new ShaderFloat :: new ShaderFloat(0.00001f, ParamShadowBiasMin),
- L600 C13: new ShaderFloat :: new ShaderFloat(0.004f, ParamShadowBiasMax),
- L603 C15: new XRMaterial :: mat = new XRMaterial(
- L605 C13: new XRShader :: new XRShader(EShaderType.Geometry, geom),
- L606 C13: new XRShader :: new XRShader(EShaderType.Fragment, frag))
- L660 C13: new ShaderVector2 :: new ShaderVector2(Vector2.One, ParamLightmapScale),
- L661 C13: new ShaderVector2 :: new ShaderVector2(Vector2.Zero, ParamLightmapOffset),
- L664 C15: new XRMaterial :: mat = new XRMaterial(parameters, new XRShader(EShaderType.Fragment, frag))
- L664 C42: new XRShader :: mat = new XRMaterial(parameters, new XRShader(EShaderType.Fragment, frag))
- L766 C13: new ShaderVector2 :: new ShaderVector2(info.Scale, ParamLightmapScale),
- L767 C13: new ShaderVector2 :: new ShaderVector2(info.Offset, ParamLightmapOffset),
- L770 C23: new XRMaterial :: var preview = new XRMaterial(parameters, new XRTexture?[] { info.Atlas }, previewBase.Shaders)
- L770 C50: new XRTexture :: var preview = new XRMaterial(parameters, new XRTexture?[] { info.Atlas }, previewBase.Shaders)
- L807 C37: new LightmapBakeTarget :: targets.Add(new LightmapBakeTarget(node, renderable, link, mesh, request.LightmapUvChannel, hasUv));


## XRENGINE/Rendering/Lights3DCollection.cs
- L41 C74: new XRTexture2D :: private static XRTexture2D DummyShadowMap => _dummyShadowMap ??= new XRTexture2D(1, 1, ColorF4.White);
- L54 C85: new() :: private readonly ConcurrentQueue<SceneCaptureComponentBase> _captureQueue = new();
- L57 C62: new() :: private readonly Stopwatch _captureBudgetStopwatch = new();
- L63 C83: new() :: private readonly HashSet<LightComponent> _shadowLightsCollectedThisTick = new();
- L80 C69: new AABB :: public Octree<LightProbeCell> LightProbeTree { get; } = new(new AABB());
- L81 C62: new LightmapBakeManager :: public LightmapBakeManager LightmapBaking { get; } = new LightmapBakeManager(world);
- L90 C89: new() :: public EventList<DirectionalLightComponent> DynamicDirectionalLights { get; } = new() { ThreadSafe = true };
- L94 C77: new() :: public EventList<PointLightComponent> DynamicPointLights { get; } = new() { ThreadSafe = true };
- L98 C75: new() :: public EventList<SpotLightComponent> DynamicSpotLights { get; } = new() { ThreadSafe = true };
- L102 C70: new() :: public EventList<LightProbeComponent> LightProbes { get; } = new() { ThreadSafe = true };
- L136 C46: new Vector3 :: program.Uniform("GlobalAmbient", new Vector3(0.1f, 0.1f, 0.1f));
- L452 C23: new() :: Box box = new()
- L561 C112: new ColorF4 :: UpdateDirectionalCameraLightIntersections(DynamicDirectionalLights, preparedCamera, cameraForward, new ColorF4(0.2f, 0.8f, 1.0f, 1.0f));
- L562 C79: new ColorF4 :: UpdateCameraLightIntersections(DynamicSpotLights, preparedCamera, new ColorF4(1.0f, 0.85f, 0.2f, 1.0f));
- L563 C80: new ColorF4 :: UpdateCameraLightIntersections(DynamicPointLights, preparedCamera, new ColorF4(1.0f, 0.2f, 0.8f, 1.0f));
- L687 C35: new AABB :: LightProbeTree.Remake(new AABB());
- L838 C26: new AABB :: var bounds = new AABB(firstPos, firstPos);
- L866 C28: new Dictionary :: var distinct = new Dictionary<(int, int, int), LightProbeComponent>();
- L929 C25: new SceneNode :: new SceneNode(parent, $"Probe[{x},{y},{z}]", new Transform(localMin + baseInc + new Vector3(x, y, z) * probeInc)).AddComponent<LightProbeComponent>();
- L929 C70: new Transform :: new SceneNode(parent, $"Probe[{x},{y},{z}]", new Transform(localMin + baseInc + new Vector3(x, y, z) * probeInc)).AddComponent<LightProbeComponent>();
- L929 C105: new Vector3 :: new SceneNode(parent, $"Probe[{x},{y},{z}]", new Transform(localMin + baseInc + new Vector3(x, y, z) * probeInc)).AddComponent<LightProbeComponent>();
- L964 C23: new NotImplementedException :: throw new NotImplementedException();
- L969 C23: new NotImplementedException :: throw new NotImplementedException();
- L974 C23: new NotImplementedException :: throw new NotImplementedException();
- L979 C23: new NotImplementedException :: throw new NotImplementedException();
- L984 C23: new NotImplementedException :: throw new NotImplementedException();
- L989 C23: new NotImplementedException :: throw new NotImplementedException();
- L994 C23: new NotImplementedException :: throw new NotImplementedException();
- L999 C23: new NotImplementedException :: throw new NotImplementedException();
- L1004 C23: new NotImplementedException :: throw new NotImplementedException();
- L1009 C23: new NotImplementedException :: throw new NotImplementedException();
- L1014 C23: new NotImplementedException :: throw new NotImplementedException();
- L1019 C23: new NotImplementedException :: throw new NotImplementedException();


## XRENGINE/Rendering/Materials/GPUMaterialTable.cs
- L29 C58: new uint :: private static readonly uint[] EmptyEntryWords = new uint[12];
- L39 C22: new XRDataBuffer :: Buffer = new XRDataBuffer(


## XRENGINE/Rendering/Meshlets/MeshletCollection.cs
- L53 C32: new XRRenderProgram :: _taskMeshProgram = new XRRenderProgram(false, true, taskShader, meshShader, fragmentShader);
- L146 C42: new uint :: var visibleMeshletData = new uint[1 + _meshlets.Count];
- L163 C38: new Matrix4x4 :: var transformArray = new Matrix4x4[maxMeshID];


## XRENGINE/Rendering/Meshlets/MeshletGenerator.cs
- L121 C41: new MeshoptMeshlet :: MeshoptMeshlet[] meshlets = new MeshoptMeshlet[maxMeshlets];
- L152 C36: new uint :: meshletVertexIndices = new uint[meshletCount * maxVerticesPerMeshlet];
- L153 C38: new byte :: meshletTriangleIndices = new byte[meshletCount * maxTrianglesPerMeshlet * 3];
- L160 C33: new Meshlet :: Meshlet[] results = new Meshlet[meshletCount];
- L167 C30: new Meshlet :: results[i] = new Meshlet
- L204 C20: new Vector4 :: return new Vector4(center, radius);


## XRENGINE/Rendering/Modeling/XRMeshModelingExporter.cs
- L14 C21: new XRMeshModelingExportOptions :: options ??= new XRMeshModelingExportOptions();
- L22 C23: new InvalidOperationException :: throw new InvalidOperationException(BuildValidationFailureMessage(report));
- L30 C19: new InvalidOperationException :: throw new InvalidOperationException(
- L47 C19: new InvalidOperationException :: throw new InvalidOperationException(
- L54 C19: new InvalidOperationException :: throw new InvalidOperationException(
- L72 C23: new InvalidOperationException :: throw new InvalidOperationException(
- L82 C23: new InvalidOperationException :: throw new InvalidOperationException(
- L95 C37: new TransformBase :: TransformBase[] bones = new TransformBase[skinBones.Count];
- L100 C34: new() :: Transform bone = new()
- L156 C51: new() :: VertexData blendshapeVertex = new()
- L197 C73: new ExportOrderingResult :: XRMeshModelingExportOrderingPolicy.PreserveDocumentOrder => new ExportOrderingResult(document.TriangleIndices, null),
- L199 C24: new ArgumentOutOfRangeException :: _ => throw new ArgumentOutOfRangeException(nameof(orderingPolicy), orderingPolicy, "Unknown export ordering policy.")
- L206 C19: new InvalidOperationException :: throw new InvalidOperationException("Triangle index count must be divisible by 3 for canonicalized export ordering.");
- L210 C39: new CanonicalVertexComparer :: Array.Sort(newToOldVertexMap, new CanonicalVertexComparer(document));
- L212 C35: new int :: int[] oldToNewVertexMap = new int[vertexCount];
- L225 C27: new CanonicalTriangle :: triangles.Add(new CanonicalTriangle(a, b, c, i / 3));
- L238 C16: new ExportOrderingResult :: return new ExportOrderingResult(remappedIndices, newToOldVertexMap);
- L245 C19: new InvalidOperationException :: throw new InvalidOperationException(
- L436 C19: new InvalidOperationException :: throw new InvalidOperationException("Triangle index count must be divisible by 3.");
- L443 C23: new InvalidOperationException :: throw new InvalidOperationException($"Triangle index at element {i} is negative.");
- L445 C23: new InvalidOperationException :: throw new InvalidOperationException($"Triangle index {index} exceeds {ushort.MaxValue}.");
- L456 C27: new IndexTriangle :: triangles.Add(new IndexTriangle(triangleIndices[i], triangleIndices[i + 1], triangleIndices[i + 2]));
- L470 C69: new() :: public static readonly CanonicalTriangleComparer Instance = new();


## XRENGINE/Rendering/Modeling/XRMeshModelingImporter.cs
- L13 C21: new XRMeshModelingImportOptions :: options ??= new XRMeshModelingImportOptions();
- L20 C41: new() :: ModelingMeshDocument document = new()
- L87 C27: new ModelingSkinBone :: skinBones.Add(new ModelingSkinBone
- L117 C35: new ModelingSkinBone :: skinBones.Add(new ModelingSkinBone
- L124 C36: new ModelingSkinWeight :: modeledWeights.Add(new ModelingSkinWeight(boneIndex, pair.Value.weight));
- L147 C26: new ModelingBlendshapeChannel :: channels.Add(new ModelingBlendshapeChannel
- L150 C34: new List :: PositionDeltas = new List<Vector3>(mesh.VertexCount),
- L151 C54: new List :: NormalDeltas = includeNormalDeltas ? new List<Vector3>(mesh.VertexCount) : null,
- L152 C56: new List :: TangentDeltas = includeTangentDeltas ? new List<Vector3>(mesh.VertexCount) : null
- L190 C16: new VertexData :: data = new VertexData();
- L209 C16: new ModelingMeshMetadata :: return new ModelingMeshMetadata


## XRENGINE/Rendering/Occlusion/AsyncOcclusionQueryManager.cs
- L17 C41: new() :: private readonly object _lock = new();
- L18 C55: new() :: private readonly Queue<XRRenderQuery> _pool = new();
- L27 C33: new XRRenderQuery :: query = isNew ? new XRRenderQuery() : _pool.Dequeue();


## XRENGINE/Rendering/Occlusion/CpuRenderOcclusionCoordinator.cs
- L34 C68: new() :: public readonly Dictionary<uint, QueryState> Queries = new();
- L42 C41: new() :: private readonly object _lock = new();
- L43 C67: new() :: private readonly Dictionary<int, PassState> _passStates = new();
- L44 C69: new() :: private readonly AsyncOcclusionQueryManager _queryManager = new();
- L130 C25: new PassState :: state = new PassState();
- L142 C27: new QueryState :: var created = new QueryState
- L173 C35: new() :: staleKeys ??= new();


## XRENGINE/Rendering/Pipelines/Commands/Features/VPRC_BloomPass.cs
- L147 C21: new ShaderFloat :: new ShaderFloat(0.0f, "Ping"),
- L148 C21: new ShaderInt :: new ShaderInt(0, "LOD"),
- L149 C21: new ShaderFloat :: new ShaderFloat(1.0f, "Radius"),
- L154 C33: new RenderingParameters :: RenderOptions = new RenderingParameters()
- L165 C25: new XRQuadFrameBuffer :: var blur1 = new XRQuadFrameBuffer(bloomBlurMat) { Name = BloomBlur1FBOName };
- L166 C25: new XRQuadFrameBuffer :: var blur2 = new XRQuadFrameBuffer(bloomBlurMat) { Name = BloomBlur2FBOName };
- L167 C25: new XRQuadFrameBuffer :: var blur4 = new XRQuadFrameBuffer(bloomBlurMat) { Name = BloomBlur4FBOName };
- L168 C25: new XRQuadFrameBuffer :: var blur8 = new XRQuadFrameBuffer(bloomBlurMat) { Name = BloomBlur8FBOName };
- L169 C26: new XRQuadFrameBuffer :: var blur16 = new XRQuadFrameBuffer(bloomBlurMat) { Name = BloomBlur16FBOName };
- L174 C23: new InvalidOperationException :: throw new InvalidOperationException("Output texture is not an IFrameBufferAttachement.");


## XRENGINE/Rendering/Pipelines/Commands/Features/VPRC_ForwardPlusLightCullingPass.cs
- L54 C31: new XRRenderProgram :: _computeProgram = new XRRenderProgram(true, false, compute);
- L124 C52: new IVector2 :: _computeProgram!.Uniform("screenSize", new IVector2(width, height));
- L134 C60: new Vector2 :: Engine.Rendering.State.ForwardPlusScreenSize = new Vector2(width, height);
- L153 C28: new ForwardPlusLocalLight :: result.Add(new ForwardPlusLocalLight
- L155 C34: new Vector4 :: PositionWS = new Vector4(p.Transform.RenderTranslation, 1.0f),
- L156 C44: new Vector4 :: DirectionWS_Exponent = new Vector4(0, 0, 0, 0),
- L157 C34: new Vector4 :: Color_Type = new Vector4(p.Color, 0.0f),
- L158 C30: new Vector4 :: Params = new Vector4(p.Radius, p.Brightness, p.DiffuseIntensity, 0.0f),
- L168 C28: new ForwardPlusLocalLight :: result.Add(new ForwardPlusLocalLight
- L170 C34: new Vector4 :: PositionWS = new Vector4(s.Transform.RenderTranslation, 1.0f),
- L171 C44: new Vector4 :: DirectionWS_Exponent = new Vector4(Vector3.Normalize(s.Transform.RenderForward), s.Exponent),
- L172 C34: new Vector4 :: Color_Type = new Vector4(s.Color, 1.0f),
- L173 C30: new Vector4 :: Params = new Vector4(s.Distance, s.Brightness, s.DiffuseIntensity, 0.0f),
- L174 C34: new Vector4 :: SpotAngles = new Vector4(s.InnerCutoff, s.OuterCutoff, 0.0f, 0.0f),
- L187 C38: new XRDataBuffer :: _localLightsBuffer = new XRDataBuffer(
- L208 C41: new XRDataBuffer :: _visibleIndicesBuffer = new XRDataBuffer(


## XRENGINE/Rendering/Pipelines/Commands/Features/VPRC_LightCombinePass.cs
- L43 C23: new Exception :: throw new Exception("One or more required textures are missing.");
- L140 C34: new XRMeshRenderer :: PointLightRenderer = new XRMeshRenderer(pointLightMesh, pointLightMat);
- L143 C33: new XRMeshRenderer :: SpotLightRenderer = new XRMeshRenderer(spotLightMesh, spotLightMat);
- L146 C40: new XRMeshRenderer :: DirectionalLightRenderer = new XRMeshRenderer(dirLightMesh, dirLightMat);
- L152 C56: new() :: RenderingParameters additiveRenderParams = new()
- L171 C43: new() :: BlendModeAllDrawBuffers = new()
- L182 C29: new() :: DepthTest = new()


## XRENGINE/Rendering/Pipelines/Commands/Features/VPRC_LightVolumesPass.cs
- L124 C41: new XRRenderProgram :: _computeProgramStereo = new XRRenderProgram(true, false, shader);
- L133 C35: new XRRenderProgram :: _computeProgram = new XRRenderProgram(true, false, shader);
- L158 C51: new IVector2 :: _computeProgram.Uniform("resolution", new IVector2((int)width, (int)height));
- L208 C57: new IVector2 :: _computeProgramStereo.Uniform("resolution", new IVector2((int)width, (int)height));


## XRENGINE/Rendering/Pipelines/Commands/Features/VPRC_MSVO.cs
- L99 C48: new() :: RenderingParameters renderParams = new()
- L120 C23: new ArgumentException :: throw new ArgumentException("Albedo texture must be an IFrameBufferAttachement");
- L123 C23: new ArgumentException :: throw new ArgumentException("Normal texture must be an IFrameBufferAttachement");
- L126 C23: new ArgumentException :: throw new ArgumentException("RMSE texture must be an IFrameBufferAttachement");
- L129 C23: new ArgumentException :: throw new ArgumentException("DepthStencil texture must be an IFrameBufferAttachement");


## XRENGINE/Rendering/Pipelines/Commands/Features/VPRC_MVAOPass.cs
- L72 C113: new() :: private static readonly ConditionalWeakTable<XRRenderPipelineInstance, InstanceState> _instanceStates = new();
- L75 C56: new InstanceState :: => _instanceStates.GetValue(instance, _ => new InstanceState());
- L201 C32: new Vector2 :: state.NoiseScale = new Vector2(
- L248 C48: new() :: RenderingParameters renderParams = new()
- L279 C23: new ArgumentException :: throw new ArgumentException("Albedo texture must be an IFrameBufferAttachement");
- L282 C23: new ArgumentException :: throw new ArgumentException("Normal texture must be an IFrameBufferAttachement");
- L285 C23: new ArgumentException :: throw new ArgumentException("RMSE texture must be an IFrameBufferAttachement");
- L288 C23: new ArgumentException :: throw new ArgumentException("TransformId texture must be an IFrameBufferAttachement");
- L291 C23: new ArgumentException :: throw new ArgumentException("DepthStencil texture must be an IFrameBufferAttachement");
- L305 C23: new ArgumentException :: throw new ArgumentException("Ambient occlusion texture must be an IFrameBufferAttachement");
- L326 C29: new() :: Random random = new();
- L328 C22: new Vector3 :: Kernel = new Vector3[MaxKernelSize];
- L329 C21: new Vector2 :: Noise = new Vector2[NoiseWidth * NoiseHeight];
- L401 C40: new() :: XRTexture2D noiseTexture = new()
- L413 C21: new() :: new()
- L415 C76: new float :: Data = DataSource.FromArray(Noise!.SelectMany(v => new float[] { v.X, v.Y }).ToArray()),


## XRENGINE/Rendering/Pipelines/Commands/Features/VPRC_RadianceCascadesPass.cs
- L141 C32: new XRTexture2D :: _historyTextureA = new XRTexture2D((uint)width, (uint)height, EPixelInternalFormat.Rgba16f, EPixelFormat.Rgba, EPixelType.HalfFloat)
- L150 C32: new XRTexture2D :: _historyTextureB = new XRTexture2D((uint)width, (uint)height, EPixelInternalFormat.Rgba16f, EPixelFormat.Rgba, EPixelType.HalfFloat)
- L171 C38: new XRTexture2DArray :: _historyTextureStereoA = new XRTexture2DArray((uint)width, (uint)height, 2, EPixelInternalFormat.Rgba16f, EPixelFormat.Rgba, EPixelType.HalfFloat)
- L180 C38: new XRTexture2DArray :: _historyTextureStereoB = new XRTexture2DArray((uint)width, (uint)height, 2, EPixelInternalFormat.Rgba16f, EPixelFormat.Rgba, EPixelType.HalfFloat)
- L211 C41: new XRRenderProgram :: _computeProgramStereo = new XRRenderProgram(true, false, shader);
- L219 C31: new XRRenderProgram :: _computeProgram = new XRRenderProgram(true, false, monoShader);
- L258 C59: new Vector4 :: program.Uniform($"cascadeHalfExtents{i}", new Vector4(halfExtents, intensity));
- L304 C51: new IVector2 :: _computeProgram.Uniform("resolution", new IVector2((int)width, (int)height));
- L307 C60: new Vector4 :: _computeProgram.Uniform("volumeTintIntensity", new Vector4(component.Tint.R, component.Tint.G, component.Tint.B, component.Intensity));
- L356 C57: new IVector2 :: _computeProgramStereo.Uniform("resolution", new IVector2((int)width, (int)height));
- L359 C66: new Vector4 :: _computeProgramStereo.Uniform("volumeTintIntensity", new Vector4(component.Tint.R, component.Tint.G, component.Tint.B, component.Intensity));


## XRENGINE/Rendering/Pipelines/Commands/Features/VPRC_ReSTIRPass.cs
- L134 C35: new XRRenderProgram :: _initialProgram = new XRRenderProgram(true, false,
- L140 C36: new XRRenderProgram :: _resampleProgram = new XRRenderProgram(true, false,
- L146 C33: new XRRenderProgram :: _finalProgram = new XRRenderProgram(true, false,
- L177 C26: new XRDataBuffer :: var buffer = new XRDataBuffer(name, EBufferTarget.ShaderStorageBuffer, elementCount, EComponentType.Struct, _reservoirStride, false, false)
- L196 C51: new IVector2 :: _initialProgram.Uniform("resolution", new IVector2((int)width, (int)height));
- L197 C47: new Vector2 :: _initialProgram.Uniform("invRes", new Vector2(1.0f / width, 1.0f / height));
- L218 C52: new IVector2 :: _resampleProgram.Uniform("resolution", new IVector2((int)width, (int)height));
- L219 C48: new Vector2 :: _resampleProgram.Uniform("invRes", new Vector2(1.0f / width, 1.0f / height));
- L235 C49: new IVector2 :: _finalProgram.Uniform("resolution", new IVector2((int)width, (int)height));


## XRENGINE/Rendering/Pipelines/Commands/Features/VPRC_SpatialHashAOPass.cs
- L72 C113: new() :: private static readonly ConditionalWeakTable<XRRenderPipelineInstance, InstanceState> _instanceStates = new();
- L75 C56: new InstanceState :: => _instanceStates.GetValue(instance, _ => new InstanceState());
- L190 C41: new XRRenderProgram :: _computeProgramStereo = new XRRenderProgram(true, false, compute);
- L198 C35: new XRRenderProgram :: _computeProgram = new XRRenderProgram(true, false, compute);
- L291 C23: new ArgumentException :: throw new ArgumentException("Ambient occlusion texture must be an IFrameBufferAttachement");
- L294 C23: new ArgumentException :: throw new ArgumentException("Albedo texture must be an IFrameBufferAttachement");
- L297 C23: new ArgumentException :: throw new ArgumentException("Normal texture must be an IFrameBufferAttachement");
- L300 C23: new ArgumentException :: throw new ArgumentException("RMSE texture must be an IFrameBufferAttachement");
- L303 C23: new ArgumentException :: throw new ArgumentException("TransformId texture must be an IFrameBufferAttachement");
- L306 C23: new ArgumentException :: throw new ArgumentException("DepthStencil texture must be an IFrameBufferAttachement");
- L350 C32: new XRDataBuffer :: state.HashBuffer = new XRDataBuffer("SpatialHashKeys", EBufferTarget.ShaderStorageBuffer, state.HashCapacity, EComponentType.UInt, 1, false, true)
- L359 C36: new XRDataBuffer :: state.HashTimeBuffer = new XRDataBuffer("SpatialHashTime", EBufferTarget.ShaderStorageBuffer, state.HashCapacity, EComponentType.UInt, 1, false, true)
- L368 C35: new XRDataBuffer :: state.SpatialBuffer = new XRDataBuffer("SpatialHashData", EBufferTarget.ShaderStorageBuffer, state.HashCapacity, EComponentType.UInt, 2, false, true)
- L475 C54: new Vector2 :: _computeProgram.Uniform("InvResolution", new Vector2(1.0f / width, 1.0f / height));
- L560 C60: new Vector2 :: _computeProgramStereo.Uniform("InvResolution", new Vector2(1.0f / width, 1.0f / height));


## XRENGINE/Rendering/Pipelines/Commands/Features/VPRC_SSAOPass.cs
- L66 C113: new() :: private static readonly ConditionalWeakTable<XRRenderPipelineInstance, InstanceState> _instanceStates = new();
- L69 C56: new InstanceState :: => _instanceStates.GetValue(instance, _ => new InstanceState());
- L73 C24: new() :: Random r = new();
- L75 C22: new Vector3 :: Kernel = new Vector3[Samples];
- L76 C21: new Vector2 :: Noise = new Vector2[NoiseWidth * NoiseHeight];
- L83 C26: new Vector3 :: sample = new Vector3(
- L93 C46: new Vector2 :: Noise[i] = Vector2.Normalize(new Vector2((float)r.NextDouble(), (float)r.NextDouble()));
- L211 C32: new Vector2 :: state.NoiseScale = new Vector2(
- L260 C48: new() :: RenderingParameters renderParams = new()
- L288 C23: new ArgumentException :: throw new ArgumentException("Albedo texture must be an IFrameBufferAttachement");
- L291 C23: new ArgumentException :: throw new ArgumentException("Normal texture must be an IFrameBufferAttachement");
- L294 C23: new ArgumentException :: throw new ArgumentException("RMSI texture must be an IFrameBufferAttachement");
- L297 C23: new ArgumentException :: throw new ArgumentException("TransformId texture must be an IFrameBufferAttachement");
- L300 C23: new ArgumentException :: throw new ArgumentException("DepthStencil texture must be an IFrameBufferAttachement");
- L314 C23: new ArgumentException :: throw new ArgumentException("SSAO texture must be an IFrameBufferAttachement");
- L372 C36: new() :: XRTexture2D noiseTex = new()
- L384 C21: new() :: new()
- L386 C76: new float :: Data = DataSource.FromArray(Noise!.SelectMany(v => new float[] { v.X, v.Y }).ToArray()),


## XRENGINE/Rendering/Pipelines/Commands/Features/VPRC_SurfelDebugVisualization.cs
- L161 C29: new XRRenderProgram :: _debugProgram = new XRRenderProgram(true, false, shader);
- L197 C45: new Data.Vectors.IVector2 :: _debugProgram.Uniform("resolution", new Data.Vectors.IVector2((int)width, (int)height));
- L203 C42: new Data.Vectors.UVector3 :: _debugProgram.Uniform("gridDim", new Data.Vectors.UVector3(


## XRENGINE/Rendering/Pipelines/Commands/Features/VPRC_SurfelGIPass.cs
- L153 C46: new Vector3 :: Vector3 gridOrigin = cameraPos - new Vector3(GridHalfExtent);
- L183 C32: new XRRenderProgram :: _initProgram = new XRRenderProgram(true, false, shader);
- L189 C35: new XRRenderProgram :: _recycleProgram = new XRRenderProgram(true, false, shader);
- L195 C37: new XRRenderProgram :: _resetGridProgram = new XRRenderProgram(true, false, shader);
- L201 C37: new XRRenderProgram :: _buildGridProgram = new XRRenderProgram(true, false, shader);
- L207 C33: new XRRenderProgram :: _spawnProgram = new XRRenderProgram(true, false, shader);
- L213 C33: new XRRenderProgram :: _shadeProgram = new XRRenderProgram(true, false, shader);
- L223 C33: new XRDataBuffer :: _surfelBuffer = new XRDataBuffer(
- L243 C34: new XRDataBuffer :: _counterBuffer = new XRDataBuffer(
- L262 C36: new XRDataBuffer :: _freeStackBuffer = new XRDataBuffer(
- L282 C37: new XRDataBuffer :: _gridCountsBuffer = new XRDataBuffer(
- L301 C38: new XRDataBuffer :: _gridIndicesBuffer = new XRDataBuffer(
- L375 C50: new UVector3 :: _buildGridProgram.Uniform("gridDim", new UVector3(GridDimX, GridDimY, GridDimZ));
- L402 C49: new IVector2 :: _spawnProgram.Uniform("resolution", new IVector2((int)width, (int)height));
- L410 C46: new UVector3 :: _spawnProgram.Uniform("gridDim", new UVector3(GridDimX, GridDimY, GridDimZ));
- L432 C49: new IVector2 :: _shadeProgram.Uniform("resolution", new IVector2((int)width, (int)height));
- L440 C46: new UVector3 :: _shadeProgram.Uniform("gridDim", new UVector3(GridDimX, GridDimY, GridDimZ));


## XRENGINE/Rendering/Pipelines/Commands/Features/VPRC_TemporalAccumulationPass.cs
- L51 C92: new() :: private static readonly ConditionalWeakTable<XRCamera, TemporalState> TemporalStates = new();
- L199 C20: new TemporalUniformData :: data = new TemporalUniformData
- L227 C54: new TemporalState :: state = TemporalStates.GetValue(camera, _ => new TemporalState());
- L359 C16: new Vector2 :: return new Vector2(x, y);


## XRENGINE/Rendering/Pipelines/Commands/Flow/VPRC_IfElse.cs
- L16 C102: new() :: private readonly ConditionalWeakTable<XRRenderPipelineInstance, BranchState> _branchStates = new();
- L58 C63: new BranchState :: var state = _branchStates.GetValue(instance, _ => new BranchState());


## XRENGINE/Rendering/Pipelines/Commands/Flow/VPRC_Switch.cs
- L16 C102: new() :: private readonly ConditionalWeakTable<XRRenderPipelineInstance, SwitchState> _switchStates = new();
- L60 C63: new SwitchState :: var state = _switchStates.GetValue(instance, _ => new SwitchState());


## XRENGINE/Rendering/Pipelines/Commands/State/ViewportStateRenderCommand.cs
- L7 C131: new() :: public abstract class ViewportStateRenderCommand<T> : ViewportStateRenderCommandBase where T : ViewportPopStateRenderCommand, new()
- L9 C40: new T :: public T PopCommand { get; } = new T();


## XRENGINE/Rendering/Pipelines/Commands/ViewportRenderCommandContainer.cs
- L75 C116: new() :: public StateObject AddUsing<T>(Action<T>? setOptionsFunc = null) where T : ViewportStateRenderCommandBase, new()
- L91 C23: new ArgumentException :: throw new ArgumentException("Type must be a subclass of ViewportStateRenderCommand.", nameof(t));
- L112 C60: new() :: public T Add<T>() where T : ViewportRenderCommand, new()
- L115 C21: new() :: T cmd = new();
- L128 C23: new ArgumentException :: throw new ArgumentException("Type must be a subclass of ViewportRenderCommand.", nameof(t));
- L130 C103: new ArgumentException :: ViewportRenderCommand cmd = Activator.CreateInstance(t) as ViewportRenderCommand ?? throw new ArgumentException("Type must have a public parameterless constructor.", nameof(t));
- L137 C23: new ArgumentException :: throw new ArgumentException("Type must be a subclass of ViewportRenderCommand.", nameof(t));
- L139 C112: new ArgumentException :: ViewportRenderCommand cmd = (ViewportRenderCommand)Activator.CreateInstance(t, arguments) ?? throw new ArgumentException("Type must have a public constructor with the specified arguments.", nameof(t));
- L217 C25: new InstanceResourceState :: state = new InstanceResourceState();


## XRENGINE/Rendering/Pipelines/Commands/VPRC_DispatchCompute.cs
- L33 C53: new XRShader :: _computeProgram.Shaders.Add(new XRShader(EShaderType.Compute, ComputeShaderCode));


## XRENGINE/Rendering/Pipelines/RenderingState.cs
- L122 C63: new() :: private readonly Stack<XRCamera?> _renderingCameras = new();
- L133 C72: new() :: private readonly Stack<BoundingRectangle> _renderRegionStack = new();
- L137 C31: new BoundingRectangle :: => PushRenderArea(new BoundingRectangle(x, y, width, height));
- L156 C70: new() :: private readonly Stack<BoundingRectangle> _cropRegionStack = new();
- L160 C29: new BoundingRectangle :: => PushCropArea(new BoundingRectangle(x, y, width, height));
- L185 C65: new() :: private readonly Stack<XRMaterial> _overrideMaterials = new();
- L243 C66: new() :: private readonly Stack<XRViewport> _renderingViewports = new();
- L259 C64: new() :: private readonly Stack<VisualScene> _renderingScenes = new();
- L275 C36: New() :: return StateObject.New();
- L285 C36: New() :: return StateObject.New();
- L294 C24: new Vector2 :: return new Vector2(region.Width, region.Height);
- L302 C28: new Vector2 :: return new Vector2(width, height);


## XRENGINE/Rendering/Pipelines/Types/CustomRenderPipeline.cs
- L10 C40: new Lazy :: => _invalidMaterialFactory ??= new Lazy<XRMaterial>(() => CustomInvalidMaterial is not null ? CustomInvalidMaterial : XRMaterial.CreateUnlitColorMaterialForward());


## XRENGINE/Rendering/Pipelines/Types/DebugOpaqueRenderPipeline.cs
- L20 C70: new() :: private readonly NearToFarRenderCommandSorter _nearToFarSorter = new();
- L57 C70: new() :: private readonly FarToNearRenderCommandSorter _farToNearSorter = new();
- L60 C12: new() :: => new()


## XRENGINE/Rendering/Pipelines/Types/DefaultRenderPipeline.cs
- L26 C70: new() :: private readonly NearToFarRenderCommandSorter _nearToFarSorter = new();
- L27 C70: new() :: private readonly FarToNearRenderCommandSorter _farToNearSorter = new();
- L102 C12: new() :: => new()
- L201 C49: new Lazy :: _voxelConeTracingVoxelizationMaterial = new Lazy<XRMaterial>(CreateVoxelConeTracingVoxelizationMaterial, LazyThreadSafetyMode.PublicationOnly);
- L202 C34: new Lazy :: _motionVectorsMaterial = new Lazy<XRMaterial>(CreateMotionVectorsMaterial, LazyThreadSafetyMode.PublicationOnly);
- L350 C34: new() :: aoSwitch.Cases = new()
- L532 C21: new[] :: new[]
- L678 C17: new ViewportRenderCommandContainer :: var c = new ViewportRenderCommandContainer(this);
- L904 C25: new ViewportRenderCommandContainer :: var container = new ViewportRenderCommandContainer(this)
- L917 C25: new ViewportRenderCommandContainer :: var container = new ViewportRenderCommandContainer(this)
- L927 C25: new ViewportRenderCommandContainer :: var container = new ViewportRenderCommandContainer(this)
- L937 C25: new ViewportRenderCommandContainer :: var container = new ViewportRenderCommandContainer(this);
- L966 C25: new ViewportRenderCommandContainer :: var container = new ViewportRenderCommandContainer(this);
- L1016 C34: new[] :: pass.DependentFboNames = new[] { LightCombineFBOName };
- L1042 C34: new[] :: pass.DependentFboNames = new[] { LightCombineFBOName };
- L1067 C34: new[] :: pass.DependentFboNames = new[] { LightCombineFBOName };
- L1103 C72: new() :: private readonly Dictionary<Guid, Vector3> _cachedProbePositions = new();
- L1104 C111: new() :: private readonly Dictionary<Guid, (XRTexture2D Irradiance, XRTexture2D Prefilter)> _cachedProbeTextures = new();
- L1105 C75: new() :: private readonly Dictionary<Guid, uint> _cachedProbeCaptureVersions = new();
- L1248 C37: new IVector3 :: dimsI = IVector3.Min(dimsI, new IVector3(64, 64, 64));
- L1252 C25: new List :: var cellLists = new List<int>[cellCount];
- L1254 C28: new List :: cellLists[i] = new List<int>(4);
- L1259 C28: new Vector3 :: Vector3 rel = (new Vector3(pos4.X, pos4.Y, pos4.Z) - _probeGridOrigin) / _probeGridCellSize;
- L1268 C23: new List :: var offsets = new List<ProbeGridCell>(cellCount);
- L1269 C23: new List :: var indices = new List<int>();
- L1275 C25: new ProbeGridCell :: offsets.Add(new ProbeGridCell { OffsetCount = new IVector2(offset, list.Count) });
- L1275 C59: new IVector2 :: offsets.Add(new ProbeGridCell { OffsetCount = new IVector2(offset, list.Count) });
- L1278 C32: new XRDataBuffer :: _probeGridCellBuffer = new XRDataBuffer("LightProbeGridCells", EBufferTarget.ShaderStorageBuffer, (uint)offsets.Count, EComponentType.Struct, (uint)Marshal.SizeOf<ProbeGridCell>(), false, false)
- L1285 C33: new XRDataBuffer :: _probeGridIndexBuffer = new XRDataBuffer("LightProbeGridIndices", EBufferTarget.ShaderStorageBuffer, (uint)indices.Count, EComponentType.Int, sizeof(int), false, false)
- L1295 C27: new List :: var readyProbes = new List<LightProbeComponent>(probes.Count);
- L1385 C27: new List :: var irrTextures = new List<XRTexture2D>(readyProbes.Count);
- L1386 C27: new List :: var preTextures = new List<XRTexture2D>(readyProbes.Count);
- L1387 C25: new List :: var positions = new List<ProbePositionData>(readyProbes.Count);
- L1388 C26: new List :: var parameters = new List<ProbeParamData>(readyProbes.Count);
- L1396 C27: new ProbePositionData :: positions.Add(new ProbePositionData { Position = new Vector4(position, 1.0f) });
- L1396 C62: new Vector4 :: positions.Add(new ProbePositionData { Position = new Vector4(position, 1.0f) });
- L1398 C28: new ProbeParamData :: parameters.Add(new ProbeParamData
- L1400 C34: new Vector4 :: InfluenceInner = new Vector4(probe.InfluenceBoxInnerExtents, probe.InfluenceSphereInnerRadius),
- L1401 C34: new Vector4 :: InfluenceOuter = new Vector4(probe.InfluenceBoxOuterExtents, probe.InfluenceSphereOuterRadius),
- L1402 C40: new Vector4 :: InfluenceOffsetShape = new Vector4(probe.InfluenceOffset, probe.InfluenceShape == LightProbeComponent.EInfluenceShape.Box ? 1.0f : 0.0f),
- L1403 C37: new Vector4 :: ProxyCenterEnable = new Vector4(probe.ProxyBoxCenterOffset, probe.ParallaxCorrectionEnabled ? 1.0f : 0.0f),
- L1404 C36: new Vector4 :: ProxyHalfExtents = new Vector4(probe.ProxyBoxHalfExtents, probe.NormalizationScale),
- L1405 C33: new Vector4 :: ProxyRotation = new Vector4(probe.ProxyBoxRotation.X, probe.ProxyBoxRotation.Y, probe.ProxyBoxRotation.Z, probe.ProxyBoxRotation.W),
- L1415 C33: new XRTexture2DArray :: _probeIrradianceArray = new XRTexture2DArray([.. irrTextures])
- L1423 C32: new XRTexture2DArray :: _probePrefilterArray = new XRTexture2DArray([.. preTextures])
- L1431 C32: new XRDataBuffer :: _probePositionBuffer = new XRDataBuffer("LightProbePositions", EBufferTarget.ShaderStorageBuffer, (uint)positions.Count, EComponentType.Struct, (uint)Marshal.SizeOf<ProbePositionData>(), false, false)
- L1438 C29: new XRDataBuffer :: _probeParamBuffer = new XRDataBuffer("LightProbeParameters", EBufferTarget.ShaderStorageBuffer, (uint)parameters.Count, EComponentType.Struct, (uint)Marshal.SizeOf<ProbeParamData>(), false, false)
- L1462 C28: new Dictionary :: var probeIndices = new Dictionary<LightProbeComponent, int>(probes.Count);
- L1495 C25: new List :: var tetraData = new List<ProbeTetraData>(cells.Count);
- L1501 C31: new ProbeTetraData :: tetraData.Add(new ProbeTetraData
- L1503 C31: new Vector4 :: Indices = new Vector4(
- L1519 C20: new List :: var list = new List<ProbeTetraData>(1);
- L1527 C18: new ProbeTetraData :: list.Add(new ProbeTetraData
- L1529 C23: new Vector4 :: Indices = new Vector4(a, b, c, d)
- L1546 C29: new XRDataBuffer :: _probeTetraBuffer = new XRDataBuffer("LightProbeTetra", EBufferTarget.ShaderStorageBuffer, (uint)tetraList.Count, EComponentType.Struct, (uint)Marshal.SizeOf<ProbeTetraData>(), false, false)
- L1613 C29: new StencilTestFace :: stencil.FrontFace = new StencilTestFace()
- L1623 C28: new StencilTestFace :: stencil.BackFace = new StencilTestFace()


## XRENGINE/Rendering/Pipelines/Types/DefaultRenderPipeline.FBOs.cs
- L53 C29: new RenderingParameters :: RenderOptions = new RenderingParameters()
- L55 C29: new DepthTest :: DepthTest = new DepthTest()
- L63 C30: new XRQuadFrameBuffer :: var PostProcessFBO = new XRQuadFrameBuffer(postProcessMat);
- L72 C19: new InvalidOperationException :: throw new InvalidOperationException($"Post-process output texture '{PostProcessOutputTextureName}' not found. Ensure textures are created before FBOs.");
- L74 C19: new InvalidOperationException :: throw new InvalidOperationException($"Post-process output texture must be FBO attachable. Got type: {outputTexture.GetType().Name}");
- L76 C16: new XRFrameBuffer :: return new XRFrameBuffer((attach, EFrameBufferAttachment.ColorAttachment0, 0, -1))
- L86 C19: new InvalidOperationException :: throw new InvalidOperationException("TransformId debug output texture must be FBO attachable.");
- L88 C16: new XRFrameBuffer :: return new XRFrameBuffer((attach, EFrameBufferAttachment.ColorAttachment0, 0, -1))
- L100 C29: new RenderingParameters :: RenderOptions = new RenderingParameters()
- L102 C29: new DepthTest :: DepthTest = new DepthTest()
- L109 C19: new XRQuadFrameBuffer :: var fbo = new XRQuadFrameBuffer(mat)
- L124 C29: new RenderingParameters :: RenderOptions = new RenderingParameters()
- L126 C29: new DepthTest :: DepthTest = new DepthTest()
- L139 C19: new InvalidOperationException :: throw new InvalidOperationException("FXAA output texture is not an FBO-attachable texture.");
- L164 C17: new ShaderFloat :: new ShaderFloat(1.0f, "BloomIntensity"),
- L165 C17: new ShaderFloat :: new ShaderFloat(1.0f, "BloomThreshold"),
- L166 C17: new ShaderFloat :: new ShaderFloat(0.5f, "SoftKnee"),
- L167 C17: new ShaderVector3 :: new ShaderVector3(Engine.Rendering.Settings.DefaultLuminance, "Luminance")
- L172 C29: new RenderingParameters :: RenderOptions = new RenderingParameters()
- L174 C29: new() :: DepthTest = new()
- L183 C19: new XRQuadFrameBuffer :: var fbo = new XRQuadFrameBuffer(brightMat, false);
- L187 C19: new InvalidOperationException :: throw new InvalidOperationException("HDR Scene texture is not an FBO-attachable texture.");
- L190 C19: new InvalidOperationException :: throw new InvalidOperationException("Depth/Stencil texture is not an FBO-attachable texture.");
- L228 C19: new InvalidOperationException :: throw new InvalidOperationException("AO intensity texture must be FBO-attachable.");
- L230 C16: new XRFrameBuffer :: return new XRFrameBuffer((aoAttach, EFrameBufferAttachment.ColorAttachment0, 0, -1))
- L241 C29: new RenderingParameters :: RenderOptions = new RenderingParameters()
- L243 C29: new DepthTest :: DepthTest = new DepthTest()
- L291 C19: new InvalidOperationException :: throw new InvalidOperationException("Velocity texture is not an FBO-attachable texture.");
- L294 C19: new InvalidOperationException :: throw new InvalidOperationException("Depth/Stencil texture is not an FBO-attachable texture.");
- L296 C16: new XRFrameBuffer :: return new XRFrameBuffer(
- L307 C19: new InvalidOperationException :: throw new InvalidOperationException("History color texture is not an FBO-attachable texture.");
- L310 C19: new InvalidOperationException :: throw new InvalidOperationException("History depth texture is not an FBO-attachable texture.");
- L312 C16: new XRFrameBuffer :: return new XRFrameBuffer(
- L323 C19: new InvalidOperationException :: throw new InvalidOperationException("Temporal color input texture is not FBO attachable.");
- L325 C16: new XRFrameBuffer :: return new XRFrameBuffer((colorAttachment, EFrameBufferAttachment.ColorAttachment0, 0, -1))
- L346 C29: new RenderingParameters :: RenderOptions = new RenderingParameters()
- L348 C29: new() :: DepthTest = new()
- L357 C19: new XRQuadFrameBuffer :: var fbo = new XRQuadFrameBuffer(material) { Name = TemporalAccumulationFBOName };
- L360 C19: new InvalidOperationException :: throw new InvalidOperationException("HDR scene texture is not FBO attachable.");
- L363 C19: new InvalidOperationException :: throw new InvalidOperationException("Temporal exposure texture is not FBO attachable.");
- L376 C19: new InvalidOperationException :: throw new InvalidOperationException("Motion blur texture is not FBO attachable.");
- L378 C16: new XRFrameBuffer :: return new XRFrameBuffer((attachment, EFrameBufferAttachment.ColorAttachment0, 0, -1))
- L394 C29: new RenderingParameters :: RenderOptions = new RenderingParameters()
- L396 C29: new() :: DepthTest = new()
- L405 C19: new XRQuadFrameBuffer :: var fbo = new XRQuadFrameBuffer(material) { Name = MotionBlurFBOName };
- L413 C19: new InvalidOperationException :: throw new InvalidOperationException("Depth of field texture is not FBO attachable.");
- L415 C16: new XRFrameBuffer :: return new XRFrameBuffer((attachment, EFrameBufferAttachment.ColorAttachment0, 0, -1))
- L430 C29: new RenderingParameters :: RenderOptions = new RenderingParameters()
- L432 C29: new() :: DepthTest = new()
- L442 C19: new XRQuadFrameBuffer :: var fbo = new XRQuadFrameBuffer(material) { Name = DepthOfFieldFBOName };
- L450 C19: new InvalidOperationException :: throw new InvalidOperationException("History exposure texture is not FBO attachable.");
- L452 C16: new XRFrameBuffer :: return new XRFrameBuffer((attachment, EFrameBufferAttachment.ColorAttachment0, 0, -1))
- L469 C29: new RenderingParameters :: RenderOptions = new RenderingParameters()
- L471 C29: new() :: DepthTest = new()
- L484 C16: new XRQuadFrameBuffer :: return new XRQuadFrameBuffer(material, false) { Name = DepthPreloadFBOName };
- L503 C29: new RenderingParameters :: RenderOptions = new RenderingParameters()
- L505 C29: new() :: DepthTest = new()
- L515 C31: new XRQuadFrameBuffer :: var lightCombineFBO = new XRQuadFrameBuffer(lightCombineMat) { Name = LightCombineFBOName };
- L520 C19: new InvalidOperationException :: throw new InvalidOperationException("Diffuse texture is not an FBO-attachable texture.");
- L530 C35: new() :: BlendMode additiveBlend = new()
- L542 C29: new RenderingParameters :: RenderOptions = new RenderingParameters()
- L544 C29: new DepthTest :: DepthTest = new DepthTest()
- L553 C19: new XRQuadFrameBuffer :: var fbo = new XRQuadFrameBuffer(restirCompositeMaterial) { Name = RestirCompositeFBOName };
- L562 C35: new() :: BlendMode additiveBlend = new()
- L575 C29: new RenderingParameters :: RenderOptions = new RenderingParameters()
- L577 C29: new DepthTest :: DepthTest = new DepthTest()
- L587 C19: new XRQuadFrameBuffer :: var fbo = new XRQuadFrameBuffer(material) { Name = SurfelGICompositeFBOName };
- L596 C35: new() :: BlendMode additiveBlend = new()
- L609 C29: new RenderingParameters :: RenderOptions = new RenderingParameters()
- L611 C29: new DepthTest :: DepthTest = new DepthTest()
- L621 C19: new XRQuadFrameBuffer :: var fbo = new XRQuadFrameBuffer(material) { Name = LightVolumeCompositeFBOName };
- L632 C35: new() :: BlendMode additiveBlend = new()
- L645 C29: new RenderingParameters :: RenderOptions = new RenderingParameters()
- L647 C29: new DepthTest :: DepthTest = new DepthTest()
- L658 C19: new XRQuadFrameBuffer :: var fbo = new XRQuadFrameBuffer(material) { Name = RadianceCascadeCompositeFBOName };


## XRENGINE/Rendering/Pipelines/Types/DefaultRenderPipeline.PostProcessing.cs
- L235 C13: new Vector3 :: new Vector3(0.299f, 0.587f, 0.114f),
- L906 C13: new Vector3 :: new Vector3(0.5f, 0.5f, 0.5f),
- L914 C43: new PostProcessEnumOption :: PostProcessEnumOption[] options = new PostProcessEnumOption[values.Length];
- L919 C26: new PostProcessEnumOption :: options[i] = new PostProcessEnumOption(value.ToString(), Convert.ToInt32(value));
- L966 C22: new VignetteSettings :: (vignette ?? new VignetteSettings()).SetUniforms(program);
- L969 C19: new ColorGradingSettings :: (color ?? new ColorGradingSettings()).SetUniforms(program);
- L972 C20: new ChromaticAberrationSettings :: (chroma ?? new ChromaticAberrationSettings()).SetUniforms(program);
- L975 C17: new FogSettings :: (fog ?? new FogSettings()).SetUniforms(program);
- L998 C42: new Vector2 :: distortionCenterUv = new Vector2(
- L1004 C18: new LensDistortionSettings :: (lens ?? new LensDistortionSettings()).SetUniforms(program, cameraFov, aspectRatio, distortionCenterUv);
- L1007 C19: new BloomSettings :: (bloom ?? new BloomSettings()).SetCombineUniforms(program);
- L1027 C25: new Vector2 :: var texelStep = new Vector2(1.0f / width, 1.0f / height);
- L1041 C25: new Vector2 :: var texelSize = new Vector2(1.0f / width, 1.0f / height);
- L1064 C25: new Vector2 :: var texelSize = new Vector2(1.0f / width, 1.0f / height);
- L1090 C42: new Vector2 :: program.Uniform("TexelSize", new Vector2(1.0f / width, 1.0f / height));


## XRENGINE/Rendering/Pipelines/Types/DefaultRenderPipeline.Textures.cs
- L59 C20: new XRTexture2DArrayView :: return new XRTexture2DArrayView(
- L73 C20: new XRTexture2DView :: return new XRTexture2DView(
- L90 C20: new XRTexture2DArrayView :: return new XRTexture2DArrayView(
- L104 C20: new XRTexture2DView :: return new XRTexture2DView(
- L159 C20: new XRTexture2DArrayView :: return new XRTexture2DArrayView(
- L173 C20: new XRTexture2DView :: return new XRTexture2DView(


## XRENGINE/Rendering/Pipelines/Types/SurfelDebugRenderPipeline.cs
- L53 C70: new() :: private readonly NearToFarRenderCommandSorter _nearToFarSorter = new();
- L54 C70: new() :: private readonly FarToNearRenderCommandSorter _farToNearSorter = new();
- L130 C12: new() :: => new()
- L205 C41: new Dictionary :: visualizationSwitch.Cases = new Dictionary<int, ViewportRenderCommandContainer>
- L225 C38: new Dictionary :: outputChoice.Cases = new Dictionary<int, ViewportRenderCommandContainer>
- L277 C16: new ViewportRenderCommandContainer :: return new ViewportRenderCommandContainer(this);
- L282 C17: new ViewportRenderCommandContainer :: var c = new ViewportRenderCommandContainer(this);
- L292 C17: new ViewportRenderCommandContainer :: var c = new ViewportRenderCommandContainer(this);
- L307 C17: new ViewportRenderCommandContainer :: var c = new ViewportRenderCommandContainer(this);
- L322 C17: new ViewportRenderCommandContainer :: var c = new ViewportRenderCommandContainer(this);
- L329 C17: new ViewportRenderCommandContainer :: var c = new ViewportRenderCommandContainer(this);
- L336 C17: new ViewportRenderCommandContainer :: var c = new ViewportRenderCommandContainer(this);
- L417 C16: new XRTexture2DView :: return new XRTexture2DView(
- L506 C19: new InvalidOperationException :: throw new InvalidOperationException("Albedo texture must be FBO-attachable.");
- L509 C19: new InvalidOperationException :: throw new InvalidOperationException("Normal texture must be FBO-attachable.");
- L512 C19: new InvalidOperationException :: throw new InvalidOperationException("TransformId texture must be FBO-attachable.");
- L515 C19: new InvalidOperationException :: throw new InvalidOperationException("Depth/Stencil texture must be FBO-attachable.");
- L517 C16: new XRFrameBuffer :: return new XRFrameBuffer(
- L530 C19: new InvalidOperationException :: throw new InvalidOperationException("HDR scene texture must be FBO-attachable.");
- L533 C19: new InvalidOperationException :: throw new InvalidOperationException("Depth/Stencil texture must be FBO-attachable.");
- L538 C29: new RenderingParameters :: RenderOptions = new RenderingParameters()
- L540 C29: new DepthTest :: DepthTest = new DepthTest()
- L547 C19: new XRQuadFrameBuffer :: var fbo = new XRQuadFrameBuffer(mat)
- L564 C29: new RenderingParameters :: RenderOptions = new RenderingParameters()
- L566 C29: new DepthTest :: DepthTest = new DepthTest()
- L573 C19: new XRQuadFrameBuffer :: var fbo = new XRQuadFrameBuffer(mat)
- L610 C29: new RenderingParameters :: RenderOptions = new RenderingParameters()
- L612 C29: new DepthTest :: DepthTest = new DepthTest()
- L619 C19: new XRQuadFrameBuffer :: var fbo = new XRQuadFrameBuffer(mat)
- L635 C29: new RenderingParameters :: RenderOptions = new RenderingParameters()
- L637 C29: new DepthTest :: DepthTest = new DepthTest()
- L644 C19: new XRQuadFrameBuffer :: var fbo = new XRQuadFrameBuffer(mat)


## XRENGINE/Rendering/Pipelines/Types/TestRenderPipeline.cs
- L11 C70: new() :: private readonly FarToNearRenderCommandSorter _farToNearSorter = new();
- L21 C12: new() :: => new() { { (int)EDefaultRenderPass.OpaqueForward, _farToNearSorter }, };
- L52 C32: new ColorF4 :: ClearColor(new ColorF4(0.0f, 0.0f, 0.0f, 1.0f));
- L69 C32: new ColorF4 :: ClearColor(new ColorF4(0.0f, 0.0f, 0.0f, 1.0f));
- L123 C29: new RenderingParameters :: RenderOptions = new RenderingParameters()
- L125 C29: new DepthTest :: DepthTest = new DepthTest()
- L133 C19: new XRQuadFrameBuffer :: var fbo = new XRQuadFrameBuffer(mat);


## XRENGINE/Rendering/Pipelines/Types/UserInterfaceRenderPipeline.cs
- L21 C70: new() :: private readonly NearToFarRenderCommandSorter _nearToFarSorter = new();
- L22 C70: new() :: private readonly FarToNearRenderCommandSorter _farToNearSorter = new();
- L25 C12: new() :: => new()
- L65 C37: new ColorF4 :: c.Add<VPRC_SetClears>().Set(new ColorF4(0f, 0f, 0f, 0f), 1.0f, 0);
- L137 C12: new XRTexture2DView :: => new XRTexture2DView(
- L148 C12: new XRTexture2DView :: => new XRTexture2DView(


## XRENGINE/Rendering/Pipelines/XRRenderPipeline.cs
- L99 C51: new() :: RenderPassMetadataCollection collection = new();
- L149 C30: new InvalidOperationException :: => TryState ?? throw new InvalidOperationException("Rendering pipeline state is not available.");
- L324 C29: new() :: RenderOptions = new()
- L326 C29: new() :: DepthTest = new()
- L337 C55: new IVector2 :: BoundingRectangle region = new(IVector2.Zero, new IVector2((int)width, (int)height));


## XRENGINE/Rendering/Pipelines/XRRenderPipelineInstance.cs
- L46 C66: new() :: public RenderCommandCollection MeshRenderCommands { get; } = new();
- L48 C56: new() :: public RenderResourceRegistry Resources { get; } = new();
- L52 C58: new() :: private readonly object _renderGraphValidationLock = new();
- L111 C20: new List :: var tags = new List<string>(2);
- L247 C58: new() :: public RenderingState CollectVisibleState { get; } = new();
- L248 C50: new() :: public RenderingState RenderState { get; } = new();


## XRENGINE/Rendering/PostProcessing/CameraPostProcessStateCollection.cs
- L21 C46: new() :: private readonly object _pipelinesSync = new();
- L22 C69: new() :: private Dictionary<Guid, PipelinePostProcessState> _pipelines = new();
- L34 C25: new PipelinePostProcessState :: state = new PipelinePostProcessState();
- L68 C30: new() :: _pipelines = new();
- L72 C26: new Dictionary :: _pipelines = new Dictionary<Guid, PipelinePostProcessState>(_pipelines);
- L83 C43: new() :: private readonly object _stagesSync = new();
- L148 C25: new PostProcessStageState :: stage = new PostProcessStageState();
- L168 C23: new Dictionary :: _stages = new Dictionary<string, PostProcessStageState>(_stages, StringComparer.OrdinalIgnoreCase);
- L181 C44: new() :: private readonly object _backingSync = new();
- L242 C31: new HashSet :: var knownParameters = new HashSet<string>(descriptor.Parameters.Select(p => p.Name), StringComparer.OrdinalIgnoreCase);
- L276 C26: new Dictionary :: var backingMap = new Dictionary<string, PropertyInfo>(StringComparer.OrdinalIgnoreCase);
- L347 C21: new Vector3 :: value = new Vector3(color.R, color.G, color.B);
- L404 C30: new Vector2 :: result = new Vector2(v3.X, v3.Y);
- L416 C38: new Vector3 :: ColorF3 color => new Vector3(color.R, color.G, color.B),
- L432 C30: new Vector4 :: result = new Vector4(v3, 0.0f);
- L444 C34: new ColorF3 :: Vector3 v => new ColorF3(v.X, v.Y, v.Z),
- L486 C23: new Dictionary :: _values = new Dictionary<string, object?>(_values, StringComparer.OrdinalIgnoreCase);


## XRENGINE/Rendering/PostProcessing/RenderPipelinePostProcessSchema.cs
- L78 C9: new Dictionary :: new Dictionary<string, PostProcessStageDescriptor>(StringComparer.Ordinal),
- L81 C101: new Dictionary :: public IReadOnlyDictionary<string, PostProcessStageDescriptor> StagesByKey { get; } = stages ?? new Dictionary<string, PostProcessStageDescriptor>(StringComparer.Ordinal);


## XRENGINE/Rendering/PostProcessing/RenderPipelinePostProcessSchemaBuilder.cs
- L20 C19: new ArgumentException :: throw new ArgumentException("Stage key cannot be empty.", nameof(key));
- L24 C26: new StageDefinition :: definition = new StageDefinition(key, displayName ?? key);
- L32 C16: new PostProcessStageBuilder :: return new PostProcessStageBuilder(definition);
- L38 C19: new ArgumentException :: throw new ArgumentException("Category key cannot be empty.", nameof(key));
- L42 C26: new CategoryDefinition :: definition = new CategoryDefinition(key, displayName ?? key);
- L50 C16: new PostProcessCategoryBuilder :: return new PostProcessCategoryBuilder(definition);
- L76 C35: new List :: var categoryDescriptors = new List<PostProcessCategoryDescriptor>(_categories.Count);
- L82 C37: new PostProcessCategoryDescriptor :: categoryDescriptors.Add(new PostProcessCategoryDescriptor(category.Key, category.DisplayName, category.Description, stageKeys));
- L89 C37: new PostProcessCategoryDescriptor :: categoryDescriptors.Add(new PostProcessCategoryDescriptor("default", "Post Processing", null, orderedKeys));
- L92 C16: new RenderPipelinePostProcessSchema :: return new RenderPipelinePostProcessSchema(stageDescriptors, categoryDescriptors);
- L97 C59: new() :: List<PostProcessParameterDescriptor> parameters = new();
- L119 C32: new PostProcessParameterDescriptor :: parameters.Add(new PostProcessParameterDescriptor(
- L137 C28: new PostProcessParameterDescriptor :: parameters.Add(new PostProcessParameterDescriptor(
- L155 C16: new PostProcessStageDescriptor :: return new PostProcessStageDescriptor(definition.Key, definition.DisplayName, parameters, definition.BackingType);
- L200 C76: new() :: public List<CustomParameterDefinition> CustomParameters { get; } = new();
- L204 C50: new ArgumentNullException :: => _shaderFactory = factory ?? throw new ArgumentNullException(nameof(factory));
- L218 C50: new() :: public List<string> StageKeys { get; } = new();
- L253 C87: new() :: public PostProcessStageBuilder BackedBy<TSettings>() where TSettings : class, new()
- L287 C33: new UniformCustomization :: customization = new UniformCustomization();
- L298 C33: new UniformCustomization :: customization = new UniformCustomization();
- L309 C33: new UniformCustomization :: customization = new UniformCustomization();
- L322 C33: new UniformCustomization :: customization = new UniformCustomization();
- L333 C33: new UniformCustomization :: customization = new UniformCustomization();
- L352 C23: new ArgumentException :: throw new ArgumentException("Parameter name cannot be empty.", nameof(name));
- L354 C46: new CustomParameterDefinition :: _definition.CustomParameters.Add(new CustomParameterDefinition


## XRENGINE/Rendering/RenderGraph/RenderGraphDescribeContext.cs
- L11 C64: new() :: private readonly Stack<RenderTargetBinding> _targetStack = new();
- L12 C70: new() :: private readonly Dictionary<string, int> _syntheticPassIndices = new();
- L24 C27: new RenderTargetBinding :: _targetStack.Push(new RenderTargetBinding(name!, writes, clearColor && writes, clearDepth && writes, clearStencil && writes));


## XRENGINE/Rendering/RenderGraph/RenderGraphDescriptorSchemas.cs
- L45 C13: new RenderGraphDescriptorBinding :: new RenderGraphDescriptorBinding("EngineUniforms", 0, ERenderPassResourceType.UniformBuffer, ERenderGraphAccess.Read)
- L52 C13: new RenderGraphDescriptorBinding :: new RenderGraphDescriptorBinding("MaterialUniforms", 0, ERenderPassResourceType.UniformBuffer, ERenderGraphAccess.Read),
- L53 C13: new RenderGraphDescriptorBinding :: new RenderGraphDescriptorBinding("MaterialTextures", 1, ERenderPassResourceType.SampledTexture, ERenderGraphAccess.Read),
- L54 C13: new RenderGraphDescriptorBinding :: new RenderGraphDescriptorBinding("MaterialStorage", 2, ERenderPassResourceType.StorageBuffer, ERenderGraphAccess.ReadWrite)


## XRENGINE/Rendering/RenderGraph/RenderGraphSynchronization.cs
- L81 C28: new Dictionary :: _edgesByConsumer = new Dictionary<int, List<RenderGraphSynchronizationEdge>>();
- L113 C21: new List :: var edges = new List<RenderGraphSynchronizationEdge>();
- L114 C35: new Dictionary :: var lastUsageByResource = new Dictionary<string, (int PassIndex, ERenderPassResourceType Type, RenderGraphSyncState State)>(StringComparer.OrdinalIgnoreCase);
- L128 C35: new RenderGraphSynchronizationEdge :: edges.Add(new RenderGraphSynchronizationEdge(
- L158 C27: new RenderGraphSynchronizationEdge :: edges.Add(new RenderGraphSynchronizationEdge(
- L169 C16: new RenderGraphSynchronizationInfo :: return new RenderGraphSynchronizationInfo(edges);
- L176 C82: new List :: Dictionary<int, List<int>> edges = lookup.Keys.ToDictionary(k => k, _ => new List<int>());
- L225 C16: new RenderGraphSyncState :: return new RenderGraphSyncState(ResolveStage(ERenderPassResourceType.TransferDestination, stage), RenderGraphAccessMask.MemoryRead | RenderGraphAccessMask.MemoryWrite, null);


## XRENGINE/Rendering/RenderGraph/RenderPassBuilder.cs
- L75 C32: new RenderPassResourceUsage :: _metadata.AddUsage(new RenderPassResourceUsage(resourceName, type, access, load, store));


## XRENGINE/Rendering/RenderGraph/RenderPassMetadata.cs
- L13 C70: new() :: private readonly List<RenderPassResourceUsage> _resourceUsages = new();
- L14 C59: new() :: private readonly HashSet<int> _explicitDependencies = new();


## XRENGINE/Rendering/RenderGraph/RenderPassMetadataCollection.cs
- L10 C68: new() :: private readonly Dictionary<int, RenderPassMetadata> _passes = new();
- L16 C24: new RenderPassMetadata :: metadata = new RenderPassMetadata(passIndex, name ?? $"Pass{passIndex}", stage);
- L28 C16: new RenderPassBuilder :: return new RenderPassBuilder(metadata);
- L40 C12: new ReadOnlyCollection :: => new ReadOnlyCollection<RenderPassMetadata>(_passes.Values.OrderBy(p => p.PassIndex).ToList());


## XRENGINE/Rendering/Resources/RenderResourceRegistry.cs
- L72 C16: new TextureResourceDescriptor :: return new TextureResourceDescriptor(
- L132 C33: new FrameBufferAttachmentDescriptor :: attachments.Add(new FrameBufferAttachmentDescriptor(resourceName, attachment, mipLevel, layerIndex));
- L136 C16: new FrameBufferResourceDescriptor :: return new FrameBufferResourceDescriptor(
- L163 C16: new BufferResourceDescriptor :: return new BufferResourceDescriptor(
- L276 C22: new RenderTextureResource :: record = new RenderTextureResource(descriptor);
- L293 C22: new RenderFrameBufferResource :: record = new RenderFrameBufferResource(descriptor);
- L310 C22: new RenderBufferResource :: record = new RenderBufferResource(descriptor);
- L324 C45: new InvalidOperationException :: string name = texture.Name ?? throw new InvalidOperationException("Texture name must be set before binding to the registry.");
- L336 C49: new InvalidOperationException :: string name = frameBuffer.Name ?? throw new InvalidOperationException("FrameBuffer name must be set before binding to the registry.");
- L351 C19: new InvalidOperationException :: throw new InvalidOperationException("Data buffer attribute name must be set before binding to the registry.");


## XRENGINE/Rendering/RootNodeCollection.cs
- L16 C41: new ArgumentNullException :: _world = world ?? throw new ArgumentNullException(nameof(world));
- L32 C28: new SceneNode :: var node = new SceneNode(name);


## XRENGINE/Rendering/Shaders/ShaderSnippets.cs
- L41 C48: new() :: private static readonly object _scanLock = new();
- L159 C30: new HashSet :: resolvedSnippets ??= new HashSet<string>(StringComparer.OrdinalIgnoreCase);
- L167 C22: new StringBuilder :: var result = new StringBuilder(source.Length * 2);


## XRENGINE/Rendering/Tools/OctahedralImposterGenerator.cs
- L160 C19: new XRTexture2D :: ? new XRTexture2D(settings.SheetSize, settings.SheetSize, EPixelInternalFormat.DepthComponent32f, EPixelFormat.DepthComponent, EPixelType.Float, false)
- L168 C19: new XRRenderBuffer :: ? new XRRenderBuffer(settings.SheetSize, settings.SheetSize, ERenderBufferStorage.Depth24Stencil8)
- L193 C20: new Result :: return new Result(viewArray, depthTexture, captureBounds, s_captureDirections);
- L208 C22: new() :: AABB total = new();
- L216 C22: new() :: AABB total = new();
- L252 C15: new XRFrameBuffer :: ? new XRFrameBuffer((colorArray, EFrameBufferAttachment.ColorAttachment0, 0, viewIndex))
- L254 C19: new XRFrameBuffer :: ? new XRFrameBuffer(
- L257 C19: new XRFrameBuffer :: : new XRFrameBuffer(
- L282 C33: new CameraPostProcessStateCollection :: PostProcessStates = new CameraPostProcessStateCollection(),
- L362 C54: new Vector3 :: directions.Add(Vector3.Normalize(new Vector3(xSign, ySign, zSign)));


## XRENGINE/Rendering/UI/ImGuiContextTracker.cs
- L10 C50: new() :: private static readonly object ContextLock = new();


## XRENGINE/Rendering/UI/ImGuiControllerUtilities.cs
- L110 C19: new DirectoryInfo :: var dir = new DirectoryInfo(AppContext.BaseDirectory);
- L119 C15: new DirectoryInfo :: dir = new DirectoryInfo(Environment.CurrentDirectory);


## XRENGINE/Rendering/UI/UIBatchCollector.cs
- L165 C21: new MaterialQuadBatchData :: batch = new MaterialQuadBatchData();
- L168 C27: new MaterialQuadEntry :: batch.Entries.Add(new MaterialQuadEntry
- L201 C21: new TextBatchData :: batch = new TextBatchData();
- L204 C27: new TextEntry :: batch.Entries.Add(new TextEntry
- L344 C24: new XRMaterial :: var material = new XRMaterial(Array.Empty<ShaderVar>(), [vertexShader, fragmentShader])
- L347 C29: new RenderingParameters :: RenderOptions = new RenderingParameters
- L350 C29: new DepthTest :: DepthTest = new DepthTest
- L359 C24: new XRMeshRenderer :: _matQuadMesh = new XRMeshRenderer(
- L378 C32: new XRDataBuffer :: _matQuadTransformBuf = new XRDataBuffer(
- L389 C28: new XRDataBuffer :: _matQuadColorBuf = new XRDataBuffer(
- L400 C29: new XRDataBuffer :: _matQuadBoundsBuf = new XRDataBuffer(
- L469 C15: new TextGPUResources :: gpu = new TextGPUResources();
- L476 C24: new XRMaterial :: var material = new XRMaterial(Array.Empty<ShaderVar>(), [fontAtlas], [vertexShader, fragmentShader])
- L479 C29: new RenderingParameters :: RenderOptions = new RenderingParameters
- L482 C29: new DepthTest :: DepthTest = new DepthTest
- L491 C20: new XRMeshRenderer :: gpu.Mesh = new XRMeshRenderer(
- L526 C34: new XRDataBuffer :: gpu.GlyphTransformsBuf = new XRDataBuffer(
- L537 C33: new XRDataBuffer :: gpu.GlyphTexCoordsBuf = new XRDataBuffer(
- L548 C31: new XRDataBuffer :: gpu.TextInstanceBuf = new XRDataBuffer(
- L559 C33: new XRDataBuffer :: gpu.GlyphTextIndexBuf = new XRDataBuffer(


## XRENGINE/Rendering/UI/Ultralight/OpenGLGPUDriver.cs
- L36 C51: new() :: public readonly List<TextureEntry> Textures = new();
- L37 C56: new() :: private readonly List<GeometryEntry> _geometries = new();
- L38 C61: new() :: public readonly List<RenderBufferEntry> RenderBuffers = new();
- L40 C49: new() :: private readonly Stack<int> _freeTextures = new();
- L41 C49: new() :: private readonly Stack<int> _freeGeometry = new();
- L42 C54: new() :: private readonly Stack<int> _freeRenderBuffers = new();
- L65 C22: new TextureEntry :: Textures.Add(new TextureEntry());
- L66 C25: new GeometryEntry :: _geometries.Add(new GeometryEntry());
- L67 C27: new RenderBufferEntry :: RenderBuffers.Add(new RenderBufferEntry());
- L136 C19: new Exception :: throw new Exception($"[UltralightGL] Program failed to link: {_gl.GetProgramInfoLog(program)}");
- L153 C19: new FileNotFoundException :: throw new FileNotFoundException($"Embedded shader resource not found: {resourceName}");
- L164 C32: new TextureEntry :: Textures[freeId] = new TextureEntry();
- L167 C22: new TextureEntry :: Textures.Add(new TextureEntry());
- L321 C37: new RenderBufferEntry :: RenderBuffers[freeId] = new RenderBufferEntry();
- L324 C27: new RenderBufferEntry :: RenderBuffers.Add(new RenderBufferEntry());
- L389 C35: new GeometryEntry :: _geometries[freeId] = new GeometryEntry();
- L392 C25: new GeometryEntry :: _geometries.Add(new GeometryEntry());
- L560 C40: new Span :: gpuState.Scalar.CopyTo(new Span<float>(&uniforms.Scalar4_0.W, 8));
- L561 C40: new Span :: gpuState.Vector.CopyTo(new Span<Vector4>(&uniforms.Vector_0, 8));
- L562 C38: new Span :: gpuState.Clip.CopyTo(new Span<Matrix4x4>(&uniforms.Clip_0.M11, 8));
- L657 C23: new Exception :: throw new Exception($"Invalid {nameof(ULCommandType)} value.");
- L693 C40: new() :: public TextureEntry TexEntry = new();


## XRENGINE/Rendering/Vertex/Vertex.cs
- L89 C24: new HashCode :: var hash = new HashCode();
- L101 C16: new() :: => new()
- L103 C52: new Dictionary :: Weights = Weights is null ? null : new Dictionary<TransformBase, (float weight, Matrix4x4 bindInvWorldMatrix)>(Weights),
- L141 C32: new() :: Matrix4x4 matrix = new();
- L153 C32: new() :: Matrix4x4 matrix = new();
- L179 C24: new() :: Vertex v = new()
- L195 C48: new Vector2 :: v.TextureCoordinateSets = [new Vector2(uv.X, uv.Y)];
- L197 C49: new Vector2 :: v.TextureCoordinateSets.Add(new Vector2(uv.X, uv.Y));
- L221 C39: new() :: VertexData data = new()
- L240 C59: new Vector2 :: data.TextureCoordinateSets = [new Vector2(uv.X, uv.Y)];
- L242 C60: new Vector2 :: data.TextureCoordinateSets.Add(new Vector2(uv.X, uv.Y));


## XRENGINE/Rendering/Vertex/VertexLineStrip.cs
- L18 C34: new VertexLine :: VertexLine[] lines = new VertexLine[count];
- L22 C28: new VertexLine :: lines[i] = new VertexLine(_vertices[i], next);


## XRENGINE/Rendering/Vertex/VertexPolygon.cs
- L9 C23: new InvalidOperationException :: throw new InvalidOperationException("Not enough vertices for a polygon.");
- L14 C23: new InvalidOperationException :: throw new InvalidOperationException("Not enough vertices for a polygon.");
- L35 C37: new VertexTriangle :: VertexTriangle[] list = new VertexTriangle[triangleCount];
- L37 C27: new VertexTriangle :: list[i] = new VertexTriangle(
- L46 C34: new VertexLine :: VertexLine[] lines = new VertexLine[Vertices.Count];
- L49 C28: new VertexLine :: lines[i] = new VertexLine(Vertices[i].HardCopy(), Vertices[i + 1].HardCopy());
- L51 C41: new VertexLine :: lines[Vertices.Count - 1] = new VertexLine(Vertices[^1].HardCopy(), Vertices[0].HardCopy());


## XRENGINE/Rendering/Vertex/VertexPrimitive.cs
- L24 C20: new AABB :: return new AABB(XRMath.ComponentMin(positions), XRMath.ComponentMax(positions));


## XRENGINE/Rendering/Vertex/VertexQuad.cs
- L52 C24: new VertexQuad :: return new VertexQuad(
- L53 C21: new Vertex :: new Vertex(bottomLeft,  new Vector2(0.0f, flipVerticalUVCoord ? 1.0f : 0.0f)),
- L53 C45: new Vector2 :: new Vertex(bottomLeft,  new Vector2(0.0f, flipVerticalUVCoord ? 1.0f : 0.0f)),
- L54 C21: new Vertex :: new Vertex(bottomRight, new Vector2(1.0f, flipVerticalUVCoord ? 1.0f : 0.0f)),
- L54 C45: new Vector2 :: new Vertex(bottomRight, new Vector2(1.0f, flipVerticalUVCoord ? 1.0f : 0.0f)),
- L55 C21: new Vertex :: new Vertex(topRight,    new Vector2(1.0f, flipVerticalUVCoord ? 0.0f : 1.0f)),
- L55 C45: new Vector2 :: new Vertex(topRight,    new Vector2(1.0f, flipVerticalUVCoord ? 0.0f : 1.0f)),
- L56 C21: new Vertex :: new Vertex(topLeft,     new Vector2(0.0f, flipVerticalUVCoord ? 0.0f : 1.0f)));
- L56 C45: new Vector2 :: new Vertex(topLeft,     new Vector2(0.0f, flipVerticalUVCoord ? 0.0f : 1.0f)));
- L62 C17: new Vertex :: new Vertex(bottomLeft,  normal, new Vector2(0.0f, flipVerticalUVCoord ? 1.0f : 0.0f)),
- L62 C49: new Vector2 :: new Vertex(bottomLeft,  normal, new Vector2(0.0f, flipVerticalUVCoord ? 1.0f : 0.0f)),
- L63 C17: new Vertex :: new Vertex(bottomRight, normal, new Vector2(1.0f, flipVerticalUVCoord ? 1.0f : 0.0f)),
- L63 C49: new Vector2 :: new Vertex(bottomRight, normal, new Vector2(1.0f, flipVerticalUVCoord ? 1.0f : 0.0f)),
- L64 C17: new Vertex :: new Vertex(topRight,    normal, new Vector2(1.0f, flipVerticalUVCoord ? 0.0f : 1.0f)),
- L64 C49: new Vector2 :: new Vertex(topRight,    normal, new Vector2(1.0f, flipVerticalUVCoord ? 0.0f : 1.0f)),
- L65 C17: new Vertex :: new Vertex(topLeft,     normal, new Vector2(0.0f, flipVerticalUVCoord ? 0.0f : 1.0f)));
- L65 C49: new Vector2 :: new Vertex(topLeft,     normal, new Vector2(0.0f, flipVerticalUVCoord ? 0.0f : 1.0f)));
- L209 C27: new ArgumentOutOfRangeException :: throw new ArgumentOutOfRangeException(nameof(cubeMapFace), cubeMapFace, null);
- L230 C20: new VertexQuad :: return new VertexQuad(
- L231 C17: new Vertex :: new Vertex(bottomLeft, normal, bottomLeftUV),
- L232 C17: new Vertex :: new Vertex(bottomRight, normal, bottomRightUV),
- L233 C17: new Vertex :: new Vertex(topRight, normal, topRightUV),
- L234 C17: new Vertex :: new Vertex(topLeft, normal, topLeftUV));
- L244 C20: new VertexQuad :: return new VertexQuad(
- L245 C17: new Vertex :: new Vertex(bottomLeft,  bottomLeftInf,  normal, new Vector2(0.0f, flipVerticalUVCoord ? 1.0f : 0.0f)),
- L245 C65: new Vector2 :: new Vertex(bottomLeft,  bottomLeftInf,  normal, new Vector2(0.0f, flipVerticalUVCoord ? 1.0f : 0.0f)),
- L246 C17: new Vertex :: new Vertex(bottomRight, bottomRightInf, normal, new Vector2(1.0f, flipVerticalUVCoord ? 1.0f : 0.0f)),
- L246 C65: new Vector2 :: new Vertex(bottomRight, bottomRightInf, normal, new Vector2(1.0f, flipVerticalUVCoord ? 1.0f : 0.0f)),
- L247 C17: new Vertex :: new Vertex(topRight,    topRightInf,    normal, new Vector2(1.0f, flipVerticalUVCoord ? 0.0f : 1.0f)),
- L247 C65: new Vector2 :: new Vertex(topRight,    topRightInf,    normal, new Vector2(1.0f, flipVerticalUVCoord ? 0.0f : 1.0f)),
- L248 C17: new Vertex :: new Vertex(topLeft,     topLeftInf,     normal, new Vector2(0.0f, flipVerticalUVCoord ? 0.0f : 1.0f)));
- L248 C65: new Vector2 :: new Vertex(topLeft,     topLeftInf,     normal, new Vector2(0.0f, flipVerticalUVCoord ? 0.0f : 1.0f)));
- L257 C20: new VertexQuad :: return new VertexQuad(
- L258 C17: new Vertex :: new Vertex(bottomLeft,  bottomLeftInf,  bottomLeftNormal,   new Vector2(0.0f, flipVerticalUVCoord ? 1.0f : 0.0f)),
- L258 C77: new Vector2 :: new Vertex(bottomLeft,  bottomLeftInf,  bottomLeftNormal,   new Vector2(0.0f, flipVerticalUVCoord ? 1.0f : 0.0f)),
- L259 C17: new Vertex :: new Vertex(bottomRight, bottomRightInf, bottomRightNormal,  new Vector2(1.0f, flipVerticalUVCoord ? 1.0f : 0.0f)),
- L259 C77: new Vector2 :: new Vertex(bottomRight, bottomRightInf, bottomRightNormal,  new Vector2(1.0f, flipVerticalUVCoord ? 1.0f : 0.0f)),
- L260 C17: new Vertex :: new Vertex(topRight,    topRightInf,    topRightNormal,     new Vector2(1.0f, flipVerticalUVCoord ? 0.0f : 1.0f)),
- L260 C77: new Vector2 :: new Vertex(topRight,    topRightInf,    topRightNormal,     new Vector2(1.0f, flipVerticalUVCoord ? 0.0f : 1.0f)),
- L261 C17: new Vertex :: new Vertex(topLeft,     topLeftInf,     topLeftNormal,      new Vector2(0.0f, flipVerticalUVCoord ? 0.0f : 1.0f)));
- L261 C77: new Vector2 :: new Vertex(topLeft,     topLeftInf,     topLeftNormal,      new Vector2(0.0f, flipVerticalUVCoord ? 0.0f : 1.0f)));
- L274 C24: new VertexQuad :: return new VertexQuad(
- L275 C21: new Vertex :: new Vertex(bottomLeft,  bottomLeftInf,  normal, new Vector2(0.0f, flipVerticalUVCoord ? 1.0f : 0.0f)),
- L275 C69: new Vector2 :: new Vertex(bottomLeft,  bottomLeftInf,  normal, new Vector2(0.0f, flipVerticalUVCoord ? 1.0f : 0.0f)),
- L276 C21: new Vertex :: new Vertex(bottomRight, bottomRightInf, normal, new Vector2(1.0f, flipVerticalUVCoord ? 1.0f : 0.0f)),
- L276 C69: new Vector2 :: new Vertex(bottomRight, bottomRightInf, normal, new Vector2(1.0f, flipVerticalUVCoord ? 1.0f : 0.0f)),
- L277 C21: new Vertex :: new Vertex(topRight,    topRightInf,    normal, new Vector2(1.0f, flipVerticalUVCoord ? 0.0f : 1.0f)),
- L277 C69: new Vector2 :: new Vertex(topRight,    topRightInf,    normal, new Vector2(1.0f, flipVerticalUVCoord ? 0.0f : 1.0f)),
- L278 C21: new Vertex :: new Vertex(topLeft,     topLeftInf,     normal, new Vector2(0.0f, flipVerticalUVCoord ? 0.0f : 1.0f)));
- L278 C69: new Vector2 :: new Vertex(topLeft,     topLeftInf,     normal, new Vector2(0.0f, flipVerticalUVCoord ? 0.0f : 1.0f)));
- L281 C24: new VertexQuad :: return new VertexQuad(
- L282 C21: new Vertex :: new Vertex(bottomLeft,  bottomLeftInf,  new Vector2(0.0f, flipVerticalUVCoord ? 1.0f : 0.0f)),
- L282 C61: new Vector2 :: new Vertex(bottomLeft,  bottomLeftInf,  new Vector2(0.0f, flipVerticalUVCoord ? 1.0f : 0.0f)),
- L283 C21: new Vertex :: new Vertex(bottomRight, bottomRightInf, new Vector2(1.0f, flipVerticalUVCoord ? 1.0f : 0.0f)),
- L283 C61: new Vector2 :: new Vertex(bottomRight, bottomRightInf, new Vector2(1.0f, flipVerticalUVCoord ? 1.0f : 0.0f)),
- L284 C21: new Vertex :: new Vertex(topRight,    topRightInf,    new Vector2(1.0f, flipVerticalUVCoord ? 0.0f : 1.0f)),
- L284 C61: new Vector2 :: new Vertex(topRight,    topRightInf,    new Vector2(1.0f, flipVerticalUVCoord ? 0.0f : 1.0f)),
- L285 C21: new Vertex :: new Vertex(topLeft,     topLeftInf,     new Vector2(0.0f, flipVerticalUVCoord ? 0.0f : 1.0f)));
- L285 C61: new Vector2 :: new Vertex(topLeft,     topLeftInf,     new Vector2(0.0f, flipVerticalUVCoord ? 0.0f : 1.0f)));
- L322 C17: new Vector3 :: new Vector3(region.BottomLeft.X, 0.0f, region.BottomLeft.Y),
- L323 C17: new Vector3 :: new Vector3(region.BottomRight.X, 0.0f, region.BottomRight.Y),
- L324 C17: new Vector3 :: new Vector3(region.TopRight.X, 0.0f, region.TopRight.Y),
- L325 C17: new Vector3 :: new Vector3(region.TopLeft.X, 0.0f, region.TopLeft.Y),
- L362 C17: new Vector3 :: new Vector3(region.BottomLeft.X, region.BottomLeft.Y, 0.0f),
- L363 C17: new Vector3 :: new Vector3(region.BottomRight.X, region.BottomRight.Y, 0.0f),
- L364 C17: new Vector3 :: new Vector3(region.TopRight.X, region.TopRight.Y, 0.0f),
- L365 C17: new Vector3 :: new Vector3(region.TopLeft.X, region.TopLeft.Y, 0.0f),


## XRENGINE/Rendering/Vertex/VertexTriangleStrip.cs
- L10 C42: new VertexTriangle :: VertexTriangle[] triangles = new VertexTriangle[FaceCount];
- L12 C36: new VertexTriangle :: triangles[i - 2] = new VertexTriangle(


## XRENGINE/Rendering/VideoStreaming/FFmpegStreamDecoder.cs
- L46 C35: new() :: private readonly Lock _lock = new();
- L186 C27: new InvalidOperationException :: throw new InvalidOperationException(
- L207 C33: new Thread :: _decodeThread = new Thread(DecodeLoop)
- L416 C27: new byte :: byte[] data = new byte[dataSize];
- L430 C25: new DecodedVideoFrame :: var frame = new DecodedVideoFrame(width, height, pts, VideoPixelFormat.Rgb24, data);
- L539 C23: new byte :: byte[] data = new byte[totalBytes];
- L582 C21: new DecodedAudioFrame :: var frame = new DecodedAudioFrame(sampleRate, channels, sampleFormat, pts, data);
- L957 C32: new() :: AVRational dstTb = new() { num = 1, den = (int)TimeSpan.TicksPerSecond };
- L1023 C22: new byte :: byte[] buf = new byte[1024];
- L1027 C20: new string :: return new string((sbyte*)ptr).Trim('\0');


## XRENGINE/Rendering/VideoStreaming/HlsMediaStreamSession.cs
- L57 C37: new() :: private readonly object _sync = new();
- L117 C20: new FFmpegStreamDecoder :: _decoder = new FFmpegStreamDecoder


## XRENGINE/Rendering/VideoStreaming/HlsReferenceRuntime.cs
- L15 C62: new() :: private static readonly object StreamingEngineInitLock = new();
- L116 C62: new PathFirstFunctionResolver :: DynamicallyLoadedBindings.FunctionResolver = new PathFirstFunctionResolver(ffmpegPath);
- L194 C12: new HlsMediaStreamSession :: => new HlsMediaStreamSession();


## XRENGINE/Rendering/VideoStreaming/OpenGLVideoFrameGpuActions.cs
- L35 C39: new uint :: private readonly uint[] _pboIds = new uint[PboCount];


## XRENGINE/Rendering/VideoStreaming/StreamVariantInfo.cs
- L94 C24: new List :: var variants = new List<StreamVariantInfo>();
- L115 C26: new StreamVariantInfo :: variants.Add(new StreamVariantInfo
- L201 C16: new Uri :: return new Uri(baseUri, maybeRelative).ToString();


## XRENGINE/Rendering/VideoStreaming/TwitchHlsStreamResolver.cs
- L29 C47: new() :: private static readonly HttpClient Http = new();
- L35 C19: new ArgumentException :: throw new ArgumentException("Stream source cannot be empty.", nameof(source));
- L44 C20: new ResolvedStream :: return new ResolvedStream
- L58 C20: new ResolvedStream :: return new ResolvedStream
- L71 C19: new InvalidOperationException :: throw new InvalidOperationException("Twitch channel resolution produced an empty channel name.");
- L74 C19: new InvalidOperationException :: throw new InvalidOperationException("Twitch VOD resolution produced an empty VOD id.");
- L86 C16: new ResolvedStream :: return new ResolvedStream
- L110 C37: new HttpRequestMessage :: using var request = new HttpRequestMessage(HttpMethod.Post, "https://gql.twitch.tv/gql");
- L112 C47: new ProductInfoHeaderValue :: request.Headers.UserAgent.Add(new ProductInfoHeaderValue("Mozilla", "5.0"));
- L128 C35: new StringContent :: request.Content = new StringContent(JsonSerializer.Serialize(payload), Encoding.UTF8, "application/json");
- L144 C27: new InvalidOperationException :: throw new InvalidOperationException("Twitch token response did not include a playback access token payload.");
- L152 C27: new InvalidOperationException :: throw new InvalidOperationException($"Twitch playback token was not available for {target}.");
- L159 C27: new InvalidOperationException :: throw new InvalidOperationException("Twitch token response did not include a valid token/signature.");
- L172 C15: new InvalidOperationException :: throw new InvalidOperationException($"Failed to resolve Twitch token for channel '{channel}' after {maxAttempts} attempts.");
- L202 C15: new InvalidOperationException :: throw new InvalidOperationException($"Failed to fetch Twitch playlist '{masterPlaylistUrl}' after {maxAttempts} attempts.");
- L256 C16: new Uri :: return new Uri(baseUri, maybeRelative).ToString();
- L282 C12: new() :: => new()
- L286 C23: new Dictionary :: Headers = new Dictionary<string, string>
- L300 C16: new StreamOpenOptions :: return new StreamOpenOptions();
- L318 C22: new InvalidOperationException :: ?? throw new InvalidOperationException("YouTube URL detected, but yt-dlp was not found. Install yt-dlp and ensure it is on PATH or copied beside the app executable as 'yt-dlp.exe'.");
- L320 C25: new ProcessStartInfo :: var startInfo = new ProcessStartInfo
- L337 C29: new Process :: using var process = new Process { StartInfo = startInfo };
- L339 C19: new InvalidOperationException :: throw new InvalidOperationException("Failed to start yt-dlp process.");
- L350 C19: new InvalidOperationException :: throw new InvalidOperationException($"yt-dlp failed to resolve YouTube URL: {error}");
- L359 C19: new InvalidOperationException :: throw new InvalidOperationException("yt-dlp did not return a playable URL for this YouTube source.");


## XRENGINE/Rendering/VideoStreaming/VideoFrameGpuActionsFactory.cs
- L13 C31: new OpenGLVideoFrameGpuActions :: OpenGLRenderer => new OpenGLVideoFrameGpuActions(),
- L14 C31: new VulkanVideoFrameGpuActions :: VulkanRenderer => new VulkanVideoFrameGpuActions(),
- L15 C18: new NullVideoFrameGpuActions :: _ => new NullVideoFrameGpuActions(renderer.GetType().Name)


## XRENGINE/Rendering/VideoStreaming/VideoStreamingSubsystem.cs
- L13 C16: new TwitchHlsStreamResolver :: => new(new TwitchHlsStreamResolver(), sessionFactory);


## XRENGINE/Rendering/VisualScene.cs
- L15 C48: new() :: public GPUScene GPUCommands { get; } = new();


## XRENGINE/Rendering/VisualScene2D.cs
- L25 C61: new Quadtree :: public Quadtree<RenderInfo2D> RenderTree { get; } = new Quadtree<RenderInfo2D>(new BoundingRectangleF());
- L25 C88: new BoundingRectangleF :: public Quadtree<RenderInfo2D> RenderTree { get; } = new Quadtree<RenderInfo2D>(new BoundingRectangleF());
- L40 C50: new Vector3 :: => Engine.Rendering.Debug.RenderQuad(new Vector3(center, 0.0f) + AbstractRenderer.UIPositionBias, AbstractRenderer.UIRotation, extents, false, color);
- L116 C110: new() :: private readonly ConcurrentQueue<(RenderInfo2D renderable, bool add)> _pendingRenderableOperations = new(); // staged until PreCollectVisible runs on the collect visible thread
- L117 C52: new() :: private readonly object _renderablesLock = new();


## XRENGINE/Rendering/VisualScene3D.cs
- L26 C59: new Octree :: public Octree<RenderInfo3D> RenderTree { get; } = new Octree<RenderInfo3D>(new AABB());
- L26 C84: new AABB :: public Octree<RenderInfo3D> RenderTree { get; } = new Octree<RenderInfo3D>(new AABB());
- L31 C60: new() :: public BvhRaycastDispatcher BvhRaycasts { get; } = new();
- L113 C110: new() :: private readonly ConcurrentQueue<(RenderInfo3D renderable, bool add)> _pendingRenderableOperations = new(); // staged until PreCollectVisible runs on the collect visible thread
- L115 C67: new() :: private readonly HashSet<RenderableMesh> _skinnedMeshes = new();


## XRENGINE/Rendering/XeSS/IntelXessManager.cs
- L17 C94: new() :: private static readonly ConcurrentDictionary<XRViewport, float> _lastViewportScale = new();


## XRENGINE/Rendering/XRMeshRenderer.cs
- L247 C31: new SubMesh :: Submeshes.Add(new SubMesh() { Mesh = mesh, Material = material, InstanceCount = 1 });
- L254 C50: new Version :: GeneratedVertexShaderVersions.Add(0, new Version<DefaultVertexShaderGenerator>(this, NoSpecialExtensions, true));
- L255 C50: new Version :: GeneratedVertexShaderVersions.Add(1, new Version<OVRMultiViewVertexShaderGenerator>(this, HasMultiViewExtension, false));
- L256 C50: new Version :: GeneratedVertexShaderVersions.Add(2, new Version<NVStereoVertexShaderGenerator>(this, HasNVStereoViewRendering, false));
- L259 C50: new MeshDeformVersion :: GeneratedVertexShaderVersions.Add(3, new MeshDeformVersion(this, NoSpecialExtensions, true));
- L260 C50: new MeshDeformVersion :: GeneratedVertexShaderVersions.Add(4, new MeshDeformVersion(this, HasMultiViewExtension, false) { UseOVRMultiView = true });
- L261 C50: new MeshDeformVersion :: GeneratedVertexShaderVersions.Add(5, new MeshDeformVersion(this, HasNVStereoViewRendering, false) { UseNVStereo = true });
- L286 C33: new OVRMultiViewMeshDeformVertexShaderGenerator :: generator = new OVRMultiViewMeshDeformVertexShaderGenerator(m, maxInfluences, optimizeToVec4);
- L288 C33: new NVStereoMeshDeformVertexShaderGenerator :: generator = new NVStereoMeshDeformVertexShaderGenerator(m, maxInfluences, optimizeToVec4);
- L290 C33: new MeshDeformVertexShaderGenerator :: generator = new MeshDeformVertexShaderGenerator(m, maxInfluences, optimizeToVec4);
- L529 C42: new XRDataBuffer :: IndirectDrawBuffer = new XRDataBuffer(
- L565 C23: new DrawElementsIndirectCommand :: ? new DrawElementsIndirectCommand()
- L573 C23: new DrawElementsIndirectCommand :: : new DrawElementsIndirectCommand()
- L762 C33: new XRDataBuffer :: BlendshapeWeights = new XRDataBuffer($"{ECommonBufferType.BlendshapeWeights}Buffer", EBufferTarget.ShaderStorageBuffer, blendshapeCount.Align(4), EComponentType.Float, 1, false, false)
- L980 C22: new RenderBone :: _bones = new RenderBone[boneCount];
- L981 C32: new Dictionary :: _boneByTransform = new Dictionary<TransformBase, RenderBone>((int)boneCount);
- L982 C33: new List :: _dirtyBoneIndices = new List<uint>((int)boneCount);
- L983 C31: new bool :: _dirtyBoneFlags = new bool[boneCount + 1];
- L984 C34: new Matrix4x4 :: _dirtyBoneMatrices = new Matrix4x4[boneCount + 1];
- L990 C26: new RenderBone :: var rb = new RenderBone(tfm, invBindWorldMtx, boneIndex);
- L1104 C39: new XRDataBuffer :: DeformerPositionsBuffer = new XRDataBuffer(
- L1117 C43: new XRDataBuffer :: DeformerRestPositionsBuffer = new XRDataBuffer(
- L1134 C55: new Vector4 :: DeformerPositionsBuffer.SetVector4(i, new Vector4(pos, 1.0f));
- L1135 C59: new Vector4 :: DeformerRestPositionsBuffer.SetVector4(i, new Vector4(pos, 1.0f));
- L1144 C41: new XRDataBuffer :: DeformerNormalsBuffer = new XRDataBuffer(
- L1160 C57: new Vector4 :: DeformerNormalsBuffer.SetVector4(i, new Vector4(nrm, 0.0f));
- L1169 C42: new XRDataBuffer :: DeformerTangentsBuffer = new XRDataBuffer(
- L1185 C58: new Vector4 :: DeformerTangentsBuffer.SetVector4(i, new Vector4(tan, 0.0f));
- L1209 C45: new XRDataBuffer :: MeshDeformVertexIndicesBuffer = new XRDataBuffer(
- L1222 C45: new XRDataBuffer :: MeshDeformVertexWeightsBuffer = new XRDataBuffer(
- L1272 C72: new IVector4 :: MeshDeformVertexIndicesBuffer.SetDataRawAtIndex(v, new IVector4((int)indices.X, (int)indices.Y, (int)indices.Z, (int)indices.W));
- L1296 C39: new XRDataBuffer :: MeshDeformIndicesBuffer = new XRDataBuffer(
- L1309 C39: new XRDataBuffer :: MeshDeformWeightsBuffer = new XRDataBuffer(
- L1323 C44: new XRDataBuffer :: MeshDeformVertexOffsetBuffer = new XRDataBuffer(
- L1336 C43: new XRDataBuffer :: MeshDeformVertexCountBuffer = new XRDataBuffer(
- L1410 C55: new Vector4 :: DeformerPositionsBuffer.SetVector4(i, new Vector4(pos, 1.0f));
- L1430 C53: new Vector4 :: DeformerNormalsBuffer.SetVector4(i, new Vector4(nrm, 0.0f));
- L1450 C54: new Vector4 :: DeformerTangentsBuffer.SetVector4(i, new Vector4(tan, 0.0f));


## XRENGINE/Rendering/XRViewport.cs
- L52 C45: new() :: private BoundingRectangle _region = new();
- L58 C63: new() :: private BoundingRectangle _internalResolutionRegion = new();
- L64 C69: new() :: private readonly XRRenderPipelineInstance _renderPipeline = new();
- L1428 C26: new InvalidOperationException :: ?? throw new InvalidOperationException("No camera is set to this viewport.");
- L1437 C52: new Vector2 :: => NormalizedViewportToWorldCoordinate(new Vector2(normalizedViewportPoint.X, normalizedViewportPoint.Y), normalizedViewportPoint.Z);
- L1449 C26: new InvalidOperationException :: ?? throw new InvalidOperationException("No camera is set to this viewport.");
- L1531 C26: new InvalidOperationException :: ?? throw new InvalidOperationException("No camera is set to this viewport.");
- L1542 C20: new Segment :: ?? new Segment(Vector3.Zero, Vector3.Zero);


## XRENGINE/Rendering/XRWorld.cs
- L16 C43: new() :: private WorldSettings _settings = new();


## XRENGINE/Rendering/XRWorldInstance.cs
- L76 C36: new XRScene :: _editorScene = new XRScene("__EditorScene__")
- L160 C91: new() :: private readonly ConcurrentQueue<PhysicsRaycastRequest> _pendingPhysicsRaycasts = new();
- L161 C94: new() :: private readonly ConcurrentQueue<PhysicsRaycastRequest> _physicsRaycastRequestPool = new();
- L282 C26: new RootNodeCollection :: _rootNodes = new RootNodeCollection(this);
- L283 C22: new Lights3DCollection :: Lights = new Lights3DCollection(this);
- L346 C102: new() :: private readonly ConcurrentQueue<IAbstractDynamicRigidBody> _pendingMinYPlaneResetRequests = new();
- L782 C99: new() :: private ConcurrentQueue<(TransformBase tfm, Matrix4x4 renderMatrix)> _pushToRenderWrite = new();
- L783 C102: new() :: private ConcurrentQueue<(TransformBase tfm, Matrix4x4 renderMatrix)> _pushToRenderSnapshot = new();
- L924 C25: new HashSet :: var moved = new HashSet<SceneNode>(System.Collections.Generic.ReferenceEqualityComparer.Instance);
- L1004 C48: new() :: private readonly Lock _listGroupLock = new();
- L1015 C43: new TickList :: dic.Add(order, list = new TickList(Engine.Rendering.Settings.TickGroupedItemsInParallel));
- L1131 C27: new PhysicsRaycastRequest :: request = new PhysicsRaycastRequest();
- L1254 C22: new MeshEdgePickResult :: result = new MeshEdgePickResult(faceHit, bestStart, bestEnd, closest, bestEdgeIndex);
- L1286 C22: new MeshVertexPickResult :: result = new MeshVertexPickResult(faceHit, bestVertex, bestIndex);
- L1356 C31: new IndexTriangle :: triangleIndices = new IndexTriangle();
- L1457 C29: new Triangle :: worldTriangle = new Triangle(
- L1474 C28: new XRWorldInstance :: instance = new XRWorldInstance(targetWorld);
- L1575 C45: new WorldSettings :: return TargetWorld?.Settings ?? new WorldSettings();
- L1584 C60: new Data.Colors.ColorF3 :: return settings?.GetEffectiveAmbientColor() ?? new Data.Colors.ColorF3(0.03f, 0.03f, 0.03f);


## XRENGINE/Rendering/XRWorldObjectBase.cs
- L139 C34: new ReplicationInfo :: repl ??= new ReplicationInfo();
- L146 C34: new ReplicationInfo :: repl ??= new ReplicationInfo();


## XRENGINE/Scene/Components/Animation/AnimStateMachineComponent.cs
- L21 C50: new() :: private AnimStateMachine _stateMachine = new();
- L115 C28: new MemoryStream :: using var ms = new MemoryStream();
- L116 C29: new BinaryWriter :: using (var bw = new BinaryWriter(ms, Encoding.UTF8, leaveOpen: true))
- L199 C27: new byte :: byte[] data = new byte[bitCount.Align(8) / 8];
- L315 C36: new MemoryStream :: using var ms = new MemoryStream(bytes);
- L316 C36: new BinaryReader :: using var br = new BinaryReader(ms, Encoding.UTF8, leaveOpen: false);
- L320 C35: new List :: var entries = new List<AnimStateMachine.AnimParameterSchemaEntry>(count);
- L348 C37: new AnimStateMachine.AnimParameterSchemaEntry :: entries.Add(new AnimStateMachine.AnimParameterSchemaEntry(name, type, boolDefault, intDefault, floatDefault));


## XRENGINE/Scene/Components/Animation/EyeTrackingBlendTrees.cs
- L9 C57: new() :: public static BlendTree2D RightEyeLidBlend() => new()
- L17 C17: new BlendTree2D.Child :: new BlendTree2D.Child
- L23 C17: new BlendTree2D.Child :: new BlendTree2D.Child
- L29 C17: new BlendTree2D.Child :: new BlendTree2D.Child
- L35 C17: new BlendTree2D.Child :: new BlendTree2D.Child
- L41 C17: new BlendTree2D.Child :: new BlendTree2D.Child
- L47 C17: new BlendTree2D.Child :: new BlendTree2D.Child
- L53 C17: new BlendTree2D.Child :: new BlendTree2D.Child
- L61 C62: new() :: private static AnimationClip EyeOpenSquintRight() => new()
- L71 C61: new() :: private static AnimationClip EyelidSquintRight() => new()
- L81 C59: new() :: private static AnimationClip EyelidWideRight() => new()
- L91 C62: new() :: private static AnimationClip EyelidNeutralRight() => new()
- L101 C60: new() :: private static AnimationClip EyelidBlinkRight() => new()
- L114 C56: new() :: public static BlendTree2D LeftEyeLidBlend() => new()
- L122 C17: new BlendTree2D.Child :: new BlendTree2D.Child
- L128 C17: new BlendTree2D.Child :: new BlendTree2D.Child
- L134 C17: new BlendTree2D.Child :: new BlendTree2D.Child
- L140 C17: new BlendTree2D.Child :: new BlendTree2D.Child
- L146 C17: new BlendTree2D.Child :: new BlendTree2D.Child
- L152 C17: new BlendTree2D.Child :: new BlendTree2D.Child
- L158 C17: new BlendTree2D.Child :: new BlendTree2D.Child
- L166 C61: new() :: private static AnimationClip EyeOpenSquintLeft() => new()
- L176 C60: new() :: private static AnimationClip EyelidSquintLeft() => new()
- L186 C58: new() :: private static AnimationClip EyelidWideLeft() => new()
- L196 C61: new() :: private static AnimationClip EyelidNeutralLeft() => new()
- L206 C59: new() :: private static AnimationClip EyelidBlinkLeft() => new()
- L219 C61: new() :: public static BlendTreeDirect BrowInnerUpBlend() => new()
- L224 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child
- L229 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child
- L236 C66: new() :: private static BlendTree1D LimitBrowSad_MouthClosed() => new()
- L242 C17: new BlendTree1D.Child :: new BlendTree1D.Child
- L247 C17: new BlendTree1D.Child :: new BlendTree1D.Child
- L254 C58: new() :: private static BlendTree2D BrowSadEmulation() => new()
- L262 C17: new BlendTree2D.Child :: new BlendTree2D.Child
- L268 C17: new BlendTree2D.Child :: new BlendTree2D.Child
- L276 C59: new() :: private static BlendTree2D BrowInnerUpBlend2() => new()
- L284 C17: new BlendTree2D.Child :: new BlendTree2D.Child
- L290 C17: new BlendTree2D.Child :: new BlendTree2D.Child
- L298 C55: new() :: private static AnimationClip BrowInnerUp() => new()
- L306 C56: new() :: private static AnimationClip BrowInnerUp0() => new()
- L319 C20: new BlendTree2D :: return new BlendTree2D
- L327 C21: new BlendTree2D.Child :: new BlendTree2D.Child
- L333 C21: new BlendTree2D.Child :: new BlendTree2D.Child
- L339 C21: new BlendTree2D.Child :: new BlendTree2D.Child
- L345 C21: new BlendTree2D.Child :: new BlendTree2D.Child
- L351 C21: new BlendTree2D.Child :: new BlendTree2D.Child
- L360 C59: new() :: private static AnimationClip EyeLookDownLeft() => new()
- L371 C57: new() :: private static AnimationClip EyeLookUpLeft() => new()
- L382 C58: new() :: private static AnimationClip EyeLookOutLeft() => new()
- L393 C57: new() :: private static AnimationClip EyeLookInLeft() => new()
- L404 C62: new() :: private static AnimationClip EyeLookNeutralLeft() => new()
- L418 C58: new() :: public static BlendTree2D EyeLookRightBlend() => new()
- L426 C21: new BlendTree2D.Child :: new BlendTree2D.Child
- L432 C21: new BlendTree2D.Child :: new BlendTree2D.Child
- L438 C21: new BlendTree2D.Child :: new BlendTree2D.Child
- L444 C21: new BlendTree2D.Child :: new BlendTree2D.Child
- L450 C21: new BlendTree2D.Child :: new BlendTree2D.Child
- L458 C60: new() :: private static AnimationClip EyeLookDownRight() => new()
- L469 C58: new() :: private static AnimationClip EyeLookUpRight() => new()
- L480 C59: new() :: private static AnimationClip EyeLookOutRight() => new()
- L491 C58: new() :: private static AnimationClip EyeLookInRight() => new()
- L502 C63: new() :: private static AnimationClip EyeLookNeutralRight() => new()
- L516 C62: new() :: public static BlendTreeDirect BrowDownLeftBlend() => new()
- L521 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child
- L526 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child
- L531 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child
- L538 C76: new() :: private static BlendTree1D BrowAngry_NoseSneer_Emulation_Left() => new()
- L544 C17: new BlendTree1D.Child :: new BlendTree1D.Child
- L549 C17: new BlendTree1D.Child :: new BlendTree1D.Child
- L556 C83: new() :: private static BlendTree1D BrowAngry_MouthRaiserLower_Emulation_Left() => new()
- L562 C17: new BlendTree1D.Child :: new BlendTree1D.Child
- L567 C17: new BlendTree1D.Child :: new BlendTree1D.Child
- L574 C60: new() :: private static BlendTree1D BrowDownLeftBlend2() => new()
- L580 C17: new BlendTree1D.Child :: new BlendTree1D.Child
- L585 C17: new BlendTree1D.Child :: new BlendTree1D.Child
- L592 C57: new() :: private static AnimationClip BrowDownLeft0() => new()
- L600 C56: new() :: private static AnimationClip BrowDownLeft() => new()
- L611 C63: new() :: public static BlendTreeDirect BrowDownRightBlend() => new()
- L616 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child
- L621 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child
- L626 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child
- L633 C77: new() :: private static BlendTree1D BrowAngry_NoseSneer_Emulation_Right() => new()
- L639 C17: new BlendTree1D.Child :: new BlendTree1D.Child
- L644 C17: new BlendTree1D.Child :: new BlendTree1D.Child
- L651 C84: new() :: private static BlendTree1D BrowAngry_MouthRaiserLower_Emulation_Right() => new()
- L657 C17: new BlendTree1D.Child :: new BlendTree1D.Child
- L662 C17: new BlendTree1D.Child :: new BlendTree1D.Child
- L669 C61: new() :: private static BlendTree1D BrowDownRightBlend2() => new()
- L675 C17: new BlendTree1D.Child :: new BlendTree1D.Child
- L680 C17: new BlendTree1D.Child :: new BlendTree1D.Child
- L687 C58: new() :: private static AnimationClip BrowDownRight0() => new()
- L695 C57: new() :: private static AnimationClip BrowDownRight() => new()
- L706 C65: new() :: public static BlendTreeDirect BrowOuterUpLeftBlend() => new()
- L711 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child
- L716 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child
- L723 C63: new() :: private static BlendTree1D BrowWideLeftEmulation() => new()
- L729 C17: new BlendTree1D.Child :: new BlendTree1D.Child
- L734 C17: new BlendTree1D.Child :: new BlendTree1D.Child
- L741 C63: new() :: private static BlendTree1D BrowOuterUpLeftBlend2() => new()
- L747 C17: new BlendTree1D.Child :: new BlendTree1D.Child
- L752 C17: new BlendTree1D.Child :: new BlendTree1D.Child
- L759 C59: new() :: private static AnimationClip BrowOuterUpLeft() => new()
- L767 C60: new() :: private static AnimationClip BrowOuterUpLeft0() => new()
- L778 C66: new() :: public static BlendTreeDirect BrowOuterUpRightBlend() => new()
- L783 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child
- L788 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child
- L795 C64: new() :: private static BlendTree1D BrowWideRightEmulation() => new()
- L801 C17: new BlendTree1D.Child :: new BlendTree1D.Child
- L806 C17: new BlendTree1D.Child :: new BlendTree1D.Child
- L813 C64: new() :: private static BlendTree1D BrowOuterUpRightBlend2() => new()
- L819 C17: new BlendTree1D.Child :: new BlendTree1D.Child
- L824 C17: new BlendTree1D.Child :: new BlendTree1D.Child
- L831 C60: new() :: private static AnimationClip BrowOuterUpRight() => new()
- L839 C61: new() :: private static AnimationClip BrowOuterUpRight0() => new()


## XRENGINE/Scene/Components/Animation/HumanoidComponent.cs
- L22 C53: new() :: private readonly object _muscleValuesLock = new();
- L45 C46: new() :: private HumanoidSettings _settings = new();
- L169 C124: new Vector2 :: yawDeg: MapMuscleToDeg(EHumanoidValue.NeckTurnLeftRight, GetMuscleValue(EHumanoidValue.NeckTurnLeftRight), new Vector2(-30.0f, 30.0f)),
- L171 C125: new Vector2 :: rollDeg: MapMuscleToDeg(EHumanoidValue.NeckTiltLeftRight, GetMuscleValue(EHumanoidValue.NeckTiltLeftRight), new Vector2(-20.0f, 20.0f)));
- L175 C124: new Vector2 :: yawDeg: MapMuscleToDeg(EHumanoidValue.HeadTurnLeftRight, GetMuscleValue(EHumanoidValue.HeadTurnLeftRight), new Vector2(-60.0f, 60.0f)),
- L177 C125: new Vector2 :: rollDeg: MapMuscleToDeg(EHumanoidValue.HeadTiltLeftRight, GetMuscleValue(EHumanoidValue.HeadTiltLeftRight), new Vector2(-30.0f, 30.0f)));
- L182 C114: new Vector2 :: yawDeg: MapMuscleToDeg(EHumanoidValue.JawLeftRight, GetMuscleValue(EHumanoidValue.JawLeftRight), new Vector2(-15.0f, 15.0f)),
- L183 C108: new Vector2 :: pitchDeg: MapMuscleToDeg(EHumanoidValue.JawClose, GetMuscleValue(EHumanoidValue.JawClose), new Vector2(-5.0f, 25.0f)),
- L237 C90: new Vector2 :: pitchDeg: MapMuscleToDeg(shoulderDownUp, GetMuscleValue(shoulderDownUp), new Vector2(-35.0f, 35.0f)),
- L238 C95: new Vector2 :: rollDeg: MapMuscleToDeg(shoulderFrontBack, GetMuscleValue(shoulderFrontBack), new Vector2(-25.0f, 25.0f)));
- L243 C76: new Vector2 :: yawDeg: MapMuscleToDeg(armTwist, GetMuscleValue(armTwist), new Vector2(-40.0f, 40.0f)),
- L244 C80: new Vector2 :: pitchDeg: MapMuscleToDeg(armDownUp, GetMuscleValue(armDownUp), new Vector2(-90.0f, 90.0f)),
- L245 C85: new Vector2 :: rollDeg: MapMuscleToDeg(armFrontBack, GetMuscleValue(armFrontBack), new Vector2(-60.0f, 60.0f)));
- L250 C84: new Vector2 :: yawDeg: MapMuscleToDeg(forearmTwist, GetMuscleValue(forearmTwist), new Vector2(-60.0f, 60.0f)),
- L258 C36: new Vector2 :: defaultScaleRange: new Vector2(0.97f, 1.03f));
- L264 C82: new Vector2 :: pitchDeg: MapMuscleToDeg(handDownUp, GetMuscleValue(handDownUp), new Vector2(-60.0f, 60.0f)),
- L265 C79: new Vector2 :: rollDeg: MapMuscleToDeg(handInOut, GetMuscleValue(handInOut), new Vector2(-45.0f, 45.0f)));
- L270 C86: new Vector2 :: yawDeg: MapMuscleToDeg(upperLegTwist, GetMuscleValue(upperLegTwist), new Vector2(-45.0f, 45.0f)),
- L271 C96: new Vector2 :: pitchDeg: MapMuscleToDeg(upperLegFrontBack, GetMuscleValue(upperLegFrontBack), new Vector2(-90.0f, 90.0f)),
- L272 C87: new Vector2 :: rollDeg: MapMuscleToDeg(upperLegInOut, GetMuscleValue(upperLegInOut), new Vector2(-35.0f, 35.0f)));
- L277 C86: new Vector2 :: yawDeg: MapMuscleToDeg(lowerLegTwist, GetMuscleValue(lowerLegTwist), new Vector2(-30.0f, 30.0f)),
- L285 C36: new Vector2 :: defaultScaleRange: new Vector2(0.97f, 1.03f));
- L290 C78: new Vector2 :: yawDeg: MapMuscleToDeg(footTwist, GetMuscleValue(footTwist), new Vector2(-30.0f, 30.0f)),
- L291 C82: new Vector2 :: pitchDeg: MapMuscleToDeg(footUpDown, GetMuscleValue(footUpDown), new Vector2(-45.0f, 45.0f)),
- L297 C82: new Vector2 :: pitchDeg: MapMuscleToDeg(toesUpDown, GetMuscleValue(toesUpDown), new Vector2(-35.0f, 35.0f)),
- L341 C72: new Vector2 :: yawDeg: MapMuscleToDeg(spread, GetMuscleValue(spread), new Vector2(-15.0f, 15.0f)),
- L342 C70: new Vector2 :: pitchDeg: MapMuscleToDeg(prox, GetMuscleValue(prox), new Vector2(-45.0f, 45.0f)),
- L348 C68: new Vector2 :: pitchDeg: MapMuscleToDeg(mid, GetMuscleValue(mid), new Vector2(-45.0f, 45.0f)),
- L354 C70: new Vector2 :: pitchDeg: MapMuscleToDeg(dist, GetMuscleValue(dist), new Vector2(-45.0f, 45.0f)),
- L396 C25: new Vector3 :: tfm.Scale = new Vector3(bind.X, bind.Y * s, bind.Z);
- L581 C40: new() :: public BoneDef Hips { get; } = new();
- L582 C41: new() :: public BoneDef Spine { get; } = new();
- L583 C41: new() :: public BoneDef Chest { get; } = new();
- L584 C40: new() :: public BoneDef Neck { get; } = new();
- L585 C40: new() :: public BoneDef Head { get; } = new();
- L586 C39: new() :: public BoneDef Jaw { get; } = new();
- L590 C46: new() :: public BoneDef EyesTarget { get; } = new();
- L601 C56: new() :: public BoneDef Proximal { get; } = new();
- L605 C60: new() :: public BoneDef Intermediate { get; } = new();
- L609 C54: new() :: public BoneDef Distal { get; } = new();
- L619 C48: new() :: public Finger Pinky { get; } = new();
- L620 C47: new() :: public Finger Ring { get; } = new();
- L621 C49: new() :: public Finger Middle { get; } = new();
- L622 C48: new() :: public Finger Index { get; } = new();
- L623 C48: new() :: public Finger Thumb { get; } = new();
- L635 C48: new() :: public BoneDef Shoulder { get; } = new();
- L636 C43: new() :: public BoneDef Arm { get; } = new();
- L637 C45: new() :: public BoneDef Elbow { get; } = new();
- L638 C45: new() :: public BoneDef Wrist { get; } = new();
- L639 C44: new() :: public Fingers Hand { get; } = new();
- L640 C43: new() :: public BoneDef Leg { get; } = new();
- L641 C44: new() :: public BoneDef Knee { get; } = new();
- L642 C44: new() :: public BoneDef Foot { get; } = new();
- L643 C44: new() :: public BoneDef Toes { get; } = new();
- L644 C43: new() :: public BoneDef Eye { get; } = new();
- L661 C41: new() :: public BodySide Left { get; } = new();
- L662 C42: new() :: public BodySide Right { get; } = new();
- L702 C40: new BoneChainItem :: : [.. bones.Select(bone => new BoneChainItem(bone.Node!, bone.Constraints))];
- L1032 C27: new System.Collections.Generic.List :: var missing = new System.Collections.Generic.List<string>();
- L1076 C20: new BoneIKConstraints :: return new BoneIKConstraints()
- L1089 C20: new BoneIKConstraints :: return new BoneIKConstraints()
- L1111 C69: new Vector3 :: LeftFootTarget = (null, Matrix4x4.CreateTranslation(new Vector3(x, LeftFootTarget.offset.Translation.Y, LeftFootTarget.offset.Translation.Z)));
- L1113 C70: new Vector3 :: RightFootTarget = (null, Matrix4x4.CreateTranslation(new Vector3(x, RightFootTarget.offset.Translation.Y, RightFootTarget.offset.Translation.Z)));
- L1118 C69: new Vector3 :: LeftFootTarget = (null, Matrix4x4.CreateTranslation(new Vector3(LeftFootTarget.offset.Translation.X, y, LeftFootTarget.offset.Translation.Z)));
- L1120 C70: new Vector3 :: RightFootTarget = (null, Matrix4x4.CreateTranslation(new Vector3(RightFootTarget.offset.Translation.X, y, RightFootTarget.offset.Translation.Z)));
- L1125 C69: new Vector3 :: LeftFootTarget = (null, Matrix4x4.CreateTranslation(new Vector3(LeftFootTarget.offset.Translation.X, LeftFootTarget.offset.Translation.Y, z)));
- L1127 C70: new Vector3 :: RightFootTarget = (null, Matrix4x4.CreateTranslation(new Vector3(RightFootTarget.offset.Translation.X, RightFootTarget.offset.Translation.Y, z)));


## XRENGINE/Scene/Components/Animation/IK/BaseIKSolverComponent.cs
- L14 C41: new RenderCommandMethod3D :: RenderInfo = RenderInfo3D.New(this, new RenderCommandMethod3D(EDefaultRenderPass.OnTopForward, Visualize))


## XRENGINE/Scene/Components/Animation/IK/HumanoidIKSolverComponent.cs
- L17 C40: new() :: public IKSolverFABRIK _spine = new();
- L20 C45: new() :: public TransformConstrainer _hips = new();
- L151 C32: new Vector3 :: ik.RawIKPosition = new Vector3(x, ik.RawIKPosition.Y, ik.RawIKPosition.Z);
- L159 C32: new Vector3 :: ik.RawIKPosition = new Vector3(ik.RawIKPosition.X, y, ik.RawIKPosition.Z);
- L167 C32: new Vector3 :: ik.RawIKPosition = new Vector3(ik.RawIKPosition.X, ik.RawIKPosition.Y, z);


## XRENGINE/Scene/Components/Animation/IK/Solvers/IKSolverFABRIK.cs
- L66 C29: new bool :: _limitedBones = new bool[_bones.Length];
- L67 C37: new Vector3 :: _solverLocalPositions = new Vector3[_bones.Length];


## XRENGINE/Scene/Components/Animation/IK/Solvers/IKSolverHeuristic.cs
- L43 C26: new IKBone :: _bones = new IKBone[hierarchy.Length];
- L48 C33: new IKBone :: _bones[i] = new IKBone();
- L63 C37: new Transform :: Transform?[] newBones = new Transform?[_bones.Length + 1];


## XRENGINE/Scene/Components/Animation/IK/Solvers/IKSolverLimb.cs
- L180 C55: new AxisDirection :: private AxisDirection[] _axisDirectionsLeft = new AxisDirection[4];
- L181 C56: new AxisDirection :: private AxisDirection[] _axisDirectionsRight = new AxisDirection[4];
- L194 C33: new AxisDirection :: axisDirections[0] = new AxisDirection(
- L196 C17: new Vector3 :: new Vector3(-1f, 0f, 0f)); // default
- L198 C33: new AxisDirection :: axisDirections[1] = new AxisDirection(
- L199 C17: new Vector3 :: new Vector3(0.5f, 0f, -0.2f),
- L200 C17: new Vector3 :: new Vector3(-0.5f, 1f, 1f)); // behind head
- L202 C33: new AxisDirection :: axisDirections[2] = new AxisDirection(
- L203 C17: new Vector3 :: new Vector3(-0.5f, -1f, -0.2f),
- L204 C17: new Vector3 :: new Vector3(0f, -0.5f, -1f)); // arm twist
- L206 C33: new AxisDirection :: axisDirections[3] = new AxisDirection(
- L207 C17: new Vector3 :: new Vector3(-0.5f, -0.5f, 1f),
- L208 C17: new Vector3 :: new Vector3(-1f, 1f, -1f)); // cross heart


## XRENGINE/Scene/Components/Animation/IK/Solvers/IKSolverTrigonometric.cs
- L75 C43: new() :: public TrigonometricBone _bone1 = new();
- L79 C43: new() :: public TrigonometricBone _bone2 = new();
- L83 C43: new() :: public TrigonometricBone _bone3 = new();
- L229 C37: new Vector3 :: : Vector3.Transform(new Vector3(0f, y, x), XRMath.LookRotation(direction, bendDirection));
- L398 C38: new Vector3 :: return Vector3.Transform(new Vector3(0.0f, y, x), lookRot);


## XRENGINE/Scene/Components/Animation/IK/Solvers/VR/IKSolverVR.Arm.cs
- L23 C60: new ArmSettings :: private JsonAsset<ArmSettings> _settings = new(new ArmSettings());
- L367 C43: new() :: private AnimationCurve _stretchCurve = new();
- L491 C62: new JsonAsset :: _settings = Engine.LoadOrGenerateAsset(() => new JsonAsset<ArmSettings>(new ArmSettings()), "arms.json", true, "IKTweaks");
- L491 C89: new ArmSettings :: _settings = Engine.LoadOrGenerateAsset(() => new JsonAsset<ArmSettings>(new ArmSettings()), "arms.json", true, "IKTweaks");


## XRENGINE/Scene/Components/Animation/IK/Solvers/VR/IKSolverVR.cs
- L282 C36: new FloatKeyframe :: FloatKeyframe[] keys = new FloatKeyframe[3];
- L408 C26: new VirtualBone :: RootBone ??= new VirtualBone(_solverTransforms.Root);
- L745 C38: new() :: private SpineSolver _spine = new();
- L787 C37: new LegSolver :: private LegSolver[] _legs = new LegSolver[2];
- L788 C37: new ArmSolver :: private ArmSolver[] _arms = new ArmSolver[2];
- L796 C60: new() :: private PhysxScene.PhysxQueryFilter _queryFilter = new()


## XRENGINE/Scene/Components/Animation/IK/Solvers/VR/IKSolverVR.Leg.cs
- L117 C43: new() :: private AnimationCurve _stretchCurve = new();


## XRENGINE/Scene/Components/Animation/IK/Solvers/VR/IKSolverVR.Locomotion.cs
- L232 C69: new Vector3 :: Vector3 standOffsetWorld = rb.SolverRotation.Rotate(new Vector3(_standOffset.X, 0f, _standOffset.Y) * scale);


## XRENGINE/Scene/Components/Animation/IK/Solvers/VR/IKSolverVR.SolverTransforms.cs
- L45 C59: new SolverTransformsArm :: public SolverTransformsArm Arm { get; } = new SolverTransformsArm(shoulder, arm, elbow, wrist);
- L46 C59: new SolverTransformsLeg :: public SolverTransformsLeg Leg { get; } = new SolverTransformsLeg(leg, knee, foot, toes);
- L77 C57: new SolverTransformsSide :: public SolverTransformsSide Left { get; } = new SolverTransformsSide(
- L86 C58: new SolverTransformsSide :: public SolverTransformsSide Right { get; } = new SolverTransformsSide(
- L155 C28: new ArgumentOutOfRangeException :: _ => throw new ArgumentOutOfRangeException(nameof(index), "Invalid index for SolverTransforms."),
- L183 C32: new IndexOutOfRangeException :: _ => throw new IndexOutOfRangeException("Invalid index for SolverTransforms."),


## XRENGINE/Scene/Components/Animation/IK/Solvers/VR/IKSolverVR.SolverTransforms.TransformPoses.cs
- L16 C55: new PoseData :: public PoseData InputWorld { get; } = new PoseData();
- L20 C56: new PoseData :: public PoseData SolvedWorld { get; } = new PoseData();
- L24 C57: new PoseData :: public PoseData DefaultLocal { get; } = new PoseData();


## XRENGINE/Scene/Components/Animation/IK/Solvers/VR/IKSolverVR.Spine.cs
- L554 C26: new VirtualBone :: _bones = new VirtualBone[boneCount];
- L574 C29: new VirtualBone :: _bones[0] = new VirtualBone(transforms.Hips);
- L575 C29: new VirtualBone :: _bones[1] = new VirtualBone(transforms.Spine);
- L578 C43: new VirtualBone :: _bones[_chestIndex] = new VirtualBone(transforms.Chest);
- L581 C42: new VirtualBone :: _bones[_neckIndex] = new VirtualBone(transforms.Neck);
- L583 C38: new VirtualBone :: _bones[_headIndex] = new VirtualBone(transforms.Head);


## XRENGINE/Scene/Components/Animation/IK/Solvers/VR/IKSolverVR.VirtualBone.cs
- L13 C65: new ArgumentNullException :: public TransformPoses Pose { get; } = pose ?? throw new ArgumentNullException(nameof(pose), "VirtualBone Pose cannot be null.");
- L233 C65: new Vector3 :: return XRMath.LookRotation(dir, lookRot).Rotate(new Vector3(0.0f, y, -x));


## XRENGINE/Scene/Components/Animation/IK/VRIKCalibrator.cs
- L107 C36: new() :: CalibrationData data = new();
- L162 C25: new CalibrationData.Target :: data.Head = new CalibrationData.Target(spine.HeadTarget);
- L163 C25: new CalibrationData.Target :: data.Hips = new CalibrationData.Target(spine.HipsTarget);
- L164 C29: new CalibrationData.Target :: data.LeftHand = new CalibrationData.Target(ik.Solver.LeftArm.Target);
- L165 C30: new CalibrationData.Target :: data.RightHand = new CalibrationData.Target(ik.Solver.RightArm.Target);
- L166 C29: new CalibrationData.Target :: data.LeftFoot = new CalibrationData.Target(ik.Solver.LeftLeg.Target);
- L167 C30: new CalibrationData.Target :: data.RightFoot = new CalibrationData.Target(ik.Solver.RightLeg.Target);
- L168 C32: new CalibrationData.Target :: data.LeftLegGoal = new CalibrationData.Target(ik.Solver.LeftLeg.KneeTarget);
- L169 C33: new CalibrationData.Target :: data.RightLegGoal = new CalibrationData.Target(ik.Solver.RightLeg.KneeTarget);


## XRENGINE/Scene/Components/Animation/IK/VRIKSolverComponent.cs
- L17 C120: new() :: private static readonly Dictionary<ushort, (QuantizedHumanoidPose pose, ushort sequence)> _receivedBaselines = new();
- L18 C85: new() :: private static readonly Dictionary<ushort, VRIKSolverComponent> _registry = new();
- L20 C45: new() :: public IKSolverVR Solver { get; } = new();
- L157 C20: new HumanoidPoseSample :: return new HumanoidPoseSample(


## XRENGINE/Scene/Components/Animation/LipTrackingBlendTrees.cs
- L9 C55: new() :: public static BlendTree1D CheekPuffBlend() => new()
- L14 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L19 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L26 C53: new() :: private static AnimationClip CheekPuff() => new()
- L34 C54: new() :: private static AnimationClip CheekPuff0() => new()
- L45 C61: new() :: public static BlendTree1D CheekSquintLeftBlend() => new()
- L50 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L55 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L62 C59: new() :: private static AnimationClip CheekSquintLeft() => new()
- L70 C60: new() :: private static AnimationClip CheekSquintLeft0() => new()
- L81 C62: new() :: public static BlendTree1D CheekSquintRightBlend() => new()
- L86 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L91 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L98 C60: new() :: private static AnimationClip CheekSquintRight() => new()
- L106 C61: new() :: private static AnimationClip CheekSquintRight0() => new()
- L117 C56: new() :: public static BlendTree1D JawForwardBlend() => new()
- L122 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L127 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L134 C54: new() :: private static AnimationClip JawForward() => new()
- L142 C55: new() :: private static AnimationClip JawForward0() => new()
- L153 C53: new() :: public static BlendTree1D JawOpenBlend() => new()
- L158 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L163 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L170 C55: new() :: private static BlendTree1D JawOpenHelper() => new()
- L175 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L180 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L187 C52: new() :: private static AnimationClip JawOpen0() => new()
- L195 C51: new() :: private static AnimationClip JawOpen() => new()
- L206 C57: new() :: public static BlendTree1D LimitJawX_MouthX() => new()
- L211 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L216 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L221 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L228 C51: new() :: private static BlendTree1D JawXBlend() => new()
- L233 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L238 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L243 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L250 C52: new() :: private static AnimationClip JawRight() => new()
- L259 C51: new() :: private static AnimationClip JawLeft() => new()
- L268 C49: new() :: private static AnimationClip JawX0() => new()
- L280 C55: new() :: public static BlendTree1D LipPuckerBlend() => new()
- L285 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L290 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L297 C68: new() :: private static BlendTree1D LimitMouthPucker_LipFunnel() => new()
- L302 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L307 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L314 C55: new() :: private static AnimationClip MouthPucker() => new()
- L322 C56: new() :: private static AnimationClip MouthPucker0() => new()
- L333 C57: new() :: public static BlendTree1D MouthClosedBlend() => new()
- L338 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L343 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L350 C55: new() :: private static AnimationClip MouthClosed() => new()
- L358 C56: new() :: private static AnimationClip MouthClosed0() => new()
- L369 C60: new() :: public static BlendTree1D MouthFrownLeftBlend() => new()
- L374 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L379 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L386 C59: new() :: private static AnimationClip MouthFrownLeft0() => new()
- L394 C72: new() :: private static BlendTree1D LimitMouthFrownLeft_MouthXLeft() => new()
- L399 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L404 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L411 C58: new() :: private static AnimationClip MouthFrownLeft() => new()
- L422 C61: new() :: public static BlendTree1D MouthFrownRightBlend() => new()
- L427 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L432 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L439 C74: new() :: private static BlendTree1D LimitMouthFrownRight_MouthXRight() => new()
- L444 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L449 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L456 C59: new() :: private static AnimationClip MouthFrownRight() => new()
- L464 C60: new() :: private static AnimationClip MouthFrownRight0() => new()
- L475 C57: new() :: public static BlendTree1D MouthFunnelBlend() => new()
- L480 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L485 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L492 C55: new() :: private static AnimationClip MouthFunnel() => new()
- L500 C56: new() :: private static AnimationClip MouthFunnel0() => new()
- L511 C60: new() :: public static BlendTree1D MouthLowerDownBlend() => new()
- L516 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L521 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L528 C71: new() :: private static BlendTree1D LimitMouthLowerDown_LipFunnel() => new()
- L533 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L538 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L545 C58: new() :: private static AnimationClip MouthLowerDown() => new()
- L554 C59: new() :: private static AnimationClip MouthLowerDown0() => new()
- L566 C56: new() :: public static BlendTree1D MouthPressBlend() => new()
- L571 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L576 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L583 C54: new() :: private static AnimationClip MouthPress() => new()
- L592 C55: new() :: private static AnimationClip MouthPress0() => new()
- L604 C60: new() :: public static BlendTree1D MouthRollLowerBlend() => new()
- L609 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L614 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L621 C73: new() :: private static BlendTree1D LimitMouthRollLower_MouthClosed() => new()
- L626 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L631 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L638 C58: new() :: private static AnimationClip MouthRollLower() => new()
- L646 C59: new() :: private static AnimationClip MouthRollLower0() => new()
- L657 C60: new() :: public static BlendTree1D MouthRollUpperBlend() => new()
- L662 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L667 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L674 C73: new() :: private static BlendTree1D LimitMouthRollUpper_MouthClosed() => new()
- L679 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L684 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L691 C58: new() :: private static AnimationClip MouthRollUpper() => new()
- L699 C59: new() :: private static AnimationClip MouthRollUpper0() => new()
- L710 C61: new() :: public static BlendTree1D MouthShrugLowerBlend() => new()
- L715 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L720 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L727 C74: new() :: private static BlendTree1D LimitMouthShrugLower_MouthClosed() => new()
- L732 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L737 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L744 C59: new() :: private static AnimationClip MouthShrugLower() => new()
- L752 C60: new() :: private static AnimationClip MouthShrugLower0() => new()
- L763 C61: new() :: public static BlendTree1D MouthShrugUpperBlend() => new()
- L768 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L773 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L780 C74: new() :: private static BlendTree1D LimitMouthShrugUpper_MouthClosed() => new()
- L785 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L790 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L797 C59: new() :: private static AnimationClip MouthShrugUpper() => new()
- L805 C60: new() :: private static AnimationClip MouthShrugUpper0() => new()
- L816 C60: new() :: public static BlendTree1D MouthSmileLeftBlend() => new()
- L821 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L826 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L833 C58: new() :: private static AnimationClip MouthSmileLeft() => new()
- L841 C59: new() :: private static AnimationClip MouthSmileLeft0() => new()
- L852 C61: new() :: public static BlendTree1D MouthSmileRightBlend() => new()
- L857 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L862 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L869 C59: new() :: private static AnimationClip MouthSmileRight() => new()
- L877 C60: new() :: private static AnimationClip MouthSmileRight0() => new()
- L888 C62: new() :: public static BlendTree1D MouthStretchLeftBlend() => new()
- L893 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L898 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L905 C60: new() :: private static AnimationClip MouthStretchLeft() => new()
- L913 C61: new() :: private static AnimationClip MouthStretchLeft0() => new()
- L924 C63: new() :: public static BlendTree1D MouthStretchRightBlend() => new()
- L929 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L934 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L941 C61: new() :: private static AnimationClip MouthStretchRight() => new()
- L949 C62: new() :: private static AnimationClip MouthStretchRight0() => new()
- L960 C62: new() :: public static BlendTree1D MouthUpperUpLeftBlend() => new()
- L965 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L970 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L977 C52: new() :: private static BlendTree1D MouthRight() => new()
- L982 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L987 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L994 C73: new() :: private static BlendTree1D LimitMouthUpperUpLeft_LipFunnel() => new()
- L999 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L1004 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L1011 C60: new() :: private static AnimationClip MouthUpperUpLeft() => new()
- L1019 C61: new() :: private static AnimationClip MouthUpperUpLeft0() => new()
- L1030 C63: new() :: public static BlendTree1D MouthUpperUpRightBlend() => new()
- L1035 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L1040 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L1047 C51: new() :: private static BlendTree1D MouthLeft() => new()
- L1052 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L1057 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L1064 C74: new() :: private static BlendTree1D LimitMouthUpperUpRight_LipFunnel() => new()
- L1069 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L1074 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L1081 C61: new() :: private static AnimationClip MouthUpperUpRight() => new()
- L1089 C62: new() :: private static AnimationClip MouthUpperUpRight0() => new()
- L1100 C52: new() :: public static BlendTree1D MouthXBlend() => new()
- L1105 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L1110 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L1115 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L1122 C58: new() :: private static AnimationClip MouthRightClip() => new()
- L1131 C57: new() :: private static AnimationClip MouthLeftClip() => new()
- L1140 C51: new() :: private static AnimationClip MouthX0() => new()
- L1152 C55: new() :: public static BlendTree1D NoseSneerBlend() => new()
- L1157 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L1162 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L1169 C53: new() :: private static AnimationClip NoseSneer() => new()
- L1178 C54: new() :: private static AnimationClip NoseSneer0() => new()
- L1190 C55: new() :: public static BlendTree1D TongueOutBlend() => new()
- L1195 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L1200 C17: new BlendTree1D.Child :: new BlendTree1D.Child()
- L1207 C53: new() :: private static AnimationClip TongueOut() => new()
- L1215 C54: new() :: private static AnimationClip TongueOut0() => new()


## XRENGINE/Scene/Components/Animation/MotionCapture/FaceMotion3DCaptureComponent.cs
- L144 C35: new() :: using (UdpClient sender = new())
- L238 C28: new IPEndPoint :: remoteEP = new IPEndPoint(IPAddress.Any, 0);
- L256 C37: new IPEndPoint :: EndPoint remoteEP = new IPEndPoint(IPAddress.Any, 0);
- L278 C39: new() :: using (UdpClient sender = new())
- L318 C29: new byte :: byte[] buffer = new byte[10000]; // buffer size as per sample
- L319 C41: new() :: StringBuilder dataBuilder = new();
- L502 C25: new Vector3 :: _headPosition = new Vector3(


## XRENGINE/Scene/Components/Animation/MotionCapture/FaceTrackingReceiverComponent.cs
- L720 C31: new() :: AnimLayer layer = new()
- L726 C26: new BlendTreeDirect :: Motion = new BlendTreeDirect()
- L735 C25: new() :: new()
- L740 C25: new() :: new()
- L753 C65: new() :: private static AnimationClip ResetAdditiveAnimator() => new()
- L757 C26: new AnimationMember :: RootMember = new AnimationMember("Set Humanoid Values", EAnimationMemberType.Group)
- L761 C21: new AnimationMember :: new AnimationMember("SetFloat", EAnimationMemberType.Method)
- L766 C21: new AnimationMember :: new AnimationMember("SetFloat", EAnimationMemberType.Method)
- L771 C21: new AnimationMember :: new AnimationMember("SetFloat", EAnimationMemberType.Method)
- L780 C62: new() :: private static BlendTree2D MakeEyeRightRotation() => new()
- L787 C17: new() :: new()
- L793 C17: new() :: new()
- L799 C17: new() :: new()
- L805 C17: new() :: new()
- L811 C17: new() :: new()
- L820 C63: new() :: private static AnimationClip EyeLookDownRightRot() => new()
- L824 C26: new AnimationMember :: RootMember = new AnimationMember("SetHumanoidValue", EAnimationMemberType.Method)
- L831 C61: new() :: private static AnimationClip EyeLookUpRightRot() => new()
- L835 C26: new AnimationMember :: RootMember = new AnimationMember("SetHumanoidValue", EAnimationMemberType.Method)
- L842 C61: new() :: private static AnimationClip EyeLookInRightRot() => new()
- L846 C26: new AnimationMember :: RootMember = new AnimationMember("SetHumanoidValue", EAnimationMemberType.Method)
- L853 C62: new() :: private static AnimationClip EyeLookOutRightRot() => new()
- L857 C26: new AnimationMember :: RootMember = new AnimationMember("SetHumanoidValue", EAnimationMemberType.Method)
- L864 C66: new() :: private static AnimationClip EyeLookNeutralRightRot() => new()
- L868 C26: new AnimationMember :: RootMember = new AnimationMember("Set Humanoid Values", EAnimationMemberType.Group)
- L872 C21: new AnimationMember :: new AnimationMember("SetHumanoidValue", EAnimationMemberType.Method)
- L877 C21: new AnimationMember :: new AnimationMember("SetHumanoidValue", EAnimationMemberType.Method)
- L886 C61: new() :: private static BlendTree2D MakeEyeLeftRotation() => new()
- L893 C17: new() :: new()
- L899 C17: new() :: new()
- L905 C17: new() :: new()
- L911 C17: new() :: new()
- L917 C17: new() :: new()
- L927 C62: new() :: private static AnimationClip EyeLookDownLeftRot() => new()
- L931 C26: new AnimationMember :: RootMember = new AnimationMember("SetHumanoidValue", EAnimationMemberType.Method)
- L938 C60: new() :: private static AnimationClip EyeLookUpLeftRot() => new()
- L942 C26: new AnimationMember :: RootMember = new AnimationMember("SetHumanoidValue", EAnimationMemberType.Method)
- L949 C60: new() :: private static AnimationClip EyeLookInLeftRot() => new()
- L953 C26: new AnimationMember :: RootMember = new AnimationMember("SetHumanoidValue", EAnimationMemberType.Method)
- L960 C61: new() :: private static AnimationClip EyeLookOutLeftRot() => new()
- L964 C26: new AnimationMember :: RootMember = new AnimationMember("SetHumanoidValue", EAnimationMemberType.Method)
- L971 C65: new() :: private static AnimationClip EyeLookNeutralLeftRot() => new()
- L975 C26: new AnimationMember :: RootMember = new AnimationMember("Set Humanoid Values", EAnimationMemberType.Group)
- L979 C21: new AnimationMember :: new AnimationMember("SetHumanoidValue", EAnimationMemberType.Method)
- L984 C21: new AnimationMember :: new AnimationMember("SetHumanoidValue", EAnimationMemberType.Method)
- L995 C31: new() :: AnimLayer layer = new();
- L1133 C31: new() :: AnimLayer layer = new();
- L1164 C39: new BlendTreeDirect :: ftLocalRootState.Motion = new BlendTreeDirect()
- L1169 C21: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1181 C21: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1220 C68: new() :: private static BlendTreeDirect MakeFTBlendShapeDriver() => new()
- L1225 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1230 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1235 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1240 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1245 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1250 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1255 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1260 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1265 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1270 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1275 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1280 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1285 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1290 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1295 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1300 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1305 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1310 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1315 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1320 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1325 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1330 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1335 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1340 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1345 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1350 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1355 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1360 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1365 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1370 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1375 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1380 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1385 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1390 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1395 C17: new BlendTreeDirect.Child :: new BlendTreeDirect.Child()
- L1519 C63: new() :: private static AnimationClip MakeResetFTAnimator() => new()
- L1524 C26: new AnimationMember :: RootMember = new AnimationMember("SetFloat Group", EAnimationMemberType.Group)
- L1578 C31: new AnimationMember :: setFloats.Add(new AnimationMember(nameof(AnimStateMachineComponent.SetFloat), EAnimationMemberType.Method)


## XRENGINE/Scene/Components/Animation/MotionCapture/VMCCaptureComponent.cs
- L143 C13: new Vector3 :: new Vector3(
- L165 C13: new Vector3 :: new Vector3(
- L169 C13: new Quaternion :: new Quaternion(
- L188 C13: new Vector3 :: new Vector3(
- L192 C13: new Quaternion :: new Quaternion(
- L208 C13: new Vector3 :: new Vector3(
- L212 C13: new Quaternion :: new Quaternion(
- L217 C13: new ColorF4 :: new ColorF4(
- L232 C13: new Vector3 :: new Vector3(
- L236 C13: new Quaternion :: new Quaternion(
- L271 C13: new Vector3 :: new Vector3(
- L275 C13: new Quaternion :: new Quaternion(
- L287 C13: new Vector3 :: new Vector3(
- L291 C13: new Quaternion :: new Quaternion(
- L303 C13: new Vector3 :: new Vector3(
- L307 C13: new Quaternion :: new Quaternion(
- L319 C13: new Vector3 :: new Vector3(
- L323 C13: new Quaternion :: new Quaternion(
- L335 C13: new Vector3 :: new Vector3(
- L339 C13: new Quaternion :: new Quaternion(
- L351 C13: new Vector3 :: new Vector3(
- L355 C13: new Quaternion :: new Quaternion(
- L402 C64: new() :: private readonly Queue<(string, float)> _blendshapeQueue = new();
- L438 C30: new XRPerspectiveCameraParameters :: cam.Parameters = new XRPerspectiveCameraParameters(fov, null, cam.Parameters.NearZ, cam.Parameters.FarZ);
- L454 C23: new ColorF3 :: light.Color = new ColorF3(color.R, color.G, color.B);


## XRENGINE/Scene/Components/Animation/TransformParameterDriverComponent.cs
- L375 C20: new Vector3 :: return new Vector3(rotator.Pitch, rotator.Yaw, rotator.Roll);
- L398 C27: new TransformParameterBinding :: var binding = new TransformParameterBinding


## XRENGINE/Scene/Components/Audio/AudioSourceComponent.cs
- L766 C31: new float :: float[] samples = new float[sampleCount.CeilingToPowerOfTwo()];


## XRENGINE/Scene/Components/Audio/Converters/MicrophoneComponent.ElevenLabsConverter.cs
- L9 C55: new() :: private readonly HttpClient _httpClient = new();
- L21 C63: new() :: private readonly Queue<byte[]> _processingQueue = new();
- L22 C48: new() :: private readonly Lock _queueLock = new();
- L189 C46: new MultipartFormDataContent :: using var formData = new MultipartFormDataContent();
- L192 C49: new MemoryStream :: using var audioStream = new MemoryStream(pcmData);
- L193 C38: new StreamContent :: formData.Add(new StreamContent(audioStream), "audio", "input.pcm");
- L196 C43: new List :: var queryParams = new List<string>
- L219 C38: new StringContent :: formData.Add(new StringContent(voiceSettingsJson), "voice_settings");
- L277 C46: new MemoryStream :: using var memoryStream = new MemoryStream();
- L280 C40: new NAudio.Wave.WaveFormat :: var targetFormat = new NAudio.Wave.WaveFormat(targetSampleRate, 16, 1);
- L293 C41: new byte :: convertedData = new byte[targetSampleRate * 2]; // 1 second of silence at 16-bit
- L315 C28: new byte :: return new byte[targetSampleRate * targetBitsPerSample / 8];
- L320 C30: new byte :: var result = new byte[targetLength];
- L334 C43: new MemoryStream :: using var mp3Stream = new MemoryStream(mp3Data);
- L335 C43: new Mp3FileReader :: using var mp3Reader = new Mp3FileReader(mp3Stream);
- L338 C44: new byte :: var convertedSamples = new byte[mp3Reader.Length];


## XRENGINE/Scene/Components/Audio/Converters/MicrophoneComponent.RVCConverter.cs
- L20 C63: new() :: private readonly Queue<byte[]> _processingQueue = new();
- L21 C50: new() :: private readonly object _queueLock = new();
- L260 C37: new List :: var arguments = new List<string>
- L288 C37: new ProcessStartInfo :: var startInfo = new ProcessStartInfo
- L299 C41: new Process :: using var process = new Process { StartInfo = startInfo };
- L332 C46: new MemoryStream :: using var memoryStream = new MemoryStream();
- L333 C38: new NAudio.Wave.WaveFormat :: var waveFormat = new NAudio.Wave.WaveFormat(sampleRate, bitsPerSample, 1);
- L335 C44: new NAudio.Wave.WaveFileWriter :: using var waveWriter = new NAudio.Wave.WaveFileWriter(filePath, waveFormat);
- L349 C44: new NAudio.Wave.WaveFileReader :: using var waveReader = new NAudio.Wave.WaveFileReader(filePath);
- L350 C37: new byte :: var audioData = new byte[waveReader.Length];


## XRENGINE/Scene/Components/Audio/MicrophoneComponent.cs
- L173 C23: new WaveInEvent :: _waveIn = new WaveInEvent
- L176 C30: new WaveFormat :: WaveFormat = new WaveFormat(SampleRate, _bitsPerSample, channels: 1),
- L183 C30: new byte :: _currentBuffer = new byte[bufferSize];
- L288 C23: new NotSupportedException :: throw new NotSupportedException($"Unsupported bits per sample: {_bitsPerSample}");
- L336 C44: new byte :: byte[] smoothedBytes = new byte[length];
- L364 C39: new short :: short[] samples = new short[shortLength];
- L365 C46: new short :: short[] smoothedShorts = new short[shortLength];
- L395 C44: new float :: float[] floatSamples = new float[floatLength];
- L396 C46: new float :: float[] smoothedFloats = new float[floatLength];
- L424 C27: new NotSupportedException :: throw new NotSupportedException($"Unsupported bits per sample: {_bitsPerSample}");
- L441 C26: new byte :: var buffer = new byte[col.Count];
- L466 C42: new short :: short[] shorts = new short[buffer.Length / 2];
- L474 C42: new float :: float[] floats = new float[buffer.Length / 4];
- L499 C29: new ElevenLabsConverter :: var converter = new ElevenLabsConverter(apiKey, voiceId, modelId);
- L546 C29: new RVCConverter :: var converter = new RVCConverter(modelPath, indexPath, rvcPythonPath, rvcScriptPath);


## XRENGINE/Scene/Components/Audio/OVRLipSyncComponent.cs
- L34 C42: new() :: private ovrLipSyncContext _ctx = new();
- L41 C54: new float :: private readonly float[] _lastInputVisemes = new float[VisemeCount];
- L44 C45: new float :: private readonly float[] _visemes = new float[VisemeCount];


## XRENGINE/Scene/Components/Audio/STT/Providers/AmazonSTTProvider.cs
- L5 C51: new() :: private readonly HttpClient _httpClient = new();
- L11 C20: new STTResult :: return new STTResult


## XRENGINE/Scene/Components/Audio/STT/Providers/AssemblyAISTTProvider.cs
- L16 C27: new HttpClient :: _httpClient = new HttpClient();
- L24 C31: new ByteArrayContent :: var content = new ByteArrayContent(audioData);
- L25 C47: new System.Net.Http.Headers.MediaTypeHeaderValue :: content.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue("audio/wav");
- L33 C28: new STTResult :: return new STTResult
- L43 C28: new STTResult :: return new STTResult { Success = false, Error = "Failed to get upload URL" };
- L47 C37: new ByteArrayContent :: var uploadContent = new ByteArrayContent(audioData);
- L52 C28: new STTResult :: return new STTResult { Success = false, Error = "Failed to upload audio file" };
- L62 C44: new StringContent :: var transcriptionContent = new StringContent(JsonSerializer.Serialize(transcriptionRequest), Encoding.UTF8, "application/json");
- L67 C28: new STTResult :: return new STTResult { Success = false, Error = "Failed to start transcription" };
- L73 C28: new STTResult :: return new STTResult { Success = false, Error = "Failed to get transcription ID" };
- L89 C32: new STTResult :: return new STTResult
- L99 C32: new STTResult :: return new STTResult { Success = false, Error = statusResult.Error ?? "Transcription failed" };
- L103 C24: new STTResult :: return new STTResult { Success = false, Error = "Transcription timeout" };
- L107 C24: new STTResult :: return new STTResult { Success = false, Error = ex.Message };


## XRENGINE/Scene/Components/Audio/STT/Providers/AzureSTTProvider.cs
- L16 C27: new HttpClient :: _httpClient = new HttpClient();
- L24 C31: new ByteArrayContent :: var content = new ByteArrayContent(audioData);
- L25 C47: new System.Net.Http.Headers.MediaTypeHeaderValue :: content.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue("audio/wav");
- L33 C28: new STTResult :: return new STTResult
- L43 C24: new STTResult :: return new STTResult
- L53 C24: new STTResult :: return new STTResult { Success = false, Error = ex.Message };


## XRENGINE/Scene/Components/Audio/STT/Providers/DeepgramSTTProvider.cs
- L15 C27: new HttpClient :: _httpClient = new HttpClient();
- L23 C31: new ByteArrayContent :: var content = new ByteArrayContent(audioData);
- L24 C47: new System.Net.Http.Headers.MediaTypeHeaderValue :: content.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue("audio/wav");
- L32 C28: new STTResult :: return new STTResult
- L45 C28: new STTResult :: return new STTResult
- L54 C24: new STTResult :: return new STTResult { Success = false, Error = "No transcription results" };
- L58 C24: new STTResult :: return new STTResult { Success = false, Error = ex.Message };


## XRENGINE/Scene/Components/Audio/STT/Providers/GoogleSTTProvider.cs
- L8 C51: new() :: private readonly HttpClient _httpClient = new();
- L34 C31: new StringContent :: var content = new StringContent(json, Encoding.UTF8, "application/json");
- L42 C28: new STTResult :: return new STTResult
- L55 C28: new STTResult :: return new STTResult
- L64 C24: new STTResult :: return new STTResult { Success = false, Error = "No transcription results" };
- L68 C24: new STTResult :: return new STTResult { Success = false, Error = ex.Message };


## XRENGINE/Scene/Components/Audio/STT/Providers/OpenAIWhisperProvider.cs
- L15 C27: new HttpClient :: _httpClient = new HttpClient();
- L23 C38: new MultipartFormDataContent :: using var formData = new MultipartFormDataContent();
- L24 C41: new MemoryStream :: using var audioStream = new MemoryStream(audioData);
- L25 C30: new StreamContent :: formData.Add(new StreamContent(audioStream), "file", "audio.wav");
- L26 C30: new StringContent :: formData.Add(new StringContent("whisper-1"), "model");
- L27 C30: new StringContent :: formData.Add(new StringContent(_language), "language");
- L33 C28: new STTResult :: return new STTResult
- L43 C24: new STTResult :: return new STTResult
- L53 C24: new STTResult :: return new STTResult { Success = false, Error = ex.Message };


## XRENGINE/Scene/Components/Audio/STT/Providers/RevAISTTProvider.cs
- L15 C27: new HttpClient :: _httpClient = new HttpClient();
- L23 C38: new MultipartFormDataContent :: using var formData = new MultipartFormDataContent();
- L24 C41: new MemoryStream :: using var audioStream = new MemoryStream(audioData);
- L25 C30: new StreamContent :: formData.Add(new StreamContent(audioStream), "file", "audio.wav");
- L26 C30: new StringContent :: formData.Add(new StringContent(_language), "language");
- L32 C28: new STTResult :: return new STTResult
- L42 C28: new STTResult :: return new STTResult { Success = false, Error = "Failed to get job ID" };
- L65 C32: new STTResult :: return new STTResult
- L75 C32: new STTResult :: return new STTResult { Success = false, Error = "Transcription failed" };
- L79 C24: new STTResult :: return new STTResult { Success = false, Error = "Transcription timeout" };
- L83 C24: new STTResult :: return new STTResult { Success = false, Error = ex.Message };


## XRENGINE/Scene/Components/Audio/STT/SpeechToTextComponent.cs
- L13 C54: new() :: private readonly List<byte[]> _audioBuffer = new();
- L14 C47: new() :: private readonly object _bufferLock = new();
- L132 C29: new byte :: audioData = new byte[totalSize];
- L198 C36: new GoogleSTTProvider :: ESTTProvider.Google => new GoogleSTTProvider(ApiKey, Language),
- L199 C36: new OpenAIWhisperProvider :: ESTTProvider.OpenAI => new OpenAIWhisperProvider(ApiKey, Language),
- L200 C35: new AzureSTTProvider :: ESTTProvider.Azure => new AzureSTTProvider(ApiKey, Language),
- L201 C36: new AmazonSTTProvider :: ESTTProvider.Amazon => new AmazonSTTProvider(ApiKey, Language),
- L202 C38: new DeepgramSTTProvider :: ESTTProvider.Deepgram => new DeepgramSTTProvider(ApiKey, Language),
- L203 C40: new AssemblyAISTTProvider :: ESTTProvider.AssemblyAI => new AssemblyAISTTProvider(ApiKey, Language),
- L204 C35: new RevAISTTProvider :: ESTTProvider.RevAI => new RevAISTTProvider(ApiKey, Language),
- L205 C24: new NotSupportedException :: _ => throw new NotSupportedException($"STT provider {_selectedProvider} is not supported")


## XRENGINE/Scene/Components/Audio/TTS/Providers/AmazonPollyTTSProvider.cs
- L19 C51: new() :: private readonly HttpClient _httpClient = new();
- L39 C31: new StringContent :: var content = new StringContent(json, Encoding.UTF8, "application/json");
- L71 C26: new TTSVoice :: var voices = new TTSVoice[]
- L73 C17: new() :: new() { Id = "Joanna", Name = "Joanna", LanguageCode = "en-US", Gender = EVoiceGender.Female },
- L74 C17: new() :: new() { Id = "Matthew", Name = "Matthew", LanguageCode = "en-US", Gender = EVoiceGender.Male },
- L75 C17: new() :: new() { Id = "Ivy", Name = "Ivy", LanguageCode = "en-US", Gender = EVoiceGender.Female, Description = "Child voice" },
- L76 C17: new() :: new() { Id = "Kendra", Name = "Kendra", LanguageCode = "en-US", Gender = EVoiceGender.Female },
- L77 C17: new() :: new() { Id = "Kimberly", Name = "Kimberly", LanguageCode = "en-US", Gender = EVoiceGender.Female },
- L78 C17: new() :: new() { Id = "Salli", Name = "Salli", LanguageCode = "en-US", Gender = EVoiceGender.Female },
- L79 C17: new() :: new() { Id = "Joey", Name = "Joey", LanguageCode = "en-US", Gender = EVoiceGender.Male },
- L80 C17: new() :: new() { Id = "Justin", Name = "Justin", LanguageCode = "en-US", Gender = EVoiceGender.Male, Description = "Child voice" },
- L81 C17: new() :: new() { Id = "Amy", Name = "Amy", LanguageCode = "en-GB", Gender = EVoiceGender.Female },
- L82 C17: new() :: new() { Id = "Brian", Name = "Brian", LanguageCode = "en-GB", Gender = EVoiceGender.Male },
- L83 C17: new() :: new() { Id = "Emma", Name = "Emma", LanguageCode = "en-GB", Gender = EVoiceGender.Female },
- L92 C23: new Uri :: var uri = new Uri(url);
- L97 C27: new HttpRequestMessage :: var request = new HttpRequestMessage(method, url);
- L136 C30: new System.Security.Cryptography.HMACSHA256 :: using var hmac = new System.Security.Cryptography.HMACSHA256(key);


## XRENGINE/Scene/Components/Audio/TTS/Providers/AzureTTSProvider.cs
- L19 C51: new HttpClient :: private readonly HttpClient _httpClient = new HttpClient();
- L23 C69: new() :: private static readonly JsonSerializerOptions JsonOptions = new()
- L40 C37: new HttpRequestMessage :: using var request = new HttpRequestMessage(HttpMethod.Post, $"https://{region}.tts.speech.microsoft.com/cognitiveservices/v1");
- L41 C49: new AuthenticationHeaderValue :: request.Headers.Authorization = new AuthenticationHeaderValue("Bearer", _accessToken);
- L43 C35: new StringContent :: request.Content = new StringContent(ssml, Encoding.UTF8, "application/ssml+xml");
- L73 C37: new HttpRequestMessage :: using var request = new HttpRequestMessage(HttpMethod.Get,
- L75 C49: new AuthenticationHeaderValue :: request.Headers.Authorization = new AuthenticationHeaderValue("Bearer", _accessToken);
- L87 C44: new TTSVoice :: return voices?.Select(v => new TTSVoice
- L111 C33: new HttpRequestMessage :: using var request = new HttpRequestMessage(HttpMethod.Post,


## XRENGINE/Scene/Components/Audio/TTS/Providers/ElevenLabsTTSProvider.cs
- L18 C69: new() :: private static readonly JsonSerializerOptions JsonOptions = new()
- L35 C27: new HttpClient :: _httpClient = new HttpClient();
- L45 C31: new ElevenLabsRequest :: var request = new ElevenLabsRequest
- L49 C37: new ElevenLabsVoiceSettings :: VoiceSettings = new ElevenLabsVoiceSettings
- L57 C31: new StringContent :: var content = new StringContent(json, Encoding.UTF8, "application/json");
- L100 C52: new TTSVoice :: return result?.Voices?.Select(v => new TTSVoice


## XRENGINE/Scene/Components/Audio/TTS/Providers/GoogleTTSProvider.cs
- L17 C51: new() :: private readonly HttpClient _httpClient = new();
- L18 C69: new() :: private static readonly JsonSerializerOptions JsonOptions = new()
- L28 C31: new GoogleTTSRequest :: var request = new GoogleTTSRequest
- L30 C29: new GoogleTTSInput :: Input = new GoogleTTSInput { Text = text },
- L31 C29: new GoogleTTSVoice :: Voice = new GoogleTTSVoice
- L36 C35: new GoogleTTSAudioConfig :: AudioConfig = new GoogleTTSAudioConfig
- L44 C31: new StringContent :: var content = new StringContent(json, Encoding.UTF8, "application/json");
- L96 C52: new TTSVoice :: return result?.Voices?.Select(v => new TTSVoice


## XRENGINE/Scene/Components/Audio/TTS/Providers/OpenAITTSProvider.cs
- L17 C69: new() :: private static readonly JsonSerializerOptions JsonOptions = new()
- L39 C27: new HttpClient :: _httpClient = new HttpClient();
- L47 C31: new OpenAITTSRequest :: var request = new OpenAITTSRequest
- L56 C31: new StringContent :: var content = new StringContent(json, Encoding.UTF8, "application/json");
- L87 C26: new TTSVoice :: var voices = new TTSVoice[]
- L89 C17: new() :: new() { Id = "alloy", Name = "Alloy", LanguageCode = "en", Gender = EVoiceGender.Neutral, Description = "Neutral, balanced voice" },
- L90 C17: new() :: new() { Id = "echo", Name = "Echo", LanguageCode = "en", Gender = EVoiceGender.Male, Description = "Deep, resonant voice" },
- L91 C17: new() :: new() { Id = "fable", Name = "Fable", LanguageCode = "en", Gender = EVoiceGender.Neutral, Description = "Expressive, narrative voice" },
- L92 C17: new() :: new() { Id = "onyx", Name = "Onyx", LanguageCode = "en", Gender = EVoiceGender.Male, Description = "Deep, authoritative voice" },
- L93 C17: new() :: new() { Id = "nova", Name = "Nova", LanguageCode = "en", Gender = EVoiceGender.Female, Description = "Warm, friendly voice" },
- L94 C17: new() :: new() { Id = "shimmer", Name = "Shimmer", LanguageCode = "en", Gender = EVoiceGender.Female, Description = "Clear, optimistic voice" }


## XRENGINE/Scene/Components/Audio/TTS/TextToSpeechComponent.cs
- L66 C72: new() :: private readonly ConcurrentQueue<SpeechRequest> _speechQueue = new();
- L68 C46: new() :: private readonly object _speakLock = new();
- L371 C37: new short :: var shortData = new short[result.AudioData.Length / 2];
- L382 C37: new float :: var floatData = new float[result.AudioData.Length / 4];
- L417 C34: new SpeechRequest :: _speechQueue.Enqueue(new SpeechRequest(text, priority));
- L469 C40: new OpenAITTSProvider :: ETTSProvider.OpenAI => new OpenAITTSProvider(ApiKey,
- L471 C40: new GoogleTTSProvider :: ETTSProvider.Google => new GoogleTTSProvider(ApiKey, Language),
- L472 C39: new AzureTTSProvider :: ETTSProvider.Azure => new AzureTTSProvider(ApiKey,
- L474 C44: new ElevenLabsTTSProvider :: ETTSProvider.ElevenLabs => new ElevenLabsTTSProvider(ApiKey),
- L475 C40: new AmazonPollyTTSProvider :: ETTSProvider.Amazon => new AmazonPollyTTSProvider(ApiKey, SecondaryApiKey),
- L476 C28: new NotSupportedException :: _ => throw new NotSupportedException($"TTS provider {SelectedProvider} is not supported")
- L498 C37: new CancellationTokenSource :: _currentSpeechCts = new CancellationTokenSource();


## XRENGINE/Scene/Components/Audio/TTS/TTSResult.cs
- L53 C58: new() :: public static TTSResult Failure(string error) => new() { Success = false, Error = error };
- L58 C128: new() :: public static TTSResult FromPcm(byte[] audioData, int sampleRate = 24000, int channels = 1, int bitsPerSample = 16) => new()


## XRENGINE/Scene/Components/Audio/VoiceMcpBridgeComponent.cs
- L68 C51: new() :: private readonly HttpClient _httpClient = new();
- L69 C63: new() :: private readonly JsonSerializerOptions _jsonOptions = new()
- L427 C33: new VoiceCommand :: _customCommands.Add(new VoiceCommand(patterns, toolName, argumentBuilder));
- L605 C27: new JsonObject :: var request = new JsonObject
- L610 C30: new JsonObject :: ["params"] = new JsonObject
- L613 C50: new JsonObject :: ["arguments"] = arguments ?? new JsonObject()
- L618 C27: new StringContent :: var content = new StringContent(json, Encoding.UTF8, "application/json");
- L626 C32: new McpVoiceResponse :: var response = new McpVoiceResponse
- L673 C32: new McpVoiceResponse :: var response = new McpVoiceResponse
- L689 C27: new JsonObject :: var request = new JsonObject
- L697 C27: new StringContent :: var content = new StringContent(json, Encoding.UTF8, "application/json");
- L757 C69: new JsonObject :: var arguments = parsed?["arguments"]?.AsObject() ?? new JsonObject();
- L758 C24: new LlmToolCall :: return new LlmToolCall(toolName, arguments);
- L798 C27: new JsonObject :: var request = new JsonObject
- L801 C32: new JsonArray :: ["messages"] = new JsonArray
- L803 C21: new JsonObject :: new JsonObject { ["role"] = "system", ["content"] = systemPrompt },
- L804 C21: new JsonObject :: new JsonObject { ["role"] = "user", ["content"] = userPrompt }
- L810 C27: new StringContent :: var content = new StringContent(request.ToJsonString(), Encoding.UTF8, "application/json");
- L811 C37: new HttpRequestMessage :: using var httpRequest = new HttpRequestMessage(HttpMethod.Post, "https://api.openai.com/v1/chat/completions")
- L832 C27: new JsonObject :: var request = new JsonObject
- L836 C32: new JsonArray :: ["messages"] = new JsonArray
- L838 C21: new JsonObject :: new JsonObject { ["role"] = "user", ["content"] = userPrompt }
- L843 C27: new StringContent :: var content = new StringContent(request.ToJsonString(), Encoding.UTF8, "application/json");
- L844 C37: new HttpRequestMessage :: using var httpRequest = new HttpRequestMessage(HttpMethod.Post, "https://api.anthropic.com/v1/messages")
- L926 C26: new JsonObject :: m => new JsonObject { ["shapeType"] = NormalizeShapeType(m.Groups[1].Value) }
- L934 C26: new JsonObject :: m => new JsonObject { ["worldName"] = m.Groups[1].Value.Trim() }
- L945 C26: new JsonObject :: m => new JsonObject { ["nodeName"] = m.Groups[1].Value.Trim() }
- L1028 C46: new Regex :: _patterns = patterns.Select(p => new Regex(p, RegexOptions.IgnoreCase | RegexOptions.Compiled)).ToArray();


## XRENGINE/Scene/Components/Camera/CameraComponent.cs
- L209 C25: new List :: var parts = new List<string>();
- L284 C23: new XRCamera :: var cam = new XRCamera(Transform);
- L499 C36: new XROrthographicCameraParameters :: => Camera.Parameters = new XROrthographicCameraParameters(width, height, nearPlane, farPlane);
- L509 C36: new XRPerspectiveCameraParameters :: => Camera.Parameters = new XRPerspectiveCameraParameters(verticalFieldOfView, aspectRatio, nearPlane, farPlane);


## XRENGINE/Scene/Components/Camera/StereoCameraComponent.cs
- L33 C32: new Transform :: LeftEyeTransform = new Transform(Globals.Left * halfIpd, Transform);
- L34 C33: new Transform :: RightEyeTransform = new Transform(Globals.Right * halfIpd, Transform);
- L35 C40: new XRCamera :: _leftEyeCamera = new(() => new XRCamera(LeftEyeTransform, StereoCameraParameters), true);
- L36 C41: new XRCamera :: _rightEyeCamera = new(() => new XRCamera(RightEyeTransform, StereoCameraParameters), true);


## XRENGINE/Scene/Components/Capture/EditorSelectionAccessor.cs
- L38 C56: new EditorSelectionAccessor :: return sceneNodesProperty is null ? null : new EditorSelectionAccessor(sceneNodesProperty);


## XRENGINE/Scene/Components/Capture/LightProbeComponent.cs
- L132 C37: new GameTimer :: _realtimeCaptureTimer = new GameTimer(this);
- L133 C33: new RenderCommandMethod3D :: _debugAxesCommand = new RenderCommandMethod3D(EDefaultRenderPass.OnTopForward, RenderCameraOrientationDebug)
- L137 C38: new RenderCommandMethod3D :: _debugInfluenceCommand = new RenderCommandMethod3D(EDefaultRenderPass.OnTopForward, RenderVolumesDebug)
- L143 C71: new RenderCommandMesh3D :: VisualRenderInfo = RenderInfo3D.New(this, _visualRC = new RenderCommandMesh3D((int)EDefaultRenderPass.OpaqueForward)),
- L566 C48: new() :: RenderingParameters renderParams = new();
- L583 C30: new XRQuadFrameBuffer :: _irradianceFBO = new XRQuadFrameBuffer(irradianceMaterial);
- L586 C29: new XRQuadFrameBuffer :: _prefilterFBO = new XRQuadFrameBuffer(prefilterMaterial);
- L612 C53: new BoundingRectangle :: AbstractRenderer.Current?.SetRenderArea(new BoundingRectangle(IVector2.Zero, new IVector2(width, height)));
- L612 C90: new IVector2 :: AbstractRenderer.Current?.SetRenderArea(new BoundingRectangle(IVector2.Zero, new IVector2(width, height)));
- L640 C57: new BoundingRectangle :: AbstractRenderer.Current?.SetRenderArea(new BoundingRectangle(IVector2.Zero, new IVector2(mipWidth, mipHeight)));
- L640 C94: new IVector2 :: AbstractRenderer.Current?.SetRenderArea(new BoundingRectangle(IVector2.Zero, new IVector2(mipWidth, mipHeight)));
- L669 C17: new ShaderFloat :: new ShaderFloat(0.0f, "Roughness"),
- L670 C17: new ShaderInt :: new ShaderInt(Math.Max(1, sourceDimension), "SourceDim"),
- L757 C23: new XRMaterial :: var mat = new XRMaterial([GetPreviewTexture()], XRShader.EngineShader(GetPreviewShaderPath(), EShaderType.Fragment)) { RenderPass = pass };
- L758 C29: new XRMeshRenderer :: PreviewSphere = new XRMeshRenderer(mesh, mat);


## XRENGINE/Scene/Components/Capture/LightProbeGridSpawnerComponent.cs
- L18 C58: new() :: private readonly List<SceneNode> _spawnedNodes = new();
- L30 C31: new IVector3 :: var clamped = new IVector3(
- L49 C31: new Vector3 :: var clamped = new Vector3(
- L270 C52: new Vector3 :: Vector3 localPos = start + new Vector3(x * Spacing.X, y * Spacing.Y, z * Spacing.Z);
- L271 C37: new SceneNode :: var child = new SceneNode(SceneNode, $"LightProbe[{x},{y},{z}]", new Transform(localPos));
- L271 C90: new Transform :: var child = new SceneNode(SceneNode, $"LightProbe[{x},{y},{z}]", new Transform(localPos));


## XRENGINE/Scene/Components/Capture/MirrorCaptureComponent.cs
- L25 C25: new XRMaterial :: _material = new XRMaterial(ShaderHelper.LoadEngineShader(Path.Combine("Common", "Mirror.fs")));
- L28 C26: new XRFrameBuffer :: _renderFBO = new XRFrameBuffer();
- L33 C30: new RenderCommandMesh3D :: _displayQuadRC = new RenderCommandMesh3D((int)EDefaultRenderPass.OpaqueForward, meshRenderer, Matrix4x4.Identity);
- L37 C80: new Vector3 :: _renderInfo.LocalCullingVolume = AABB.FromCenterSize(Vector3.Zero, new Vector3(1.0f, 1.0f, 0.001f));
- L142 C66: new() :: private readonly DrivenWorldTransform _mirrorTransform = new();
- L181 C35: new XRTexture2D :: _environmentTexture = new XRTexture2D(width, height, EPixelInternalFormat.Rgba8, EPixelFormat.Rgba, EPixelType.UnsignedByte, false)
- L199 C44: new XRTexture2D :: _environmentDepthTexture = new XRTexture2D(width, height, EPixelInternalFormat.DepthComponent24, EPixelFormat.DepthStencil, EPixelType.UnsignedInt248, false)
- L215 C30: new XRRenderBuffer :: _tempDepth = new XRRenderBuffer(width, height, ERenderBufferStorage.Depth24Stencil8);
- L221 C24: new XRViewport :: Viewport = new XRViewport(null, width, height)
- L291 C42: new Vector3 :: return Matrix4x4.CreateScale(new Vector3(-1.0f, 1.0f, 1.0f)) * Matrix4x4.CreateWorld(camPosMirror, camFwdDirMirror, camUpDirMirror);


## XRENGINE/Scene/Components/Capture/SceneCaptureComponent.cs
- L41 C51: new XRViewport :: public XRViewport?[] Viewports { get; } = new XRViewport?[6];
- L45 C13: new Rotator :: new Rotator(0.0f, -90.0f, 180.0f).ToQuaternion(), // +X
- L46 C13: new Rotator :: new Rotator(0.0f, 90.0f, 180.0f).ToQuaternion(),  // -X
- L47 C13: new Rotator :: new Rotator(90.0f, 0.0f, 0.0f).ToQuaternion(),    // +Y
- L48 C13: new Rotator :: new Rotator(-90.0f, 0.0f, 0.0f).ToQuaternion(),   // -Y
- L49 C13: new Rotator :: new Rotator(0.0f, 180.0f, 180.0f).ToQuaternion(), // +Z
- L50 C13: new Rotator :: new Rotator(0.0f, 0.0f, 180.0f).ToQuaternion(),   // -Z
- L102 C42: new XRTextureCube :: _environmentTextureCubemap = new XRTextureCube(Resolution, EPixelInternalFormat.Rgba8, EPixelFormat.Rgba, EPixelType.UnsignedByte, false)
- L120 C51: new XRTextureCube :: _environmentDepthTextureCubemap = new XRTextureCube(Resolution, EPixelInternalFormat.DepthComponent24, EPixelFormat.DepthStencil, EPixelType.UnsignedInt248, false)
- L137 C30: new XRRenderBuffer :: _tempDepth = new XRRenderBuffer(Resolution, Resolution, ERenderBufferStorage.Depth24Stencil8);
- L142 C26: new XRCubeFrameBuffer :: _renderFBO = new XRCubeFrameBuffer(null);
- L153 C32: new XRViewport :: Viewports[i] = new XRViewport(null, Resolution, Resolution)
- L304 C52: new() :: RenderingParameters renderParams = new();
- L311 C39: new XRMaterial :: _octahedralMaterial = new XRMaterial([_environmentTextureCubemap], GetFullscreenTriVertexShader(), GetCubemapToOctaShader())
- L315 C34: new XRQuadFrameBuffer :: _octahedralFBO = new XRQuadFrameBuffer(_octahedralMaterial);
- L406 C57: new BoundingRectangle :: AbstractRenderer.Current?.SetRenderArea(new BoundingRectangle(IVector2.Zero, new IVector2(width, height)));
- L406 C94: new IVector2 :: AbstractRenderer.Current?.SetRenderArea(new BoundingRectangle(IVector2.Zero, new IVector2(width, height)));


## XRENGINE/Scene/Components/Debug/Draw/DebugDrawComponent.cs
- L14 C35: new RenderCommandMethod3D :: ri.RenderCommands.Add(new RenderCommandMethod3D(EDefaultRenderPass.OnTopForward, Render));
- L40 C27: new DebugDrawSphere :: => Shapes.Add(new DebugDrawSphere(radius, localOffset, color, solid));
- L42 C27: new DebugDrawBox :: => Shapes.Add(new DebugDrawBox(halfExtents, localOffset, color, solid));
- L44 C27: new DebugDrawCircle :: => Shapes.Add(new DebugDrawCircle(radius, localOffset, localNormal, color, solid));
- L46 C27: new DebugDrawCapsule :: => Shapes.Add(new DebugDrawCapsule(radius, localStartOffset, localEndOffset, color, solid));
- L48 C27: new DebugDrawCone :: => Shapes.Add(new DebugDrawCone(radius, height, localOffset, localUpAxis, color, solid));
- L50 C27: new DebugDrawCylinder :: => Shapes.Add(new DebugDrawCylinder(radius, halfHeight, localOffset, localUpAxis, color, solid));
- L52 C27: new DebugDrawLine :: => Shapes.Add(new DebugDrawLine(localStartOffset, localEndOffset, color));
- L54 C27: new DebugDrawPoint :: => Shapes.Add(new DebugDrawPoint(localOffset, color));


## XRENGINE/Scene/Components/Debug/Visualize/ModelBvhPreviewComponent.cs
- L22 C60: new() :: private readonly Stack<BVHNode<Triangle>> _nodeStack = new();
- L23 C60: new() :: private readonly HashSet<XRMesh> _attemptedBvhBuilds = new();


## XRENGINE/Scene/Components/Editing/BSPMeshComponent.cs
- L19 C66: new() :: private readonly EventList<BSPMeshModifier> _modifiers = new() { ThreadSafe = true };
- L91 C29: new() :: BSPNode a = new();
- L94 C29: new() :: BSPNode b = new();
- L108 C24: new RenderableMesh :: Meshes.Add(new RenderableMesh(new SubMesh(resultMesh, Material), this));
- L108 C43: new SubMesh :: Meshes.Add(new RenderableMesh(new SubMesh(resultMesh, Material), this));
- L123 C31: new Triangle :: triangles.Add(new Triangle(a, b, c));
- L131 C24: new XRMesh :: return new XRMesh([]);
- L138 C27: new VertexTriangle :: prims.Add(new VertexTriangle(new Vertex(t.A, n), new Vertex(t.B, n), new Vertex(t.C, n)));
- L138 C46: new Vertex :: prims.Add(new VertexTriangle(new Vertex(t.A, n), new Vertex(t.B, n), new Vertex(t.C, n)));
- L138 C66: new Vertex :: prims.Add(new VertexTriangle(new Vertex(t.A, n), new Vertex(t.B, n), new Vertex(t.C, n)));
- L138 C86: new Vertex :: prims.Add(new VertexTriangle(new Vertex(t.A, n), new Vertex(t.B, n), new Vertex(t.C, n)));
- L140 C20: new XRMesh :: return new XRMesh(prims);


## XRENGINE/Scene/Components/Editing/TransformTool3D.cs
- L31 C19: new RenderCommandMethod3D :: _rc = new RenderCommandMethod3D((int)EDefaultRenderPass.OnTopForward, Render);
- L117 C33: new SceneNode :: _instanceNode = new SceneNode("TransformTool3D");
- L141 C50: new XRMaterial :: private readonly XRMaterial[] _axisMat = new XRMaterial[3];
- L142 C56: new XRMaterial :: private readonly XRMaterial[] _transPlaneMat = new XRMaterial[6];
- L143 C56: new XRMaterial :: private readonly XRMaterial[] _scalePlaneMat = new XRMaterial[3];
- L174 C42: new Model :: translationModelComp.Model = new Model(translationMeshes);
- L178 C42: new Model :: nonRotationModelComp.Model = new Model(nonRotationMeshes);
- L182 C36: new Model :: scaleModelComp.Model = new Model(scaleMeshes);
- L186 C39: new Model :: rotationModelComp.Model = new Model(rotationMeshes);
- L195 C45: new Model :: screenRotationModelComp.Model = new Model(screenRotationMeshes);
- L199 C48: new Model :: screenTranslationModelComp.Model = new Model(screenTranslationMeshes);
- L269 C39: new SubMesh :: nonRotationMeshes.Add(new SubMesh(axisPrim, axisMat));
- L270 C39: new SubMesh :: nonRotationMeshes.Add(new SubMesh(arrowPrim, axisMat));
- L273 C39: new SubMesh :: translationMeshes.Add(new SubMesh(transPrim1, planeMat1));
- L274 C39: new SubMesh :: translationMeshes.Add(new SubMesh(transPrim2, planeMat2));
- L277 C33: new SubMesh :: scaleMeshes.Add(new SubMesh(scalePrim, scalePlaneMat));
- L280 C36: new SubMesh :: rotationMeshes.Add(new SubMesh(rotPrim, axisMat));
- L287 C25: new Vector3 :: Vertex v1 = new Vector3(-_screenTransExtent, -_screenTransExtent, 0.0f);
- L288 C25: new Vector3 :: Vertex v2 = new Vector3(_screenTransExtent, -_screenTransExtent, 0.0f);
- L289 C25: new Vector3 :: Vertex v3 = new Vector3(_screenTransExtent, _screenTransExtent, 0.0f);
- L290 C25: new Vector3 :: Vertex v4 = new Vector3(-_screenTransExtent, _screenTransExtent, 0.0f);
- L295 C38: new SubMesh :: screenRotationMeshes.Add(new SubMesh(screenRotPrim, _screenMat));
- L297 C41: new SubMesh :: screenTranslationMeshes.Add(new SubMesh(screenTransPrim, _screenMat));
- L332 C45: new Vector4 :: transLine1.Vertex0.ColorSets = [new Vector4(unit1, 1.0f)];
- L333 C45: new Vector4 :: transLine1.Vertex1.ColorSets = [new Vector4(unit1, 1.0f)];
- L336 C45: new Vector4 :: transLine2.Vertex0.ColorSets = [new Vector4(unit2, 1.0f)];
- L337 C45: new Vector4 :: transLine2.Vertex1.ColorSets = [new Vector4(unit2, 1.0f)];
- L340 C45: new Vector4 :: scaleLine1.Vertex0.ColorSets = [new Vector4(unit, 1.0f)];
- L341 C45: new Vector4 :: scaleLine1.Vertex1.ColorSets = [new Vector4(unit, 1.0f)];
- L344 C45: new Vector4 :: scaleLine2.Vertex0.ColorSets = [new Vector4(unit, 1.0f)];
- L345 C45: new Vector4 :: scaleLine2.Vertex1.ColorSets = [new Vector4(unit, 1.0f)];
- L409 C32: new SubMesh :: rotationMeshes.Add(new SubMesh(spherePrim, sphereMat));
- L472 C41: new() :: phys.AddActor(_linkRB = new() { Flags = PxRigidBodyFlags.Kinematic, ActorFlags = PxActorFlags.DisableGravity });
- L495 C41: new() :: phys.AddActor(_linkRB = new() { Flags = PxRigidBodyFlags.Kinematic, ActorFlags = PxActorFlags.DisableGravity });
- L1168 C45: new Vector3 :: Vector3?[] intersectionPoints = new Vector3?[3];
- L1226 C45: new Vector3 :: Vector3?[] intersectionPoints = new Vector3?[3];
- L1267 C51: new Vector3 :: if (XRMath.IsInTriangle(diff, new Vector3(), new Vector3(halfDist, 0, 0), new Vector3(0, halfDist, 0)))
- L1267 C66: new Vector3 :: if (XRMath.IsInTriangle(diff, new Vector3(), new Vector3(halfDist, 0, 0), new Vector3(0, halfDist, 0)))
- L1267 C95: new Vector3 :: if (XRMath.IsInTriangle(diff, new Vector3(), new Vector3(halfDist, 0, 0), new Vector3(0, halfDist, 0)))
- L1269 C55: new Vector3 :: if (XRMath.IsInTriangle(diff, new Vector3(), new Vector3(centerDist, 0, 0), new Vector3(0, centerDist, 0)))
- L1269 C70: new Vector3 :: if (XRMath.IsInTriangle(diff, new Vector3(), new Vector3(centerDist, 0, 0), new Vector3(0, centerDist, 0)))
- L1269 C101: new Vector3 :: if (XRMath.IsInTriangle(diff, new Vector3(), new Vector3(centerDist, 0, 0), new Vector3(0, centerDist, 0)))
- L1274 C56: new Vector3 :: else if (XRMath.IsInTriangle(diff, new Vector3(), new Vector3(halfDist, 0, 0), new Vector3(0, 0, halfDist)))
- L1274 C71: new Vector3 :: else if (XRMath.IsInTriangle(diff, new Vector3(), new Vector3(halfDist, 0, 0), new Vector3(0, 0, halfDist)))
- L1274 C100: new Vector3 :: else if (XRMath.IsInTriangle(diff, new Vector3(), new Vector3(halfDist, 0, 0), new Vector3(0, 0, halfDist)))
- L1276 C55: new Vector3 :: if (XRMath.IsInTriangle(diff, new Vector3(), new Vector3(centerDist, 0, 0), new Vector3(0, 0, centerDist)))
- L1276 C70: new Vector3 :: if (XRMath.IsInTriangle(diff, new Vector3(), new Vector3(centerDist, 0, 0), new Vector3(0, 0, centerDist)))
- L1276 C101: new Vector3 :: if (XRMath.IsInTriangle(diff, new Vector3(), new Vector3(centerDist, 0, 0), new Vector3(0, 0, centerDist)))
- L1281 C56: new Vector3 :: else if (XRMath.IsInTriangle(diff, new Vector3(), new Vector3(0, halfDist, 0), new Vector3(0, 0, halfDist)))
- L1281 C71: new Vector3 :: else if (XRMath.IsInTriangle(diff, new Vector3(), new Vector3(0, halfDist, 0), new Vector3(0, 0, halfDist)))
- L1281 C100: new Vector3 :: else if (XRMath.IsInTriangle(diff, new Vector3(), new Vector3(0, halfDist, 0), new Vector3(0, 0, halfDist)))
- L1283 C55: new Vector3 :: if (XRMath.IsInTriangle(diff, new Vector3(), new Vector3(0, centerDist, 0), new Vector3(0, 0, centerDist)))
- L1283 C70: new Vector3 :: if (XRMath.IsInTriangle(diff, new Vector3(), new Vector3(0, centerDist, 0), new Vector3(0, 0, centerDist)))
- L1283 C101: new Vector3 :: if (XRMath.IsInTriangle(diff, new Vector3(), new Vector3(0, centerDist, 0), new Vector3(0, 0, centerDist)))


## XRENGINE/Scene/Components/Landscape/LandscapeComponent.cs
- L154 C64: new() :: private readonly TerrainShaderAssembler _shaderAssembler = new();
- L189 C36: new XRMesh :: private XRMesh?[] _lodMeshes = new XRMesh?[MaxLODLevels];
- L192 C46: new float :: private readonly float[] _lodDistances = new float[MaxLODLevels];
- L315 C19: new InvalidOperationException :: throw new InvalidOperationException($"Maximum of {MaxLayers} layers supported.");
- L451 C19: new HeightmapModule :: AddModule(new HeightmapModule());
- L452 C19: new SlopeSplatModule :: AddModule(new SlopeSplatModule());
- L455 C18: new TerrainLayer :: AddLayer(new TerrainLayer { Name = "Grass", Tint = new ColorF4(0.3f, 0.5f, 0.2f, 1.0f), Roughness = 0.7f });
- L455 C60: new ColorF4 :: AddLayer(new TerrainLayer { Name = "Grass", Tint = new ColorF4(0.3f, 0.5f, 0.2f, 1.0f), Roughness = 0.7f });
- L456 C18: new TerrainLayer :: AddLayer(new TerrainLayer { Name = "Rock", Tint = new ColorF4(0.5f, 0.5f, 0.5f, 1.0f), Roughness = 0.8f });
- L456 C59: new ColorF4 :: AddLayer(new TerrainLayer { Name = "Rock", Tint = new ColorF4(0.5f, 0.5f, 0.5f, 1.0f), Roughness = 0.8f });
- L457 C18: new TerrainLayer :: AddLayer(new TerrainLayer { Name = "Cliff", Tint = new ColorF4(0.4f, 0.35f, 0.3f, 1.0f), Roughness = 0.9f });
- L457 C60: new ColorF4 :: AddLayer(new TerrainLayer { Name = "Cliff", Tint = new ColorF4(0.4f, 0.35f, 0.3f, 1.0f), Roughness = 0.9f });
- L551 C27: new XRRenderProgram :: _lodProgram = new XRRenderProgram(true, false, _lodShader);
- L552 C31: new XRRenderProgram :: _cullingProgram = new XRRenderProgram(true, false, _cullingShader);
- L553 C31: new XRRenderProgram :: _normalsProgram = new XRRenderProgram(true, false, _normalsShader);
- L583 C31: new XRShader :: _splatGenShader = new XRShader(EShaderType.Compute, splatSource);
- L584 C32: new XRShader :: _heightGenShader = new XRShader(EShaderType.Compute, heightSource);
- L586 C32: new XRRenderProgram :: _splatGenProgram = new XRRenderProgram(true, false, _splatGenShader);
- L587 C33: new XRRenderProgram :: _heightGenProgram = new XRRenderProgram(true, false, _heightGenShader);
- L607 C32: new XRRenderProgram :: _splatGenProgram = new XRRenderProgram(true, false, _splatGenShader);
- L687 C26: new float :: _heightmapData = new float[res * res];
- L943 C21: new Vector4 :: new Vector4(layer.Tint.R, layer.Tint.G, layer.Tint.B, layer.Tint.A));
- L975 C22: new GPUTerrainChunk :: _chunkData = new GPUTerrainChunk[totalChunks];
- L979 C25: new XRDataBuffer :: _chunksBuffer = new XRDataBuffer(
- L990 C32: new XRDataBuffer :: _visibleChunksBuffer = new XRDataBuffer(
- L1001 C32: new XRDataBuffer :: _terrainParamsBuffer = new XRDataBuffer(
- L1012 C29: new XRDataBuffer :: _chunkCountBuffer = new XRDataBuffer(
- L1023 C31: new XRDataBuffer :: _indirectDrawBuffer = new XRDataBuffer(
- L1063 C37: new GPUTerrainChunk :: _chunkData[index] = new GPUTerrainChunk
- L1065 C37: new Vector3 :: WorldPosition = new Vector3(worldX, (MinHeight + MaxHeight) * 0.5f, worldZ),
- L1067 C39: new Vector2 :: HeightmapOffset = new Vector2(u0, v0),
- L1068 C38: new Vector2 :: HeightmapScale = new Vector2(uScale, vScale),
- L1117 C56: new Vector3 :: _chunkData[chunkIndex].WorldPosition = new Vector3(
- L1184 C24: new Vertex :: var vertices = new Vertex[vertexCount];
- L1185 C23: new List :: var indices = new List<ushort>(indexCount);
- L1199 C27: new Vector3 :: var pos = new Vector3(u - 0.5f, 0, v - 0.5f);
- L1200 C30: new Vertex :: var vertex = new Vertex(pos);
- L1201 C49: new Vector2 :: vertex.TextureCoordinateSets = [new Vector2(u, v)];
- L1230 C16: new XRMesh :: return new XRMesh(vertices, indices);
- L1253 C32: new XRMeshRenderer :: _terrainRenderer = new XRMeshRenderer(_lodMeshes[0], material);
- L1278 C42: new AABB :: _renderInfo.LocalCullingVolume = new AABB(
- L1279 C13: new Vector3 :: new Vector3(-halfSize, MinHeight, -halfSize),
- L1280 C13: new Vector3 :: new Vector3(halfSize, MaxHeight, halfSize));
- L1300 C24: new XRMaterial :: var material = new XRMaterial(vertShader, fragShader)
- L1398 C26: new GPUTerrainParams :: _terrainParams = new GPUTerrainParams
- L1402 C29: new Vector2 :: HeightmapSize = new Vector2(HeightmapResolution, HeightmapResolution),
- L1419 C42: new[] :: _terrainParamsBuffer?.SetDataRaw(new[] { _terrainParams });
- L1424 C16: new Vector4 :: return new Vector4(
- L1459 C38: new uint :: _chunkCountBuffer.SetDataRaw(new uint[] { 0 });
- L1513 C13: new Vector4 :: new Vector4(1, 0, 0, float.MaxValue),
- L1514 C13: new Vector4 :: new Vector4(-1, 0, 0, float.MaxValue),
- L1515 C13: new Vector4 :: new Vector4(0, 1, 0, float.MaxValue),
- L1516 C13: new Vector4 :: new Vector4(0, -1, 0, float.MaxValue),
- L1517 C13: new Vector4 :: new Vector4(0, 0, 1, float.MaxValue),
- L1518 C13: new Vector4 :: new Vector4(0, 0, -1, float.MaxValue)
- L1524 C16: new Vector4 :: return new Vector4(plane.Normal, plane.D);
- L1591 C26: new Vector3 :: Vector3 normal = new Vector3(hL - hR, 2.0f * delta, hD - hU);
- L1767 C20: new float :: var copy = new float[_heightmapData.Length];
- L1808 C36: new ShaderFloat :: param = (T)(object)new ShaderFloat((float)(object)value, name, null);
- L1810 C36: new ShaderInt :: param = (T)(object)new ShaderInt((int)(object)value, name, null);
- L1812 C36: new ShaderVector3 :: param = (T)(object)new ShaderVector3((Vector3)(object)value, name, null);
- L1814 C36: new ShaderVector4 :: param = (T)(object)new ShaderVector4((Vector4)(object)value, name, null);
- L1816 C23: new NotImplementedException :: throw new NotImplementedException($"Shader type {typeof(T).Name} not supported in SetUniform auto-creation yet.");


## XRENGINE/Scene/Components/Landscape/TerrainShaderAssembler.cs
- L419 C35: new StringBuilder :: var uniformDeclarations = new StringBuilder();
- L420 C31: new StringBuilder :: var moduleFunctions = new StringBuilder();
- L421 C31: new StringBuilder :: var moduleSplatCode = new StringBuilder();
- L460 C35: new StringBuilder :: var uniformDeclarations = new StringBuilder();
- L461 C32: new StringBuilder :: var moduleHeightCode = new StringBuilder();
- L497 C35: new StringBuilder :: var uniformDeclarations = new StringBuilder();
- L519 C35: new StringBuilder :: var uniformDeclarations = new StringBuilder();
- L566 C22: new string :: var indent = new string(' ', spaces);
- L568 C22: new StringBuilder :: var result = new StringBuilder();


## XRENGINE/Scene/Components/Lights/RadianceCascadeComponents.cs
- L274 C43: new PropertyChangedEventArgs :: PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));


## XRENGINE/Scene/Components/Lights/Types/DirectionalLightComponent.cs
- L94 C39: new Vector3 :: => XRMesh.Shapes.SolidBox(new Vector3(-0.5f), new Vector3(0.5f));
- L94 C59: new Vector3 :: => XRMesh.Shapes.SolidBox(new Vector3(-0.5f), new Vector3(0.5f));
- L96 C43: new Vector3 :: => XRMesh.Shapes.WireframeBox(new Vector3(-0.5f), new Vector3(0.5f));
- L96 C63: new Vector3 :: => XRMesh.Shapes.WireframeBox(new Vector3(-0.5f), new Vector3(0.5f));
- L104 C30: new float :: float[] result = new float[count];
- L162 C30: new float :: float[] result = new float[_cascadeCount];
- L214 C32: new Vector3 :: cornersWS[0] = new Vector3(min.X, min.Y, min.Z);
- L215 C32: new Vector3 :: cornersWS[1] = new Vector3(min.X, min.Y, max.Z);
- L216 C32: new Vector3 :: cornersWS[2] = new Vector3(min.X, max.Y, min.Z);
- L217 C32: new Vector3 :: cornersWS[3] = new Vector3(min.X, max.Y, max.Z);
- L218 C32: new Vector3 :: cornersWS[4] = new Vector3(max.X, min.Y, min.Z);
- L219 C32: new Vector3 :: cornersWS[5] = new Vector3(max.X, min.Y, max.Z);
- L220 C32: new Vector3 :: cornersWS[6] = new Vector3(max.X, max.Y, min.Z);
- L221 C32: new Vector3 :: cornersWS[7] = new Vector3(max.X, max.Y, max.Z);
- L297 C84: new Vector3 :: Vector3 centerLS = fwdLS * centerSlice + perpLS * centerPerp + new Vector3(0, 0, centerZ);
- L304 C39: new CascadedShadowAabb :: _cascadeAabbs.Add(new CascadedShadowAabb(
- L325 C79: new Transform :: private Transform ShadowCameraTransform => _shadowCameraTransform ??= new Transform()
- L409 C18: new XRTexture2D :: new XRTexture2D(width, height, GetShadowDepthMapFormat(precision), EPixelFormat.DepthComponent, EPixelType.Float)
- L421 C40: new XRShader :: XRMaterial mat = new(refs, new XRShader(EShaderType.Fragment, ShaderHelper.Frag_Nothing));


## XRENGINE/Scene/Components/Lights/Types/LightComponent.cs
- L96 C73: new ColorF4 :: XRMaterial mat = XRMaterial.CreateUnlitColorMaterialForward(new ColorF4(0.0f, 1.0f, 0.0f, 0.0f));
- L99 C36: new XRMeshRenderer :: _shadowVolumeRC.Mesh = new XRMeshRenderer(GetWireframeMesh(), mat);
- L225 C29: new XRMaterialFrameBuffer :: ShadowMap = new XRMaterialFrameBuffer(GetShadowMapMaterial(width, height));
- L283 C46: new FrustumIntersectionAabb :: _cameraIntersections.Add(new FrustumIntersectionAabb(i, min, max));


## XRENGINE/Scene/Components/Lights/Types/OneViewLightComponent.cs
- L17 C30: new ShadowRenderPipeline :: RenderPipeline = new ShadowRenderPipeline(),


## XRENGINE/Scene/Components/Lights/Types/PointLightComponent.cs
- L19 C54: new XRViewport :: protected readonly XRViewport[] _viewports = new XRViewport[6].Fill(x => new(null, 1024, 1024)
- L21 C30: new ShadowRenderPipeline :: RenderPipeline = new ShadowRenderPipeline(),
- L112 C32: new Sphere :: _influenceVolume = new Sphere(Vector3.Zero, radius);
- L227 C17: new XRTextureCube :: new XRTextureCube(cubeExtent, GetShadowDepthMapFormat(precision), EPixelFormat.DepthComponent, EPixelType.UnsignedByte, false)
- L236 C17: new XRTextureCube :: new XRTextureCube(cubeExtent, EPixelInternalFormat.R16f, EPixelFormat.Red, EPixelType.HalfFloat, false)


## XRENGINE/Scene/Components/Lights/Types/ShadowRenderPipeline.cs
- L48 C20: new() :: return new()


## XRENGINE/Scene/Components/Lights/Types/SpotLightComponent.cs
- L153 C17: new XRTexture2D :: new XRTexture2D(width, height, GetShadowDepthMapFormat(precision), EPixelFormat.DepthComponent, EPixelType.UnsignedByte)
- L161 C17: new XRTexture2D :: new XRTexture2D(width, height, EPixelInternalFormat.R16f, EPixelFormat.Red, EPixelType.HalfFloat)
- L173 C40: new XRShader :: XRMaterial mat = new(refs, new XRShader(EShaderType.Fragment, ShaderHelper.Frag_DepthOutput));


## XRENGINE/Scene/Components/Mesh/GaussianSplatComponent.cs
- L94 C31: new SubMeshLOD :: SubMesh subMesh = new(new SubMeshLOD(material, mesh, float.PositiveInfinity))
- L100 C17: new Model :: Model = new Model(subMesh);
- L142 C25: new XRMesh :: return (new XRMesh([]), new AABB(), 0);
- L142 C41: new AABB :: return (new XRMesh([]), new AABB(), 0);
- L146 C35: new Vector3 :: Vector3[] positions = new Vector3[count];
- L147 C32: new Vector4 :: Vector4[] colors = new Vector4[count];
- L148 C32: new Vector4 :: Vector4[] scales = new Vector4[count];
- L149 C35: new Vector4 :: Vector4[] rotations = new Vector4[count];
- L162 C29: new Vector4 :: scales[i] = new Vector4(scaledExtents, scaledExtents.Length());
- L237 C33: new RenderingParameters :: RenderOptions = new RenderingParameters()
- L240 C33: new DepthTest :: DepthTest = new DepthTest()


## XRENGINE/Scene/Components/Mesh/HlodGroupComponent.cs
- L41 C58: new() :: private readonly List<SourceHook> _sourceHooks = new();
- L53 C30: new RenderCommandMesh3D :: _renderCommand = new RenderCommandMesh3D((int)EDefaultRenderPass.OpaqueForward)
- L295 C34: new SourceHook :: _sourceHooks.Add(new SourceHook(ri, prev));
- L336 C27: new List :: var results = new List<RenderableMesh>();
- L408 C28: new OctahedralImposterGenerator.Settings :: var settings = new OctahedralImposterGenerator.Settings(ImposterSheetSize, ImposterCapturePadding, ImposterCaptureDepth);
- L444 C27: new SubMeshLOD :: var lod = new SubMeshLOD(sub.Material, sub.Mesh, 0.0f);
- L445 C31: new SubMesh :: subMeshes.Add(new SubMesh(lod));
- L448 C50: new Model :: return subMeshes.Count == 0 ? null : new Model(subMeshes);
- L457 C39: new Dictionary :: var trianglesByMaterial = new Dictionary<XRMaterial, List<VertexTriangle>>(System.Collections.Generic.ReferenceEqualityComparer.Instance);
- L489 C86: new AABB :: localBounds = localBounds?.ExpandedToInclude(localCorner) ?? new AABB(localCorner, localCorner);
- L508 C32: new List :: tris = new List<VertexTriangle>(Math.Max(64, indices.Length / 3));
- L536 C34: new VertexTriangle :: tris.Add(new VertexTriangle(MakeVertex(i0), MakeVertex(i1), MakeVertex(i2)));
- L548 C29: new List :: var submeshes = new List<(XRMesh mesh, XRMaterial material)>(trianglesByMaterial.Count);
- L568 C30: new XRMeshRenderer :: _proxyRenderer = new XRMeshRenderer(submeshes)


## XRENGINE/Scene/Components/Mesh/ModelComponent.cs
- L21 C85: new() :: private readonly ConcurrentDictionary<SubMesh, RenderableMesh> _meshLinks = new();
- L170 C30: new JobProgress :: yield return new JobProgress(1f, "BVH ready");
- L198 C26: new JobProgress :: yield return new JobProgress(1f, "BVH warmup complete");


## XRENGINE/Scene/Components/Mesh/OctahedralBillboardComponent.cs
- L57 C30: new RenderCommandMesh3D :: _renderCommand = new RenderCommandMesh3D((int)EDefaultRenderPass.TransparentForward)
- L124 C33: new Vector2 :: BillboardSize = new Vector2(width, height);
- L158 C25: new XRMeshRenderer :: _renderer = new XRMeshRenderer(mesh, material);
- L195 C33: new RenderingParameters :: RenderOptions = new RenderingParameters
- L199 C33: new DepthTest :: DepthTest = new DepthTest
- L234 C26: new XRShader :: shader = new XRShader(EShaderType.Fragment, ShaderHelper.Frag_Nothing);
- L274 C46: new AABB :: _renderInfo.LocalCullingVolume = new AABB(-halfExtents, halfExtents);
- L336 C20: new Vector2 :: return new Vector2(width, height);


## XRENGINE/Scene/Components/Mesh/RenderableComponent.cs
- L46 C73: new EventList :: public EventList<RenderableMesh> Meshes { get; private set; } = new EventList<RenderableMesh>() { ThreadSafe = true };


## XRENGINE/Scene/Components/Mesh/RenderableMesh.cs
- L26 C95: new() :: private static readonly ConcurrentQueue<RenderableMesh> _pendingRenderMatrixUpdates = new();
- L31 C80: new() :: private readonly Dictionary<TransformBase, int> _trackedSkinnedBones = new();
- L32 C86: new() :: private readonly Dictionary<TransformBase, Matrix4x4> _currentSkinMatrices = new();
- L34 C54: new() :: private readonly object _relativeCacheLock = new();
- L35 C52: new() :: private readonly object _skinnedDataLock = new();
- L69 C71: new() :: public LinkedList<RenderableLOD> LODs { get; private set; } = new();
- L97 C60: new() :: private readonly object _pendingRenderMatrixLock = new();
- L142 C30: new RenderableLOD :: LODs.AddLast(new RenderableLOD(renderer, lod.MaxVisibleDistance));
- L146 C36: new RenderCommandMethod3D :: _renderBoundsCommand = new RenderCommandMethod3D((int)EDefaultRenderPass.OpaqueForward, DoRenderBounds);
- L147 C60: new RenderCommandMesh3D :: RenderInfo = RenderInfo3D.New(component, _rc = new RenderCommandMesh3D(0));
- L292 C24: new SkinnedMeshBoundsCalculator.Result :: return new SkinnedMeshBoundsCalculator.Result(worldPositions, result.Bounds, basis);
- L294 C34: new Vector3 :: var localPositions = new Vector3[worldPositions.Length];
- L299 C20: new SkinnedMeshBoundsCalculator.Result :: return new SkinnedMeshBoundsCalculator.Result(localPositions, localBounds, basis);
- L477 C43: new Vector3 :: _skinnedVertexPositions = new Vector3[vertices.Length];
- L511 C31: new AABB :: var localBounds = new AABB(min, max);
- L512 C35: new SkinnedMeshBoundsCalculator.Result :: var localizedResult = new SkinnedMeshBoundsCalculator.Result((Vector3[])_skinnedVertexPositions.Clone(), localBounds, basis);


## XRENGINE/Scene/Components/Mesh/Shapes/ConeMeshComponent.cs
- L22 C29: new Cone :: Shape = new Cone(Vector3.Zero, Globals.Up, Height, Radius);


## XRENGINE/Scene/Components/Mesh/Shapes/ShapeMeshComponent.cs
- L34 C36: new RenderableMesh :: Meshes.Add(new RenderableMesh(new(XRMesh.Shapes.FromVolume(Shape, false), Material), this));


## XRENGINE/Scene/Components/Mesh/Shapes/SphereMeshComponent.cs
- L30 C29: new Sphere :: Shape = new Sphere(Vector3.Zero, Radius);


## XRENGINE/Scene/Components/Misc/AdvancedForwardMirrorComponent.cs
- L24 C33: new() :: mat.RenderOptions = new()
- L29 C31: new StencilTest :: StencilTest = new StencilTest()
- L36 C29: new DepthTest :: DepthTest = new DepthTest()
- L49 C25: new RenderCommandMesh3D :: _rcMirror = new RenderCommandMesh3D((int)EDefaultRenderPass.Background, rend, Matrix4x4.Identity);
- L56 C59: new() :: private static StencilTestFace MirrorStencil() => new()
- L93 C62: new Plane :: public Plane ReflectionPlane { get; private set; } = new Plane(Globals.Backward, 0);
- L95 C64: new AABB :: public AABB LocalCullingVolume { get; private set; } = new AABB(Vector3.Zero, Vector3.Zero);
- L96 C63: new Box :: public Box WorldCullingVolume { get; private set; } = new Box(Vector3.Zero, Vector3.Zero, Matrix4x4.Identity);
- L115 C42: new AABB :: LocalCullingVolume = new AABB(
- L116 C25: new Vector3 :: new Vector3(0, 0, 0),
- L117 C25: new Vector3 :: new Vector3(MirrorWidth, MirrorHeight, 0.001f));


## XRENGINE/Scene/Components/Misc/DeferredDecalComponent.cs
- L38 C75: new RenderCommandMethod3D :: DebugRenderInfo = RenderInfo3D.New(this, DebugRenderCommand = new RenderCommandMethod3D((int)EDefaultRenderPass.OpaqueForward, RenderDebug));
- L53 C27: new Vector3 :: HalfExtents = new Vector3(texture.Width * 0.5f, depth, texture.Height * 0.5f);
- L61 C27: new Vector3 :: HalfExtents = new Vector3(texture.Width * 0.5f, Math.Max(texture.Width, texture.Height) * 0.5f, texture.Height * 0.5f);
- L96 C45: new AABB :: RenderInfo.LocalCullingVolume = new AABB(-HalfExtents, HalfExtents);
- L122 C53: new() :: RenderingParameters decalRenderParams = new()
- L126 C29: new DepthTest :: DepthTest = new DepthTest() { Enabled = ERenderParamUsage.Disabled }
- L128 C20: new XRMaterial :: return new XRMaterial(decalVars, decalRefs, GetDefaultShader())
- L141 C39: new XRMeshRenderer :: RenderCommandDecal.Mesh = new XRMeshRenderer(XRMesh.Shapes.SolidBox(-Vector3.One, Vector3.One), Material);
- L173 C15: new RenderCommandMesh3D :: = new RenderCommandMesh3D(EDefaultRenderPass.DeferredDecals);


## XRENGINE/Scene/Components/Misc/SkyboxComponent.cs
- L109 C30: new RenderCommandMesh3D :: _renderCommand = new RenderCommandMesh3D(EDefaultRenderPass.Background);
- L318 C17: new Vertex :: new Vertex(new Vector3(-1, -1, 0)),
- L318 C28: new Vector3 :: new Vertex(new Vector3(-1, -1, 0)),
- L319 C17: new Vertex :: new Vertex(new Vector3(3, -1, 0)),
- L319 C28: new Vector3 :: new Vertex(new Vector3(3, -1, 0)),
- L320 C17: new Vertex :: new Vertex(new Vector3(-1, 3, 0)));
- L320 C28: new Vector3 :: new Vertex(new Vector3(-1, 3, 0)));
- L342 C48: new() :: RenderingParameters renderParams = new()
- L345 C29: new DepthTest :: DepthTest = new DepthTest()
- L358 C25: new XRMaterial :: _material = new XRMaterial(tex is not null ? [tex] : [], vertexShader, fragmentShader)
- L372 C33: new XRMeshRenderer :: _meshRenderer = new XRMeshRenderer(_mesh, _material);
- L441 C36: new XRShader :: s_vertexShader ??= new XRShader(EShaderType.Vertex, VertexShaderSource);
- L456 C41: new XRShader :: return s_gradientShader ??= new XRShader(EShaderType.Fragment, GradientShaderSource);
- L468 C38: new XRShader :: s_equirectShader ??= new XRShader(EShaderType.Fragment, EquirectShaderSource);
- L482 C40: new XRShader :: s_octahedralShader ??= new XRShader(EShaderType.Fragment, OctahedralShaderSource);
- L496 C37: new XRShader :: s_cubemapShader ??= new XRShader(EShaderType.Fragment, CubemapShaderSource);
- L510 C42: new XRShader :: s_cubemapArrayShader ??= new XRShader(EShaderType.Fragment, CubemapArrayShaderSource);
- L774 C20: new SkyboxComponent :: return new SkyboxComponent
- L787 C20: new SkyboxComponent :: return new SkyboxComponent
- L800 C20: new SkyboxComponent :: return new SkyboxComponent
- L813 C20: new SkyboxComponent :: return new SkyboxComponent


## XRENGINE/Scene/Components/Movement/CharacterMovementComponent.cs
- L114 C42: new XRMeshRenderer :: _capsuleRenderMeshRenderer = new XRMeshRenderer(null, _capsuleRenderMaterial);
- L115 C37: new RenderCommandMesh3D :: _capsuleRenderCommand = new RenderCommandMesh3D((int)EDefaultRenderPass.OnTopForward, _capsuleRenderMeshRenderer, Matrix4x4.Identity, null);
- L140 C41: new FeetInches :: private float _standingHeight = new FeetInches(5, 2.0f).ToMeters();
- L141 C41: new FeetInches :: private float _crouchedHeight = new FeetInches(3, 0.0f).ToMeters();
- L142 C38: new FeetInches :: private float _proneHeight = new FeetInches(1, 0.0f).ToMeters();
- L168 C50: new ModernMovementModule :: private MovementModule _movementModule = new ModernMovementModule();
- L202 C59: new ModernMovementModule :: set => SetField(ref _movementModule, value ?? new ModernMovementModule());
- L627 C67: new Vector3 :: _capsuleRenderInfo.LocalCullingVolume = AABB.FromSize(new Vector3(radius * 2.0f, yHalfExtent * 2.0f, radius * 2.0f));
- L690 C36: new PhysxCharacterControllerAdapter :: ActiveController = new PhysxCharacterControllerAdapter(_physxController);
- L693 C50: new PhysxControllerActorProxy :: unsafe { _controllerActorProxy = new PhysxControllerActorProxy(_physxController.ControllerPtr); }
- L705 C35: new JoltCharacterVirtualController :: _joltController = new JoltCharacterVirtualController(joltScene, pos)
- L715 C36: new JoltCharacterControllerAdapter :: ActiveController = new JoltCharacterControllerAdapter(_joltController);
- L899 C20: new MovementModule.MovementContext :: return new MovementModule.MovementContext(
- L999 C65: new Vector3 :: Vector3 inputDirection = posDelta != Vector3.Zero ? new Vector3(posDelta.X, 0, posDelta.Z).Normalized() : Vector3.Zero;
- L1028 C25: new Vector3 :: delta = new Vector3(delta.X * frictionFactor, delta.Y, delta.Z * frictionFactor);


## XRENGINE/Scene/Components/Movement/HeightScaleBaseComponent.cs
- L277 C30: new Vector3 :: eyePosWorldAvg = new Vector3(sumX, sumY, sumZ);


## XRENGINE/Scene/Components/Movement/Modules/MovementModule.cs
- L386 C24: new MovementResult :: return new MovementResult(horizontal + up * vertical, gravityApplied, requestedMode);
- L394 C24: new MovementResult :: return new MovementResult(NewVelocity, GravityApplied, mode);
- L440 C20: new MovementResult :: return new MovementResult(newVelocity);


## XRENGINE/Scene/Components/Movement/PlayerMovementComponentBase.cs
- L48 C33: new Vector3 :: => AddMovementInput(new Vector3(x, y, z));


## XRENGINE/Scene/Components/Networking/NetworkDiscoveryComponent.cs
- L222 C23: new TaskCompletionSource :: var tcs = new TaskCompletionSource<Engine.BaseNetworkingManager?>();
- L251 C23: new TaskCompletionSource :: var tcs = new TaskCompletionSource<Engine.BaseNetworkingManager?>();
- L257 C85: new GameStartupSettings :: GameStartupSettings startup = settings ?? AdvertisedSettings ?? new GameStartupSettings();
- L278 C79: new GameStartupSettings :: GameStartupSettings settings = ClientSettingsFactory?.Invoke() ?? new GameStartupSettings();
- L296 C34: new CancellationTokenSource :: => _discoveryCts ??= new CancellationTokenSource();
- L325 C36: new IPEndPoint :: client.Client.Bind(new IPEndPoint(IPAddress.Any, _discoveryPort));
- L362 C37: new IPEndPoint :: multicastEndPoint = new IPEndPoint(multicast, _discoveryPort);
- L394 C66: new GameStartupSettings :: GameStartupSettings settings = AdvertisedSettings ?? new GameStartupSettings();
- L397 C20: new DiscoveryAnnouncement :: return new DiscoveryAnnouncement
- L460 C32: new DiscoveredEndpoint :: _discovered[key] = new DiscoveredEndpoint(announcement, now);


## XRENGINE/Scene/Components/Networking/OscSenderComponent.cs
- L35 C22: new OscClient :: Client = new OscClient("127.0.0.1", port);


## XRENGINE/Scene/Components/Networking/RestApiComponent.cs
- L26 C51: new() :: private readonly object _httpClientLock = new();
- L29 C60: new() :: private CancellationTokenSource _requestScopeCts = new();
- L88 C27: new ArgumentOutOfRangeException :: throw new ArgumentOutOfRangeException(nameof(value), "Timeout must be greater than zero.");
- L121 C23: new ArgumentException :: throw new ArgumentException("Header name cannot be empty.", nameof(name));
- L174 C26: new RestApiRequest :: => SendAsync(new RestApiRequest
- L185 C37: new RestApiRequest :: => SendAsync<TResponse>(new RestApiRequest
- L196 C26: new RestApiRequest :: => SendAsync(new RestApiRequest
- L207 C37: new RestApiRequest :: => SendAsync<TResponse>(new RestApiRequest
- L223 C23: new InvalidOperationException :: throw new InvalidOperationException("REST client has not been initialized.");
- L240 C36: new RestApiResponse :: var restResponse = new RestApiResponse(
- L255 C27: new RestApiRequestException :: throw new RestApiRequestException(request, restResponse);
- L277 C24: new RestApiResponse :: return new RestApiResponse<TResponse>(response, default);
- L284 C24: new RestApiResponse :: return new RestApiResponse<TResponse>(response, payload);
- L288 C48: new RestApiDeserializationException :: var deserializationException = new RestApiDeserializationException(typeof(TResponse), request, response, ex);
- L299 C71: new CancellationTokenSource :: var previous = Interlocked.Exchange(ref _requestScopeCts, new CancellationTokenSource());
- L340 C34: new SocketsHttpHandler :: _httpHandler ??= new SocketsHttpHandler
- L347 C27: new HttpClient :: _client = new HttpClient(_httpHandler, false)
- L397 C27: new HttpRequestMessage :: var message = new HttpRequestMessage(request.Method, targetUri);
- L417 C24: new FormUrlEncodedContent :: return new FormUrlEncodedContent(request.FormFields);
- L421 C31: new ByteArrayContent :: var content = new ByteArrayContent(binary.ToArray());
- L428 C24: new StringContent :: return new StringContent(request.RawPayload, Encoding.UTF8, request.ContentType);
- L436 C24: new StringContent :: return new StringContent(json, Encoding.UTF8, request.ContentType);
- L454 C23: new InvalidOperationException :: throw new InvalidOperationException("BaseUrl must be set to send relative REST requests.");
- L456 C20: new Uri :: return new Uri(_client.BaseAddress, target);
- L468 C27: new StringBuilder :: var builder = new StringBuilder(normalized);
- L506 C27: new Dictionary :: var headers = new Dictionary<string, string[]>(StringComparer.OrdinalIgnoreCase);
- L728 C20: new ReadOnlyMemory :: Body = new ReadOnlyMemory<byte>(body);
- L793 C16: new MemoryStream :: => new MemoryStream(Body.ToArray(), false);


## XRENGINE/Scene/Components/Networking/TcpClientComponent.cs
- L194 C23: new InvalidOperationException :: throw new InvalidOperationException("TCP connection is not established.");
- L240 C34: new CancellationTokenSource :: _connectionCts = new CancellationTokenSource();
- L282 C31: new InvalidOperationException :: DispatchError(new InvalidOperationException("Host and Port must be configured before connecting."));
- L287 C26: new TcpClient :: var client = new TcpClient
- L302 C37: new SslStream :: var sslStream = new SslStream(stream, leaveInnerStreamOpen: false, ValidateCertificate);
- L303 C39: new SslClientAuthenticationOptions :: var authOptions = new SslClientAuthenticationOptions
- L361 C38: new byte :: byte[] payload = new byte[read];


## XRENGINE/Scene/Components/Networking/TcpServerComponent.cs
- L19 C77: new() :: private readonly ConcurrentDictionary<Guid, ClientState> _clients = new();
- L121 C23: new InvalidOperationException :: throw new InvalidOperationException("Client is no longer connected.");
- L185 C27: new InvalidOperationException :: throw new InvalidOperationException("ListenPort must be greater than zero.");
- L188 C32: new TcpListener :: var listener = new TcpListener(address, _listenPort);
- L192 C32: new CancellationTokenSource :: _listenerCts = new CancellationTokenSource();
- L288 C30: new TcpServerClient :: var descriptor = new TcpServerClient(Guid.NewGuid(), (IPEndPoint?)client.Client.RemoteEndPoint);
- L290 C25: new ClientState :: var state = new ClientState(descriptor.Id, client, stream);
- L309 C38: new byte :: byte[] payload = new byte[read];
- L440 C28: new SemaphoreSlim :: SendLock = new SemaphoreSlim(1, 1);
- L441 C30: new CancellationTokenSource :: ReceiveCts = new CancellationTokenSource();


## XRENGINE/Scene/Components/Networking/UdpSocketComponent.cs
- L165 C23: new InvalidOperationException :: throw new InvalidOperationException("Socket is not bound.");
- L168 C23: new InvalidOperationException :: throw new InvalidOperationException("A valid host and port are required.");
- L172 C23: new InvalidOperationException :: throw new InvalidOperationException($"Unable to resolve host '{host}'.");
- L174 C28: new IPEndPoint :: var endpoint = new IPEndPoint(address, port);
- L219 C37: new IPEndPoint :: var localEndPoint = new IPEndPoint(address, _localPort);
- L220 C30: new UdpClient :: var client = new UdpClient(localEndPoint.AddressFamily);
- L231 C31: new CancellationTokenSource :: _receiveCts = new CancellationTokenSource();
- L280 C36: new UdpDatagram :: var datagram = new UdpDatagram(result.RemoteEndPoint, result.Buffer);


## XRENGINE/Scene/Components/Networking/WebhookListenerComponent.cs
- L19 C73: new() :: private readonly ConcurrentQueue<WebhookEvent> _pendingEvents = new();
- L96 C23: new ArgumentException :: throw new ArgumentException("Header name cannot be blank.", nameof(name));
- L121 C25: new HttpListener :: _listener = new HttpListener();
- L127 C28: new CancellationTokenSource :: _listenerCts = new CancellationTokenSource();
- L202 C36: new StreamReader :: using var reader = new StreamReader(context.Request.InputStream, context.Request.ContentEncoding ?? Encoding.UTF8, leaveOpen: false);
- L205 C36: new WebhookEvent :: var webhookEvent = new WebhookEvent(
- L252 C27: new Dictionary :: var headers = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
- L262 C29: new char :: char[] buffer = new char[Math.Min(4096, maxBytes)];
- L264 C32: new StringWriter :: using var writer = new StringWriter();
- L315 C71: new JsonSerializerOptions :: return JsonSerializer.Deserialize<T>(Body, options ?? new JsonSerializerOptions(JsonSerializerDefaults.Web));


## XRENGINE/Scene/Components/Networking/WebSocketClientComponent.cs
- L107 C23: new ArgumentException :: throw new ArgumentException("Header name cannot be blank.", nameof(name));
- L171 C23: new InvalidOperationException :: throw new InvalidOperationException("WebSocket is not connected.");
- L208 C34: new CancellationTokenSource :: _connectionCts = new CancellationTokenSource();
- L249 C31: new InvalidOperationException :: DispatchError(new InvalidOperationException($"WebSocket endpoint '{_endpoint}' is invalid."));
- L254 C26: new ClientWebSocket :: var socket = new ClientWebSocket();
- L306 C47: new MemoryStream :: using var messageStream = new MemoryStream();
- L325 C35: new WebSocketMessage :: var message = new WebSocketMessage(result.MessageType == WebSocketMessageType.Text, payload);


## XRENGINE/Scene/Components/Particles/ParticleEmitterComponent.cs
- L77 C65: new() :: private readonly ParticleShaderAssembler _shaderAssembler = new();
- L171 C45: new AABB :: public AABB LocalBounds { get; set; } = new AABB(new Vector3(-10), new Vector3(10));
- L171 C54: new Vector3 :: public AABB LocalBounds { get; set; } = new AABB(new Vector3(-10), new Vector3(10));
- L171 C72: new Vector3 :: public AABB LocalBounds { get; set; } = new AABB(new Vector3(-10), new Vector3(10));
- L281 C19: new PointSpawnModule :: AddModule(new PointSpawnModule());
- L282 C19: new GravityModule :: AddModule(new GravityModule());
- L371 C28: new XRShader :: _spawnShader = new XRShader(EShaderType.Compute, spawnSource);
- L372 C29: new XRShader :: _updateShader = new XRShader(EShaderType.Compute, updateSource);
- L374 C29: new XRRenderProgram :: _spawnProgram = new XRRenderProgram(true, false, _spawnShader);
- L375 C30: new XRRenderProgram :: _updateProgram = new XRRenderProgram(true, false, _updateShader);
- L397 C29: new XRRenderProgram :: _spawnProgram = new XRRenderProgram(true, false, _spawnShader);
- L398 C30: new XRRenderProgram :: _updateProgram = new XRRenderProgram(true, false, _updateShader);
- L428 C25: new GPUParticle :: _particleData = new GPUParticle[maxParticles];
- L429 C25: new uint :: _deadListData = new uint[maxParticles];
- L430 C26: new uint :: _aliveListData = new uint[maxParticles];
- L436 C32: new GPUParticle :: _particleData[i] = new GPUParticle { Flags = 0 }; // All dead initially
- L440 C21: new ParticleCounters :: _counters = new ParticleCounters
- L450 C28: new XRDataBuffer :: _particlesBuffer = new XRDataBuffer(
- L461 C27: new XRDataBuffer :: _deadListBuffer = new XRDataBuffer(
- L472 C28: new XRDataBuffer :: _aliveListBuffer = new XRDataBuffer(
- L483 C27: new XRDataBuffer :: _countersBuffer = new XRDataBuffer(
- L494 C32: new XRDataBuffer :: _emitterParamsBuffer = new XRDataBuffer(
- L505 C31: new XRDataBuffer :: _indirectDrawBuffer = new XRDataBuffer(
- L525 C37: new[] :: _countersBuffer?.SetDataRaw(new[] { _counters });
- L564 C29: new XRMeshRenderer :: _particleRenderer = new XRMeshRenderer(_particleMesh, material);
- L590 C18: new Vertex :: var v0 = new Vertex(new Vector3(-halfSize, -halfSize, 0))
- L590 C29: new Vector3 :: var v0 = new Vertex(new Vector3(-halfSize, -halfSize, 0))
- L592 C38: new Vector2 :: TextureCoordinateSets = [new Vector2(0, 0)]
- L595 C18: new Vertex :: var v1 = new Vertex(new Vector3(halfSize, -halfSize, 0))
- L595 C29: new Vector3 :: var v1 = new Vertex(new Vector3(halfSize, -halfSize, 0))
- L597 C38: new Vector2 :: TextureCoordinateSets = [new Vector2(1, 0)]
- L600 C18: new Vertex :: var v2 = new Vertex(new Vector3(halfSize, halfSize, 0))
- L600 C29: new Vector3 :: var v2 = new Vertex(new Vector3(halfSize, halfSize, 0))
- L602 C38: new Vector2 :: TextureCoordinateSets = [new Vector2(1, 1)]
- L605 C18: new Vertex :: var v3 = new Vertex(new Vector3(-halfSize, halfSize, 0))
- L605 C29: new Vector3 :: var v3 = new Vertex(new Vector3(-halfSize, halfSize, 0))
- L607 C38: new Vector2 :: TextureCoordinateSets = [new Vector2(0, 1)]
- L610 C24: new[] :: var vertices = new[] { v0, v1, v2, v3 };
- L611 C23: new List :: var indices = new List<ushort> { 0, 1, 2, 0, 2, 3 };
- L613 C16: new XRMesh :: return new XRMesh(vertices, indices);
- L626 C24: new XRMaterial :: var material = new XRMaterial(vertShader, fragShader)
- L635 C44: new Rendering.Models.Materials.BlendMode :: EParticleBlendMode.Additive => new Rendering.Models.Materials.BlendMode
- L643 C48: new Rendering.Models.Materials.BlendMode :: EParticleBlendMode.SoftAdditive => new Rendering.Models.Materials.BlendMode
- L651 C44: new Rendering.Models.Materials.BlendMode :: EParticleBlendMode.Multiply => new Rendering.Models.Materials.BlendMode
- L738 C26: new GPUEmitterParams :: _emitterParams = new GPUEmitterParams
- L750 C28: new Vector4 :: InitialColor = new Vector4(InitialColor.R, InitialColor.G, InitialColor.B, InitialColor.A),
- L760 C42: new[] :: _emitterParamsBuffer?.SetDataRaw(new[] { _emitterParams });
- L885 C33: new GPUParticle :: _particleData![i] = new GPUParticle { Flags = 0 };
- L888 C21: new ParticleCounters :: _counters = new ParticleCounters


## XRENGINE/Scene/Components/Particles/ParticleModules/ColorOverLifetimeModule.cs
- L22 C45: new ColorF4 :: public ColorF4 EndColor { get; set; } = new ColorF4(1, 1, 1, 0);
- L31 C40: new Vector4 :: program.Uniform("uColorStart", new Vector4(StartColor.R, StartColor.G, StartColor.B, StartColor.A));
- L32 C38: new Vector4 :: program.Uniform("uColorEnd", new Vector4(EndColor.R, EndColor.G, EndColor.B, EndColor.A));


## XRENGINE/Scene/Components/Particles/ParticleShaderAssembler.cs
- L267 C35: new StringBuilder :: var uniformDeclarations = new StringBuilder();
- L268 C31: new StringBuilder :: var moduleFunctions = new StringBuilder();
- L269 C31: new StringBuilder :: var moduleSpawnCode = new StringBuilder();
- L308 C35: new StringBuilder :: var uniformDeclarations = new StringBuilder();
- L309 C31: new StringBuilder :: var moduleFunctions = new StringBuilder();
- L310 C32: new StringBuilder :: var moduleUpdateCode = new StringBuilder();
- L372 C22: new string :: var indent = new string(' ', spaces);
- L374 C22: new StringBuilder :: var result = new StringBuilder();


## XRENGINE/Scene/Components/Pawns/CharacterPawnComponent.cs
- L687 C17: new Vector2 :: new Vector2(-1.0f, -1.0f),
- L688 C17: new Vector2 :: new Vector2(1.0f, 1.0f));
- L690 C42: new() :: NetworkInputState snapshot = new()
- L693 C30: new Vector2 :: ViewAngles = new Vector2(_viewRotation.Yaw, _viewRotation.Pitch),


## XRENGINE/Scene/Components/Pawns/FlyingCameraPawn.cs
- L58 C19: new CameraComponent :: protected new CameraComponent? CameraComponent => GetSiblingComponent<CameraComponent>();


## XRENGINE/Scene/Components/Pawns/PawnComponent.cs
- L77 C100: new Segment :: public Segment CursorPositionWorld => Viewport?.GetWorldSegment(CursorPositionViewport) ?? new Segment(Vector3.Zero, Vector3.Zero);


## XRENGINE/Scene/Components/Pawns/UICanvasComponent.cs
- L33 C59: new() :: public UIBatchCollector BatchCollector { get; } = new();
- L89 C32: new XRMeshRenderer :: var quadRenderer = new XRMeshRenderer(quadMesh, _offscreenMaterial);
- L91 C38: new RenderCommandMesh3D :: _worldSpaceQuadCommand = new RenderCommandMesh3D((int)EDefaultRenderPass.TransparentForward, quadRenderer, Matrix4x4.Identity);
- L92 C43: new RenderCommandMethod3D :: _worldSpacePreRenderCommand = new RenderCommandMethod3D((int)EDefaultRenderPass.PreRender, RenderNonScreenCanvasToTexture);
- L99 C29: new XRMaterialFrameBuffer :: _offscreenFbo = new XRMaterialFrameBuffer(_offscreenMaterial);
- L101 C31: new[] :: RenderedObjects = new[] { _worldSpaceQuadRenderInfo };
- L175 C39: new XROrthographicCameraParameters :: Camera2D.Parameters = new XROrthographicCameraParameters(bounds.Width, bounds.Height, DefaultNearZ, DefaultFarZ);
- L191 C38: new Transform :: get => _camera2D ??= new(new Transform());
- L202 C39: new() :: get => _visualScene2D ??= new();
- L577 C35: new BoundingRectangleF :: ResizeScreenSpace(new BoundingRectangleF(Vector2.Zero, new Vector2(width, height)));
- L577 C72: new Vector2 :: ResizeScreenSpace(new BoundingRectangleF(Vector2.Zero, new Vector2(width, height)));
- L665 C35: new BoundingRectangleF :: ResizeScreenSpace(new BoundingRectangleF(Vector2.Zero, new Vector2(width, height)));
- L665 C72: new Vector2 :: ResizeScreenSpace(new BoundingRectangleF(Vector2.Zero, new Vector2(width, height)));
- L686 C74: new Vector3 :: _worldSpaceQuadRenderInfo.LocalCullingVolume = AABB.FromSize(new Vector3(width, height, 0.05f));
- L801 C88: new UserInterfaceRenderPipeline :: private readonly XRRenderPipelineInstance _renderPipeline = new() { Pipeline = new UserInterfaceRenderPipeline() };
- L801 C69: new() :: private readonly XRRenderPipelineInstance _renderPipeline = new() { Pipeline = new UserInterfaceRenderPipeline() };


## XRENGINE/Scene/Components/Pawns/UICanvasInputComponent.cs
- L324 C57: new Vector2 :: var vpCoord = vp.ScreenToViewportCoordinate(new Vector2(x, y));
- L472 C28: new List :: var toRemove = new List<RenderInfo2D>();
- L633 C74: new Comparer :: private SortedSet<RenderInfo2D> LastUIElementIntersections = new(new Comparer());
- L634 C70: new Comparer :: private SortedSet<RenderInfo2D> UIElementIntersections = new(new Comparer());


## XRENGINE/Scene/Components/Pawns/VRPlayerInputSet.cs
- L157 C55: new RenderCommandMethod3D :: RenderedObjects = [RenderInfo3D.New(this, new RenderCommandMethod3D(EDefaultRenderPass.PostRender, PostRender))];
- L177 C36: new BoundingRectangle :: BoundingRectangle vp = new BoundingRectangle();
- L439 C16: new() :: => new()
- L585 C26: new IPhysicsGeometry.Sphere :: var sphere = new IPhysicsGeometry.Sphere(GrabRadius);


## XRENGINE/Scene/Components/Physics/ConvexHullUtility.cs
- L89 C31: new Vector3 :: Vector3[] positions = new Vector3[vertices.Length];
- L93 C17: new ConvexHullInput :: input = new ConvexHullInput(positions, indices);


## XRENGINE/Scene/Components/Physics/DynamicRigidBodyComponent.cs
- L441 C56: new PhysicsMassFrame :: get => RigidBody is PhysxRigidBody physx ? new PhysicsMassFrame(physx.CMassLocalPose.Item2, physx.CMassLocalPose.Item1) : _centerOfMassPose;
- L576 C63: new PhysicsSolverIterations :: get => RigidBody is PhysxDynamicRigidBody physx ? new PhysicsSolverIterations(physx.SolverIterationCounts.minPositionIters, physx.SolverIterationCounts.minVelocityIters) : _solverIterations;
- L742 C31: new PhysxDynamicRigidBody :: var created = new PhysxDynamicRigidBody(
- L754 C24: new PhysxDynamicRigidBody :: var body = new PhysxDynamicRigidBody(position, rotation);
- L767 C19: new LayerMask :: ? new LayerMask(1)
- L768 C19: new LayerMask :: : new LayerMask(1 << CollisionGroup);
- L789 C27: new PhysxMaterial :: var created = new PhysxMaterial(0.5f, 0.5f, 0.1f);


## XRENGINE/Scene/Components/Physics/GPUPhysicsChainComponent.cs
- L273 C48: new() :: private readonly object _pendingWorkLock = new();
- L289 C35: new XRRenderProgram :: _mainPhysicsProgram = new XRRenderProgram(true, false, _mainPhysicsShader);
- L290 C43: new XRRenderProgram :: _skipUpdateParticlesProgram = new XRRenderProgram(true, false, _skipUpdateParticlesShader);
- L293 C37: new RenderCommandMethod3D :: _gpuWorkRenderCommand = new RenderCommandMethod3D((int)EDefaultRenderPass.PreRender, ExecutePendingGPUWork);
- L646 C25: new List :: var particles = new List<Rendering.Compute.GPUPhysicsChainDispatcher.GPUParticleData>();
- L649 C27: new Rendering.Compute.GPUPhysicsChainDispatcher.GPUParticleData :: particles.Add(new Rendering.Compute.GPUPhysicsChainDispatcher.GPUParticleData
- L667 C21: new List :: var trees = new List<Rendering.Compute.GPUPhysicsChainDispatcher.GPUParticleTreeData>();
- L670 C23: new Rendering.Compute.GPUPhysicsChainDispatcher.GPUParticleTreeData :: trees.Add(new Rendering.Compute.GPUPhysicsChainDispatcher.GPUParticleTreeData
- L681 C25: new List :: var colliders = new List<Rendering.Compute.GPUPhysicsChainDispatcher.GPUColliderData>();
- L684 C27: new Rendering.Compute.GPUPhysicsChainDispatcher.GPUColliderData :: colliders.Add(new Rendering.Compute.GPUPhysicsChainDispatcher.GPUColliderData
- L856 C29: new ParticleData :: _readbackData = new ParticleData[_totalParticleCount];
- L885 C46: new Vector4 :: _mainPhysicsProgram.Uniform("Force", new Vector4(Force.X, Force.Y, Force.Z, 0));
- L886 C48: new Vector4 :: _mainPhysicsProgram.Uniform("Gravity", new Vector4(Gravity.X, Gravity.Y, Gravity.Z, 0));
- L887 C69: new Vector4 :: _mainPhysicsProgram.Uniform("ObjectMove", applyObjectMove ? new Vector4(_objectMove.X, _objectMove.Y, _objectMove.Z, 0) : Vector4.Zero);
- L910 C59: new Vector4 :: _skipUpdateParticlesProgram.Uniform("ObjectMove", new Vector4(_objectMove.X, _objectMove.Y, _objectMove.Z, 0));
- L931 C28: new XRDataBuffer :: _particlesBuffer = new XRDataBuffer("Particles", EBufferTarget.ShaderStorageBuffer, (uint)_particlesData.Count, EComponentType.Float, 16, false, false);
- L935 C32: new XRDataBuffer :: _particleTreesBuffer = new XRDataBuffer("ParticleTrees", EBufferTarget.ShaderStorageBuffer, (uint)_particleTreesData.Count, EComponentType.Float, 20, false, false);
- L939 C36: new XRDataBuffer :: _transformMatricesBuffer = new XRDataBuffer("TransformMatrices", EBufferTarget.ShaderStorageBuffer, (uint)_transformMatrices.Count, EComponentType.Float, 16, false, false);
- L943 C28: new XRDataBuffer :: _collidersBuffer = new XRDataBuffer("Colliders", EBufferTarget.ShaderStorageBuffer, (uint)Math.Max(_collidersData.Count, 1), EComponentType.Float, 16, false, false);
- L977 C28: new ParticleTreeData :: var treeData = new ParticleTreeData
- L993 C36: new ParticleData :: var particleData = new ParticleData
- L1029 C36: new ColliderData :: _collidersData.Add(new ColliderData
- L1031 C30: new Vector4 :: Center = new Vector4(
- L1040 C72: new Vector3 :: Vector3 end = capsuleCollider.Transform.TransformPoint(new Vector3(0, capsuleCollider.Height, 0));
- L1042 C36: new ColliderData :: _collidersData.Add(new ColliderData
- L1044 C30: new Vector4 :: Center = new Vector4(start, capsuleCollider.Radius),
- L1045 C30: new Vector4 :: Params = new Vector4(end, 0),
- L1051 C36: new ColliderData :: _collidersData.Add(new ColliderData
- L1053 C30: new Vector4 :: Center = new Vector4(boxCollider.Transform.WorldTranslation, 0),
- L1054 C30: new Vector4 :: Params = new Vector4(boxCollider.Size * 0.5f, 0),
- L1062 C36: new ColliderData :: _collidersData.Add(new ColliderData
- L1064 C30: new Vector4 :: Center = new Vector4(planeCollider.Transform.TransformPoint(planeCollider._center), 0),
- L1065 C30: new Vector4 :: Params = new Vector4(planeCollider._plane.Normal, planeCollider._bound == PhysicsChainColliderBase.EBound.Inside ? 1.0f : 0.0f),
- L1178 C28: new ParticleTree :: _particleTrees.Add(new ParticleTree(root));
- L1183 C20: new Particle :: var ptcl = new Particle(tfm, parentIndex);
- L1201 C27: new Vector3 :: : new Vector3(EndLength, 0.0f, 0.0f);
- L1297 C21: new List :: var roots = new List<Transform>();


## XRENGINE/Scene/Components/Physics/Joints/D6JointComponent.cs
- L452 C29: new JointAngularLimitPair :: d6.TwistLimit = new JointAngularLimitPair(
- L457 C29: new JointLimitCone :: d6.SwingLimit = new JointLimitCone(
- L462 C32: new JointLinearLimit :: d6.DistanceLimit = new JointLinearLimit(
- L467 C46: new JointLinearLimitPair :: d6.SetLinearLimit(JointD6Axis.X, new JointLinearLimitPair(_linearLimitXLower, _linearLimitXUpper));
- L468 C46: new JointLinearLimitPair :: d6.SetLinearLimit(JointD6Axis.Y, new JointLinearLimitPair(_linearLimitYLower, _linearLimitYUpper));
- L469 C46: new JointLinearLimitPair :: d6.SetLinearLimit(JointD6Axis.Z, new JointLinearLimitPair(_linearLimitZLower, _linearLimitZUpper));
- L493 C29: new JointAngularLimitPair :: d6.TwistLimit = new JointAngularLimitPair(
- L502 C29: new JointLimitCone :: d6.SwingLimit = new JointLimitCone(
- L511 C32: new JointLinearLimit :: d6.DistanceLimit = new JointLinearLimit(
- L522 C34: new JointLinearLimitPair :: JointD6Axis.X => new JointLinearLimitPair(_linearLimitXLower, _linearLimitXUpper),
- L523 C34: new JointLinearLimitPair :: JointD6Axis.Y => new JointLinearLimitPair(_linearLimitYLower, _linearLimitYUpper),
- L524 C34: new JointLinearLimitPair :: JointD6Axis.Z => new JointLinearLimitPair(_linearLimitZLower, _linearLimitZUpper),


## XRENGINE/Scene/Components/Physics/Joints/DistanceJointComponent.cs
- L141 C88: new ColorF4 :: Engine.Rendering.Debug.RenderSphere(anchorWorldA, _minDistance, false, new ColorF4(1f, 1f, 0f, 0.3f));
- L144 C88: new ColorF4 :: Engine.Rendering.Debug.RenderSphere(anchorWorldA, _maxDistance, false, new ColorF4(1f, 0.5f, 0f, 0.3f));


## XRENGINE/Scene/Components/Physics/Joints/HingeJointComponent.cs
- L206 C24: new JointAngularLimitPair :: hj.Limit = new JointAngularLimitPair(
- L222 C24: new JointAngularLimitPair :: hj.Limit = new JointAngularLimitPair(
- L235 C46: new Vector3 :: Vector3 axis = Vector3.Normalize(new Vector3(anchorWorld.M11, anchorWorld.M12, anchorWorld.M13));
- L236 C48: new Vector3 :: Vector3 refDir = Vector3.Normalize(new Vector3(anchorWorld.M21, anchorWorld.M22, anchorWorld.M23));


## XRENGINE/Scene/Components/Physics/Joints/PhysicsJointComponent.cs
- L40 C55: new RenderCommandMethod3D :: _gizmoRenderInfo = RenderInfo3D.New(this, new RenderCommandMethod3D((int)EDefaultRenderPass.OnTopForward, RenderJointGizmos));
- L265 C31: new JointAnchor :: var localFrameA = new JointAnchor(AnchorPosition, AnchorRotation);
- L271 C31: new JointAnchor :: localFrameB = new JointAnchor(ConnectedAnchorPosition, ConnectedAnchorRotation);
- L363 C28: new JointAnchor :: return new JointAnchor(pos, rot);
- L369 C20: new JointAnchor :: return new JointAnchor(worldPos, worldRot);
- L377 C40: new JointAnchor :: _nativeJoint.LocalFrameA = new JointAnchor(AnchorPosition, AnchorRotation);
- L380 C44: new JointAnchor :: _nativeJoint.LocalFrameB = new JointAnchor(ConnectedAnchorPosition, ConnectedAnchorRotation);
- L449 C47: new Vector3 :: Vector3 right = Vector3.Normalize(new Vector3(combinedRot.M11, combinedRot.M12, combinedRot.M13));
- L450 C44: new Vector3 :: Vector3 up = Vector3.Normalize(new Vector3(combinedRot.M21, combinedRot.M22, combinedRot.M23));
- L451 C49: new Vector3 :: Vector3 forward = Vector3.Normalize(new Vector3(combinedRot.M31, combinedRot.M32, combinedRot.M33));


## XRENGINE/Scene/Components/Physics/Joints/PrismaticJointComponent.cs
- L137 C24: new JointLinearLimitPair :: pj.Limit = new JointLinearLimitPair(
- L148 C24: new JointLinearLimitPair :: pj.Limit = new JointLinearLimitPair(
- L161 C46: new Vector3 :: Vector3 axis = Vector3.Normalize(new Vector3(anchorWorld.M11, anchorWorld.M12, anchorWorld.M13));


## XRENGINE/Scene/Components/Physics/Joints/SphericalJointComponent.cs
- L137 C28: new JointLimitCone :: sj.LimitCone = new JointLimitCone(
- L148 C28: new JointLimitCone :: sj.LimitCone = new JointLimitCone(
- L161 C46: new Vector3 :: Vector3 axis = Vector3.Normalize(new Vector3(anchorWorld.M11, anchorWorld.M12, anchorWorld.M13));
- L162 C44: new Vector3 :: Vector3 up = Vector3.Normalize(new Vector3(anchorWorld.M21, anchorWorld.M22, anchorWorld.M23));
- L163 C47: new Vector3 :: Vector3 right = Vector3.Normalize(new Vector3(anchorWorld.M31, anchorWorld.M32, anchorWorld.M33));
- L168 C30: new Vector3 :: Vector3[] ring = new Vector3[segments + 1];
- L184 C69: new ColorF4 :: Engine.Rendering.Debug.RenderLine(tip, ring[i], new ColorF4(1f, 1f, 0f, 0.5f));


## XRENGINE/Scene/Components/Physics/PhysicsActorComponent.cs
- L16 C109: new() :: private readonly Dictionary<CoACD.CoACDParameters, List<CoACD.ConvexHullMesh>> _cachedConvexHulls = new();
- L17 C156: new() :: private readonly Dictionary<(CoACD.CoACDParameters parameters, PxConvexFlags flags, bool requestGpuData), List<PhysxConvexMesh>> _physxMeshCache = new();
- L43 C78: new CoAcdRunner :: private static readonly IConvexDecompositionRunner s_defaultRunner = new CoAcdRunner();
- L64 C27: new List :: var results = new List<CoACD.ConvexHullMesh>();
- L70 C34: new ConvexHullGenerationProgress :: progress?.Report(new ConvexHullGenerationProgress(0, 0, "No collision meshes available."));
- L74 C30: new ConvexHullGenerationProgress :: progress?.Report(new ConvexHullGenerationProgress(0, totalInputs, "Starting convex decomposition."));
- L81 C34: new ConvexHullGenerationProgress :: progress?.Report(new ConvexHullGenerationProgress(i, totalInputs, $"Decomposing mesh {i + 1} of {totalInputs}..."));
- L90 C34: new ConvexHullGenerationProgress :: progress?.Report(new ConvexHullGenerationProgress(i + 1, totalInputs, $"Completed mesh {i + 1} of {totalInputs}."));
- L97 C34: new ConvexHullGenerationProgress :: progress?.Report(new ConvexHullGenerationProgress(totalInputs, totalInputs, "Convex hulls cached."));
- L101 C34: new ConvexHullGenerationProgress :: progress?.Report(new ConvexHullGenerationProgress(totalInputs, totalInputs, "No convex hulls generated."));


## XRENGINE/Scene/Components/Physics/PhysicsChainCollider.cs
- L27 C36: new RenderCommandMethod3D :: RenderInfo3D.New(this, new RenderCommandMethod3D((int)EDefaultRenderPass.OpaqueForward, RenderGizmos))


## XRENGINE/Scene/Components/Physics/PhysicsChainComponent Fields.cs
- L130 C36: new RenderCommandMethod3D :: RenderInfo3D.New(this, new RenderCommandMethod3D((int)EDefaultRenderPass.OpaqueForward, Render))


## XRENGINE/Scene/Components/Physics/PhysicsChainComponent.cs
- L272 C21: new List :: var roots = new List<Transform>();
- L453 C28: new ParticleTree :: _particleTrees.Add(new ParticleTree(root));
- L458 C20: new Particle :: var ptcl = new Particle(tfm, parentIndex);
- L483 C27: new Vector3 :: : new Vector3(EndLength, 0.0f, 0.0f);
- L931 C30: new AutoResetEvent :: _allWorksDoneEvent = new AutoResetEvent(false);
- L932 C31: new Semaphore :: _workQueueSemaphore = new Semaphore(0, int.MaxValue);
- L938 C21: new Thread :: var t = new Thread(ThreadProc)


## XRENGINE/Scene/Components/Physics/PhysicsChainPlaneCollider.cs
- L20 C49: new RenderCommandMethod3D :: var renderInfo = RenderInfo3D.New(this, new RenderCommandMethod3D((int)EDefaultRenderPass.OpaqueForward, OnDrawGizmosSelected));


## XRENGINE/Scene/Components/Physics/PhysxHeightFieldComponent.cs
- L21 C23: new PhysxHeightField :: HeightField = new PhysxHeightField(imagePath);
- L62 C19: new PhysxMaterial :: var mat = new PhysxMaterial(0.5f, 0.5f, 0.1f);
- L64 C40: new PhysxDynamicRigidBody :: RigidBodyComponent.RigidBody = new PhysxDynamicRigidBody(mat, hf, 1.0f);


## XRENGINE/Scene/Components/Physics/StaticRigidBodyComponent.cs
- L294 C31: new PhysxStaticRigidBody :: var created = new PhysxStaticRigidBody(
- L305 C24: new PhysxStaticRigidBody :: var body = new PhysxStaticRigidBody(position, rotation);
- L318 C19: new LayerMask :: ? new LayerMask(1)
- L319 C19: new LayerMask :: : new LayerMask(1 << CollisionGroup);
- L340 C27: new PhysxMaterial :: var created = new PhysxMaterial(0.5f, 0.5f, 0.1f);


## XRENGINE/Scene/Components/Scripting/GameCSProjLoader.cs
- L42 C56: new WeakReference :: _loadedAssemblies[id] = (source, assembly, new WeakReference<AssemblyLoadContext>(context), new AssemblyData(components, menuItems));
- L42 C105: new AssemblyData :: _loadedAssemblies[id] = (source, assembly, new WeakReference<AssemblyLoadContext>(context), new AssemblyData(components, menuItems));
- L43 C42: new AssemblyData :: OnAssemblyLoaded?.Invoke(id, new AssemblyData(components, menuItems));
- L54 C47: new DynamicEngineAssemblyLoadContext :: AssemblyLoadContext context = new DynamicEngineAssemblyLoadContext();
- L90 C47: new DynamicEngineAssemblyLoadContext :: AssemblyLoadContext context = new DynamicEngineAssemblyLoadContext();
- L93 C45: new MemoryStream :: using (var assemblyStream = new MemoryStream(assemblyBytes))
- L97 C47: new MemoryStream :: using var pdbStream = new MemoryStream(pdbBytes);


## XRENGINE/Scene/Components/Splines/Spline3DPreviewComponent.cs
- L34 C53: new AABB :: RenderInfo.LocalCullingVolume = new AABB(Vector3.Zero, Vector3.Zero);
- L185 C43: new Vector3 :: Vector3[] keyframePositions = new Vector3[kfCount];
- L186 C42: new VertexLine :: VertexLine[] keyframeLines = new VertexLine[kfCount];
- L187 C42: new Vector3 :: Vector3[] tangentPositions = new Vector3[kfCount];
- L225 C36: new VertexLine :: keyframeLines[i] = new VertexLine(p0, p1);
- L230 C36: new VertexLine :: keyframeLines[i] = new VertexLine(p0, p1);
- L239 C36: new VertexLine :: keyframeLines[i] = new VertexLine(p0, p1);
- L249 C33: new Vector3 :: Vector3[] extrema = new Vector3[6];
- L265 C23: new AABB :: var box = new AABB(minVal, maxVal);
- L269 C37: new() :: RenderingParameters p = new()
- L276 C34: new XRShader :: XRMaterial mat = new(new XRShader(EShaderType.Fragment,
- L291 C32: new XRMeshRenderer :: _splinePrimitive = new XRMeshRenderer(splineData, mat);
- L296 C42: new XRMeshRenderer :: _velocityTangentsPrimitive = new XRMeshRenderer(velocityData, mat);
- L301 C31: new XRMeshRenderer :: _pointPrimitive = new XRMeshRenderer(pointData, mat);
- L306 C33: new XRMeshRenderer :: _extremaPrimitive = new XRMeshRenderer(extremaData, mat);
- L311 C33: new XRMeshRenderer :: _tangentPrimitive = new XRMeshRenderer(tangentData, mat);
- L316 C39: new XRMeshRenderer :: _keyframeLinesPrimitive = new XRMeshRenderer(kfLineData, mat);
- L321 C35: new XRMeshRenderer :: _timePointPrimitive = new XRMeshRenderer(timePointData, mat);
- L341 C40: new Vector4 :: (pos.ColorSets ??= []).Add(new Vector4(Vector3.Lerp(Vector3.UnitZ, Vector3.UnitX, t), 1.0f));
- L343 C26: new VertexLine :: velocity.Add(new VertexLine(pos, new Vertex(pos.Position + vel.Normalized() * velocityScale)));
- L343 C46: new Vertex :: velocity.Add(new VertexLine(pos, new Vertex(pos.Position + vel.Normalized() * velocityScale)));


## XRENGINE/Scene/Components/UI/Core/Arrangements/UIGridTransform.cs
- L136 C24: new List :: _indices = new List<int>[Rows.Count, Columns.Count];
- L304 C63: new BoundingRectangleF :: UILayoutSystem.FitLayout(uiBoundable, new BoundingRectangleF(x, y, width, height));
- L481 C42: new BoundingRectangleF :: uiComp.FitLayout(new BoundingRectangleF(x, y, width, height));
- L525 C33: new UIGridChildPlacementInfo :: placementInfo = new UIGridChildPlacementInfo(childTransform);
- L533 C48: new UIGridChildPlacementInfo :: uic.PlacementInfo = info = new UIGridChildPlacementInfo(uic);


## XRENGINE/Scene/Components/UI/Core/Arrangements/UIGridTransform.UIGridChildPlacementInfo.cs
- L41 C23: new NotImplementedException :: throw new NotImplementedException();


## XRENGINE/Scene/Components/UI/Core/Arrangements/UIListTransform.cs
- L346 C28: new BoundingRectangleF :: bc.Arrange(new BoundingRectangleF(x, y, size, parentHeight));
- L361 C28: new BoundingRectangleF :: bc.Arrange(new BoundingRectangleF(x, y, parentWidth, size));
- L405 C34: new BoundingRectangleF :: bc.FitLayout(new BoundingRectangleF(x, y, size, parentHeight));
- L416 C34: new BoundingRectangleF :: bc.FitLayout(new BoundingRectangleF(x, y, parentWidth, size));
- L429 C29: new float :: float[] sizes = new float[Children.Count];
- L532 C34: new BoundingRectangleF :: bc.FitLayout(new BoundingRectangleF(x, y, size, parentHeight));
- L537 C30: new BoundingRectangleF :: bc.FitLayout(new BoundingRectangleF(x, y, size, parentHeight));
- L552 C34: new BoundingRectangleF :: bc.FitLayout(new BoundingRectangleF(x, y, parentWidth, size));
- L557 C30: new BoundingRectangleF :: bc.FitLayout(new BoundingRectangleF(x, y, parentWidth, size));
- L571 C33: new UIListChildPlacementInfo :: placementInfo = new UIListChildPlacementInfo(childTransform);


## XRENGINE/Scene/Components/UI/Core/Arrangements/UISizingDefinition.cs
- L7 C40: new() :: private UISizingValue _value = new();


## XRENGINE/Scene/Components/UI/Core/Interactable/UIPropertyTextDriverComponent.cs
- L33 C22: new GameTimer :: _timer = new GameTimer(this);


## XRENGINE/Scene/Components/UI/Core/Transforms/UIBoundableTransform.cs
- L34 C41: new() :: protected Vector2 _actualSize = new();
- L132 C38: new Vector2 :: set => NormalizedPivot = new Vector2(ActualWidth.IsZero() ? 0.0f : value / ActualWidth, NormalizedPivot.Y);
- L137 C38: new Vector2 :: set => NormalizedPivot = new Vector2(NormalizedPivot.X, ActualHeight.IsZero() ? 0.0f : value / ActualHeight);
- L217 C57: new Vector3 :: Matrix4x4 mtx = Matrix4x4.CreateTranslation(new Vector3(ActualLocalBottomLeftTranslation, DepthTranslation));
- L227 C49: new Vector3 :: Matrix4x4.CreateTranslation(new Vector3(LocalPivotTranslation, 0.0f)) *
- L230 C49: new Vector3 :: Matrix4x4.CreateTranslation(new Vector3(-LocalPivotTranslation, 0.0f));
- L532 C20: new Vector2 :: pos += new Vector2(left, bottom);
- L533 C21: new Vector2 :: size -= new Vector2(left + right, bottom + top);
- L534 C22: new BoundingRectangleF :: bounds = new BoundingRectangleF(pos, size);
- L552 C20: new Vector2 :: pos += new Vector2(left, bottom);
- L553 C21: new Vector2 :: size -= new Vector2(left + right, bottom + top);
- L554 C22: new BoundingRectangleF :: bounds = new BoundingRectangleF(pos, size);
- L597 C17: new Vector3 :: new Vector3(region.TopLeft, 0.0f) + Engine.Rendering.Debug.UIPositionBias,
- L598 C17: new Vector3 :: new Vector3(region.TopRight, 0.0f) + Engine.Rendering.Debug.UIPositionBias,
- L602 C17: new Vector3 :: new Vector3(region.TopRight, 0.0f) + Engine.Rendering.Debug.UIPositionBias,
- L603 C17: new Vector3 :: new Vector3(region.BottomRight, 0.0f) + Engine.Rendering.Debug.UIPositionBias,
- L607 C17: new Vector3 :: new Vector3(region.BottomRight, 0.0f) + Engine.Rendering.Debug.UIPositionBias,
- L608 C17: new Vector3 :: new Vector3(region.BottomLeft, 0.0f) + Engine.Rendering.Debug.UIPositionBias,
- L612 C17: new Vector3 :: new Vector3(region.BottomLeft, 0.0f) + Engine.Rendering.Debug.UIPositionBias,
- L613 C17: new Vector3 :: new Vector3(region.TopLeft, 0.0f) + Engine.Rendering.Debug.UIPositionBias,
- L626 C48: new Vector3 :: Vector3 maxPos = Vector3.Transform(new Vector3(Vector2.One, 0.0f), mtx);
- L730 C34: new Vector3 :: => Vector3.Transform(new Vector3(worldPoint, worldZ), InverseWorldMatrix);
- L732 C34: new Vector3 :: => Vector3.Transform(new Vector3(localPoint, worldZ), WorldMatrix);
- L743 C25: new Vector2 :: MinAnchor = new Vector2(0.0f, 0.0f);
- L744 C25: new Vector2 :: MaxAnchor = new Vector2(1.0f, 1.0f);
- L769 C73: new Vector3 :: renderInfo3D.LocalCullingVolume = AABB.FromSize(new Vector3(w, h, 0.1f));


## XRENGINE/Scene/Components/UI/Core/Transforms/UICanvasTransform.cs
- L167 C34: new Vector2 :: => new(Vector2.Zero, new Vector2(GetWidth(), GetHeight()));


## XRENGINE/Scene/Components/UI/Core/Transforms/UIDockingRootTransform.cs
- L61 C37: new Vector2 :: tfm.MaxAnchor = new Vector2(1.0f, 1.0f);
- L62 C37: new Vector2 :: tfm.MinAnchor = new Vector2(0.0f, 0.0f);
- L67 C36: new Vector2 :: aInfo.BottomLeft = new Vector2(LeftSizeWidth, BottomSizeHeight);
- L69 C50: new BoundingRectangleF :: UILayoutSystem.FitLayout(Center, new BoundingRectangleF(paddedRegion.X + LeftSizeWidth, paddedRegion.Y + BottomSizeHeight, paddedRegion.Width - LeftSizeWidth - RightSizeWidth, paddedRegion.Height));
- L72 C36: new Vector2 :: bInfo.BottomLeft = new Vector2(0.0f, BottomSizeHeight);
- L74 C48: new BoundingRectangleF :: UILayoutSystem.FitLayout(Left, new BoundingRectangleF(paddedRegion.X, paddedRegion.Y + BottomSizeHeight, LeftSizeWidth, paddedRegion.Height));
- L77 C36: new Vector2 :: cInfo.BottomLeft = new Vector2(paddedRegion.Width - RightSizeWidth, BottomSizeHeight);
- L79 C49: new BoundingRectangleF :: UILayoutSystem.FitLayout(Right, new BoundingRectangleF(paddedRegion.X + paddedRegion.Width - RightSizeWidth, paddedRegion.Y, RightSizeWidth, paddedRegion.Height));
- L82 C36: new Vector2 :: dInfo.BottomLeft = new Vector2(0.0f, paddedRegion.Height - BottomSizeHeight);
- L84 C50: new BoundingRectangleF :: UILayoutSystem.FitLayout(Bottom, new BoundingRectangleF(paddedRegion.X, paddedRegion.Y + paddedRegion.Height - BottomSizeHeight, paddedRegion.Width, BottomSizeHeight));
- L100 C37: new Vector2 :: tfm.MaxAnchor = new Vector2(1.0f, 1.0f);
- L101 C37: new Vector2 :: tfm.MinAnchor = new Vector2(0.0f, 0.0f);
- L110 C36: new Vector2 :: aInfo.BottomLeft = new Vector2(LeftSizeWidth, BottomSizeHeight);
- L111 C31: new BoundingRectangleF :: Center?.FitLayout(new BoundingRectangleF(parentRegion.X + LeftSizeWidth, parentRegion.Y + BottomSizeHeight, parentRegion.Width - LeftSizeWidth - RightSizeWidth, parentRegion.Height));
- L114 C36: new Vector2 :: bInfo.BottomLeft = new Vector2(0.0f, BottomSizeHeight);
- L115 C29: new BoundingRectangleF :: Left?.FitLayout(new BoundingRectangleF(parentRegion.X, parentRegion.Y + BottomSizeHeight, LeftSizeWidth, parentRegion.Height));
- L118 C36: new Vector2 :: cInfo.BottomLeft = new Vector2(parentRegion.Width - RightSizeWidth, BottomSizeHeight);
- L119 C30: new BoundingRectangleF :: Right?.FitLayout(new BoundingRectangleF(parentRegion.X + parentRegion.Width - RightSizeWidth, parentRegion.Y, RightSizeWidth, parentRegion.Height));
- L122 C36: new Vector2 :: dInfo.BottomLeft = new Vector2(0.0f, parentRegion.Height - BottomSizeHeight);
- L123 C31: new BoundingRectangleF :: Bottom?.FitLayout(new BoundingRectangleF(parentRegion.X, parentRegion.Y + parentRegion.Height - BottomSizeHeight, parentRegion.Width, BottomSizeHeight));
- L129 C33: new UIDockingPlacementInfo :: placementInfo = new UIDockingPlacementInfo(this);
- L153 C33: new Vector2 :: tfm.MaxAnchor = new Vector2(1.0f, 1.0f);
- L154 C33: new Vector2 :: tfm.MinAnchor = new Vector2(0.0f, 0.0f);


## XRENGINE/Scene/Components/UI/Core/Transforms/UIDualSplitTransform.cs
- L262 C33: new UISplitChildPlacementInfo :: placementInfo = new UISplitChildPlacementInfo(childTransform);


## XRENGINE/Scene/Components/UI/Core/Transforms/UILayoutSystem.cs
- L240 C27: new Vector2 :: desiredSize = new Vector2(
- L567 C20: new Vector2 :: pos += new Vector2(left, bottom);
- L568 C21: new Vector2 :: size -= new Vector2(left + right, bottom + top);
- L569 C20: new BoundingRectangleF :: return new BoundingRectangleF(pos, size);
- L586 C20: new Vector2 :: pos += new Vector2(left, bottom);
- L587 C21: new Vector2 :: size -= new Vector2(left + right, bottom + top);
- L588 C20: new BoundingRectangleF :: return new BoundingRectangleF(pos, size);
- L611 C27: new LayoutCounter :: var counter = new LayoutCounter();


## XRENGINE/Scene/Components/UI/Core/Transforms/UIMultiSplitTransform.cs
- L479 C33: new UISplitChildPlacementInfo :: placementInfo = new UISplitChildPlacementInfo(childTransform);


## XRENGINE/Scene/Components/UI/Core/Transforms/UIScrollableTransform.cs
- L88 C48: new Vector3 :: => Matrix4x4.CreateTranslation(new Vector3(BottomLeftOffset, 0.0f));


## XRENGINE/Scene/Components/UI/Core/Transforms/UITransform.cs
- L81 C63: new() :: protected Vector2 _actualLocalBottomLeftTranslation = new();
- L199 C18: new void :: internal new void MarkLocalModified(bool deferred = false) => base.MarkLocalModified(deferred);
- L200 C18: new void :: internal new void MarkLocalModified() => base.MarkLocalModified();
- L224 C71: new RenderCommandMethod2D :: => [DebugRenderInfo2D = RenderInfo2D.New(this, _debugRC = new RenderCommandMethod2D((int)EDefaultRenderPass.OnTopForward, RenderDebug))];
- L229 C41: new Vector3 :: Matrix4x4.CreateTranslation(new Vector3(Translation, DepthTranslation));
- L244 C40: new Vector2 :: Vector2 newScale = scale - new Vector2(delta);
- L267 C48: new Vector2 :: Translation += (worldScreenPoint - new Vector2(WorldTranslation.X, WorldTranslation.Y)) * Vector2.One / scale * delta;
- L268 C21: new Vector3 :: Scale = new Vector3(newScale, Scale.Z);
- L460 C49: new Vector2 :: return Vector2.Distance(worldPoint, new Vector2(worldTranslation.X, worldTranslation.Y)) < 0.0001f;
- L465 C20: new Vector2 :: return new Vector2(worldTranslation.X, worldTranslation.Y);


## XRENGINE/Scene/Components/UI/Core/UIMaterialComponent.cs
- L72 C20: new XRMeshRenderer :: Mesh = new XRMeshRenderer(XRMesh.Create(VertexQuad.PosZ(1.0f, true, 0.0f, FlipVerticalUVCoord)), material);
- L75 C66: new() :: private readonly RenderingParameters _renderParameters = new()
- L78 C25: new() :: DepthTest = new()
- L133 C46: new Vector4 :: var color = colorParam?.Value ?? new Vector4(1.0f, 0.0f, 1.0f, 1.0f);
- L136 C26: new Vector4 :: var bounds = new Vector4(bottomLeft.X, bottomLeft.Y, tfm.ActualWidth, tfm.ActualHeight);


## XRENGINE/Scene/Components/UI/Core/UIRenderableComponent.cs
- L197 C63: new RenderCommandMesh3D :: public RenderCommandMesh3D RenderCommand3D { get; } = new RenderCommandMesh3D(EDefaultRenderPass.OpaqueForward);
- L198 C63: new RenderCommandMesh2D :: public RenderCommandMesh2D RenderCommand2D { get; } = new RenderCommandMesh2D((int)EDefaultRenderPass.OpaqueForward);
- L257 C26: new Vector4 :: var bounds = new Vector4(x, y, w, h);


## XRENGINE/Scene/Components/UI/Core/UIVideoComponent.Audio.cs
- L437 C21: new short :: pcm16 = new short[inputFrameCount * outputChannels];
- L462 C27: new short :: short[] src = new short[raw.Length / sizeof(short)];
- L478 C25: new int :: int[] src = new int[raw.Length / sizeof(int)];
- L494 C27: new float :: float[] src = new float[raw.Length / sizeof(float)];
- L510 C28: new double :: double[] src = new double[raw.Length / sizeof(double)];


## XRENGINE/Scene/Components/UI/Core/UIVideoComponent.cs
- L276 C23: new ArgumentNullException :: throw new ArgumentNullException(nameof(variant));
- L391 C62: new() :: private readonly Queue<int> _submittedSampleCounts = new();
- L516 C27: new XRTexture2D :: var texture = new XRTexture2D(1u, 1u,
- L527 C20: new XRMaterial :: return new XRMaterial([texture], XRShader.EngineShader(Path.Combine("Common", "UnlitTexturedForward.fs"), EShaderType.Fragment));


## XRENGINE/Scene/Components/UI/Core/UIVideoComponent.FrameDrain.cs
- L454 C31: new IVector2 :: WidthHeight = new IVector2(frame.Width, frame.Height);


## XRENGINE/Scene/Components/UI/Core/UIVideoComponent.Pipeline.cs
- L119 C61: new StreamOpenOptions :: _streamingOpenOptions = resolved.OpenOptions ?? new StreamOpenOptions();
- L169 C37: new StreamOpenOptions :: _streamingOpenOptions = new StreamOpenOptions();


## XRENGINE/Scene/Components/UI/Core/UIViewportComponent.cs
- L25 C20: new XRMaterialFrameBuffer :: _fbo = new XRMaterialFrameBuffer(Material);
- L43 C60: new XRViewport :: public XRViewport Viewport { get; private set; } = new XRViewport(null, 1, 1);


## XRENGINE/Scene/Components/UI/Core/UIWebViewComponent.cs
- L83 C48: new NullWebRendererBackend :: private IWebRendererBackend _backend = new NullWebRendererBackend();
- L98 C52: new Mipmap2D :: private readonly Mipmap2D[] _mipmapArray = new Mipmap2D[1];
- L123 C52: new NullWebRendererBackend :: set => SetField(ref _backend, value ?? new NullWebRendererBackend());
- L135 C20: new XRMaterialFrameBuffer :: _fbo = new XRMaterialFrameBuffer(Material);
- L148 C20: new XRMaterial :: return new XRMaterial(
- L370 C32: new UltralightWebRendererBackend :: _backend = new UltralightWebRendererBackend();
- L390 C33: new Mipmap2D :: _cachedMipmap = new Mipmap2D(
- L418 C35: new DataSource :: _cachedDataSource ??= new DataSource(frame.PixelDataPtr, (uint)frame.ByteLength, copyInternal: false);
- L436 C55: new XRDataBuffer :: _pboBuffers[_currentPboIndex] = pbo = new XRDataBuffer(


## XRENGINE/Scene/Components/UI/Core/UltralightGpuWebRendererBackend.cs
- L43 C78: new() :: private readonly ConcurrentQueue<Action<View>> _pendingInputEvents = new();
- L66 C23: new ULConfig :: _config = new ULConfig
- L74 C27: new ULConfig :: _config = new ULConfig
- L89 C27: new ULViewConfig :: _viewConfig = new ULViewConfig
- L254 C63: new ULMouseEvent :: _pendingInputEvents.Enqueue(v => v.FireMouseEvent(new ULMouseEvent
- L274 C34: new ULMouseEvent :: v.FireMouseEvent(new ULMouseEvent
- L289 C64: new ULScrollEvent :: _pendingInputEvents.Enqueue(v => v.FireScrollEvent(new ULScrollEvent
- L386 C23: new InvalidOperationException :: throw new InvalidOperationException("Cannot initialize GPU driver without an OpenGL context.");
- L388 C26: new OpenGLGPUDriver :: _gpuDriver = new OpenGLGPUDriver(_cachedGL);
- L400 C38: new[] :: foreach (string start in new[] { AppContext.BaseDirectory, Environment.CurrentDirectory })


## XRENGINE/Scene/Components/UI/Core/UltralightWebRendererBackend.cs
- L32 C78: new() :: private readonly ConcurrentQueue<Action<View>> _pendingInputEvents = new();
- L44 C23: new ULConfig :: _config = new ULConfig
- L52 C27: new ULConfig :: _config = new ULConfig
- L67 C27: new ULViewConfig :: _viewConfig = new ULViewConfig
- L137 C26: new WebFrame :: _lastFrame = new WebFrame(
- L172 C63: new ULMouseEvent :: _pendingInputEvents.Enqueue(v => v.FireMouseEvent(new ULMouseEvent
- L192 C34: new ULMouseEvent :: v.FireMouseEvent(new ULMouseEvent
- L207 C64: new ULScrollEvent :: _pendingInputEvents.Enqueue(v => v.FireScrollEvent(new ULScrollEvent
- L302 C38: new[] :: foreach (string start in new[] { AppContext.BaseDirectory, Environment.CurrentDirectory })


## XRENGINE/Scene/Components/UI/DearImGuiComponent.cs
- L30 C34: new RenderCommandMethod2D :: _renderCommand = new RenderCommandMethod2D((int)EDefaultRenderPass.OnTopForward, RenderImGui))


## XRENGINE/Scene/Components/UI/Interactable/MenuComponent.cs
- L34 C29: new Vector3 :: => Show(canvas, new Vector3(worldPosition, z));
- L69 C55: new MenuDivider :: public static MenuDivider Instance { get; } = new MenuDivider();


## XRENGINE/Scene/Components/UI/Interactable/UIContextMenuComponent.cs
- L55 C54: new() :: public static ContextMenuItem Separator() => new();
- L119 C35: new Vector2 :: tfm.NormalizedPivot = new Vector2(0.0f, 1.0f); // top-left pivot
- L175 C31: new Vector4 :: listTfm.Padding = new Vector4(0.0f);
- L201 C35: new Vector2 :: buttonTfm.MinAnchor = new Vector2(0.0f, 0.0f);
- L202 C35: new Vector2 :: buttonTfm.MaxAnchor = new Vector2(1.0f, 0.0f);
- L204 C33: new Vector4 :: buttonTfm.Margins = new Vector4(0.0f);
- L232 C48: new Vector4 :: label.BoundableTransform.Margins = new Vector4(ItemPadding, 0.0f, ItemPadding, 0.0f);
- L239 C32: new Vector2 :: sepTfm.MinAnchor = new Vector2(0.0f, 0.0f);
- L240 C32: new Vector2 :: sepTfm.MaxAnchor = new Vector2(1.0f, 0.0f);
- L242 C30: new Vector4 :: sepTfm.Margins = new Vector4(0.0f);
- L247 C33: new Vector2 :: lineTfm.MinAnchor = new Vector2(0.0f, 0.5f);
- L248 C33: new Vector2 :: lineTfm.MaxAnchor = new Vector2(1.0f, 0.5f);
- L250 C31: new Vector4 :: lineTfm.Margins = new Vector4(ItemPadding, 0.0f, ItemPadding, 0.0f);


## XRENGINE/Scene/Components/UI/Rive/BoolInput.cs
- L14 C43: new value :: Apply(); // Apply the new value to the state machine.


## XRENGINE/Scene/Components/UI/Rive/NumberInput.cs
- L14 C43: new value :: Apply(); // Apply the new value to the state machine.


## XRENGINE/Scene/Components/UI/Rive/RiveUIComponent.cs
- L73 C35: new CancellationTokenSource :: _activeSourceFileLoader = new CancellationTokenSource();
- L114 C31: new DllNotFoundException :: ReportMissingRive(new DllNotFoundException("rive.dll could not be located."));
- L120 C22: new RiveSharp.Scene :: _scene = new RiveSharp.Scene();
- L190 C59: new() :: readonly ConcurrentQueue<Action> _sceneActionsQueue = new();
- L202 C32: new WeakReference :: => input.SetRivePlayer(new WeakReference<RiveUIComponent?>(this));
- L204 C32: new WeakReference :: => input.SetRivePlayer(new WeakReference<RiveUIComponent?>(null));
- L213 C41: new RenderCommandMethod3D :: RenderInfo3D.RenderCommands.Add(new RenderCommandMethod3D((int)EDefaultRenderPass.PreRender, RenderFBO));
- L231 C40: new() :: private readonly Lock _deltaLock = new();
- L269 C32: new HttpClient :: using var client = new HttpClient();
- L373 C17: new RiveSharp.AABB :: new RiveSharp.AABB(0, 0, (float)viewSize.X, (float)viewSize.Y),
- L374 C17: new RiveSharp.AABB :: new RiveSharp.AABB(0, 0, scene.Width, scene.Height));
- L376 C42: new Vec2D :: handler(scene, inverse * new Vec2D(pointerPos.X, pointerPos.Y));
- L471 C25: new Renderer :: _renderer = new Renderer(_surface.Canvas);
- L474 C16: new SKAutoCanvasRestore :: using (new SKAutoCanvasRestore(_surface.Canvas, doSave: true))
- L513 C25: new GRBackendRenderTarget :: _renderTarget = new GRBackendRenderTarget(
- L531 C16: new GRGlFramebufferInfo :: return new GRGlFramebufferInfo(bindingID, SKColorType.Rgba8888.ToGlSizedFormat());
- L601 C39: new DepthTest :: mat.RenderOptions.DepthTest = new DepthTest
- L641 C13: new RiveSharp.AABB :: new RiveSharp.AABB(0, 0, (float)width, (float)height),
- L642 C13: new RiveSharp.AABB :: new RiveSharp.AABB(0, 0, scene.Width, scene.Height));
- L658 C79: new RiveSharp.AABB :: : Renderer.ComputeAlignment(Fit.Contain, Alignment.Center, frame, new RiveSharp.AABB(0, 0, scene.Width, scene.Height));


## XRENGINE/Scene/Components/UI/Text/UIText.cs
- L97 C46: new() :: private readonly object _glyphLock = new();
- L276 C24: new XRMeshRenderer :: var rend = new XRMeshRenderer(
- L285 C57: new() :: private RenderingParameters _renderParameters = new()
- L288 C25: new() :: DepthTest = new()
- L326 C45: new() :: private readonly Lock _matrixLock = new();
- L354 C25: new ShaderVector4 :: return new([new ShaderVector4(Color, TextColorUniformName)], [atlas], new XRShader[] { vertexShader, stereoVertexShader }.Concat(nonVertexShaders))
- L354 C83: new XRShader :: return new([new ShaderVector4(Color, TextColorUniformName)], [atlas], new XRShader[] { vertexShader, stereoVertexShader }.Concat(nonVertexShaders))


## XRENGINE/Scene/Components/UI/Text/UITextComponent.cs
- L63 C44: new() :: private readonly Lock _glyphLock = new();
- L177 C57: new() :: private RenderingParameters _renderParameters = new()
- L180 C25: new() :: DepthTest = new()
- L462 C24: new XRMeshRenderer :: var rend = new XRMeshRenderer(
- L481 C25: new ShaderVector4 :: return new([new ShaderVector4(Color, TextColorUniformName)], [atlas], new XRShader[] { vertexShader, stereoVertexShader }.Concat(nonVertexShaders))
- L481 C83: new XRShader :: return new([new ShaderVector4(Color, TextColorUniformName)], [atlas], new XRShader[] { vertexShader, stereoVertexShader }.Concat(nonVertexShaders))
- L717 C29: new Vector4 :: var textColor = new Vector4(Color.R, Color.G, Color.B, Color.A);
- L719 C26: new Vector4 :: var bounds = new Vector4(bottomLeft.X, bottomLeft.Y, tfm.ActualWidth, tfm.ActualHeight);


## XRENGINE/Scene/Components/UI/UISvgComponent.cs
- L47 C49: new() :: private static readonly object _cacheLock = new();
- L48 C88: new SvgCacheKeyComparer :: private static readonly Dictionary<SvgCacheKey, SvgCacheEntry> _textureCache = new(new SvgCacheKeyComparer());
- L167 C31: new() :: using SKSvg svg = new();
- L170 C36: new MemoryStream :: using var stream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(SvgData));
- L221 C34: new SvgCacheEntry :: _textureCache[key] = new SvgCacheEntry(texture);
- L314 C46: new Vector2 :: Vector2 size = RasterSizeOverride ?? new Vector2(BoundableTransform.ActualWidth, BoundableTransform.ActualHeight);
- L331 C16: new SKSizeI :: return new SKSizeI((int)MathF.Max(1.0f, MathF.Round(width)), (int)MathF.Max(1.0f, MathF.Round(height)));
- L373 C71: new() :: private static RenderingParameters SvgRenderParameters { get; } = new()
- L376 C21: new() :: DepthTest = new()


## XRENGINE/Scene/Components/Volumes/Blocking.cs
- L16 C20: new Vector3 :: : this(new Vector3(0.5f), 0, 0) { }
- L19 C24: new IPhysicsGeometry.Box :: Geometry = new IPhysicsGeometry.Box(halfExtents);
- L21 C26: new PhysicsGroupsMask :: GroupsMask = new PhysicsGroupsMask(collidesWith, 0, 0, 0);


## XRENGINE/Scene/Components/Volumes/Trigger.cs
- L66 C28: new IPhysicsGeometry.Box :: var geometry = new IPhysicsGeometry.Box(HalfExtents);


## XRENGINE/Scene/Components/VR/VRDeviceModelComponent.cs
- L58 C23: new() :: Model m = new();
- L84 C27: new() :: XRMesh mesh = new();
- L85 C30: new() :: XRMaterial mat = new();
- L98 C30: new XRTexture2D :: textures.Add(new XRTexture2D(texture.LoadImage(true)));
- L108 C30: new Vertex :: vertices.Add(new Vertex(position, normal, uv));
- L121 C24: new XRMesh :: mesh = new XRMesh(vertices, triangleIndices);
- L126 C25: new SubMeshLOD :: m = new(new SubMeshLOD(mat, mesh, 0.0f));


## XRENGINE/Scene/Components/VR/VRHeadsetComponent.cs
- L19 C33: new VREyeTransform :: _leftEyeTransform = new VREyeTransform(true, Transform);
- L20 C34: new VREyeTransform :: _rightEyeTransform = new VREyeTransform(false, Transform);
- L22 C40: new XRCamera :: _leftEyeCamera = new(() => new XRCamera(_leftEyeTransform, _leftEyeParams), true);
- L23 C41: new XRCamera :: _rightEyeCamera = new(() => new XRCamera(_rightEyeTransform, _rightEyeParams), true);
- L25 C49: new RenderCommandMethod3D :: RenderInfo = RenderInfo3D.New(this, new RenderCommandMethod3D((int)EDefaultRenderPass.OpaqueForward, Render));


## XRENGINE/Scene/Components/VR/VRPlayerCharacterComponent.cs
- L21 C58: new RenderCommandMethod3D :: => RenderedObjects = [RenderInfo3D.New(this, new RenderCommandMethod3D((int)EDefaultRenderPass.OpaqueForward, Render))];
- L66 C55: new Vector3 :: Vector3 ipdOffset = Vector3.Transform(new Vector3(halfIpd, 0.0f, 0.0f), headNodeRot);
- L403 C58: new Vector3 :: GetCharacterMovement()?.AddLiteralInputDelta(new Vector3(dx, 0.0f, dz));
- L429 C41: new Vector3 :: avatarRootTfm.Translation = new Vector3(0.0f, rootTrans.Y, 0.0f);
- L482 C41: new Vector3 :: avatarRootTfm.Translation = new Vector3(0.0f, 0.0f, 0.0f);


## XRENGINE/Scene/Components/XRComponent.cs
- L35 C16: new string :: public new string? Name
- L154 C166: new() :: public T? TransformAs<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] T>(bool forceConvert = false) where T : TransformBase, new()


## XRENGINE/Scene/Physics/AbstractPhysicsScene.cs
- L199 C107: new() :: private readonly ConcurrentDictionary<IAbstractJoint, PhysicsJointComponent> _jointComponentMap = new();


## XRENGINE/Scene/Physics/Jitter2/JitterScene.cs
- L15 C41: new() :: private readonly World _world = new();
- L26 C23: new Vector3 :: Gravity = new Vector3(0, -9.81f, 0);
- L95 C19: new NotImplementedException :: throw new NotImplementedException();
- L100 C19: new NotImplementedException :: throw new NotImplementedException();
- L105 C19: new NotImplementedException :: throw new NotImplementedException();
- L110 C19: new NotImplementedException :: throw new NotImplementedException();
- L115 C19: new NotImplementedException :: throw new NotImplementedException();
- L120 C19: new NotImplementedException :: throw new NotImplementedException();
- L125 C19: new NotImplementedException :: throw new NotImplementedException();
- L130 C19: new NotImplementedException :: throw new NotImplementedException();
- L135 C19: new NotImplementedException :: throw new NotImplementedException();
- L140 C19: new NotImplementedException :: throw new NotImplementedException();
- L145 C19: new NotImplementedException :: throw new NotImplementedException();
- L153 C22: new NotSupportedException :: => throw new NotSupportedException("Jitter2 joint support is not yet implemented.");
- L158 C22: new NotSupportedException :: => throw new NotSupportedException("Jitter2 joint support is not yet implemented.");
- L163 C22: new NotSupportedException :: => throw new NotSupportedException("Jitter2 joint support is not yet implemented.");
- L168 C22: new NotSupportedException :: => throw new NotSupportedException("Jitter2 joint support is not yet implemented.");
- L173 C22: new NotSupportedException :: => throw new NotSupportedException("Jitter2 joint support is not yet implemented.");
- L178 C22: new NotSupportedException :: => throw new NotSupportedException("Jitter2 joint support is not yet implemented.");
- L181 C22: new NotSupportedException :: => throw new NotSupportedException("Jitter2 joint support is not yet implemented.");


## XRENGINE/Scene/Physics/Joints/JointStructs.cs
- L122 C47: new() :: public static JointAnchor Identity => new() { Position = Vector3.Zero, Rotation = Quaternion.Identity };


## XRENGINE/Scene/Physics/Jolt/JoltBootstrap.cs
- L65 C23: new InvalidOperationException :: throw new InvalidOperationException("Jolt Foundation.Init() failed. The native joltc.dll may not be found or is incompatible.");


## XRENGINE/Scene/Physics/Jolt/JoltCharacterVirtualController.cs
- L11 C108: new() :: private readonly ConcurrentQueue<(Vector3 delta, float minDist, float elapsedTime)> _inputBuffer = new();
- L192 C47: new() :: ExtendedUpdateSettings settings = new()
- L243 C53: new() :: CharacterVirtualSettings settings = new()
- L253 C30: new CharacterVirtual :: _character = new CharacterVirtual(settings, in _position, in capsuleRotation, 0, Scene.PhysicsSystem)
- L276 C22: new CapsuleShape :: _shape = new CapsuleShape(Height * 0.5f, Radius);


## XRENGINE/Scene/Physics/Jolt/JoltJoints.cs
- L196 C22: new JointAngularLimitPair :: _limit = new JointAngularLimitPair(_constraint.LimitsMin, _constraint.LimitsMax);
- L279 C22: new JointLinearLimitPair :: _limit = new JointLinearLimitPair(_constraint.LimitsMin, _constraint.LimitsMax);
- L331 C22: new JointLimitCone :: _limit = new JointLimitCone(constraint.NormalHalfConeAngle, constraint.NormalHalfConeAngle);
- L344 C30: new JointLimitCone :: _limit = new JointLimitCone(0.0f, 0.0f, _limit.Stiffness, _limit.Damping, _limit.Restitution, _limit.BounceThreshold);
- L364 C50: new JointMotion :: private readonly JointMotion[] _motion = new JointMotion[6];
- L365 C65: new JointLinearLimitPair :: private readonly JointLinearLimitPair[] _linearLimits = new JointLinearLimitPair[3];
- L366 C49: new JointDrive :: private readonly JointDrive[] _drives = new JointDrive[6];


## XRENGINE/Scene/Physics/Jolt/JoltScene.cs
- L15 C84: new() :: private readonly HashSet<IJoltCharacterController> _characterControllers = new();
- L45 C57: new() :: private Dictionary<BodyID, JoltActor> _actors = new();
- L46 C67: new() :: private Dictionary<BodyID, JoltRigidActor> _rigidActors = new();
- L47 C73: new() :: private Dictionary<BodyID, JoltStaticRigidBody> _staticBodies = new();
- L48 C75: new() :: private Dictionary<BodyID, JoltDynamicRigidBody> _dynamicBodies = new();
- L101 C28: new JoltStaticRigidBody :: var joltBody = new JoltStaticRigidBody(bodyId);
- L153 C28: new JoltDynamicRigidBody :: var joltBody = new JoltDynamicRigidBody(bodyId);
- L204 C34: new BodyID :: _worldAnchorBodyID = new BodyID(0);
- L236 C30: new JobSystemThreadPool :: _jobSystem = new JobSystemThreadPool();
- L242 C42: new ObjectLayerPairFilterMask :: _objectLayerPairFilter = new ObjectLayerPairFilterMask();
- L243 C45: new BroadPhaseLayerInterfaceMask :: _broadPhaseLayerInterface = new BroadPhaseLayerInterfaceMask(NumBroadPhaseLayers);
- L244 C35: new BroadPhaseLayer :: var staticLayer = new BroadPhaseLayer(0);
- L245 C35: new BroadPhaseLayer :: var movingLayer = new BroadPhaseLayer(1);
- L248 C50: new ObjectVsBroadPhaseLayerFilterMask :: _objectVsBroadPhaseLayerFilter = new ObjectVsBroadPhaseLayerFilterMask(_broadPhaseLayerInterface);
- L250 C50: new() :: PhysicsSystemSettings settings = new()
- L265 C34: new Vector3 :: system.Gravity = new Vector3(0, -9.81f, 0);
- L266 C35: new PhysicsSettings :: system.Settings = new PhysicsSettings
- L337 C34: new List :: var collideResults = new List<CollideShapeResult>();
- L357 C38: new OverlapHit :: list.Add((component, new OverlapHit { FaceIndex = 0 }));
- L383 C34: new List :: var collideResults = new List<CollideShapeResult>();
- L403 C38: new OverlapHit :: list.Add((component, new OverlapHit { FaceIndex = 0 }));
- L425 C24: new List :: var hits = new List<RayCastResult>();
- L426 C57: new Ray :: if (_physicsSystem.NarrowPhaseQuery.CastRay(new Ray(start, direction), new RayCastSettings(), CollisionCollectorType.AnyHit, hits))
- L426 C84: new RayCastSettings :: if (_physicsSystem.NarrowPhaseQuery.CastRay(new Ray(start, direction), new RayCastSettings(), CollisionCollectorType.AnyHit, hits))
- L460 C27: new Ray :: var rayCast = new Ray(start, direction);
- L461 C35: new RayCastSettings :: var rayCastSettings = new RayCastSettings();
- L481 C46: new RaycastHit :: list.Add((component, new RaycastHit
- L512 C27: new JoltPhysicsSharp.Ray :: var rayCast = new JoltPhysicsSharp.Ray(start, direction);
- L513 C35: new RayCastSettings :: var rayCastSettings = new RayCastSettings();
- L539 C46: new RaycastHit :: list.Add((component, new RaycastHit
- L604 C24: new BodyID :: return new BodyID(0);
- L610 C17: new BoxShape :: new BoxShape(new Vector3(0.05f), 0.0f),
- L610 C30: new Vector3 :: new BoxShape(new Vector3(0.05f), 0.0f),
- L614 C17: new LayerMask :: new LayerMask(1).AsJoltObjectLayer());
- L747 C32: new List :: var sweepResults = new List<ShapeCastResult>();
- L804 C32: new List :: var sweepResults = new List<ShapeCastResult>();
- L834 C38: new SweepHit :: list.Add((component, new SweepHit
- L879 C32: new List :: var sweepResults = new List<ShapeCastResult>();
- L908 C38: new SweepHit :: list.Add((component, new SweepHit
- L960 C48: new() :: FixedConstraintSettings settings = new()
- L972 C61: new FixedConstraint :: if (!TryBuildConstraint(a, b, (body1, body2) => new FixedConstraint(settings, body1, body2), out FixedConstraint? constraint)
- L974 C23: new InvalidOperationException :: throw new InvalidOperationException("Failed to create Jolt fixed joint.");
- L976 C25: new JoltFixedJoint :: var joint = new JoltFixedJoint(this, constraint, a, b, localFrameA, localFrameB);
- L988 C51: new() :: DistanceConstraintSettings settings = new()
- L995 C40: new SpringSettings :: LimitsSpringSettings = new SpringSettings(SpringMode.StiffnessAndDamping, 0.0f, 0.0f)
- L998 C61: new DistanceConstraint :: if (!TryBuildConstraint(a, b, (body1, body2) => new DistanceConstraint(settings, body1, body2), out DistanceConstraint? constraint)
- L1000 C23: new InvalidOperationException :: throw new InvalidOperationException("Failed to create Jolt distance joint.");
- L1002 C25: new JoltDistanceJoint :: var joint = new JoltDistanceJoint(this, constraint, a, b, localFrameA, localFrameB);
- L1014 C48: new() :: HingeConstraintSettings settings = new()
- L1025 C40: new SpringSettings :: LimitsSpringSettings = new SpringSettings(SpringMode.StiffnessAndDamping, 0.0f, 0.0f),
- L1026 C33: new MotorSettings :: MotorSettings = new MotorSettings(),
- L1030 C61: new HingeConstraint :: if (!TryBuildConstraint(a, b, (body1, body2) => new HingeConstraint(settings, body1, body2), out HingeConstraint? constraint)
- L1032 C23: new InvalidOperationException :: throw new InvalidOperationException("Failed to create Jolt hinge joint.");
- L1034 C25: new JoltHingeJoint :: var joint = new JoltHingeJoint(this, constraint, a, b, localFrameA, localFrameB);
- L1046 C49: new() :: SliderConstraintSettings settings = new()
- L1058 C40: new SpringSettings :: LimitsSpringSettings = new SpringSettings(SpringMode.StiffnessAndDamping, 0.0f, 0.0f),
- L1059 C33: new MotorSettings :: MotorSettings = new MotorSettings(),
- L1063 C61: new SliderConstraint :: if (!TryBuildConstraint(a, b, (body1, body2) => new SliderConstraint(settings, body1, body2), out SliderConstraint? constraint)
- L1065 C23: new InvalidOperationException :: throw new InvalidOperationException("Failed to create Jolt prismatic joint.");
- L1067 C25: new JoltPrismaticJoint :: var joint = new JoltPrismaticJoint(this, constraint, a, b, localFrameA, localFrameB);
- L1079 C53: new() :: SwingTwistConstraintSettings settings = new()
- L1094 C38: new MotorSettings :: SwingMotorSettings = new MotorSettings(),
- L1095 C38: new MotorSettings :: TwistMotorSettings = new MotorSettings(),
- L1098 C61: new SwingTwistConstraint :: if (!TryBuildConstraint(a, b, (body1, body2) => new SwingTwistConstraint(settings, body1, body2), out SwingTwistConstraint? constraint)
- L1100 C23: new InvalidOperationException :: throw new InvalidOperationException("Failed to create Jolt spherical joint.");
- L1102 C25: new JoltSphericalJoint :: var joint = new JoltSphericalJoint(this, constraint, a, b, localFrameA, localFrameB);
- L1114 C49: new() :: SixDOFConstraintSettings settings = new()
- L1129 C61: new SixDOFConstraint :: if (!TryBuildConstraint(a, b, (body1, body2) => new SixDOFConstraint(settings, body1, body2), out SixDOFConstraint? constraint)
- L1131 C23: new InvalidOperationException :: throw new InvalidOperationException("Failed to create Jolt D6 joint.");
- L1133 C25: new JoltD6Joint :: var joint = new JoltD6Joint(this, constraint, a, b, localFrameA, localFrameB);


## XRENGINE/Scene/Physics/Physx/Controller.cs
- L66 C102: new() :: private static readonly ConcurrentDictionary<nint, PhysxController> _hitReportToController = new();
- L69 C109: new() :: private static readonly ConcurrentDictionary<nint, PhysxController> _behaviorCallbackToController = new();
- L91 C108: new() :: private readonly ConcurrentQueue<(Vector3 delta, float minDist, float elapsedTime)> _inputBuffer = new();
- L128 C23: new KeyNotFoundException :: throw new KeyNotFoundException($"PhysxScene not found for PxScene* 0x{scenePtr:X}");
- L203 C24: new Vector3 :: return new Vector3((float)pos->x, (float)pos->y, (float)pos->z);
- L219 C24: new Vector3 :: return new Vector3((float)pos.x, (float)pos.y, (float)pos.z);
- L235 C24: new Vector3 :: return new Vector3(up.x, up.y, up.z);
- L337 C74: new PxUserControllerHitReportVTable :: _userControllerHitReportVTableSource = DataSource.FromStruct(new PxUserControllerHitReportVTable
- L345 C68: new PxUserControllerHitReport :: _userControllerHitReportSource = DataSource.FromStruct(new PxUserControllerHitReport()
- L355 C77: new PxControllerBehaviorCallbackVTable :: _controllerBehaviorCallbackVTableSource = DataSource.FromStruct(new PxControllerBehaviorCallbackVTable
- L363 C71: new PxControllerBehaviorCallback :: _controllerBehaviorCallbackSource = DataSource.FromStruct(new PxControllerBehaviorCallback()


## XRENGINE/Scene/Physics/Physx/ControllerManager.cs
- L66 C108: new() :: private static readonly ConcurrentDictionary<nint, ControllerManager> _controllerFilterToManager = new();
- L69 C103: new() :: private static readonly ConcurrentDictionary<nint, ControllerManager> _queryFilterToManager = new();
- L116 C23: new KeyNotFoundException :: throw new KeyNotFoundException($"PhysxScene not found for PxScene* 0x{scenePtr:X}");
- L177 C75: new PxControllerFilterCallbackVTable :: _controllerFilterCallbackVTableSource = DataSource.FromStruct(new PxControllerFilterCallbackVTable
- L183 C69: new PxControllerFilterCallback :: _controllerFilterCallbackSource = DataSource.FromStruct(new PxControllerFilterCallback()
- L192 C70: new PxQueryFilterCallbackVTable :: _queryFilterCallbackVTableSource = DataSource.FromStruct(new PxQueryFilterCallbackVTable
- L199 C64: new PxQueryFilterCallback :: _queryFilterCallbackSource = DataSource.FromStruct(new PxQueryFilterCallback()
- L229 C31: new List :: var controllers = new List<PhysxController>((int)count);
- L265 C30: new PhysxBoxController :: var controller = new PhysxBoxController();
- L287 C23: new Exception :: throw new Exception("Invalid box controller description");
- L317 C30: new PhysxCapsuleController :: var controller = new PhysxCapsuleController();
- L347 C23: new Exception :: throw new Exception("Invalid capsule controller description");
- L419 C42: new ObstacleContext :: ObstacleContext[] contexts = new ObstacleContext[count];
- L429 C35: new ObstacleContext :: var obstacleContext = new ObstacleContext(context);


## XRENGINE/Scene/Physics/Physx/Geometry/IPhysicsGeometry.cs
- L22 C52: new SphereShape :: public readonly Shape AsJoltShape() => new SphereShape(Radius);
- L30 C52: new BoxShape :: public readonly Shape AsJoltShape() => new BoxShape(HalfExtents);
- L39 C52: new CapsuleShape :: public readonly Shape AsJoltShape() => new CapsuleShape(HalfHeight, Radius);
- L60 C31: new BoxShape :: Shape shape = new BoxShape(new Vector3(0.05f), 0.0f);
- L60 C44: new Vector3 :: Shape shape = new BoxShape(new Vector3(0.05f), 0.0f);
- L61 C25: new ScaledShape :: shape = new ScaledShape(shape, Scale);
- L62 C25: new RotatedTranslatedShape :: shape = new RotatedTranslatedShape(Vector3.Zero, Rotation, shape);
- L86 C31: new BoxShape :: Shape shape = new BoxShape(new Vector3(0.1f), 0.0f);
- L86 C44: new Vector3 :: Shape shape = new BoxShape(new Vector3(0.1f), 0.0f);
- L87 C25: new ScaledShape :: shape = new ScaledShape(shape, Scale);
- L88 C25: new RotatedTranslatedShape :: shape = new RotatedTranslatedShape(Vector3.Zero, Rotation, shape);
- L110 C24: new BoxShape :: return new BoxShape(new Vector3(MathF.Max(0.1f, RowScale), MathF.Max(0.1f, HeightScale), MathF.Max(0.1f, ColumnScale)), 0.0f);
- L110 C37: new Vector3 :: return new BoxShape(new Vector3(MathF.Max(0.1f, RowScale), MathF.Max(0.1f, HeightScale), MathF.Max(0.1f, ColumnScale)), 0.0f);
- L115 C54: new System.Numerics.Plane :: public System.Numerics.Plane PlaneData = new System.Numerics.Plane(Globals.Up, 0.0f);
- L119 C52: new PlaneShape :: public readonly Shape AsJoltShape() => new PlaneShape(PlaneData);
- L135 C24: new SphereShape :: return new SphereShape(0.01f);
- L149 C24: new BoxShape :: return new BoxShape(new Vector3(0.05f), 0.0f);
- L149 C37: new Vector3 :: return new BoxShape(new Vector3(0.05f), 0.0f);


## XRENGINE/Scene/Physics/Physx/InstancedDebugVisualizer.cs
- L100 C49: new Task :: private readonly Task?[] _renderTasks = new Task?[3];
- L374 C38: new XRDataBuffer :: _debugPointsBuffer = new XRDataBuffer(
- L414 C37: new XRDataBuffer :: _debugLinesBuffer = new XRDataBuffer(
- L454 C41: new XRDataBuffer :: _debugTrianglesBuffer = new XRDataBuffer(
- L482 C24: new XRMeshRenderer :: var rend = new XRMeshRenderer(CreateDebugMesh(), CreateDebugPointMaterial());
- L488 C24: new XRMeshRenderer :: var rend = new XRMeshRenderer(CreateDebugMesh(), CreateDebugLineMaterial());
- L494 C24: new XRMeshRenderer :: var rend = new XRMeshRenderer(CreateDebugMesh(), CreateDebugTriangleMaterial());
- L523 C21: new Vertex :: => new([new Vertex(Vector3.Zero)]);
- L547 C21: new ShaderFloat :: new ShaderFloat(PointSize, "PointSize"),
- L548 C21: new ShaderInt :: new ShaderInt(0, "TotalPoints"),
- L550 C27: new XRMaterial :: var mat = new XRMaterial(vars, [.. vertexShaders, geomShader, fragShader]);
- L587 C21: new ShaderFloat :: new ShaderFloat(LineWidth, "LineWidth"),
- L588 C21: new ShaderInt :: new ShaderInt(0, "TotalLines"),
- L590 C27: new XRMaterial :: var mat = new XRMaterial(vars, [.. vertexShaders, geomShader, fragShader]);
- L627 C21: new ShaderInt :: new ShaderInt(0, "TotalTriangles"),
- L629 C27: new XRMaterial :: var mat = new XRMaterial(vars, [.. vertexShaders, geomShader, fragShader]);


## XRENGINE/Scene/Physics/Physx/Joints/PhysxJoint.cs
- L88 C33: new() :: PxTransform v = new() { p = value.position, q = value.rotation };
- L101 C33: new() :: PxTransform v = new() { p = value.position, q = value.rotation };
- L122 C24: new JointAnchor :: return new JointAnchor(p, q);
- L132 C24: new JointAnchor :: return new JointAnchor(p, q);


## XRENGINE/Scene/Physics/Physx/Joints/PhysxJoint_D6.cs
- L26 C44: new() :: PxJointLinearLimit limit = new() { value = value.@value, restitution = value.restitution, bounceThreshold = value.bounceThreshold, stiffness = value.stiffness, damping = value.damping };
- L40 C48: new() :: PxJointLinearLimitPair limit = new() { lower = value.lower, upper = value.upper, restitution = value.restitution, bounceThreshold = value.bounceThreshold, stiffness = value.stiffness, damping = value.damping };
- L53 C48: new() :: PxJointLinearLimitPair limit = new() { lower = value.lower, upper = value.upper, restitution = value.restitution, bounceThreshold = value.bounceThreshold, stiffness = value.stiffness, damping = value.damping };
- L66 C48: new() :: PxJointLinearLimitPair limit = new() { lower = value.lower, upper = value.upper, restitution = value.restitution, bounceThreshold = value.bounceThreshold, stiffness = value.stiffness, damping = value.damping };
- L79 C49: new() :: PxJointAngularLimitPair limit = new() { lower = value.lower, upper = value.upper, restitution = value.restitution, bounceThreshold = value.bounceThreshold, stiffness = value.stiffness, damping = value.damping };
- L92 C48: new() :: PxJointLinearLimitPair limit = new() { lower = value.lower, upper = value.upper, restitution = value.restitution, bounceThreshold = value.bounceThreshold, stiffness = value.stiffness, damping = value.damping };
- L105 C48: new() :: PxJointLinearLimitPair limit = new() { lower = value.lower, upper = value.upper, restitution = value.restitution, bounceThreshold = value.bounceThreshold, stiffness = value.stiffness, damping = value.damping };
- L119 C40: new() :: PxD6JointDrive drive = new() { stiffness = value.stiffness, damping = value.damping, forceLimit = value.forceLimit, flags = value.flags };
- L132 C40: new() :: PxD6JointDrive drive = new() { stiffness = value.stiffness, damping = value.damping, forceLimit = value.forceLimit, flags = value.flags };
- L145 C40: new() :: PxD6JointDrive drive = new() { stiffness = value.stiffness, damping = value.damping, forceLimit = value.forceLimit, flags = value.flags };
- L158 C40: new() :: PxD6JointDrive drive = new() { stiffness = value.stiffness, damping = value.damping, forceLimit = value.forceLimit, flags = value.flags };
- L171 C40: new() :: PxD6JointDrive drive = new() { stiffness = value.stiffness, damping = value.damping, forceLimit = value.forceLimit, flags = value.flags };
- L184 C40: new() :: PxD6JointDrive drive = new() { stiffness = value.stiffness, damping = value.damping, forceLimit = value.forceLimit, flags = value.flags };
- L198 C33: new() :: PxTransform t = new() { p = value.position, q = value.Quaternion };
- L205 C29: new() :: PxTransform t = new() { p = position, q = Quaternion };
- L253 C45: new() :: PxJointLimitPyramid limit = new() { yAngleMin = value.yAngleMin, yAngleMax = value.yAngleMax, zAngleMin = value.zAngleMin, zAngleMax = value.zAngleMax, restitution = value.restitution, bounceThreshold = value.bounceThreshold, stiffness = value.stiffness, damping = value.damping };
- L267 C42: new() :: PxJointLimitCone limit = new() { yAngle = value.yAngle, zAngle = value.zAngle, restitution = value.restitution, bounceThreshold = value.bounceThreshold, stiffness = value.stiffness, damping = value.damping };
- L320 C24: new JointLinearLimit :: return new JointLinearLimit(value, stiffness, damping, restitution, bounceThreshold);
- L328 C20: new JointLinearLimitPair :: return new JointLinearLimitPair(limit.lower, limit.upper, limit.stiffness, limit.damping, limit.restitution, limit.bounceThreshold);
- L333 C41: new() :: PxJointLinearLimitPair px = new()
- L350 C24: new JointAngularLimitPair :: return new JointAngularLimitPair(lower, upper, stiffness, damping, restitution, bounceThreshold);
- L354 C46: new() :: PxJointAngularLimitPair px = new()
- L372 C24: new JointLimitCone :: return new JointLimitCone(yAngle, zAngle, stiffness, damping, restitution, bounceThreshold);
- L376 C39: new() :: PxJointLimitCone px = new()
- L392 C20: new JointDrive :: return new JointDrive(drive.stiffness, drive.damping, drive.forceLimit,
- L398 C33: new() :: PxD6JointDrive px = new()


## XRENGINE/Scene/Physics/Physx/Joints/PhysxJoint_Prismatic.cs
- L23 C47: new() :: PxJointLinearLimitPair pair = new()
- L60 C24: new JointLinearLimitPair :: return new JointLinearLimitPair(lower, upper, stiffness, damping, restitution, bounceThreshold);


## XRENGINE/Scene/Physics/Physx/Joints/PhysxJoint_Revolute.cs
- L25 C28: new PxJointAngularLimitPair :: var pair = new PxJointAngularLimitPair
- L84 C24: new JointAngularLimitPair :: return new JointAngularLimitPair(lower, upper, stiffness, damping, restitution, bounceThreshold);


## XRENGINE/Scene/Physics/Physx/Joints/PhysxJoint_Spherical.cs
- L21 C28: new PxJointLimitCone :: var cone = new PxJointLimitCone() { zAngle = value.zAngle, yAngle = value.yAngle, restitution = value.restitution, bounceThreshold = value.bounceThreshold, stiffness = value.stiffness, damping = value.damping };
- L54 C24: new JointLimitCone :: return new JointLimitCone(yAngle, zAngle, stiffness, damping, restitution, bounceThreshold);


## XRENGINE/Scene/Physics/Physx/PhysxActor.cs
- L16 C83: new() :: public static ConcurrentDictionary<nint, PhysxActor> AllActors { get; } = new();
- L153 C20: new AABB :: return new AABB(bounds.minimum, bounds.maximum);
- L161 C24: new string :: return new string((sbyte*)name);


## XRENGINE/Scene/Physics/Physx/PhysxControllerActorProxy.cs
- L48 C31: new Vector3 :: var newPosition = new Vector3((float)pos->x, (float)pos->y, (float)pos->z);
- L68 C70: new Vector3 :: rotation = XRMath.RotationBetweenVectors(Globals.Up, new Vector3(up.x, up.y, up.z));


## XRENGINE/Scene/Physics/Physx/PhysxConvexHullCooker.cs
- L14 C52: new() :: private static readonly object _initLock = new();
- L48 C23: new InvalidOperationException :: throw new InvalidOperationException("PhysxConvexHullCooker.Initialize must be called before cooking convex meshes.");
- L57 C23: new ArgumentException :: throw new ArgumentException("Convex hull requires at least four vertices.", nameof(hull));
- L73 C37: new PxVec3 :: PxVec3[] vertexBuffer = new PxVec3[hull.Vertices.Length];
- L77 C35: new PxVec3 :: vertexBuffer[i] = new PxVec3 { x = v.X, y = v.Y, z = v.Z };
- L89 C27: new InvalidOperationException :: throw new InvalidOperationException("PxConvexMeshDesc validation failed for supplied hull.");
- L94 C27: new InvalidOperationException :: throw new InvalidOperationException("PhysX must be initialized before cooking convex meshes.");
- L98 C27: new InvalidOperationException :: throw new InvalidOperationException($"PxCreateConvexMesh failed with result {result}.");
- L100 C24: new PhysxConvexMesh :: return new PhysxConvexMesh(meshPtr);


## XRENGINE/Scene/Physics/Physx/PhysxConvexMesh.cs
- L30 C26: new Vector3 :: var result = new Vector3[count];
- L40 C20: new AABB :: return new AABB(bounds.minimum, bounds.maximum);
- L54 C28: new Matrix4x4 :: localInertia = new Matrix4x4(


## XRENGINE/Scene/Physics/Physx/PhysxDynamicRigidBody.cs
- L14 C95: new() :: public static ConcurrentDictionary<nint, PhysxDynamicRigidBody> AllDynamic { get; } = new();


## XRENGINE/Scene/Physics/Physx/PhysxHeightField.cs
- L32 C65: new Exception :: var values = image.GetPixels().GetValues() ?? throw new Exception("Image does not contain pixel values.");
- L34 C23: new Exception :: throw new Exception("Image size does not match heightfield size.");


## XRENGINE/Scene/Physics/Physx/PhysxMaterial.cs
- L15 C80: new() :: public static ConcurrentDictionary<nint, PhysxMaterial> All { get; } = new();
- L197 C28: new ArgumentOutOfRangeException :: _ => throw new ArgumentOutOfRangeException(nameof(mode), mode, null),
- L207 C28: new ArgumentOutOfRangeException :: _ => throw new ArgumentOutOfRangeException(nameof(mode), mode, null),


## XRENGINE/Scene/Physics/Physx/PhysxObjectLog.cs
- L49 C43: new KeyValuePair :: bool removed = dict.TryRemove(new KeyValuePair<nint, T>(ptr, value));


## XRENGINE/Scene/Physics/Physx/PhysxPlane.cs
- L21 C20: new PhysxPlane :: return new PhysxPlane(p);
- L55 C20: new PhysxPlane :: return new PhysxPlane(InternalPlane.Transform(&tfm));
- L60 C20: new PhysxPlane :: return new PhysxPlane(InternalPlane.InverseTransform(&tfm));


## XRENGINE/Scene/Physics/Physx/PhysxRigidActor.cs
- L19 C93: new() :: public static ConcurrentDictionary<nint, PhysxRigidActor> AllRigidActors { get; } = new();
- L62 C33: new() :: set => SetTransform(new() { p = value.position, q = value.rotation }, true);
- L68 C24: new Vector3 :: position = new Vector3(pose.p.x, pose.p.y, pose.p.z);
- L69 C24: new Quaternion :: rotation = new Quaternion(pose.q.x, pose.q.y, pose.q.z, pose.q.w);
- L84 C29: new() :: => SetTransform(new() { p = position, q = rotation }, wake);
- L98 C31: new PxConstraint :: var constraints = new PxConstraint*[ConstraintCount];
- L108 C26: new PxShape :: var shapes = new PxShape*[ShapeCount];
- L111 C27: new PhysxShape :: var shapes2 = new PhysxShape[ShapeCount];


## XRENGINE/Scene/Physics/Physx/PhysxRigidBody.cs
- L51 C25: new PxTransform :: var x = new PxTransform { q = value.Item1, p = value.Item2 };


## XRENGINE/Scene/Physics/Physx/PhysxScene.cs
- L29 C80: new() :: public static ConcurrentDictionary<nint, PhysxScene> Scenes { get; } = new();
- L51 C56: new() :: public static readonly PxVec3 DefaultGravity = new() { x = 0.0f, y = -9.81f, z = 0.0f };
- L104 C34: new KeyValuePair :: Scenes.TryRemove(new KeyValuePair<nint, PhysxScene>((nint)_scene, this));
- L190 C43: new[] :: [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvCdecl) })]
- L201 C43: new[] :: [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvCdecl) })]
- L213 C43: new[] :: [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvCdecl) })]
- L245 C43: new[] :: [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvCdecl) })]
- L257 C43: new[] :: [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvCdecl) })]
- L321 C25: new List :: var owned = new List<PhysxRigidActor>(PhysxDynamicRigidBody.AllDynamic.Count + PhysxStaticRigidBody.AllStaticRigidBodies.Count);
- L400 C43: new[] :: [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvCdecl) })]
- L452 C88: new() :: private readonly ConcurrentQueue<PhysxController> _pendingControllerReleases = new();
- L544 C28: new PxContactPairHeader :: contactPairs = new PxContactPairHeader[numPairs];
- L602 C24: new FilterShader :: return new FilterShader { data = data, dataSize = dataSize };
- L662 C27: new List :: var addList = new List<PhysxActor>(actors.Length);
- L730 C30: new List :: var removeList = new List<PhysxActor>(actors.Length);
- L823 C73: new() :: public ConcurrentDictionary<nint, PhysxShape> Shapes { get; } = new();
- L831 C48: new PhysxShape :: shape = PhysxShape.Get(ptr) ?? new PhysxShape(ptr);
- L851 C73: new() :: public ConcurrentDictionary<nint, PhysxJoint> Joints { get; } = new();
- L855 C88: new() :: public ConcurrentDictionary<nint, PhysxJoint_Contact> ContactJoints { get; } = new();
- L860 C41: new() :: PxTransform pxlocalFrame0 = new() { p = localFrame0.position, q = localFrame0.rotation };
- L861 C41: new() :: PxTransform pxlocalFrame1 = new() { p = localFrame1.position, q = localFrame1.rotation };
- L863 C28: new PhysxJoint_Contact :: var jointObj = new PhysxJoint_Contact(joint);
- L870 C90: new() :: public ConcurrentDictionary<nint, PhysxJoint_Distance> DistanceJoints { get; } = new();
- L875 C41: new() :: PxTransform pxlocalFrame0 = new() { p = localFrame0.position, q = localFrame0.rotation };
- L876 C41: new() :: PxTransform pxlocalFrame1 = new() { p = localFrame1.position, q = localFrame1.rotation };
- L878 C28: new PhysxJoint_Distance :: var jointObj = new PhysxJoint_Distance(joint);
- L885 C78: new() :: public ConcurrentDictionary<nint, PhysxJoint_D6> D6Joints { get; } = new();
- L890 C41: new() :: PxTransform pxlocalFrame0 = new() { p = localFrame0.position, q = localFrame0.rotation };
- L891 C41: new() :: PxTransform pxlocalFrame1 = new() { p = localFrame1.position, q = localFrame1.rotation };
- L893 C28: new PhysxJoint_D6 :: var jointObj = new PhysxJoint_D6(joint);
- L900 C84: new() :: public ConcurrentDictionary<nint, PhysxJoint_Fixed> FixedJoints { get; } = new();
- L905 C41: new() :: PxTransform pxlocalFrame0 = new() { p = localFrame0.position, q = localFrame0.rotation };
- L906 C41: new() :: PxTransform pxlocalFrame1 = new() { p = localFrame1.position, q = localFrame1.rotation };
- L908 C28: new PhysxJoint_Fixed :: var jointObj = new PhysxJoint_Fixed(joint);
- L915 C92: new() :: public ConcurrentDictionary<nint, PhysxJoint_Prismatic> PrismaticJoints { get; } = new();
- L920 C41: new() :: PxTransform pxlocalFrame0 = new() { p = localFrame0.position, q = localFrame0.rotation };
- L921 C41: new() :: PxTransform pxlocalFrame1 = new() { p = localFrame1.position, q = localFrame1.rotation };
- L923 C28: new PhysxJoint_Prismatic :: var jointObj = new PhysxJoint_Prismatic(joint);
- L930 C90: new() :: public ConcurrentDictionary<nint, PhysxJoint_Revolute> RevoluteJoints { get; } = new();
- L935 C41: new() :: PxTransform pxlocalFrame0 = new() { p = localFrame0.position, q = localFrame0.rotation };
- L936 C41: new() :: PxTransform pxlocalFrame1 = new() { p = localFrame1.position, q = localFrame1.rotation };
- L938 C28: new PhysxJoint_Revolute :: var jointObj = new PhysxJoint_Revolute(joint);
- L945 C92: new() :: public ConcurrentDictionary<nint, PhysxJoint_Spherical> SphericalJoints { get; } = new();
- L950 C41: new() :: PxTransform pxlocalFrame0 = new() { p = localFrame0.position, q = localFrame0.rotation };
- L951 C41: new() :: PxTransform pxlocalFrame1 = new() { p = localFrame1.position, q = localFrame1.rotation };
- L953 C28: new PhysxJoint_Spherical :: var jointObj = new PhysxJoint_Spherical(joint);
- L976 C31: new() :: PxTransform tfA = new() { p = localFrameA.Position, q = localFrameA.Rotation };
- L977 C31: new() :: PxTransform tfB = new() { p = localFrameB.Position, q = localFrameB.Rotation };
- L979 C23: new PhysxJoint_Fixed :: var obj = new PhysxJoint_Fixed(joint);
- L991 C31: new() :: PxTransform tfA = new() { p = localFrameA.Position, q = localFrameA.Rotation };
- L992 C31: new() :: PxTransform tfB = new() { p = localFrameB.Position, q = localFrameB.Rotation };
- L994 C23: new PhysxJoint_Distance :: var obj = new PhysxJoint_Distance(joint);
- L1006 C31: new() :: PxTransform tfA = new() { p = localFrameA.Position, q = localFrameA.Rotation };
- L1007 C31: new() :: PxTransform tfB = new() { p = localFrameB.Position, q = localFrameB.Rotation };
- L1009 C23: new PhysxJoint_Revolute :: var obj = new PhysxJoint_Revolute(joint);
- L1021 C31: new() :: PxTransform tfA = new() { p = localFrameA.Position, q = localFrameA.Rotation };
- L1022 C31: new() :: PxTransform tfB = new() { p = localFrameB.Position, q = localFrameB.Rotation };
- L1024 C23: new PhysxJoint_Prismatic :: var obj = new PhysxJoint_Prismatic(joint);
- L1036 C31: new() :: PxTransform tfA = new() { p = localFrameA.Position, q = localFrameA.Rotation };
- L1037 C31: new() :: PxTransform tfB = new() { p = localFrameB.Position, q = localFrameB.Rotation };
- L1039 C23: new PhysxJoint_Spherical :: var obj = new PhysxJoint_Spherical(joint);
- L1051 C31: new() :: PxTransform tfA = new() { p = localFrameA.Position, q = localFrameA.Rotation };
- L1052 C31: new() :: PxTransform tfB = new() { p = localFrameB.Position, q = localFrameB.Rotation };
- L1054 C23: new PhysxJoint_D6 :: var obj = new PhysxJoint_D6(joint);
- L1085 C26: new() :: PxVec3 pos = new() { x = p.X, y = p.Y, z = p.Z };
- L1086 C26: new() :: PxQuat rot = new() { x = q.X, y = q.Y, z = q.Z, w = q.W };
- L1120 C35: new PhysxActor :: PhysxActor[] actors = new PhysxActor[count];
- L1134 C35: new PhysxActor :: PhysxActor[] actors = new PhysxActor[count];
- L1147 C64: new PxArticulationReducedCoordinate :: PxArticulationReducedCoordinate*[] articulations = new PxArticulationReducedCoordinate*[count];
- L1160 C43: new PxConstraint :: PxConstraint*[] constraints = new PxConstraint*[count];
- L1173 C41: new PxAggregate :: PxAggregate*[] aggregates = new PxAggregate*[count];
- L1261 C24: new AABB :: return new AABB { Min = b.minimum, Max = b.maximum };
- L1265 C31: new() :: PxBounds3 b = new() { minimum = value.Min, maximum = value.Max };
- L1313 C48: new PxBroadPhaseRegionInfo :: PxBroadPhaseRegionInfo[] regions = new PxBroadPhaseRegionInfo[count];
- L1417 C34: new ControllerManager :: _controllerManager = new ControllerManager(mgrPtr);
- L1552 C35: new PxRaycastHit :: PxRaycastHit[] hits = new PxRaycastHit[hitCount];
- L1666 C33: new PxSweepHit :: PxSweepHit[] hits = new PxSweepHit[hitCount];
- L1693 C35: new PxOverlapHit :: PxOverlapHit[] hits = new PxOverlapHit[hitCount];
- L1738 C20: new PhysxBatchQuery :: return new PhysxBatchQuery(ptr);
- L1770 C20: new PhysxBatchQuery :: return new PhysxBatchQuery(ptr);
- L1845 C30: new() :: filterCallback = new() { vtable_ = PhysxScene.Native.CreateVTable(PreFilter, PostFilter, Destructor) };
- L1876 C16: new() :: => new()
- L1882 C22: new Vector2 :: UV = new Vector2(hit.u, hit.v),
- L1887 C20: new SweepHit :: return new SweepHit
- L1898 C20: new OverlapHit :: return new OverlapHit
- L2574 C94: new() :: private static Queue<(Vector3 delta, float minDist, float elapsedTime)> _moveQueue = new();


## XRENGINE/Scene/Physics/Physx/PhysxShape.cs
- L34 C77: new() :: public static ConcurrentDictionary<nint, PhysxShape> All { get; } = new();
- L213 C39: new PxMaterial :: PxMaterial*[] materials = new PxMaterial*[MaterialCount];
- L216 C36: new PhysxMaterial :: PhysxMaterial[] mats = new PhysxMaterial[MaterialCount];
- L271 C38: new PxRaycastHit :: PxRaycastHit[] rayHits = new PxRaycastHit[maxHits];
- L275 C39: new PxRaycastHit :: PxRaycastHit[] hits = new PxRaycastHit[num];
- L302 C20: new AABB :: return new AABB(bounds.minimum, bounds.maximum);


## XRENGINE/Scene/Physics/Physx/PhysxStaticRigidBody.cs
- L15 C104: new() :: public static ConcurrentDictionary<nint, PhysxStaticRigidBody> AllStaticRigidBodies { get; } = new();
- L77 C20: new PhysxStaticRigidBody :: return new PhysxStaticRigidBody(stat);


## XRENGINE/Scene/Physics/Physx/PhysxTetrahedronMesh.cs
- L17 C34: new Vector3 :: Vector3[] vertices = new Vector3[VertexCount];
- L27 C30: new uint :: uint[] indices = new uint[TetrahedronCount * 4];
- L51 C28: new uint :: uint[] remap = new uint[TetrahedronCount];
- L61 C20: new AABB :: return new AABB(bounds.minimum, bounds.maximum);


## XRENGINE/Scene/Physics/Physx/PhysxTriangleMesh.cs
- L30 C32: new Vector3 :: Vector3[] result = new Vector3[numVertices];
- L40 C32: new Vector3 :: Vector3[] result = new Vector3[numVertices];
- L49 C20: new AABB :: return new AABB(bounds.minimum, bounds.maximum);
- L60 C33: new uint :: uint[] result = new uint[numTriangleIndices];
- L68 C33: new uint :: uint[] result = new uint[numTriangleIndices];
- L79 C29: new uint :: uint[] result = new uint[numTriangles];
- L91 C20: new AABB :: return new AABB(bounds.minimum, bounds.maximum);
- L99 C30: new float :: float[] result = new float[size];
- L115 C20: new UVector3 :: return new UVector3(numX, numY, numZ);


## XRENGINE/Scene/Prefabs/SceneNodePrefabService.cs
- L24 C37: new() :: XRPrefabSource prefab = new()
- L50 C39: new() :: XRPrefabVariant variant = new()


## XRENGINE/Scene/Prefabs/SceneNodePrefabUtility.cs
- L27 C33: new SceneNodePrefabLink :: node.Prefab ??= new SceneNodePrefabLink();
- L63 C26: new InvalidOperationException :: ?? throw new InvalidOperationException("Failed to deserialize prefab hierarchy");
- L104 C33: new SceneNodePrefabLink :: node.Prefab ??= new SceneNodePrefabLink();
- L122 C29: new SceneNodePrefabLink :: node.Prefab ??= new SceneNodePrefabLink();
- L127 C59: new SceneNodePrefabPropertyOverride :: node.Prefab.PropertyOverrides[propertyPath] = new SceneNodePrefabPropertyOverride
- L178 C47: new() :: Dictionary<Guid, SceneNode> map = new();
- L336 C36: new StringReader :: using var reader = new StringReader(overrideData.SerializedValue);
- L368 C52: new() :: SceneNodePrefabNodeOverride snapshot = new()
- L371 C30: new Dictionary :: Properties = new Dictionary<string, SceneNodePrefabPropertyOverride>(link.PropertyOverrides.Count, StringComparer.Ordinal)
- L381 C16: new() :: => new()


## XRENGINE/Scene/Prefabs/XRPrefabSource.cs
- L113 C23: new InvalidOperationException :: throw new InvalidOperationException("Cannot instantiate an empty prefab.");
- L147 C63: new ModelImportOptions :: var opts = importOptions as ModelImportOptions ?? new ModelImportOptions();
- L149 C34: new ModelImporter :: using var importer = new ModelImporter(filePath, onCompleted: null, materialFactory: null);
- L243 C17: new ShaderVector3 :: new ShaderVector3(new Vector3(1.0f, 1.0f, 1.0f), "BaseColor"),
- L243 C35: new Vector3 :: new ShaderVector3(new Vector3(1.0f, 1.0f, 1.0f), "BaseColor"),
- L244 C17: new ShaderFloat :: new ShaderFloat(1.0f, "Opacity"),
- L245 C17: new ShaderFloat :: new ShaderFloat(1.0f, "Roughness"),
- L246 C17: new ShaderFloat :: new ShaderFloat(0.0f, "Metallic"),
- L247 C17: new ShaderFloat :: new ShaderFloat(0.0f, "Specular"),
- L248 C17: new ShaderFloat :: new ShaderFloat(0.0f, "Emission"),


## XRENGINE/Scene/Prefabs/XRPrefabVariant.cs
- L46 C80: new() :: public List<SceneNodePrefabNodeOverride> NodeOverrides { get; set; } = new();
- L57 C26: new InvalidOperationException :: ?? throw new InvalidOperationException("Prefab variant is missing a base prefab reference.");


## XRENGINE/Scene/SceneNode.cs
- L63 C63: new() :: private readonly EventList<XRComponent> _components = new() { ThreadSafe = true };
- L139 C38: new Transform :: Transform = transform ?? new Transform();
- L156 C38: new Transform :: Transform = transform ?? new Transform();
- L173 C38: new Transform :: Transform = transform ?? new Transform();
- L397 C29: new List :: var nodes = new List<SceneNode>();


## XRENGINE/Scene/SceneNode.Factory.cs
- L22 C45: new SceneNode :: var node = parentNode is null ? new SceneNode(name) : new SceneNode(parentNode, name);
- L22 C67: new SceneNode :: var node = parentNode is null ? new SceneNode(name) : new SceneNode(parentNode, name);
- L40 C45: new SceneNode :: var node = parentNode is null ? new SceneNode(name) : new SceneNode(parentNode, name);
- L40 C67: new SceneNode :: var node = parentNode is null ? new SceneNode(name) : new SceneNode(parentNode, name);
- L61 C45: new SceneNode :: var node = parentNode is null ? new SceneNode(name) : new SceneNode(parentNode, name);
- L61 C67: new SceneNode :: var node = parentNode is null ? new SceneNode(name) : new SceneNode(parentNode, name);
- L85 C45: new SceneNode :: var node = parentNode is null ? new SceneNode(name) : new SceneNode(parentNode, name);
- L85 C67: new SceneNode :: var node = parentNode is null ? new SceneNode(name) : new SceneNode(parentNode, name);
- L112 C45: new SceneNode :: var node = parentNode is null ? new SceneNode(name) : new SceneNode(parentNode, name);
- L112 C67: new SceneNode :: var node = parentNode is null ? new SceneNode(name) : new SceneNode(parentNode, name);
- L142 C45: new SceneNode :: var node = parentNode is null ? new SceneNode(name) : new SceneNode(parentNode, name);
- L142 C67: new SceneNode :: var node = parentNode is null ? new SceneNode(name) : new SceneNode(parentNode, name);
- L159 C214: new() :: private static SceneNode SetTransform<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] TTransform>(SceneNode sceneNode, out TTransform tfm) where TTransform : TransformBase, new()
- L273 C215: new() :: public SceneNode NewChildWithTransform<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] TTransform>(out TTransform tfm, string? name = null) where TTransform : TransformBase, new()
- L274 C29: new SceneNode :: => SetTransform(new SceneNode(this) { Name = name }, out tfm);
- L285 C256: new() :: public SceneNode NewChildWithTransform<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] TTransform, T1>(out TTransform tfm, out T1 comp1, string? name = null) where T1 : XRComponent where TTransform : TransformBase, new()
- L299 C297: new() :: public SceneNode NewChildWithTransform<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] TTransform, T1, T2>(out TTransform tfm, out T1 comp1, out T2 comp2, string? name = null) where T1 : XRComponent where T2 : XRComponent where TTransform : TransformBase, new()
- L315 C338: new() :: public SceneNode NewChildWithTransform<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] TTransform, T1, T2, T3>(out TTransform tfm, out T1 comp1, out T2 comp2, out T3 comp3, string? name = null) where T1 : XRComponent where T2 : XRComponent where T3 : XRComponent where TTransform : TransformBase, new()
- L333 C379: new() :: public SceneNode NewChildWithTransform<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] TTransform, T1, T2, T3, T4>(out TTransform tfm, out T1 comp1, out T2 comp2, out T3 comp3, out T4 comp4, string? name = null) where T1 : XRComponent where T2 : XRComponent where T3 : XRComponent where T4 : XRComponent where TTransform : TransformBase, new()
- L353 C420: new() :: public SceneNode NewChildWithTransform<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] TTransform, T1, T2, T3, T4, T5>(out TTransform tfm, out T1 comp1, out T2 comp2, out T3 comp3, out T4 comp4, out T5 comp5, string? name = null) where T1 : XRComponent where T2 : XRComponent where T3 : XRComponent where T4 : XRComponent where T5 : XRComponent where TTransform : TransformBase, new()
- L375 C461: new() :: public SceneNode NewChildWithTransform<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] TTransform, T1, T2, T3, T4, T5, T6>(out TTransform tfm, out T1 comp1, out T2 comp2, out T3 comp3, out T4 comp4, out T5 comp5, out T6 comp6, string? name = null) where T1 : XRComponent where T2 : XRComponent where T3 : XRComponent where T4 : XRComponent where T5 : XRComponent where T6 : XRComponent where TTransform : TransformBase, new()


## XRENGINE/Scene/SceneNode.Hierarchy.cs
- L134 C34: new SceneNode :: SceneNode?[] nodes = new SceneNode?[predicates.Length];


## XRENGINE/Scene/SceneNode.Transform.cs
- L184 C194: new() :: public T SetTransform<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] T>(ETransformSetFlags flags = ETransformSetFlags.Default) where T : TransformBase, new()
- L186 C23: new() :: T value = new();
- L195 C169: new() :: public T? GetTransformAs<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] T>(bool forceConvert = false) where T : TransformBase, new()


## XRENGINE/Scene/Transforms/Misc/Boom.cs
- L87 C60: new() :: private PhysxScene.PhysxQueryFilter _queryFilter = new()


## XRENGINE/Scene/Transforms/Misc/DefaultLayers.cs
- L14 C62: new() :: public static Dictionary<int, string> All { get; } = new()


## XRENGINE/Scene/Transforms/Misc/OrbitTransform.cs
- L62 C51: new Vector3 :: var mtx = Matrix4x4.CreateTranslation(new Vector3(0, 0, Radius)) * Matrix4x4.CreateRotationY(float.DegreesToRadians(AngleDegrees));


## XRENGINE/Scene/Transforms/Misc/RectTransform.cs
- L55 C32: new Vector2 :: set => SizeDelta = new Vector2(value, SizeDelta.Y);
- L60 C32: new Vector2 :: set => SizeDelta = new Vector2(SizeDelta.X, value);
- L67 C25: new Vector2 :: AnchorMin = new Vector2(0.5f, 0.5f);
- L68 C25: new Vector2 :: AnchorMax = new Vector2(0.5f, 0.5f);
- L71 C21: new Vector2 :: Pivot = new Vector2(0.5f, 0.5f);
- L77 C33: new Vector3 :: Vector3[] corners = new Vector3[4];
- L82 C26: new Vector3 :: corners[0] = new Vector3(AnchoredPosition.X + OffsetMin.X, AnchoredPosition.Y + OffsetMin.Y, 0); // bottom left
- L83 C26: new Vector3 :: corners[1] = new Vector3(AnchoredPosition.X + OffsetMin.X, AnchoredPosition.Y + height, 0); // top left
- L84 C26: new Vector3 :: corners[2] = new Vector3(AnchoredPosition.X + width, AnchoredPosition.Y + height, 0); // top right
- L85 C26: new Vector3 :: corners[3] = new Vector3(AnchoredPosition.X + width, AnchoredPosition.Y + OffsetMin.Y, 0); // bottom right


## XRENGINE/Scene/Transforms/Noise/NoiseRotationTransform.cs
- L59 C46: new() :: private readonly Rotator _rotation = new();
- L60 C45: new() :: private readonly FastNoise _noise = new();


## XRENGINE/Scene/Transforms/Transform.cs
- L65 C30: new Vector3 :: => Translation = new Vector3(x, Translation.Y, Translation.Z);
- L67 C30: new Vector3 :: => Translation = new Vector3(Translation.X, y, Translation.Z);
- L69 C30: new Vector3 :: => Translation = new Vector3(Translation.X, Translation.Y, z);
- L89 C30: new Vector3 :: => Translation = new Vector3(x + _bindState.Translation.X, Translation.Y, Translation.Z);
- L91 C30: new Vector3 :: => Translation = new Vector3(Translation.X, y + _bindState.Translation.Y, Translation.Z);
- L93 C30: new Vector3 :: => Translation = new Vector3(Translation.X, Translation.Y, z + _bindState.Translation.Z);
- L97 C46: new() :: private TransformState _frameState = new();
- L98 C45: new() :: private TransformState _bindState = new();
- L106 C26: new TransformState :: _bindState = new TransformState { Translation = Translation, Rotation = Rotation, Scale = Scale, Order = Order };
- L331 C49: new Vector3 :: => Translation += Vector3.Transform(new Vector3(x, y, z), Matrix4x4.CreateFromQuaternion(Rotation));
- L406 C26: new byte :: byte[] all = new byte[4 + scale?.Length ?? 0 + translation?.Length ?? 0 + rotation?.Length ?? 0];
- L480 C28: new byte :: byte[] bytes = new byte[6];
- L606 C16: new Quaternion :: public new Quaternion TransformRotation(Quaternion localRotation)
- L620 C16: new Quaternion :: public new Quaternion InverseTransformRotation(Quaternion worldRotation)


## XRENGINE/Scene/Transforms/TransformBase.cs
- L72 C93: new() :: private static readonly ConcurrentQueue<ParentReassignRequest> _parentsToReassign = new();
- L122 C30: new HashSet :: var ancestorsA = new HashSet<TransformBase>();
- L518 C53: new() :: private readonly object _renderMatrixLock = new();
- L534 C60: new() :: private readonly object _inverseRenderMatrixLock = new();
- L582 C52: new() :: private readonly object _localMatrixLock = new();
- L606 C52: new() :: private readonly object _worldMatrixLock = new();
- L620 C59: new() :: private readonly object _inverseLocalMatrixLock = new();
- L635 C59: new() :: private readonly object _inverseWorldMatrixLock = new();
- L655 C25: new EventList :: _children = new EventList<TransformBase>() { ThreadSafe = true };
- L664 C49: new RenderCommandMethod3D :: RenderInfo = RenderInfo3D.New(this, new RenderCommandMethod3D((int)EDefaultRenderPass.OnTopForward, RenderDebug));
- L676 C27: new EventList :: _children ??= new EventList<TransformBase>() { ThreadSafe = true };
- L687 C39: new EventList :: _parent._children ??= new EventList<TransformBase>() { ThreadSafe = true };
- L848 C48: new ParentReassignRequest :: _parentsToReassign.Enqueue(new ParentReassignRequest(this, newParent, preserveWorldTransform, onApplied));
- L1389 C20: new Capsule :: return new Capsule(center, dir, SelectionRadius, halfHeight);
- L1455 C29: new Task :: var tasks = new Task[count];
- L1534 C29: new Task :: var tasks = new Task[count];
- L1577 C60: new() :: private readonly object _renderMatrixEnqueueLock = new();


## XRENGINE/Scene/Transforms/TransformBase.MatrixInfo.cs
- L97 C38: new MemoryStream :: using var memoryStream = new MemoryStream();
- L98 C37: new GZipStream :: using (var gzipStream = new GZipStream(memoryStream, CompressionLevel.Optimal))
- L129 C38: new MemoryStream :: using var memoryStream = new MemoryStream(arr);
- L130 C36: new GZipStream :: using var gzipStream = new GZipStream(memoryStream, CompressionMode.Decompress);
- L131 C30: new byte :: var deltaBytes = new byte[sizeof(bool)];
- L135 C31: new byte :: var matrixBytes = new byte[16 * sizeof(float)];
- L147 C25: new byte :: var bytes = new byte[16 * sizeof(float)];
- L148 C30: new[] :: Buffer.BlockCopy(new[]
- L160 C26: new float :: var values = new float[16];
- L162 C20: new Matrix4x4 :: return new Matrix4x4(


## XRENGINE/Scene/Transforms/VR/VREyeTransform.cs
- L86 C58: new Vector3 :: _ipdOffset = Matrix4x4.CreateTranslation(new Vector3(IsLeftEye ? -diff : diff, 0.0f, 0.0f));


## XRENGINE/Scene/WorldSettings.cs
- L574 C18: new FogSettings :: return new FogSettings
- L606 C41: new() :: public WorldSettings Clone() => new()
- L672 C20: new WorldSettings :: return new WorldSettings
- L717 C14: new ColorF3 :: return new ColorF3(
- L725 C10: new ColorF4 :: return new ColorF4(


## XRENGINE/Settings/EditorPreferences.cs
- L30 C46: new() :: private EditorThemeSettings _theme = new();
- L31 C45: new() :: private EditorDebugOptions _debug = new();
- L53 C50: new EditorThemeSettings :: set => SetField(ref _theme, value ?? new EditorThemeSettings());
- L62 C50: new EditorDebugOptions :: set => SetField(ref _debug, value ?? new EditorDebugOptions());
- L396 C48: new ColorF4 :: private ColorF4 _consoleGeneralColor = new ColorF4(0.9f, 0.9f, 0.9f, 1.0f);    // White/Gray
- L397 C50: new ColorF4 :: private ColorF4 _consoleRenderingColor = new ColorF4(0.4f, 0.8f, 1.0f, 1.0f);  // Light Blue
- L398 C47: new ColorF4 :: private ColorF4 _consoleOpenGLColor = new ColorF4(0.4f, 1.0f, 0.4f, 1.0f);     // Light Green
- L399 C48: new ColorF4 :: private ColorF4 _consolePhysicsColor = new ColorF4(1.0f, 0.8f, 0.4f, 1.0f);    // Orange
- L400 C50: new ColorF4 :: private ColorF4 _consoleAnimationColor = new ColorF4(1.0f, 0.6f, 0.8f, 1.0f);  // Pink
- L401 C43: new ColorF4 :: private ColorF4 _consoleUIColor = new ColorF4(0.8f, 0.6f, 1.0f, 1.0f);         // Purple


## XRENGINE/Settings/EditorPreferencesOverrides.cs
- L22 C47: new() :: private EditorThemeOverrides _theme = new();
- L23 C47: new() :: private EditorDebugOverrides _debug = new();
- L24 C118: new() :: private OverrideableSetting<EditorPreferences.EViewportPresentationMode> _viewportPresentationModeOverride = new();
- L25 C80: new() :: private OverrideableSetting<int> _scenePanelResizeDebounceMsOverride = new();
- L26 C71: new() :: private OverrideableSetting<bool> _mcpServerEnabledOverride = new();
- L27 C67: new() :: private OverrideableSetting<int> _mcpServerPortOverride = new();
- L28 C75: new() :: private OverrideableSetting<bool> _mcpServerRequireAuthOverride = new();
- L29 C75: new() :: private OverrideableSetting<string> _mcpServerAuthTokenOverride = new();
- L30 C79: new() :: private OverrideableSetting<string> _mcpServerCorsAllowlistOverride = new();
- L31 C78: new() :: private OverrideableSetting<int> _mcpServerMaxRequestBytesOverride = new();
- L32 C79: new() :: private OverrideableSetting<int> _mcpServerRequestTimeoutMsOverride = new();
- L33 C72: new() :: private OverrideableSetting<bool> _mcpServerReadOnlyOverride = new();
- L34 C78: new() :: private OverrideableSetting<string> _mcpServerAllowedToolsOverride = new();
- L35 C77: new() :: private OverrideableSetting<string> _mcpServerDeniedToolsOverride = new();
- L36 C80: new() :: private OverrideableSetting<bool> _mcpServerRateLimitEnabledOverride = new();
- L37 C80: new() :: private OverrideableSetting<int> _mcpServerRateLimitRequestsOverride = new();
- L38 C85: new() :: private OverrideableSetting<int> _mcpServerRateLimitWindowSecondsOverride = new();
- L39 C83: new() :: private OverrideableSetting<bool> _mcpServerIncludeStatusInPingOverride = new();
- L46 C50: new EditorThemeOverrides :: set => SetField(ref _theme, value ?? new EditorThemeOverrides());
- L54 C50: new EditorDebugOverrides :: set => SetField(ref _debug, value ?? new EditorDebugOverrides());
- L62 C77: new() :: set => SetField(ref _viewportPresentationModeOverride, value ?? new());
- L70 C79: new() :: set => SetField(ref _scenePanelResizeDebounceMsOverride, value ?? new());
- L78 C69: new() :: set => SetField(ref _mcpServerEnabledOverride, value ?? new());
- L86 C66: new() :: set => SetField(ref _mcpServerPortOverride, value ?? new());
- L94 C73: new() :: set => SetField(ref _mcpServerRequireAuthOverride, value ?? new());
- L102 C71: new() :: set => SetField(ref _mcpServerAuthTokenOverride, value ?? new());
- L110 C75: new() :: set => SetField(ref _mcpServerCorsAllowlistOverride, value ?? new());
- L118 C77: new() :: set => SetField(ref _mcpServerMaxRequestBytesOverride, value ?? new());
- L126 C78: new() :: set => SetField(ref _mcpServerRequestTimeoutMsOverride, value ?? new());
- L134 C70: new() :: set => SetField(ref _mcpServerReadOnlyOverride, value ?? new());
- L142 C74: new() :: set => SetField(ref _mcpServerAllowedToolsOverride, value ?? new());
- L150 C73: new() :: set => SetField(ref _mcpServerDeniedToolsOverride, value ?? new());
- L158 C78: new() :: set => SetField(ref _mcpServerRateLimitEnabledOverride, value ?? new());
- L166 C79: new() :: set => SetField(ref _mcpServerRateLimitRequestsOverride, value ?? new());
- L174 C84: new() :: set => SetField(ref _mcpServerRateLimitWindowSecondsOverride, value ?? new());
- L182 C81: new() :: set => SetField(ref _mcpServerIncludeStatusInPingOverride, value ?? new());
- L239 C66: new() :: private OverrideableSetting<string> _themeNameOverride = new();
- L240 C88: new() :: private OverrideableSetting<ColorF4> _quadtreeIntersectedBoundsColorOverride = new();
- L241 C86: new() :: private OverrideableSetting<ColorF4> _quadtreeContainedBoundsColorOverride = new();
- L242 C86: new() :: private OverrideableSetting<ColorF4> _octreeIntersectedBoundsColorOverride = new();
- L243 C84: new() :: private OverrideableSetting<ColorF4> _octreeContainedBoundsColorOverride = new();
- L244 C71: new() :: private OverrideableSetting<ColorF4> _bounds2DColorOverride = new();
- L245 C71: new() :: private OverrideableSetting<ColorF4> _bounds3DColorOverride = new();
- L246 C77: new() :: private OverrideableSetting<ColorF4> _transformPointColorOverride = new();
- L247 C76: new() :: private OverrideableSetting<ColorF4> _transformLineColorOverride = new();
- L248 C79: new() :: private OverrideableSetting<ColorF4> _transformCapsuleColorOverride = new();
- L249 C77: new() :: private OverrideableSetting<ColorF4> _consoleGeneralColorOverride = new();
- L250 C79: new() :: private OverrideableSetting<ColorF4> _consoleRenderingColorOverride = new();
- L251 C76: new() :: private OverrideableSetting<ColorF4> _consoleOpenGLColorOverride = new();
- L252 C77: new() :: private OverrideableSetting<ColorF4> _consolePhysicsColorOverride = new();
- L253 C79: new() :: private OverrideableSetting<ColorF4> _consoleAnimationColorOverride = new();
- L254 C72: new() :: private OverrideableSetting<ColorF4> _consoleUIColorOverride = new();
- L261 C62: new() :: set => SetField(ref _themeNameOverride, value ?? new());
- L267 C83: new() :: set => SetField(ref _quadtreeIntersectedBoundsColorOverride, value ?? new());
- L273 C81: new() :: set => SetField(ref _quadtreeContainedBoundsColorOverride, value ?? new());
- L279 C81: new() :: set => SetField(ref _octreeIntersectedBoundsColorOverride, value ?? new());
- L285 C79: new() :: set => SetField(ref _octreeContainedBoundsColorOverride, value ?? new());
- L291 C66: new() :: set => SetField(ref _bounds2DColorOverride, value ?? new());
- L297 C66: new() :: set => SetField(ref _bounds3DColorOverride, value ?? new());
- L303 C72: new() :: set => SetField(ref _transformPointColorOverride, value ?? new());
- L309 C71: new() :: set => SetField(ref _transformLineColorOverride, value ?? new());
- L315 C74: new() :: set => SetField(ref _transformCapsuleColorOverride, value ?? new());
- L321 C72: new() :: set => SetField(ref _consoleGeneralColorOverride, value ?? new());
- L327 C74: new() :: set => SetField(ref _consoleRenderingColorOverride, value ?? new());
- L333 C71: new() :: set => SetField(ref _consoleOpenGLColorOverride, value ?? new());
- L339 C72: new() :: set => SetField(ref _consolePhysicsColorOverride, value ?? new());
- L345 C74: new() :: set => SetField(ref _consoleAnimationColorOverride, value ?? new());
- L351 C67: new() :: set => SetField(ref _consoleUIColorOverride, value ?? new());
- L364 C73: new() :: private OverrideableSetting<bool> _renderMesh3DBoundsOverride = new();
- L365 C73: new() :: private OverrideableSetting<bool> _renderMesh2DBoundsOverride = new();
- L366 C79: new() :: private OverrideableSetting<bool> _renderTransformDebugInfoOverride = new();
- L367 C82: new() :: private OverrideableSetting<bool> _renderUITransformCoordinateOverride = new();
- L368 C75: new() :: private OverrideableSetting<bool> _renderTransformLinesOverride = new();
- L369 C76: new() :: private OverrideableSetting<bool> _renderTransformPointsOverride = new();
- L370 C78: new() :: private OverrideableSetting<bool> _renderTransformCapsulesOverride = new();
- L371 C87: new() :: private OverrideableSetting<bool> _visualizeDirectionalLightVolumesOverride = new();
- L372 C75: new() :: private OverrideableSetting<bool> _preview3DWorldOctreeOverride = new();
- L373 C77: new() :: private OverrideableSetting<bool> _preview2DWorldQuadtreeOverride = new();
- L374 C68: new() :: private OverrideableSetting<bool> _previewTracesOverride = new();
- L375 C75: new() :: private OverrideableSetting<bool> _renderCullingVolumesOverride = new();
- L376 C75: new() :: private OverrideableSetting<bool> _visualizeTransformIdOverride = new();
- L377 C81: new() :: private OverrideableSetting<bool> _renderLightProbeTetrahedraOverride = new();
- L378 C76: new() :: private OverrideableSetting<float> _debugTextMaxLifespanOverride = new();
- L379 C85: new() :: private OverrideableSetting<bool> _enableThreadAllocationTrackingOverride = new();
- L380 C77: new() :: private OverrideableSetting<bool> _useDebugOpaquePipelineOverride = new();
- L381 C81: new() :: private OverrideableSetting<bool> _forceGpuPassthroughCullingOverride = new();
- L382 C74: new() :: private OverrideableSetting<bool> _allowGpuCpuFallbackOverride = new();
- L383 C81: new() :: private OverrideableSetting<bool> _enableProfilerFrameLoggingOverride = new();
- L384 C85: new() :: private OverrideableSetting<bool> _enableRenderStatisticsTrackingOverride = new();
- L385 C81: new() :: private OverrideableSetting<bool> _enableUILayoutDebugLoggingOverride = new();
- L386 C79: new() :: private OverrideableSetting<bool> _enableProfilerUdpSendingOverride = new();
- L391 C71: new() :: set => SetField(ref _renderMesh3DBoundsOverride, value ?? new());
- L397 C71: new() :: set => SetField(ref _renderMesh2DBoundsOverride, value ?? new());
- L403 C77: new() :: set => SetField(ref _renderTransformDebugInfoOverride, value ?? new());
- L409 C80: new() :: set => SetField(ref _renderUITransformCoordinateOverride, value ?? new());
- L415 C73: new() :: set => SetField(ref _renderTransformLinesOverride, value ?? new());
- L421 C74: new() :: set => SetField(ref _renderTransformPointsOverride, value ?? new());
- L427 C76: new() :: set => SetField(ref _renderTransformCapsulesOverride, value ?? new());
- L433 C85: new() :: set => SetField(ref _visualizeDirectionalLightVolumesOverride, value ?? new());
- L439 C73: new() :: set => SetField(ref _preview3DWorldOctreeOverride, value ?? new());
- L445 C75: new() :: set => SetField(ref _preview2DWorldQuadtreeOverride, value ?? new());
- L451 C66: new() :: set => SetField(ref _previewTracesOverride, value ?? new());
- L457 C73: new() :: set => SetField(ref _renderCullingVolumesOverride, value ?? new());
- L463 C73: new() :: set => SetField(ref _visualizeTransformIdOverride, value ?? new());
- L469 C79: new() :: set => SetField(ref _renderLightProbeTetrahedraOverride, value ?? new());
- L475 C73: new() :: set => SetField(ref _debugTextMaxLifespanOverride, value ?? new());
- L481 C83: new() :: set => SetField(ref _enableThreadAllocationTrackingOverride, value ?? new());
- L487 C75: new() :: set => SetField(ref _useDebugOpaquePipelineOverride, value ?? new());
- L493 C79: new() :: set => SetField(ref _forceGpuPassthroughCullingOverride, value ?? new());
- L499 C72: new() :: set => SetField(ref _allowGpuCpuFallbackOverride, value ?? new());
- L505 C79: new() :: set => SetField(ref _enableProfilerFrameLoggingOverride, value ?? new());
- L511 C83: new() :: set => SetField(ref _enableRenderStatisticsTrackingOverride, value ?? new());
- L517 C79: new() :: set => SetField(ref _enableUILayoutDebugLoggingOverride, value ?? new());
- L523 C77: new() :: set => SetField(ref _enableProfilerUdpSendingOverride, value ?? new());


## XRENGINE/Settings/GameStartupSettings.cs
- L25 C48: new() :: private BuildSettings _buildSettings = new();
- L31 C53: new() :: private UserSettings _defaultUserSettings = new();
- L239 C58: new BuildSettings :: set => SetField(ref _buildSettings, value ?? new BuildSettings());
- L320 C64: new() :: private OverrideableSetting<int> _jobWorkersOverride = new();
- L321 C66: new() :: private OverrideableSetting<int> _jobWorkerCapOverride = new();
- L322 C67: new() :: private OverrideableSetting<int> _jobQueueLimitOverride = new();
- L323 C78: new() :: private OverrideableSetting<int> _jobQueueWarningThresholdOverride = new();
- L324 C82: new() :: private OverrideableSetting<EOutputVerbosity> _outputVerbosityOverride = new();
- L325 C84: new() :: private OverrideableSetting<bool> _enableGpuIndirectDebugLoggingOverride = new();
- L326 C83: new() :: private OverrideableSetting<bool> _enableGpuIndirectCpuFallbackOverride = new();
- L327 C89: new() :: private OverrideableSetting<bool> _enableGpuIndirectValidationLoggingOverride = new();
- L328 C64: new() :: private OverrideableSetting<bool> _useGpuBvhOverride = new();
- L329 C70: new() :: private OverrideableSetting<uint> _bvhLeafMaxPrimsOverride = new();
- L330 C66: new() :: private OverrideableSetting<EBvhMode> _bvhModeOverride = new();
- L331 C77: new() :: private OverrideableSetting<bool> _bvhRefitOnlyWhenStableOverride = new();
- L332 C72: new() :: private OverrideableSetting<uint> _raycastBufferSizeOverride = new();
- L333 C80: new() :: private OverrideableSetting<bool> _enableGpuBvhTimingQueriesOverride = new();
- L334 C96: new() :: private OverrideableSetting<EVulkanGpuDrivenProfile> _vulkanGpuDrivenProfileOverride = new();
- L337 C84: new() :: private OverrideableSetting<EAntiAliasingMode> _antiAliasingModeOverride = new();
- L338 C70: new() :: private OverrideableSetting<uint> _msaaSampleCountOverride = new();
- L339 C66: new() :: private OverrideableSetting<EVSyncMode> _vSyncOverride = new();
- L340 C96: new() :: private OverrideableSetting<EGlobalIlluminationMode> _globalIlluminationModeOverride = new();
- L341 C81: new() :: private OverrideableSetting<bool> _tickGroupedItemsInParallelOverride = new();
- L342 C71: new() :: private OverrideableSetting<bool> _enableNvidiaDlssOverride = new();
- L343 C78: new() :: private OverrideableSetting<EDlssQualityMode> _dlssQualityOverride = new();
- L344 C70: new() :: private OverrideableSetting<bool> _enableIntelXessOverride = new();
- L345 C78: new() :: private OverrideableSetting<EXessQualityMode> _xessQualityOverride = new();
- L348 C75: new() :: private OverrideableSetting<bool> _allowShaderPipelinesOverride = new();
- L349 C77: new() :: private OverrideableSetting<bool> _useIntegerWeightingIdsOverride = new();
- L350 C87: new() :: private OverrideableSetting<ELoopType> _recalcChildMatricesLoopTypeOverride = new();
- L351 C87: new() :: private OverrideableSetting<bool> _calculateSkinningInComputeShaderOverride = new();
- L352 C90: new() :: private OverrideableSetting<bool> _calculateBlendshapesInComputeShaderOverride = new();
- L354 C95: new() :: private OverrideableSetting<float> _transformReplicationKeyframeIntervalSecOverride = new();
- L355 C79: new() :: private OverrideableSetting<float> _timeBetweenReplicationsOverride = new();
- L367 C63: new() :: set => SetField(ref _jobWorkersOverride, value ?? new());
- L380 C65: new() :: set => SetField(ref _jobWorkerCapOverride, value ?? new());
- L393 C66: new() :: set => SetField(ref _jobQueueLimitOverride, value ?? new());
- L406 C77: new() :: set => SetField(ref _jobQueueWarningThresholdOverride, value ?? new());
- L419 C68: new() :: set => SetField(ref _outputVerbosityOverride, value ?? new());
- L432 C82: new() :: set => SetField(ref _enableGpuIndirectDebugLoggingOverride, value ?? new());
- L445 C81: new() :: set => SetField(ref _enableGpuIndirectCpuFallbackOverride, value ?? new());
- L458 C87: new() :: set => SetField(ref _enableGpuIndirectValidationLoggingOverride, value ?? new());
- L470 C92: new() :: set => SetField(ref _transformReplicationKeyframeIntervalSecOverride, value ?? new());
- L482 C76: new() :: set => SetField(ref _timeBetweenReplicationsOverride, value ?? new());
- L494 C62: new() :: set => SetField(ref _useGpuBvhOverride, value ?? new());
- L506 C68: new() :: set => SetField(ref _bvhLeafMaxPrimsOverride, value ?? new());
- L518 C60: new() :: set => SetField(ref _bvhModeOverride, value ?? new());
- L530 C75: new() :: set => SetField(ref _bvhRefitOnlyWhenStableOverride, value ?? new());
- L542 C70: new() :: set => SetField(ref _raycastBufferSizeOverride, value ?? new());
- L554 C78: new() :: set => SetField(ref _enableGpuBvhTimingQueriesOverride, value ?? new());
- L566 C75: new() :: set => SetField(ref _vulkanGpuDrivenProfileOverride, value ?? new());
- L579 C69: new() :: set => SetField(ref _antiAliasingModeOverride, value ?? new());
- L592 C68: new() :: set => SetField(ref _msaaSampleCountOverride, value ?? new());
- L605 C58: new() :: set => SetField(ref _vSyncOverride, value ?? new());
- L618 C75: new() :: set => SetField(ref _globalIlluminationModeOverride, value ?? new());
- L631 C79: new() :: set => SetField(ref _tickGroupedItemsInParallelOverride, value ?? new());
- L644 C69: new() :: set => SetField(ref _enableNvidiaDlssOverride, value ?? new());
- L657 C64: new() :: set => SetField(ref _dlssQualityOverride, value ?? new());
- L670 C68: new() :: set => SetField(ref _enableIntelXessOverride, value ?? new());
- L683 C64: new() :: set => SetField(ref _xessQualityOverride, value ?? new());
- L696 C73: new() :: set => SetField(ref _allowShaderPipelinesOverride, value ?? new());
- L709 C75: new() :: set => SetField(ref _useIntegerWeightingIdsOverride, value ?? new());
- L722 C80: new() :: set => SetField(ref _recalcChildMatricesLoopTypeOverride, value ?? new());
- L735 C85: new() :: set => SetField(ref _calculateSkinningInComputeShaderOverride, value ?? new());
- L748 C88: new() :: set => SetField(ref _calculateBlendshapesInComputeShaderOverride, value ?? new());


---
Total matches: 11216
